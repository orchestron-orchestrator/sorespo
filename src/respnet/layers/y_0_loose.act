import base64
import json
import xml
import yang.adata
import yang.gdata

# == This file is generated ==


mut def from_json_netinfra__netinfra__router__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__router__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_netinfra__netinfra__router__role(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__router__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_netinfra__netinfra__router__mock(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class netinfra__netinfra__router_entry(yang.adata.MNode):
    name: str
    id: ?int
    role: ?str
    asn: ?int
    mock: ?str

    mut def __init__(self, name: str, id: ?int, role: ?str, asn: ?int, mock: ?str):
        self._ns = 'http://example.com/netinfra'
        self.name = name
        self.id = id
        self.role = role
        self.asn = asn
        self.mock = mock

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint32', _id)
        _role = self.role
        if _role is not None:
            children['role'] = yang.gdata.Leaf('string', _role)
        _asn = self.asn
        if _asn is not None:
            children['asn'] = yang.gdata.Leaf('uint32', _asn)
        _mock = self.mock
        if _mock is not None:
            children['mock'] = yang.gdata.Leaf('enumeration', _mock)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.name)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra__netinfra__router_entry:
        return netinfra__netinfra__router_entry(name=n.get_str('name'), id=n.get_opt_int('id'), role=n.get_opt_str('role'), asn=n.get_opt_int('asn'), mock=n.get_opt_str('mock'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> netinfra__netinfra__router_entry:
        return netinfra__netinfra__router_entry(name=yang.gdata.from_xml_str(n, 'name'), id=yang.gdata.from_xml_opt_int(n, 'id'), role=yang.gdata.from_xml_opt_str(n, 'role'), asn=yang.gdata.from_xml_opt_int(n, 'asn'), mock=yang.gdata.from_xml_opt_str(n, 'mock'))

class netinfra__netinfra__router(yang.adata.MNode):
    elements: list[netinfra__netinfra__router_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/netinfra'
        self._name = 'router'
        self.elements = elements

    mut def create(self, name, id, asn):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = netinfra__netinfra__router_entry(name, id, asn)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra__netinfra__router_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(netinfra__netinfra__router_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[netinfra__netinfra__router_entry]:
        res = []
        for node in nodes:
            res.append(netinfra__netinfra__router_entry.from_xml(node))
        return res


mut def from_json_path_netinfra__netinfra__router_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra__netinfra__router_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_netinfra__netinfra__router__name(keys[0])
        if point == 'id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'role':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'asn':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'mock':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra__netinfra__router(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra__netinfra__router_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_netinfra__netinfra__router_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra__netinfra__router_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_netinfra__netinfra__router__name, child_name)
    child_id = yang.gdata.take_json_int(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_netinfra__netinfra__router__id, child_id)
    child_role = yang.gdata.take_json_opt_str(jd, 'role')
    yang.gdata.maybe_add(children, 'role', from_json_netinfra__netinfra__router__role, child_role)
    child_asn = yang.gdata.take_json_int(jd, 'asn')
    yang.gdata.maybe_add(children, 'asn', from_json_netinfra__netinfra__router__asn, child_asn)
    child_mock = yang.gdata.take_json_opt_str(jd, 'mock')
    yang.gdata.maybe_add(children, 'mock', from_json_netinfra__netinfra__router__mock, child_mock)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_name)])

mut def from_json_netinfra__netinfra__router(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_netinfra__netinfra__router_element(e))
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_json_netinfra__netinfra__backbone_link__left_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__backbone_link__left_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__backbone_link__right_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__backbone_link__right_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class netinfra__netinfra__backbone_link_entry(yang.adata.MNode):
    left_router: str
    left_interface: str
    right_router: str
    right_interface: str

    mut def __init__(self, left_router: str, left_interface: str, right_router: str, right_interface: str):
        self._ns = 'http://example.com/netinfra'
        self.left_router = left_router
        self.left_interface = left_interface
        self.right_router = right_router
        self.right_interface = right_interface

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _left_router = self.left_router
        if _left_router is not None:
            children['left-router'] = yang.gdata.Leaf('string', _left_router)
        _left_interface = self.left_interface
        if _left_interface is not None:
            children['left-interface'] = yang.gdata.Leaf('string', _left_interface)
        _right_router = self.right_router
        if _right_router is not None:
            children['right-router'] = yang.gdata.Leaf('string', _right_router)
        _right_interface = self.right_interface
        if _right_interface is not None:
            children['right-interface'] = yang.gdata.Leaf('string', _right_interface)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.left_router), yang.gdata.yang_str(self.left_interface), yang.gdata.yang_str(self.right_router), yang.gdata.yang_str(self.right_interface)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra__netinfra__backbone_link_entry:
        return netinfra__netinfra__backbone_link_entry(left_router=n.get_str('left-router'), left_interface=n.get_str('left-interface'), right_router=n.get_str('right-router'), right_interface=n.get_str('right-interface'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> netinfra__netinfra__backbone_link_entry:
        return netinfra__netinfra__backbone_link_entry(left_router=yang.gdata.from_xml_str(n, 'left-router'), left_interface=yang.gdata.from_xml_str(n, 'left-interface'), right_router=yang.gdata.from_xml_str(n, 'right-router'), right_interface=yang.gdata.from_xml_str(n, 'right-interface'))

class netinfra__netinfra__backbone_link(yang.adata.MNode):
    elements: list[netinfra__netinfra__backbone_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/netinfra'
        self._name = 'backbone-link'
        self.elements = elements

    mut def create(self, left_router, left_interface, right_router, right_interface):
        for e in self.elements:
            match = True
            if e.left_router != left_router:
                match = False
                continue
            if e.left_interface != left_interface:
                match = False
                continue
            if e.right_router != right_router:
                match = False
                continue
            if e.right_interface != right_interface:
                match = False
                continue
            if match:
                return e

        res = netinfra__netinfra__backbone_link_entry(left_router, left_interface, right_router, right_interface)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra__netinfra__backbone_link_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(netinfra__netinfra__backbone_link_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[netinfra__netinfra__backbone_link_entry]:
        res = []
        for node in nodes:
            res.append(netinfra__netinfra__backbone_link_entry.from_xml(node))
        return res


mut def from_json_path_netinfra__netinfra__backbone_link_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra__netinfra__backbone_link_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['left-router'] = from_json_netinfra__netinfra__backbone_link__left_router(keys[0])
        children['left-interface'] = from_json_netinfra__netinfra__backbone_link__left_interface(keys[1])
        children['right-router'] = from_json_netinfra__netinfra__backbone_link__right_router(keys[2])
        children['right-interface'] = from_json_netinfra__netinfra__backbone_link__right_interface(keys[3])
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra__netinfra__backbone_link(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['left-router', 'left-interface', 'right-router', 'right-interface']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra__netinfra__backbone_link_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], [from_json_path_netinfra__netinfra__backbone_link_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra__netinfra__backbone_link_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_left_router = yang.gdata.take_json_str(jd, 'left-router')
    yang.gdata.maybe_add(children, 'left-router', from_json_netinfra__netinfra__backbone_link__left_router, child_left_router)
    child_left_interface = yang.gdata.take_json_str(jd, 'left-interface')
    yang.gdata.maybe_add(children, 'left-interface', from_json_netinfra__netinfra__backbone_link__left_interface, child_left_interface)
    child_right_router = yang.gdata.take_json_str(jd, 'right-router')
    yang.gdata.maybe_add(children, 'right-router', from_json_netinfra__netinfra__backbone_link__right_router, child_right_router)
    child_right_interface = yang.gdata.take_json_str(jd, 'right-interface')
    yang.gdata.maybe_add(children, 'right-interface', from_json_netinfra__netinfra__backbone_link__right_interface, child_right_interface)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_left_router), yang.gdata.yang_str(child_left_interface), yang.gdata.yang_str(child_right_router), yang.gdata.yang_str(child_right_interface)])

mut def from_json_netinfra__netinfra__backbone_link(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_netinfra__netinfra__backbone_link_element(e))
    return yang.gdata.List(keys=['left-router', 'left-interface', 'right-router', 'right-interface'], elements=elements)

class netinfra__netinfra(yang.adata.MNode):
    router: netinfra__netinfra__router
    backbone_link: netinfra__netinfra__backbone_link

    mut def __init__(self, router: list[netinfra__netinfra__router_entry]=[], backbone_link: list[netinfra__netinfra__backbone_link_entry]=[]):
        self._ns = 'http://example.com/netinfra'
        self.router = netinfra__netinfra__router(elements=router)
        self.backbone_link = netinfra__netinfra__backbone_link(elements=backbone_link)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _router = self.router
        if _router is not None:
            children['router'] = _router.to_gdata()
        _backbone_link = self.backbone_link
        if _backbone_link is not None:
            children['backbone-link'] = _backbone_link.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/netinfra', module='netinfra')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> netinfra__netinfra:
        if n != None:
            return netinfra__netinfra(router=netinfra__netinfra__router.from_gdata(n.get_opt_list('router')), backbone_link=netinfra__netinfra__backbone_link.from_gdata(n.get_opt_list('backbone-link')))
        return netinfra__netinfra()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> netinfra__netinfra:
        if n != None:
            return netinfra__netinfra(router=netinfra__netinfra__router.from_xml(yang.gdata.get_xml_children(n, 'router')), backbone_link=netinfra__netinfra__backbone_link.from_xml(yang.gdata.get_xml_children(n, 'backbone-link')))
        return netinfra__netinfra()


mut def from_json_path_netinfra__netinfra(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'router':
            child = {'router': from_json_path_netinfra__netinfra__router(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/netinfra', module='netinfra')
        if point == 'backbone-link':
            child = {'backbone-link': from_json_path_netinfra__netinfra__backbone_link(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/netinfra', module='netinfra')
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_netinfra__netinfra(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_netinfra__netinfra(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_router = yang.gdata.take_json_opt_list(jd, 'router')
    yang.gdata.maybe_add(children, 'router', from_json_netinfra__netinfra__router, child_router)
    child_backbone_link = yang.gdata.take_json_opt_list(jd, 'backbone-link')
    yang.gdata.maybe_add(children, 'backbone-link', from_json_netinfra__netinfra__backbone_link, child_backbone_link)
    return yang.gdata.Container(children, ns='http://example.com/netinfra', module='netinfra')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(id=n.get_str('id'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(id=yang.gdata.from_xml_str(n, 'id'))

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'cloud-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier__id(keys[0])
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier__id, child_id)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(e))
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(id=n.get_str('id'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(id=yang.gdata.from_xml_str(n, 'id'))

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'encryption-profile-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier__id(keys[0])
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier__id, child_id)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(e))
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(id=n.get_str('id'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(id=yang.gdata.from_xml_str(n, 'id'))

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'qos-profile-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier__id(keys[0])
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier__id, child_id)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(e))
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(id=n.get_str('id'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(id=yang.gdata.from_xml_str(n, 'id'))

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'bfd-profile-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier__id(keys[0])
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier__id, child_id)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(e))
    return yang.gdata.List(keys=['id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(yang.adata.MNode):
    cloud_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier
    encryption_profile_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier
    qos_profile_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier
    bfd_profile_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier

    mut def __init__(self, cloud_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]=[], encryption_profile_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]=[], qos_profile_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]=[], bfd_profile_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cloud_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(elements=cloud_identifier)
        self.encryption_profile_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(elements=encryption_profile_identifier)
        self.qos_profile_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(elements=qos_profile_identifier)
        self.bfd_profile_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(elements=bfd_profile_identifier)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cloud_identifier = self.cloud_identifier
        if _cloud_identifier is not None:
            children['cloud-identifier'] = _cloud_identifier.to_gdata()
        _encryption_profile_identifier = self.encryption_profile_identifier
        if _encryption_profile_identifier is not None:
            children['encryption-profile-identifier'] = _encryption_profile_identifier.to_gdata()
        _qos_profile_identifier = self.qos_profile_identifier
        if _qos_profile_identifier is not None:
            children['qos-profile-identifier'] = _qos_profile_identifier.to_gdata()
        _bfd_profile_identifier = self.bfd_profile_identifier
        if _bfd_profile_identifier is not None:
            children['bfd-profile-identifier'] = _bfd_profile_identifier.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(cloud_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier.from_gdata(n.get_opt_list('cloud-identifier')), encryption_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier.from_gdata(n.get_opt_list('encryption-profile-identifier')), qos_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier.from_gdata(n.get_opt_list('qos-profile-identifier')), bfd_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier.from_gdata(n.get_opt_list('bfd-profile-identifier')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(cloud_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier.from_xml(yang.gdata.get_xml_children(n, 'cloud-identifier')), encryption_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier.from_xml(yang.gdata.get_xml_children(n, 'encryption-profile-identifier')), qos_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier.from_xml(yang.gdata.get_xml_children(n, 'qos-profile-identifier')), bfd_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier.from_xml(yang.gdata.get_xml_children(n, 'bfd-profile-identifier')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'cloud-identifier':
            child = {'cloud-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'encryption-profile-identifier':
            child = {'encryption-profile-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'qos-profile-identifier':
            child = {'qos-profile-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'bfd-profile-identifier':
            child = {'bfd-profile-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cloud_identifier = yang.gdata.take_json_opt_list(jd, 'cloud-identifier')
    yang.gdata.maybe_add(children, 'cloud-identifier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier, child_cloud_identifier)
    child_encryption_profile_identifier = yang.gdata.take_json_opt_list(jd, 'encryption-profile-identifier')
    yang.gdata.maybe_add(children, 'encryption-profile-identifier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier, child_encryption_profile_identifier)
    child_qos_profile_identifier = yang.gdata.take_json_opt_list(jd, 'qos-profile-identifier')
    yang.gdata.maybe_add(children, 'qos-profile-identifier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier, child_qos_profile_identifier)
    child_bfd_profile_identifier = yang.gdata.take_json_opt_list(jd, 'bfd-profile-identifier')
    yang.gdata.maybe_add(children, 'bfd-profile-identifier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier, child_bfd_profile_identifier)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(yang.adata.MNode):
    valid_provider_identifiers: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers

    mut def __init__(self, valid_provider_identifiers: ?ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.valid_provider_identifiers = valid_provider_identifiers if valid_provider_identifiers is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _valid_provider_identifiers = self.valid_provider_identifiers
        if _valid_provider_identifiers is not None:
            children['valid-provider-identifiers'] = _valid_provider_identifiers.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(valid_provider_identifiers=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers.from_gdata(n.get_opt_container('valid-provider-identifiers')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(valid_provider_identifiers=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers.from_xml(yang.gdata.get_xml_opt_child(n, 'valid-provider-identifiers')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'valid-provider-identifiers':
            child = {'valid-provider-identifiers': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_valid_provider_identifiers = yang.gdata.take_json_opt_cnt(jd, 'valid-provider-identifiers')
    yang.gdata.maybe_add(children, 'valid-provider-identifiers', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers, child_valid_provider_identifiers)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__customer_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_service_topology(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__cloud_identifier(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_any(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_site(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__deny_site(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__nat44_customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(yang.adata.MNode):
    enabled: ?bool
    nat44_customer_address: ?str

    mut def __init__(self, enabled: ?bool, nat44_customer_address: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled
        self.nat44_customer_address = nat44_customer_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _nat44_customer_address = self.nat44_customer_address
        if _nat44_customer_address is not None:
            children['nat44-customer-address'] = yang.gdata.Leaf('string', _nat44_customer_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(enabled=n.get_opt_bool('enabled'), nat44_customer_address=n.get_opt_str('nat44-customer-address'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(enabled=yang.gdata.from_xml_opt_bool(n, 'enabled'), nat44_customer_address=yang.gdata.from_xml_opt_str(n, 'nat44-customer-address'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'nat44-customer-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__enabled, child_enabled)
    child_nat44_customer_address = yang.gdata.take_json_opt_str(jd, 'nat44-customer-address')
    yang.gdata.maybe_add(children, 'nat44-customer-address', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__nat44_customer_address, child_nat44_customer_address)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(yang.adata.MNode):
    nat44: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44

    mut def __init__(self, nat44: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.nat44 = nat44 if nat44 is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _nat44 = self.nat44
        if _nat44 is not None:
            children['nat44'] = _nat44.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(nat44=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44.from_gdata(n.get_opt_container('nat44')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(nat44=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44.from_xml(yang.gdata.get_xml_opt_child(n, 'nat44')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'nat44':
            child = {'nat44': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_nat44 = yang.gdata.take_json_opt_cnt(jd, 'nat44')
    yang.gdata.maybe_add(children, 'nat44', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44, child_nat44)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(yang.adata.MNode):
    cloud_identifier: str
    permit_any: ?bool
    permit_site: list[str]
    deny_site: list[str]
    address_translation: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation

    mut def __init__(self, cloud_identifier: str, permit_any: ?bool, permit_site: ?list[str]=None, deny_site: ?list[str]=None, address_translation: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cloud_identifier = cloud_identifier
        self.permit_any = permit_any
        self.permit_site = permit_site if permit_site is not None else []
        self.deny_site = deny_site if deny_site is not None else []
        self.address_translation = address_translation if address_translation is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cloud_identifier = self.cloud_identifier
        if _cloud_identifier is not None:
            children['cloud-identifier'] = yang.gdata.Leaf('leafref', _cloud_identifier)
        _permit_any = self.permit_any
        if _permit_any is not None:
            children['permit-any'] = yang.gdata.Leaf('empty', _permit_any)
        children['permit-site'] = yang.gdata.LeafList('leafref', self.permit_site)
        children['deny-site'] = yang.gdata.LeafList('leafref', self.deny_site)
        _address_translation = self.address_translation
        if _address_translation is not None:
            children['address-translation'] = _address_translation.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.cloud_identifier)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(cloud_identifier=n.get_str('cloud-identifier'), permit_any=n.get_opt_bool('permit-any'), permit_site=n.get_opt_strs('permit-site'), deny_site=n.get_opt_strs('deny-site'), address_translation=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation.from_gdata(n.get_opt_container('address-translation')))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(cloud_identifier=yang.gdata.from_xml_str(n, 'cloud-identifier'), permit_any=yang.gdata.from_xml_opt_bool(n, 'permit-any'), permit_site=yang.gdata.from_xml_opt_strs(n, 'permit-site'), deny_site=yang.gdata.from_xml_opt_strs(n, 'deny-site'), address_translation=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation.from_xml(yang.gdata.get_xml_opt_child(n, 'address-translation')))

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'cloud-access'
        self.elements = elements

    mut def create(self, cloud_identifier):
        for e in self.elements:
            match = True
            if e.cloud_identifier != cloud_identifier:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(cloud_identifier)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['cloud-identifier'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['cloud-identifier'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__cloud_identifier(keys[0])
        if point == 'permit-any':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'permit-site':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'deny-site':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'address-translation':
            children['address-translation'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['cloud-identifier']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['cloud-identifier'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['cloud-identifier'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_cloud_identifier = yang.gdata.take_json_str(jd, 'cloud-identifier')
    yang.gdata.maybe_add(children, 'cloud-identifier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__cloud_identifier, child_cloud_identifier)
    child_permit_any = yang.gdata.take_json_opt_bool(jd, 'permit-any')
    yang.gdata.maybe_add(children, 'permit-any', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_any, child_permit_any)
    child_permit_site = yang.gdata.take_json_opt_strs(jd, 'permit-site')
    yang.gdata.maybe_add(children, 'permit-site', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_site, child_permit_site)
    child_deny_site = yang.gdata.take_json_opt_strs(jd, 'deny-site')
    yang.gdata.maybe_add(children, 'deny-site', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__deny_site, child_deny_site)
    child_address_translation = yang.gdata.take_json_opt_cnt(jd, 'address-translation')
    yang.gdata.maybe_add(children, 'address-translation', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation, child_address_translation)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_cloud_identifier)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(e))
    return yang.gdata.List(keys=['cloud-identifier'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(yang.adata.MNode):
    cloud_access: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access

    mut def __init__(self, cloud_access: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cloud_access = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(elements=cloud_access)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cloud_access = self.cloud_access
        if _cloud_access is not None:
            children['cloud-access'] = _cloud_access.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(cloud_access=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access.from_gdata(n.get_opt_list('cloud-access')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(cloud_access=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access.from_xml(yang.gdata.get_xml_children(n, 'cloud-access')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'cloud-access':
            child = {'cloud-access': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cloud_access = yang.gdata.take_json_opt_list(jd, 'cloud-access')
    yang.gdata.maybe_add(children, 'cloud-access', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access, child_cloud_access)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors__tree_flavor(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('identityref', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(yang.adata.MNode):
    tree_flavor: list[str]

    mut def __init__(self, tree_flavor: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.tree_flavor = tree_flavor if tree_flavor is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['tree-flavor'] = yang.gdata.LeafList('identityref', self.tree_flavor)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(tree_flavor=n.get_opt_strs('tree-flavor'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(tree_flavor=yang.gdata.from_xml_opt_strs(n, 'tree-flavor'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'tree-flavor':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_tree_flavor = yang.gdata.take_json_opt_strs(jd, 'tree-flavor')
    yang.gdata.maybe_add(children, 'tree-flavor', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors__tree_flavor, child_tree_flavor)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__rp_redundancy(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__optimal_traffic_delivery(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(yang.adata.MNode):
    enabled: ?bool
    rp_redundancy: ?bool
    optimal_traffic_delivery: ?bool

    mut def __init__(self, enabled: ?bool, rp_redundancy: ?bool, optimal_traffic_delivery: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled
        self.rp_redundancy = rp_redundancy
        self.optimal_traffic_delivery = optimal_traffic_delivery

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _rp_redundancy = self.rp_redundancy
        if _rp_redundancy is not None:
            children['rp-redundancy'] = yang.gdata.Leaf('boolean', _rp_redundancy)
        _optimal_traffic_delivery = self.optimal_traffic_delivery
        if _optimal_traffic_delivery is not None:
            children['optimal-traffic-delivery'] = yang.gdata.Leaf('boolean', _optimal_traffic_delivery)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(enabled=n.get_opt_bool('enabled'), rp_redundancy=n.get_opt_bool('rp-redundancy'), optimal_traffic_delivery=n.get_opt_bool('optimal-traffic-delivery'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(enabled=yang.gdata.from_xml_opt_bool(n, 'enabled'), rp_redundancy=yang.gdata.from_xml_opt_bool(n, 'rp-redundancy'), optimal_traffic_delivery=yang.gdata.from_xml_opt_bool(n, 'optimal-traffic-delivery'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'rp-redundancy':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'optimal-traffic-delivery':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__enabled, child_enabled)
    child_rp_redundancy = yang.gdata.take_json_opt_bool(jd, 'rp-redundancy')
    yang.gdata.maybe_add(children, 'rp-redundancy', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__rp_redundancy, child_rp_redundancy)
    child_optimal_traffic_delivery = yang.gdata.take_json_opt_bool(jd, 'optimal-traffic-delivery')
    yang.gdata.maybe_add(children, 'optimal-traffic-delivery', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__optimal_traffic_delivery, child_optimal_traffic_delivery)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__rp_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_start(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(yang.adata.MNode):
    id: int
    group_address: ?str
    group_start: ?str
    group_end: ?str

    mut def __init__(self, id: int, group_address: ?str, group_start: ?str, group_end: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.group_address = group_address
        self.group_start = group_start
        self.group_end = group_end

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint16', _id)
        _group_address = self.group_address
        if _group_address is not None:
            children['group-address'] = yang.gdata.Leaf('union', _group_address)
        _group_start = self.group_start
        if _group_start is not None:
            children['group-start'] = yang.gdata.Leaf('union', _group_start)
        _group_end = self.group_end
        if _group_end is not None:
            children['group-end'] = yang.gdata.Leaf('union', _group_end)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(id=n.get_int('id'), group_address=n.get_opt_str('group-address'), group_start=n.get_opt_str('group-start'), group_end=n.get_opt_str('group-end'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(id=yang.gdata.from_xml_int(n, 'id'), group_address=yang.gdata.from_xml_opt_str(n, 'group-address'), group_start=yang.gdata.from_xml_opt_str(n, 'group-start'), group_end=yang.gdata.from_xml_opt_str(n, 'group-end'))

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__id(keys[0])
        if point == 'group-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'group-start':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'group-end':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_int(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__id, child_id)
    child_group_address = yang.gdata.take_json_opt_str(jd, 'group-address')
    yang.gdata.maybe_add(children, 'group-address', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_address, child_group_address)
    child_group_start = yang.gdata.take_json_opt_str(jd, 'group-start')
    yang.gdata.maybe_add(children, 'group-start', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_start, child_group_start)
    child_group_end = yang.gdata.take_json_opt_str(jd, 'group-end')
    yang.gdata.maybe_add(children, 'group-end', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_end, child_group_end)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(e))
    return yang.gdata.List(keys=['id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(elements=group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(group=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group.from_gdata(n.get_opt_list('group')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(group=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group.from_xml(yang.gdata.get_xml_children(n, 'group')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.take_json_opt_list(jd, 'group')
    yang.gdata.maybe_add(children, 'group', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group, child_group)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(yang.adata.MNode):
    id: int
    provider_managed: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed
    rp_address: ?str
    groups: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups

    mut def __init__(self, id: int, provider_managed: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed=None, rp_address: ?str, groups: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.provider_managed = provider_managed if provider_managed is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed()
        self.rp_address = rp_address
        self.groups = groups if groups is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint16', _id)
        _provider_managed = self.provider_managed
        if _provider_managed is not None:
            children['provider-managed'] = _provider_managed.to_gdata()
        _rp_address = self.rp_address
        if _rp_address is not None:
            children['rp-address'] = yang.gdata.Leaf('union', _rp_address)
        _groups = self.groups
        if _groups is not None:
            children['groups'] = _groups.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(id=n.get_int('id'), provider_managed=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed.from_gdata(n.get_opt_container('provider-managed')), rp_address=n.get_opt_str('rp-address'), groups=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups.from_gdata(n.get_opt_container('groups')))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(id=yang.gdata.from_xml_int(n, 'id'), provider_managed=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed.from_xml(yang.gdata.get_xml_opt_child(n, 'provider-managed')), rp_address=yang.gdata.from_xml_opt_str(n, 'rp-address'), groups=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups.from_xml(yang.gdata.get_xml_opt_child(n, 'groups')))

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'rp-group-mapping'
        self.elements = elements

    mut def create(self, id, rp_address):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(id, rp_address)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__id(keys[0])
        if point == 'provider-managed':
            children['provider-managed'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(jd, rest_path, op)
        if point == 'rp-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'groups':
            children['groups'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_int(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__id, child_id)
    child_provider_managed = yang.gdata.take_json_opt_cnt(jd, 'provider-managed')
    yang.gdata.maybe_add(children, 'provider-managed', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed, child_provider_managed)
    child_rp_address = yang.gdata.take_json_str(jd, 'rp-address')
    yang.gdata.maybe_add(children, 'rp-address', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__rp_address, child_rp_address)
    child_groups = yang.gdata.take_json_opt_cnt(jd, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups, child_groups)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(e))
    return yang.gdata.List(keys=['id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(yang.adata.MNode):
    rp_group_mapping: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping

    mut def __init__(self, rp_group_mapping: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rp_group_mapping = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(elements=rp_group_mapping)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rp_group_mapping = self.rp_group_mapping
        if _rp_group_mapping is not None:
            children['rp-group-mapping'] = _rp_group_mapping.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(rp_group_mapping=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping.from_gdata(n.get_opt_list('rp-group-mapping')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(rp_group_mapping=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping.from_xml(yang.gdata.get_xml_children(n, 'rp-group-mapping')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'rp-group-mapping':
            child = {'rp-group-mapping': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rp_group_mapping = yang.gdata.take_json_opt_list(jd, 'rp-group-mapping')
    yang.gdata.maybe_add(children, 'rp-group-mapping', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping, child_rp_group_mapping)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__rp_discovery_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates__bsr_candidate_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('union', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(yang.adata.MNode):
    bsr_candidate_address: list[str]

    mut def __init__(self, bsr_candidate_address: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.bsr_candidate_address = bsr_candidate_address if bsr_candidate_address is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['bsr-candidate-address'] = yang.gdata.LeafList('union', self.bsr_candidate_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(bsr_candidate_address=n.get_opt_strs('bsr-candidate-address'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(bsr_candidate_address=yang.gdata.from_xml_opt_strs(n, 'bsr-candidate-address'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'bsr-candidate-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_bsr_candidate_address = yang.gdata.take_json_opt_strs(jd, 'bsr-candidate-address')
    yang.gdata.maybe_add(children, 'bsr-candidate-address', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates__bsr_candidate_address, child_bsr_candidate_address)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(yang.adata.MNode):
    rp_discovery_type: ?str
    bsr_candidates: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates

    mut def __init__(self, rp_discovery_type: ?str, bsr_candidates: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rp_discovery_type = rp_discovery_type
        self.bsr_candidates = bsr_candidates if bsr_candidates is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rp_discovery_type = self.rp_discovery_type
        if _rp_discovery_type is not None:
            children['rp-discovery-type'] = yang.gdata.Leaf('identityref', _rp_discovery_type)
        _bsr_candidates = self.bsr_candidates
        if _bsr_candidates is not None:
            children['bsr-candidates'] = _bsr_candidates.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(rp_discovery_type=n.get_opt_str('rp-discovery-type'), bsr_candidates=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates.from_gdata(n.get_opt_container('bsr-candidates')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(rp_discovery_type=yang.gdata.from_xml_opt_str(n, 'rp-discovery-type'), bsr_candidates=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates.from_xml(yang.gdata.get_xml_opt_child(n, 'bsr-candidates')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'rp-discovery-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bsr-candidates':
            child = {'bsr-candidates': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rp_discovery_type = yang.gdata.take_json_opt_str(jd, 'rp-discovery-type')
    yang.gdata.maybe_add(children, 'rp-discovery-type', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__rp_discovery_type, child_rp_discovery_type)
    child_bsr_candidates = yang.gdata.take_json_opt_cnt(jd, 'bsr-candidates')
    yang.gdata.maybe_add(children, 'bsr-candidates', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates, child_bsr_candidates)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(yang.adata.MNode):
    rp_group_mappings: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings
    rp_discovery: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery

    mut def __init__(self, rp_group_mappings: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings=None, rp_discovery: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rp_group_mappings = rp_group_mappings if rp_group_mappings is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings()
        self.rp_discovery = rp_discovery if rp_discovery is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rp_group_mappings = self.rp_group_mappings
        if _rp_group_mappings is not None:
            children['rp-group-mappings'] = _rp_group_mappings.to_gdata()
        _rp_discovery = self.rp_discovery
        if _rp_discovery is not None:
            children['rp-discovery'] = _rp_discovery.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(rp_group_mappings=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings.from_gdata(n.get_opt_container('rp-group-mappings')), rp_discovery=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery.from_gdata(n.get_opt_container('rp-discovery')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(rp_group_mappings=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings.from_xml(yang.gdata.get_xml_opt_child(n, 'rp-group-mappings')), rp_discovery=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery.from_xml(yang.gdata.get_xml_opt_child(n, 'rp-discovery')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'rp-group-mappings':
            child = {'rp-group-mappings': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'rp-discovery':
            child = {'rp-discovery': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rp_group_mappings = yang.gdata.take_json_opt_cnt(jd, 'rp-group-mappings')
    yang.gdata.maybe_add(children, 'rp-group-mappings', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings, child_rp_group_mappings)
    child_rp_discovery = yang.gdata.take_json_opt_cnt(jd, 'rp-discovery')
    yang.gdata.maybe_add(children, 'rp-discovery', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery, child_rp_discovery)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(yang.adata.MNode):
    enabled: ?bool
    customer_tree_flavors: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors
    rp: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp

    mut def __init__(self, enabled: ?bool, customer_tree_flavors: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors=None, rp: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled
        self.customer_tree_flavors = customer_tree_flavors if customer_tree_flavors is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors()
        self.rp = rp if rp is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _customer_tree_flavors = self.customer_tree_flavors
        if _customer_tree_flavors is not None:
            children['customer-tree-flavors'] = _customer_tree_flavors.to_gdata()
        _rp = self.rp
        if _rp is not None:
            children['rp'] = _rp.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(enabled=n.get_opt_bool('enabled'), customer_tree_flavors=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors.from_gdata(n.get_opt_container('customer-tree-flavors')), rp=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp.from_gdata(n.get_opt_container('rp')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(enabled=yang.gdata.from_xml_opt_bool(n, 'enabled'), customer_tree_flavors=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors.from_xml(yang.gdata.get_xml_opt_child(n, 'customer-tree-flavors')), rp=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp.from_xml(yang.gdata.get_xml_opt_child(n, 'rp')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-tree-flavors':
            child = {'customer-tree-flavors': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'rp':
            child = {'rp': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__enabled, child_enabled)
    child_customer_tree_flavors = yang.gdata.take_json_opt_cnt(jd, 'customer-tree-flavors')
    yang.gdata.maybe_add(children, 'customer-tree-flavors', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors, child_customer_tree_flavors)
    child_rp = yang.gdata.take_json_opt_cnt(jd, 'rp')
    yang.gdata.maybe_add(children, 'rp', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp, child_rp)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__carrierscarrier(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__local_sites_role(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(yang.adata.MNode):
    vpn_id: str
    local_sites_role: ?str

    mut def __init__(self, vpn_id: str, local_sites_role: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_id = vpn_id
        self.local_sites_role = local_sites_role

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('string', _vpn_id)
        _local_sites_role = self.local_sites_role
        if _local_sites_role is not None:
            children['local-sites-role'] = yang.gdata.Leaf('identityref', _local_sites_role)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.vpn_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(vpn_id=n.get_str('vpn-id'), local_sites_role=n.get_opt_str('local-sites-role'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(vpn_id=yang.gdata.from_xml_str(n, 'vpn-id'), local_sites_role=yang.gdata.from_xml_opt_str(n, 'local-sites-role'))

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'extranet-vpn'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self.elements:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(vpn_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['vpn-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__vpn_id(keys[0])
        if point == 'local-sites-role':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['vpn-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.take_json_str(jd, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__vpn_id, child_vpn_id)
    child_local_sites_role = yang.gdata.take_json_opt_str(jd, 'local-sites-role')
    yang.gdata.maybe_add(children, 'local-sites-role', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__local_sites_role, child_local_sites_role)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_vpn_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(e))
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(yang.adata.MNode):
    extranet_vpn: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn

    mut def __init__(self, extranet_vpn: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.extranet_vpn = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(elements=extranet_vpn)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _extranet_vpn = self.extranet_vpn
        if _extranet_vpn is not None:
            children['extranet-vpn'] = _extranet_vpn.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(extranet_vpn=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn.from_gdata(n.get_opt_list('extranet-vpn')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(extranet_vpn=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn.from_xml(yang.gdata.get_xml_children(n, 'extranet-vpn')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'extranet-vpn':
            child = {'extranet-vpn': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_extranet_vpn = yang.gdata.take_json_opt_list(jd, 'extranet-vpn')
    yang.gdata.maybe_add(children, 'extranet-vpn', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn, child_extranet_vpn)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(yang.adata.MNode):
    vpn_id: str
    customer_name: ?str
    vpn_service_topology: ?str
    cloud_accesses: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses
    multicast: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast
    carrierscarrier: ?bool
    extranet_vpns: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns

    mut def __init__(self, vpn_id: str, customer_name: ?str, vpn_service_topology: ?str, cloud_accesses: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses=None, multicast: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast=None, carrierscarrier: ?bool, extranet_vpns: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_id = vpn_id
        self.customer_name = customer_name
        self.vpn_service_topology = vpn_service_topology
        self.cloud_accesses = cloud_accesses if cloud_accesses is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses()
        self.multicast = multicast if multicast is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast()
        self.carrierscarrier = carrierscarrier
        self.extranet_vpns = extranet_vpns if extranet_vpns is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('string', _vpn_id)
        _customer_name = self.customer_name
        if _customer_name is not None:
            children['customer-name'] = yang.gdata.Leaf('string', _customer_name)
        _vpn_service_topology = self.vpn_service_topology
        if _vpn_service_topology is not None:
            children['vpn-service-topology'] = yang.gdata.Leaf('identityref', _vpn_service_topology)
        _cloud_accesses = self.cloud_accesses
        if _cloud_accesses is not None:
            children['cloud-accesses'] = _cloud_accesses.to_gdata()
        _multicast = self.multicast
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        _carrierscarrier = self.carrierscarrier
        if _carrierscarrier is not None:
            children['carrierscarrier'] = yang.gdata.Leaf('boolean', _carrierscarrier)
        _extranet_vpns = self.extranet_vpns
        if _extranet_vpns is not None:
            children['extranet-vpns'] = _extranet_vpns.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.vpn_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(vpn_id=n.get_str('vpn-id'), customer_name=n.get_opt_str('customer-name'), vpn_service_topology=n.get_opt_str('vpn-service-topology'), cloud_accesses=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses.from_gdata(n.get_opt_container('cloud-accesses')), multicast=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast.from_gdata(n.get_opt_container('multicast')), carrierscarrier=n.get_opt_bool('carrierscarrier'), extranet_vpns=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns.from_gdata(n.get_opt_container('extranet-vpns')))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(vpn_id=yang.gdata.from_xml_str(n, 'vpn-id'), customer_name=yang.gdata.from_xml_opt_str(n, 'customer-name'), vpn_service_topology=yang.gdata.from_xml_opt_str(n, 'vpn-service-topology'), cloud_accesses=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses.from_xml(yang.gdata.get_xml_opt_child(n, 'cloud-accesses')), multicast=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast.from_xml(yang.gdata.get_xml_opt_child(n, 'multicast')), carrierscarrier=yang.gdata.from_xml_opt_bool(n, 'carrierscarrier'), extranet_vpns=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns.from_xml(yang.gdata.get_xml_opt_child(n, 'extranet-vpns')))

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'vpn-service'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self.elements:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(vpn_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['vpn-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_id(keys[0])
        if point == 'customer-name':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'vpn-service-topology':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'cloud-accesses':
            children['cloud-accesses'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(jd, rest_path, op)
        if point == 'multicast':
            children['multicast'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(jd, rest_path, op)
        if point == 'carrierscarrier':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'extranet-vpns':
            children['extranet-vpns'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['vpn-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.take_json_str(jd, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_id, child_vpn_id)
    child_customer_name = yang.gdata.take_json_opt_str(jd, 'customer-name')
    yang.gdata.maybe_add(children, 'customer-name', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__customer_name, child_customer_name)
    child_vpn_service_topology = yang.gdata.take_json_opt_str(jd, 'vpn-service-topology')
    yang.gdata.maybe_add(children, 'vpn-service-topology', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_service_topology, child_vpn_service_topology)
    child_cloud_accesses = yang.gdata.take_json_opt_cnt(jd, 'cloud-accesses')
    yang.gdata.maybe_add(children, 'cloud-accesses', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses, child_cloud_accesses)
    child_multicast = yang.gdata.take_json_opt_cnt(jd, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast, child_multicast)
    child_carrierscarrier = yang.gdata.take_json_opt_bool(jd, 'carrierscarrier')
    yang.gdata.maybe_add(children, 'carrierscarrier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__carrierscarrier, child_carrierscarrier)
    child_extranet_vpns = yang.gdata.take_json_opt_cnt(jd, 'extranet-vpns')
    yang.gdata.maybe_add(children, 'extranet-vpns', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns, child_extranet_vpns)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_vpn_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(e))
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services(yang.adata.MNode):
    vpn_service: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service

    mut def __init__(self, vpn_service: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_service = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(elements=vpn_service)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_service = self.vpn_service
        if _vpn_service is not None:
            children['vpn-service'] = _vpn_service.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services(vpn_service=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service.from_gdata(n.get_opt_list('vpn-service')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services(vpn_service=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service.from_xml(yang.gdata.get_xml_children(n, 'vpn-service')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'vpn-service':
            child = {'vpn-service': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_service = yang.gdata.take_json_opt_list(jd, 'vpn-service')
    yang.gdata.maybe_add(children, 'vpn-service', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service, child_vpn_service)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_start(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_stop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__location_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__postal_code(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__city(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__country_code(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(yang.adata.MNode):
    location_id: str
    address: ?str
    postal_code: ?str
    state: ?str
    city: ?str
    country_code: ?str

    mut def __init__(self, location_id: str, address: ?str, postal_code: ?str, state: ?str, city: ?str, country_code: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.location_id = location_id
        self.address = address
        self.postal_code = postal_code
        self.state = state
        self.city = city
        self.country_code = country_code

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _location_id = self.location_id
        if _location_id is not None:
            children['location-id'] = yang.gdata.Leaf('string', _location_id)
        _address = self.address
        if _address is not None:
            children['address'] = yang.gdata.Leaf('string', _address)
        _postal_code = self.postal_code
        if _postal_code is not None:
            children['postal-code'] = yang.gdata.Leaf('string', _postal_code)
        _state = self.state
        if _state is not None:
            children['state'] = yang.gdata.Leaf('string', _state)
        _city = self.city
        if _city is not None:
            children['city'] = yang.gdata.Leaf('string', _city)
        _country_code = self.country_code
        if _country_code is not None:
            children['country-code'] = yang.gdata.Leaf('string', _country_code)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.location_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(location_id=n.get_str('location-id'), address=n.get_opt_str('address'), postal_code=n.get_opt_str('postal-code'), state=n.get_opt_str('state'), city=n.get_opt_str('city'), country_code=n.get_opt_str('country-code'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(location_id=yang.gdata.from_xml_str(n, 'location-id'), address=yang.gdata.from_xml_opt_str(n, 'address'), postal_code=yang.gdata.from_xml_opt_str(n, 'postal-code'), state=yang.gdata.from_xml_opt_str(n, 'state'), city=yang.gdata.from_xml_opt_str(n, 'city'), country_code=yang.gdata.from_xml_opt_str(n, 'country-code'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'location'
        self.elements = elements

    mut def create(self, location_id):
        for e in self.elements:
            match = True
            if e.location_id != location_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(location_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['location-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['location-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__location_id(keys[0])
        if point == 'address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'postal-code':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'state':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'city':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'country-code':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['location-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['location-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['location-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_location_id = yang.gdata.take_json_str(jd, 'location-id')
    yang.gdata.maybe_add(children, 'location-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__location_id, child_location_id)
    child_address = yang.gdata.take_json_opt_str(jd, 'address')
    yang.gdata.maybe_add(children, 'address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__address, child_address)
    child_postal_code = yang.gdata.take_json_opt_str(jd, 'postal-code')
    yang.gdata.maybe_add(children, 'postal-code', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__postal_code, child_postal_code)
    child_state = yang.gdata.take_json_opt_str(jd, 'state')
    yang.gdata.maybe_add(children, 'state', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__state, child_state)
    child_city = yang.gdata.take_json_opt_str(jd, 'city')
    yang.gdata.maybe_add(children, 'city', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__city, child_city)
    child_country_code = yang.gdata.take_json_opt_str(jd, 'country-code')
    yang.gdata.maybe_add(children, 'country-code', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__country_code, child_country_code)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_location_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(e))
    return yang.gdata.List(keys=['location-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(yang.adata.MNode):
    location: ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location

    mut def __init__(self, location: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.location = ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(elements=location)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _location = self.location
        if _location is not None:
            children['location'] = _location.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__locations:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(location=ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location.from_gdata(n.get_opt_list('location')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__locations:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(location=ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location.from_xml(yang.gdata.get_xml_children(n, 'location')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'location':
            child = {'location': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_location = yang.gdata.take_json_opt_list(jd, 'location')
    yang.gdata.maybe_add(children, 'location', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location, child_location)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__device_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__location(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address_family(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(yang.adata.MNode):
    address_family: ?str
    address: ?str

    mut def __init__(self, address_family: ?str, address: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family
        self.address = address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.Leaf('enumeration', _address_family)
        _address = self.address
        if _address is not None:
            children['address'] = yang.gdata.Leaf('union', _address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(address_family=n.get_opt_str('address-family'), address=n.get_opt_str('address'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management')

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(address_family=yang.gdata.from_xml_opt_str(n, 'address-family'), address=yang.gdata.from_xml_opt_str(n, 'address'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management')


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_opt_str(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address_family, child_address_family)
    child_address = yang.gdata.take_json_str(jd, 'address')
    yang.gdata.maybe_add(children, 'address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address, child_address)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(yang.adata.MNode):
    device_id: str
    location: ?str
    management: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management

    mut def __init__(self, device_id: str, location: ?str, management: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.device_id = device_id
        self.location = location
        self.management = management if management is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _device_id = self.device_id
        if _device_id is not None:
            children['device-id'] = yang.gdata.Leaf('string', _device_id)
        _location = self.location
        if _location is not None:
            children['location'] = yang.gdata.Leaf('leafref', _location)
        _management = self.management
        if _management is not None:
            children['management'] = _management.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.device_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(device_id=n.get_str('device-id'), location=n.get_opt_str('location'), management=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management.from_gdata(n.get_opt_container('management')))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(device_id=yang.gdata.from_xml_str(n, 'device-id'), location=yang.gdata.from_xml_opt_str(n, 'location'), management=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management.from_xml(yang.gdata.get_xml_opt_child(n, 'management')))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'device'
        self.elements = elements

    mut def create(self, device_id, location):
        for e in self.elements:
            match = True
            if e.device_id != device_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(device_id, location)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['device-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['device-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__device_id(keys[0])
        if point == 'location':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'management':
            children['management'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['device-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['device-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['device-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_device_id = yang.gdata.take_json_str(jd, 'device-id')
    yang.gdata.maybe_add(children, 'device-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__device_id, child_device_id)
    child_location = yang.gdata.take_json_str(jd, 'location')
    yang.gdata.maybe_add(children, 'location', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__location, child_location)
    child_management = yang.gdata.take_json_opt_cnt(jd, 'management')
    yang.gdata.maybe_add(children, 'management', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management, child_management)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_device_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(e))
    return yang.gdata.List(keys=['device-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(yang.adata.MNode):
    device: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device

    mut def __init__(self, device: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.device = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(elements=device)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _device = self.device
        if _device is not None:
            children['device'] = _device.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(device=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device.from_gdata(n.get_opt_list('device')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(device=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device.from_xml(yang.gdata.get_xml_children(n, 'device')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'device':
            child = {'device': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_device = yang.gdata.take_json_opt_list(jd, 'device')
    yang.gdata.maybe_add(children, 'device', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device, child_device)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(yang.adata.MNode):
    group_id: str

    mut def __init__(self, group_id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.group_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(group_id=n.get_str('group-id'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(group_id=yang.gdata.from_xml_str(n, 'group-id'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self.elements:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group__group_id(keys[0])
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.take_json_str(jd, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group__group_id, child_group_id)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_group_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(e))
    return yang.gdata.List(keys=['group-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(elements=group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group.from_gdata(n.get_opt_list('group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group.from_xml(yang.gdata.get_xml_children(n, 'group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.take_json_opt_list(jd, 'group')
    yang.gdata.maybe_add(children, 'group', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group, child_group)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(yang.adata.MNode):
    groups: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups

    mut def __init__(self, groups: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.groups = groups if groups is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _groups = self.groups
        if _groups is not None:
            children['groups'] = _groups.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(groups=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups.from_gdata(n.get_opt_container('groups')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(groups=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups.from_xml(yang.gdata.get_xml_opt_child(n, 'groups')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'groups':
            child = {'groups': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_groups = yang.gdata.take_json_opt_cnt(jd, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups, child_groups)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management__type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__management(yang.adata.MNode):
    type: ?str

    mut def __init__(self, type: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        if _type is not None:
            children['type'] = yang.gdata.Leaf('identityref', _type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__management:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__management(type=n.get_opt_str('type'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__management')

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__management:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__management(type=yang.gdata.from_xml_opt_str(n, 'type'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__management')


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_type = yang.gdata.take_json_str(jd, 'type')
    yang.gdata.maybe_add(children, 'type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management__type, child_type)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__vpn_policy_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__lan_tag(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv4_lan_prefix(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv6_lan_prefix(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(yang.adata.MNode):
    type: str
    lan_tag: list[str]
    ipv4_lan_prefix: list[str]
    ipv6_lan_prefix: list[str]

    mut def __init__(self, type: str, lan_tag: ?list[str]=None, ipv4_lan_prefix: ?list[str]=None, ipv6_lan_prefix: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type
        self.lan_tag = lan_tag if lan_tag is not None else []
        self.ipv4_lan_prefix = ipv4_lan_prefix if ipv4_lan_prefix is not None else []
        self.ipv6_lan_prefix = ipv6_lan_prefix if ipv6_lan_prefix is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        if _type is not None:
            children['type'] = yang.gdata.Leaf('identityref', _type)
        children['lan-tag'] = yang.gdata.LeafList('string', self.lan_tag)
        children['ipv4-lan-prefix'] = yang.gdata.LeafList('string', self.ipv4_lan_prefix)
        children['ipv6-lan-prefix'] = yang.gdata.LeafList('string', self.ipv6_lan_prefix)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.type)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(type=n.get_str('type'), lan_tag=n.get_opt_strs('lan-tag'), ipv4_lan_prefix=n.get_opt_strs('ipv4-lan-prefix'), ipv6_lan_prefix=n.get_opt_strs('ipv6-lan-prefix'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(type=yang.gdata.from_xml_str(n, 'type'), lan_tag=yang.gdata.from_xml_opt_strs(n, 'lan-tag'), ipv4_lan_prefix=yang.gdata.from_xml_opt_strs(n, 'ipv4-lan-prefix'), ipv6_lan_prefix=yang.gdata.from_xml_opt_strs(n, 'ipv6-lan-prefix'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'filter'
        self.elements = elements

    mut def create(self, type):
        for e in self.elements:
            match = True
            if e.type != type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['type'], elements, user_order=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__type(keys[0])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-lan-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-lan-prefix':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['type'], elements, user_order=True)
    elif len(path) > 1:
        return yang.gdata.List(['type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd, path, op)], user_order=True)
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_type = yang.gdata.take_json_str(jd, 'type')
    yang.gdata.maybe_add(children, 'type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__type, child_type)
    child_lan_tag = yang.gdata.take_json_opt_strs(jd, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__lan_tag, child_lan_tag)
    child_ipv4_lan_prefix = yang.gdata.take_json_opt_strs(jd, 'ipv4-lan-prefix')
    yang.gdata.maybe_add(children, 'ipv4-lan-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv4_lan_prefix, child_ipv4_lan_prefix)
    child_ipv6_lan_prefix = yang.gdata.take_json_opt_strs(jd, 'ipv6-lan-prefix')
    yang.gdata.maybe_add(children, 'ipv6-lan-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv6_lan_prefix, child_ipv6_lan_prefix)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_type)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(e))
    return yang.gdata.List(keys=['type'], elements=elements, user_order=True)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(yang.adata.MNode):
    filter: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter

    mut def __init__(self, filter: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.filter = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(elements=filter)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _filter = self.filter
        if _filter is not None:
            children['filter'] = _filter.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(filter=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter.from_gdata(n.get_opt_list('filter')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(filter=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter.from_xml(yang.gdata.get_xml_children(n, 'filter')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'filter':
            child = {'filter': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_filter = yang.gdata.take_json_opt_list(jd, 'filter')
    yang.gdata.maybe_add(children, 'filter', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter, child_filter)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__site_role(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(yang.adata.MNode):
    vpn_id: str
    site_role: ?str

    mut def __init__(self, vpn_id: str, site_role: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_id = vpn_id
        self.site_role = site_role

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('leafref', _vpn_id)
        _site_role = self.site_role
        if _site_role is not None:
            children['site-role'] = yang.gdata.Leaf('identityref', _site_role)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.vpn_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(vpn_id=n.get_str('vpn-id'), site_role=n.get_opt_str('site-role'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(vpn_id=yang.gdata.from_xml_str(n, 'vpn-id'), site_role=yang.gdata.from_xml_opt_str(n, 'site-role'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'vpn'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self.elements:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(vpn_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['vpn-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__vpn_id(keys[0])
        if point == 'site-role':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['vpn-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.take_json_str(jd, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__vpn_id, child_vpn_id)
    child_site_role = yang.gdata.take_json_opt_str(jd, 'site-role')
    yang.gdata.maybe_add(children, 'site-role', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__site_role, child_site_role)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_vpn_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(e))
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(yang.adata.MNode):
    id: str
    filters: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters
    vpn: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn

    mut def __init__(self, id: str, filters: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters=None, vpn: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.filters = filters if filters is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters()
        self.vpn = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(elements=vpn)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        _filters = self.filters
        if _filters is not None:
            children['filters'] = _filters.to_gdata()
        _vpn = self.vpn
        if _vpn is not None:
            children['vpn'] = _vpn.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(id=n.get_str('id'), filters=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters.from_gdata(n.get_opt_container('filters')), vpn=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn.from_gdata(n.get_opt_list('vpn')))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(id=yang.gdata.from_xml_str(n, 'id'), filters=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters.from_xml(yang.gdata.get_xml_opt_child(n, 'filters')), vpn=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn.from_xml(yang.gdata.get_xml_children(n, 'vpn')))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'entries'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__id(keys[0])
        if point == 'filters':
            children['filters'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(jd, rest_path, op)
        if point == 'vpn':
            children['vpn'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__id, child_id)
    child_filters = yang.gdata.take_json_opt_cnt(jd, 'filters')
    yang.gdata.maybe_add(children, 'filters', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters, child_filters)
    child_vpn = yang.gdata.take_json_opt_list(jd, 'vpn')
    yang.gdata.maybe_add(children, 'vpn', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn, child_vpn)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(e))
    return yang.gdata.List(keys=['id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(yang.adata.MNode):
    vpn_policy_id: str
    entries: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries

    mut def __init__(self, vpn_policy_id: str, entries: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_policy_id = vpn_policy_id
        self.entries = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(elements=entries)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_policy_id = self.vpn_policy_id
        if _vpn_policy_id is not None:
            children['vpn-policy-id'] = yang.gdata.Leaf('string', _vpn_policy_id)
        _entries = self.entries
        if _entries is not None:
            children['entries'] = _entries.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.vpn_policy_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(vpn_policy_id=n.get_str('vpn-policy-id'), entries=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries.from_gdata(n.get_opt_list('entries')))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(vpn_policy_id=yang.gdata.from_xml_str(n, 'vpn-policy-id'), entries=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries.from_xml(yang.gdata.get_xml_children(n, 'entries')))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'vpn-policy'
        self.elements = elements

    mut def create(self, vpn_policy_id):
        for e in self.elements:
            match = True
            if e.vpn_policy_id != vpn_policy_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(vpn_policy_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-policy-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['vpn-policy-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__vpn_policy_id(keys[0])
        if point == 'entries':
            children['entries'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-policy-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['vpn-policy-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-policy-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_vpn_policy_id = yang.gdata.take_json_str(jd, 'vpn-policy-id')
    yang.gdata.maybe_add(children, 'vpn-policy-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__vpn_policy_id, child_vpn_policy_id)
    child_entries = yang.gdata.take_json_opt_list(jd, 'entries')
    yang.gdata.maybe_add(children, 'entries', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries, child_entries)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_vpn_policy_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(e))
    return yang.gdata.List(keys=['vpn-policy-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(yang.adata.MNode):
    vpn_policy: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy

    mut def __init__(self, vpn_policy: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_policy = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(elements=vpn_policy)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_policy = self.vpn_policy
        if _vpn_policy is not None:
            children['vpn-policy'] = _vpn_policy.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(vpn_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy.from_gdata(n.get_opt_list('vpn-policy')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(vpn_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy.from_xml(yang.gdata.get_xml_children(n, 'vpn-policy')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'vpn-policy':
            child = {'vpn-policy': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_policy = yang.gdata.take_json_opt_list(jd, 'vpn-policy')
    yang.gdata.maybe_add(children, 'vpn-policy', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy, child_vpn_policy)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_vpn_flavor(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__af(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__maximum_routes(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(yang.adata.MNode):
    af: str
    maximum_routes: ?int

    mut def __init__(self, af: str, maximum_routes: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.af = af
        self.maximum_routes = maximum_routes

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _af = self.af
        if _af is not None:
            children['af'] = yang.gdata.Leaf('enumeration', _af)
        _maximum_routes = self.maximum_routes
        if _maximum_routes is not None:
            children['maximum-routes'] = yang.gdata.Leaf('uint32', _maximum_routes)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.af)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(af=n.get_str('af'), maximum_routes=n.get_opt_int('maximum-routes'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(af=yang.gdata.from_xml_str(n, 'af'), maximum_routes=yang.gdata.from_xml_opt_int(n, 'maximum-routes'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af):
        for e in self.elements:
            match = True
            if e.af != af:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(af)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['af'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['af'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__af(keys[0])
        if point == 'maximum-routes':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['af']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['af'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['af'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_af = yang.gdata.take_json_str(jd, 'af')
    yang.gdata.maybe_add(children, 'af', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__af, child_af)
    child_maximum_routes = yang.gdata.take_json_opt_int(jd, 'maximum-routes')
    yang.gdata.maybe_add(children, 'maximum-routes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__maximum_routes, child_maximum_routes)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_af)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(e))
    return yang.gdata.List(keys=['af'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(yang.adata.MNode):
    address_family: ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family

    mut def __init__(self, address_family: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(elements=address_family)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = _address_family.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family.from_gdata(n.get_opt_list('address-family')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family.from_xml(yang.gdata.get_xml_children(n, 'address-family')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            child = {'address-family': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_opt_list(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family, child_address_family)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__layer(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__preshared_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(yang.adata.MNode):
    profile_name: ?str
    algorithm: ?str
    preshared_key: ?str

    mut def __init__(self, profile_name: ?str, algorithm: ?str, preshared_key: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile_name = profile_name
        self.algorithm = algorithm
        self.preshared_key = preshared_key

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile_name = self.profile_name
        if _profile_name is not None:
            children['profile-name'] = yang.gdata.Leaf('leafref', _profile_name)
        _algorithm = self.algorithm
        if _algorithm is not None:
            children['algorithm'] = yang.gdata.Leaf('string', _algorithm)
        _preshared_key = self.preshared_key
        if _preshared_key is not None:
            children['preshared-key'] = yang.gdata.Leaf('string', _preshared_key)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(profile_name=n.get_opt_str('profile-name'), algorithm=n.get_opt_str('algorithm'), preshared_key=n.get_opt_str('preshared-key'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(profile_name=yang.gdata.from_xml_opt_str(n, 'profile-name'), algorithm=yang.gdata.from_xml_opt_str(n, 'algorithm'), preshared_key=yang.gdata.from_xml_opt_str(n, 'preshared-key'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'profile-name':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'algorithm':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'preshared-key':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile_name = yang.gdata.take_json_opt_str(jd, 'profile-name')
    yang.gdata.maybe_add(children, 'profile-name', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__profile_name, child_profile_name)
    child_algorithm = yang.gdata.take_json_opt_str(jd, 'algorithm')
    yang.gdata.maybe_add(children, 'algorithm', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__algorithm, child_algorithm)
    child_preshared_key = yang.gdata.take_json_opt_str(jd, 'preshared-key')
    yang.gdata.maybe_add(children, 'preshared-key', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__preshared_key, child_preshared_key)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(yang.adata.MNode):
    enabled: ?bool
    layer: ?str
    encryption_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile

    mut def __init__(self, enabled: ?bool, layer: ?str, encryption_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled
        self.layer = layer
        self.encryption_profile = encryption_profile if encryption_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _layer = self.layer
        if _layer is not None:
            children['layer'] = yang.gdata.Leaf('enumeration', _layer)
        _encryption_profile = self.encryption_profile
        if _encryption_profile is not None:
            children['encryption-profile'] = _encryption_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(enabled=n.get_opt_bool('enabled'), layer=n.get_opt_str('layer'), encryption_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile.from_gdata(n.get_opt_container('encryption-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(enabled=yang.gdata.from_xml_opt_bool(n, 'enabled'), layer=yang.gdata.from_xml_opt_str(n, 'layer'), encryption_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile.from_xml(yang.gdata.get_xml_opt_child(n, 'encryption-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'layer':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'encryption-profile':
            child = {'encryption-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__enabled, child_enabled)
    child_layer = yang.gdata.take_json_opt_str(jd, 'layer')
    yang.gdata.maybe_add(children, 'layer', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__layer, child_layer)
    child_encryption_profile = yang.gdata.take_json_opt_cnt(jd, 'encryption-profile')
    yang.gdata.maybe_add(children, 'encryption-profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile, child_encryption_profile)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security(yang.adata.MNode):
    authentication: ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication
    encryption: ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption

    mut def __init__(self, authentication: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication=None, encryption: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.authentication = authentication if authentication is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()
        self.encryption = encryption if encryption is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _authentication = self.authentication
        if _authentication is not None:
            children['authentication'] = _authentication.to_gdata()
        _encryption = self.encryption
        if _encryption is not None:
            children['encryption'] = _encryption.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security(authentication=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication.from_gdata(n.get_opt_container('authentication')), encryption=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption.from_gdata(n.get_opt_container('encryption')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security(authentication=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication.from_xml(yang.gdata.get_xml_opt_child(n, 'authentication')), encryption=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption.from_xml(yang.gdata.get_xml_opt_child(n, 'encryption')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'authentication':
            child = {'authentication': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'encryption':
            child = {'encryption': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_authentication = yang.gdata.take_json_opt_cnt(jd, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication, child_authentication)
    child_encryption = yang.gdata.take_json_opt_cnt(jd, 'encryption')
    yang.gdata.maybe_add(children, 'encryption', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption, child_encryption)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dscp(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dot1p(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__target_sites(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        _upper_port = self.upper_port
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(lower_port=n.get_opt_int('lower-port'), upper_port=n.get_opt_int('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(lower_port=yang.gdata.from_xml_opt_int(n, 'lower-port'), upper_port=yang.gdata.from_xml_opt_int(n, 'upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.take_json_opt_int(jd, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.take_json_opt_int(jd, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        _upper_port = self.upper_port
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(lower_port=n.get_opt_int('lower-port'), upper_port=n.get_opt_int('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(lower_port=yang.gdata.from_xml_opt_int(n, 'lower-port'), upper_port=yang.gdata.from_xml_opt_int(n, 'upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.take_json_opt_int(jd, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.take_json_opt_int(jd, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__protocol_field(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(yang.adata.MNode):
    dscp: ?int
    dot1p: ?int
    ipv4_src_prefix: ?str
    ipv6_src_prefix: ?str
    ipv4_dst_prefix: ?str
    ipv6_dst_prefix: ?str
    l4_src_port: ?int
    target_sites: list[str]
    l4_src_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range
    l4_dst_port: ?int
    l4_dst_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range
    protocol_field: ?value

    mut def __init__(self, dscp: ?int, dot1p: ?int, ipv4_src_prefix: ?str, ipv6_src_prefix: ?str, ipv4_dst_prefix: ?str, ipv6_dst_prefix: ?str, l4_src_port: ?int, target_sites: ?list[str]=None, l4_src_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range=None, l4_dst_port: ?int, l4_dst_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range=None, protocol_field: ?value):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.dscp = dscp
        self.dot1p = dot1p
        self.ipv4_src_prefix = ipv4_src_prefix
        self.ipv6_src_prefix = ipv6_src_prefix
        self.ipv4_dst_prefix = ipv4_dst_prefix
        self.ipv6_dst_prefix = ipv6_dst_prefix
        self.l4_src_port = l4_src_port
        self.target_sites = target_sites if target_sites is not None else []
        self.l4_src_port_range = l4_src_port_range if l4_src_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()
        self.l4_dst_port = l4_dst_port
        self.l4_dst_port_range = l4_dst_port_range if l4_dst_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()
        self.protocol_field = protocol_field

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _dscp = self.dscp
        if _dscp is not None:
            children['dscp'] = yang.gdata.Leaf('uint8', _dscp)
        _dot1p = self.dot1p
        if _dot1p is not None:
            children['dot1p'] = yang.gdata.Leaf('uint8', _dot1p)
        _ipv4_src_prefix = self.ipv4_src_prefix
        if _ipv4_src_prefix is not None:
            children['ipv4-src-prefix'] = yang.gdata.Leaf('string', _ipv4_src_prefix)
        _ipv6_src_prefix = self.ipv6_src_prefix
        if _ipv6_src_prefix is not None:
            children['ipv6-src-prefix'] = yang.gdata.Leaf('string', _ipv6_src_prefix)
        _ipv4_dst_prefix = self.ipv4_dst_prefix
        if _ipv4_dst_prefix is not None:
            children['ipv4-dst-prefix'] = yang.gdata.Leaf('string', _ipv4_dst_prefix)
        _ipv6_dst_prefix = self.ipv6_dst_prefix
        if _ipv6_dst_prefix is not None:
            children['ipv6-dst-prefix'] = yang.gdata.Leaf('string', _ipv6_dst_prefix)
        _l4_src_port = self.l4_src_port
        if _l4_src_port is not None:
            children['l4-src-port'] = yang.gdata.Leaf('uint16', _l4_src_port)
        children['target-sites'] = yang.gdata.LeafList('string', self.target_sites)
        _l4_src_port_range = self.l4_src_port_range
        if _l4_src_port_range is not None:
            children['l4-src-port-range'] = _l4_src_port_range.to_gdata()
        _l4_dst_port = self.l4_dst_port
        if _l4_dst_port is not None:
            children['l4-dst-port'] = yang.gdata.Leaf('uint16', _l4_dst_port)
        _l4_dst_port_range = self.l4_dst_port_range
        if _l4_dst_port_range is not None:
            children['l4-dst-port-range'] = _l4_dst_port_range.to_gdata()
        _protocol_field = self.protocol_field
        if _protocol_field is not None:
            children['protocol-field'] = yang.gdata.Leaf('union', _protocol_field)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(dscp=n.get_opt_int('dscp'), dot1p=n.get_opt_int('dot1p'), ipv4_src_prefix=n.get_opt_str('ipv4-src-prefix'), ipv6_src_prefix=n.get_opt_str('ipv6-src-prefix'), ipv4_dst_prefix=n.get_opt_str('ipv4-dst-prefix'), ipv6_dst_prefix=n.get_opt_str('ipv6-dst-prefix'), l4_src_port=n.get_opt_int('l4-src-port'), target_sites=n.get_opt_strs('target-sites'), l4_src_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_gdata(n.get_opt_container('l4-src-port-range')), l4_dst_port=n.get_opt_int('l4-dst-port'), l4_dst_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_gdata(n.get_opt_container('l4-dst-port-range')), protocol_field=n.get_opt_value('protocol-field'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(dscp=yang.gdata.from_xml_opt_int(n, 'dscp'), dot1p=yang.gdata.from_xml_opt_int(n, 'dot1p'), ipv4_src_prefix=yang.gdata.from_xml_opt_str(n, 'ipv4-src-prefix'), ipv6_src_prefix=yang.gdata.from_xml_opt_str(n, 'ipv6-src-prefix'), ipv4_dst_prefix=yang.gdata.from_xml_opt_str(n, 'ipv4-dst-prefix'), ipv6_dst_prefix=yang.gdata.from_xml_opt_str(n, 'ipv6-dst-prefix'), l4_src_port=yang.gdata.from_xml_opt_int(n, 'l4-src-port'), target_sites=yang.gdata.from_xml_opt_strs(n, 'target-sites'), l4_src_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_xml(yang.gdata.get_xml_opt_child(n, 'l4-src-port-range')), l4_dst_port=yang.gdata.from_xml_opt_int(n, 'l4-dst-port'), l4_dst_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_xml(yang.gdata.get_xml_opt_child(n, 'l4-dst-port-range')), protocol_field=yang.gdata.from_xml_opt_value(n, 'protocol-field'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'dscp':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'dot1p':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-src-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'target-sites':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-src-port-range':
            child = {'l4-src-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l4-dst-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-dst-port-range':
            child = {'l4-dst-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'protocol-field':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_dscp = yang.gdata.take_json_opt_int(jd, 'dscp')
    yang.gdata.maybe_add(children, 'dscp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dscp, child_dscp)
    child_dot1p = yang.gdata.take_json_opt_int(jd, 'dot1p')
    yang.gdata.maybe_add(children, 'dot1p', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dot1p, child_dot1p)
    child_ipv4_src_prefix = yang.gdata.take_json_opt_str(jd, 'ipv4-src-prefix')
    yang.gdata.maybe_add(children, 'ipv4-src-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix, child_ipv4_src_prefix)
    child_ipv6_src_prefix = yang.gdata.take_json_opt_str(jd, 'ipv6-src-prefix')
    yang.gdata.maybe_add(children, 'ipv6-src-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix, child_ipv6_src_prefix)
    child_ipv4_dst_prefix = yang.gdata.take_json_opt_str(jd, 'ipv4-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv4-dst-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix, child_ipv4_dst_prefix)
    child_ipv6_dst_prefix = yang.gdata.take_json_opt_str(jd, 'ipv6-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv6-dst-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix, child_ipv6_dst_prefix)
    child_l4_src_port = yang.gdata.take_json_opt_int(jd, 'l4-src-port')
    yang.gdata.maybe_add(children, 'l4-src-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port, child_l4_src_port)
    child_target_sites = yang.gdata.take_json_opt_strs(jd, 'target-sites')
    yang.gdata.maybe_add(children, 'target-sites', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__target_sites, child_target_sites)
    child_l4_src_port_range = yang.gdata.take_json_opt_cnt(jd, 'l4-src-port-range')
    yang.gdata.maybe_add(children, 'l4-src-port-range', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range, child_l4_src_port_range)
    child_l4_dst_port = yang.gdata.take_json_opt_int(jd, 'l4-dst-port')
    yang.gdata.maybe_add(children, 'l4-dst-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port, child_l4_dst_port)
    child_l4_dst_port_range = yang.gdata.take_json_opt_cnt(jd, 'l4-dst-port-range')
    yang.gdata.maybe_add(children, 'l4-dst-port-range', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range, child_l4_dst_port_range)
    child_protocol_field = yang.gdata.take_json_opt_value(jd, 'protocol-field')
    yang.gdata.maybe_add(children, 'protocol-field', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__protocol_field, child_protocol_field)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_application(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__target_class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(yang.adata.MNode):
    id: str
    match_flow: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow
    match_application: ?str
    target_class_id: ?str

    mut def __init__(self, id: str, match_flow: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow=None, match_application: ?str, target_class_id: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.match_flow = match_flow if match_flow is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow()
        self.match_application = match_application
        self.target_class_id = target_class_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        _match_flow = self.match_flow
        if _match_flow is not None:
            children['match-flow'] = _match_flow.to_gdata()
        _match_application = self.match_application
        if _match_application is not None:
            children['match-application'] = yang.gdata.Leaf('identityref', _match_application)
        _target_class_id = self.target_class_id
        if _target_class_id is not None:
            children['target-class-id'] = yang.gdata.Leaf('string', _target_class_id)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(id=n.get_str('id'), match_flow=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow.from_gdata(n.get_opt_container('match-flow')), match_application=n.get_opt_str('match-application'), target_class_id=n.get_opt_str('target-class-id'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(id=yang.gdata.from_xml_str(n, 'id'), match_flow=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow.from_xml(yang.gdata.get_xml_opt_child(n, 'match-flow')), match_application=yang.gdata.from_xml_opt_str(n, 'match-application'), target_class_id=yang.gdata.from_xml_opt_str(n, 'target-class-id'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'rule'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements, user_order=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__id(keys[0])
        if point == 'match-flow':
            children['match-flow'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(jd, rest_path, op)
        if point == 'match-application':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'target-class-id':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['id'], elements, user_order=True)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd, path, op)], user_order=True)
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__id, child_id)
    child_match_flow = yang.gdata.take_json_opt_cnt(jd, 'match-flow')
    yang.gdata.maybe_add(children, 'match-flow', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow, child_match_flow)
    child_match_application = yang.gdata.take_json_opt_str(jd, 'match-application')
    yang.gdata.maybe_add(children, 'match-application', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_application, child_match_application)
    child_target_class_id = yang.gdata.take_json_opt_str(jd, 'target-class-id')
    yang.gdata.maybe_add(children, 'target-class-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__target_class_id, child_target_class_id)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(e))
    return yang.gdata.List(keys=['id'], elements=elements, user_order=True)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(yang.adata.MNode):
    rule: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule

    mut def __init__(self, rule: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rule = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(elements=rule)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rule = self.rule
        if _rule is not None:
            children['rule'] = _rule.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(rule=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule.from_gdata(n.get_opt_list('rule')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(rule=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule.from_xml(yang.gdata.get_xml_children(n, 'rule')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'rule':
            child = {'rule': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rule = yang.gdata.take_json_opt_list(jd, 'rule')
    yang.gdata.maybe_add(children, 'rule', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule, child_rule)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__profile(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__direction(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__rate_limit(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__use_lowest_latency(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(yang.adata.MNode):
    use_lowest_latency: ?bool
    latency_boundary: ?int

    mut def __init__(self, use_lowest_latency: ?bool, latency_boundary: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_latency = use_lowest_latency
        self.latency_boundary = latency_boundary

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_latency = self.use_lowest_latency
        if _use_lowest_latency is not None:
            children['use-lowest-latency'] = yang.gdata.Leaf('empty', _use_lowest_latency)
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint16', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(use_lowest_latency=n.get_opt_bool('use-lowest-latency'), latency_boundary=n.get_opt_int('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(use_lowest_latency=yang.gdata.from_xml_opt_bool(n, 'use-lowest-latency'), latency_boundary=yang.gdata.from_xml_opt_int(n, 'latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'use-lowest-latency':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_latency = yang.gdata.take_json_opt_bool(jd, 'use-lowest-latency')
    yang.gdata.maybe_add(children, 'use-lowest-latency', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__use_lowest_latency, child_use_lowest_latency)
    child_latency_boundary = yang.gdata.take_json_opt_int(jd, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(yang.adata.MNode):
    use_lowest_jitter: ?bool
    latency_boundary: ?int

    mut def __init__(self, use_lowest_jitter: ?bool, latency_boundary: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_jitter = use_lowest_jitter
        self.latency_boundary = latency_boundary

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_jitter = self.use_lowest_jitter
        if _use_lowest_jitter is not None:
            children['use-lowest-jitter'] = yang.gdata.Leaf('empty', _use_lowest_jitter)
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint32', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(use_lowest_jitter=n.get_opt_bool('use-lowest-jitter'), latency_boundary=n.get_opt_int('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(use_lowest_jitter=yang.gdata.from_xml_opt_bool(n, 'use-lowest-jitter'), latency_boundary=yang.gdata.from_xml_opt_int(n, 'latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'use-lowest-jitter':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_jitter = yang.gdata.take_json_opt_bool(jd, 'use-lowest-jitter')
    yang.gdata.maybe_add(children, 'use-lowest-jitter', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter, child_use_lowest_jitter)
    child_latency_boundary = yang.gdata.take_json_opt_int(jd, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__end_to_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(yang.adata.MNode):
    guaranteed_bw_percent: ?float
    end_to_end: ?bool

    mut def __init__(self, guaranteed_bw_percent: ?float, end_to_end: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.guaranteed_bw_percent = guaranteed_bw_percent
        self.end_to_end = end_to_end

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _guaranteed_bw_percent = self.guaranteed_bw_percent
        if _guaranteed_bw_percent is not None:
            children['guaranteed-bw-percent'] = yang.gdata.Leaf('decimal64', _guaranteed_bw_percent)
        _end_to_end = self.end_to_end
        if _end_to_end is not None:
            children['end-to-end'] = yang.gdata.Leaf('empty', _end_to_end)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(guaranteed_bw_percent=n.get_opt_float('guaranteed-bw-percent'), end_to_end=n.get_opt_bool('end-to-end'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth')

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(guaranteed_bw_percent=yang.gdata.from_xml_opt_float(n, 'guaranteed-bw-percent'), end_to_end=yang.gdata.from_xml_opt_bool(n, 'end-to-end'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth')


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'guaranteed-bw-percent':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'end-to-end':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_guaranteed_bw_percent = yang.gdata.take_json_float(jd, 'guaranteed-bw-percent')
    yang.gdata.maybe_add(children, 'guaranteed-bw-percent', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent, child_guaranteed_bw_percent)
    child_end_to_end = yang.gdata.take_json_opt_bool(jd, 'end-to-end')
    yang.gdata.maybe_add(children, 'end-to-end', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__end_to_end, child_end_to_end)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(yang.adata.MNode):
    class_id: str
    direction: ?str
    rate_limit: ?float
    latency: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency
    jitter: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter
    bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth

    mut def __init__(self, class_id: str, direction: ?str, rate_limit: ?float, latency: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency=None, jitter: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter=None, bandwidth: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_id = class_id
        self.direction = direction
        self.rate_limit = rate_limit
        self.latency = latency if latency is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency()
        self.jitter = jitter if jitter is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter()
        self.bandwidth = bandwidth if bandwidth is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_id = self.class_id
        if _class_id is not None:
            children['class-id'] = yang.gdata.Leaf('string', _class_id)
        _direction = self.direction
        if _direction is not None:
            children['direction'] = yang.gdata.Leaf('identityref', _direction)
        _rate_limit = self.rate_limit
        if _rate_limit is not None:
            children['rate-limit'] = yang.gdata.Leaf('decimal64', _rate_limit)
        _latency = self.latency
        if _latency is not None:
            children['latency'] = _latency.to_gdata()
        _jitter = self.jitter
        if _jitter is not None:
            children['jitter'] = _jitter.to_gdata()
        _bandwidth = self.bandwidth
        if _bandwidth is not None:
            children['bandwidth'] = _bandwidth.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.class_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(class_id=n.get_str('class-id'), direction=n.get_opt_str('direction'), rate_limit=n.get_opt_float('rate-limit'), latency=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency.from_gdata(n.get_opt_container('latency')), jitter=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter.from_gdata(n.get_opt_container('jitter')), bandwidth=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth.from_gdata(n.get_opt_container('bandwidth')))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(class_id=yang.gdata.from_xml_str(n, 'class-id'), direction=yang.gdata.from_xml_opt_str(n, 'direction'), rate_limit=yang.gdata.from_xml_opt_float(n, 'rate-limit'), latency=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency.from_xml(yang.gdata.get_xml_opt_child(n, 'latency')), jitter=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter.from_xml(yang.gdata.get_xml_opt_child(n, 'jitter')), bandwidth=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth.from_xml(yang.gdata.get_xml_opt_child(n, 'bandwidth')))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'class'
        self.elements = elements

    mut def create(self, class_id):
        for e in self.elements:
            match = True
            if e.class_id != class_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(class_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['class-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['class-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__class_id(keys[0])
        if point == 'direction':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'rate-limit':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency':
            children['latency'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(jd, rest_path, op)
        if point == 'jitter':
            children['jitter'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(jd, rest_path, op)
        if point == 'bandwidth':
            children['bandwidth'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['class-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['class-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['class-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_class_id = yang.gdata.take_json_str(jd, 'class-id')
    yang.gdata.maybe_add(children, 'class-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__class_id, child_class_id)
    child_direction = yang.gdata.take_json_opt_str(jd, 'direction')
    yang.gdata.maybe_add(children, 'direction', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__direction, child_direction)
    child_rate_limit = yang.gdata.take_json_opt_float(jd, 'rate-limit')
    yang.gdata.maybe_add(children, 'rate-limit', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__rate_limit, child_rate_limit)
    child_latency = yang.gdata.take_json_opt_cnt(jd, 'latency')
    yang.gdata.maybe_add(children, 'latency', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency, child_latency)
    child_jitter = yang.gdata.take_json_opt_cnt(jd, 'jitter')
    yang.gdata.maybe_add(children, 'jitter', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter, child_jitter)
    child_bandwidth = yang.gdata.take_json_opt_cnt(jd, 'bandwidth')
    yang.gdata.maybe_add(children, 'bandwidth', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth, child_bandwidth)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_class_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(e))
    return yang.gdata.List(keys=['class-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(yang.adata.MNode):
    class_: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class

    mut def __init__(self, class_: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_ = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(elements=class_)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_ = self.class_
        if _class_ is not None:
            children['class'] = _class_.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(class_=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class.from_gdata(n.get_opt_list('class')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(class_=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class.from_xml(yang.gdata.get_xml_children(n, 'class')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'class':
            child = {'class': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_class_ = yang.gdata.take_json_opt_list(jd, 'class')
    yang.gdata.maybe_add(children, 'class', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class, child_class_)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(yang.adata.MNode):
    profile: ?str
    classes: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes

    mut def __init__(self, profile: ?str, classes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile = profile
        self.classes = classes if classes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile = self.profile
        if _profile is not None:
            children['profile'] = yang.gdata.Leaf('leafref', _profile)
        _classes = self.classes
        if _classes is not None:
            children['classes'] = _classes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(profile=n.get_opt_str('profile'), classes=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes.from_gdata(n.get_opt_container('classes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(profile=yang.gdata.from_xml_opt_str(n, 'profile'), classes=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes.from_xml(yang.gdata.get_xml_opt_child(n, 'classes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'profile':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'classes':
            child = {'classes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile = yang.gdata.take_json_opt_str(jd, 'profile')
    yang.gdata.maybe_add(children, 'profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__profile, child_profile)
    child_classes = yang.gdata.take_json_opt_cnt(jd, 'classes')
    yang.gdata.maybe_add(children, 'classes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes, child_classes)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(yang.adata.MNode):
    qos_classification_policy: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy
    qos_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile

    mut def __init__(self, qos_classification_policy: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy=None, qos_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.qos_classification_policy = qos_classification_policy if qos_classification_policy is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy()
        self.qos_profile = qos_profile if qos_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _qos_classification_policy = self.qos_classification_policy
        if _qos_classification_policy is not None:
            children['qos-classification-policy'] = _qos_classification_policy.to_gdata()
        _qos_profile = self.qos_profile
        if _qos_profile is not None:
            children['qos-profile'] = _qos_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(qos_classification_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy.from_gdata(n.get_opt_container('qos-classification-policy')), qos_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile.from_gdata(n.get_opt_container('qos-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(qos_classification_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy.from_xml(yang.gdata.get_xml_opt_child(n, 'qos-classification-policy')), qos_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile.from_xml(yang.gdata.get_xml_opt_child(n, 'qos-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'qos-classification-policy':
            child = {'qos-classification-policy': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'qos-profile':
            child = {'qos-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_qos_classification_policy = yang.gdata.take_json_opt_cnt(jd, 'qos-classification-policy')
    yang.gdata.maybe_add(children, 'qos-classification-policy', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy, child_qos_classification_policy)
    child_qos_profile = yang.gdata.take_json_opt_cnt(jd, 'qos-profile')
    yang.gdata.maybe_add(children, 'qos-profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile, child_qos_profile)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier__signalling_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(yang.adata.MNode):
    signalling_type: ?str

    mut def __init__(self, signalling_type: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.signalling_type = signalling_type

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _signalling_type = self.signalling_type
        if _signalling_type is not None:
            children['signalling-type'] = yang.gdata.Leaf('enumeration', _signalling_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(signalling_type=n.get_opt_str('signalling-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(signalling_type=yang.gdata.from_xml_opt_str(n, 'signalling-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'signalling-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_signalling_type = yang.gdata.take_json_opt_str(jd, 'signalling-type')
    yang.gdata.maybe_add(children, 'signalling-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier__signalling_type, child_signalling_type)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_site_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv4(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv6(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(yang.adata.MNode):
    ipv4: ?bool
    ipv6: ?bool

    mut def __init__(self, ipv4: ?bool, ipv6: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4 = ipv4
        self.ipv6 = ipv6

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            children['ipv4'] = yang.gdata.Leaf('boolean', _ipv4)
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            children['ipv6'] = yang.gdata.Leaf('boolean', _ipv6)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(ipv4=n.get_opt_bool('ipv4'), ipv6=n.get_opt_bool('ipv6'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(ipv4=yang.gdata.from_xml_opt_bool(n, 'ipv4'), ipv6=yang.gdata.from_xml_opt_bool(n, 'ipv6'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'ipv4':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.take_json_opt_bool(jd, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.take_json_opt_bool(jd, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv6, child_ipv6)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__protocol_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(yang.adata.MNode):
    multicast_site_type: ?str
    multicast_address_family: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family
    protocol_type: ?str

    mut def __init__(self, multicast_site_type: ?str, multicast_address_family: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family=None, protocol_type: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.multicast_site_type = multicast_site_type
        self.multicast_address_family = multicast_address_family if multicast_address_family is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family()
        self.protocol_type = protocol_type

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _multicast_site_type = self.multicast_site_type
        if _multicast_site_type is not None:
            children['multicast-site-type'] = yang.gdata.Leaf('enumeration', _multicast_site_type)
        _multicast_address_family = self.multicast_address_family
        if _multicast_address_family is not None:
            children['multicast-address-family'] = _multicast_address_family.to_gdata()
        _protocol_type = self.protocol_type
        if _protocol_type is not None:
            children['protocol-type'] = yang.gdata.Leaf('enumeration', _protocol_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(multicast_site_type=n.get_opt_str('multicast-site-type'), multicast_address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family.from_gdata(n.get_opt_container('multicast-address-family')), protocol_type=n.get_opt_str('protocol-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(multicast_site_type=yang.gdata.from_xml_opt_str(n, 'multicast-site-type'), multicast_address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family.from_xml(yang.gdata.get_xml_opt_child(n, 'multicast-address-family')), protocol_type=yang.gdata.from_xml_opt_str(n, 'protocol-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'multicast-site-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'multicast-address-family':
            child = {'multicast-address-family': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'protocol-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_multicast_site_type = yang.gdata.take_json_opt_str(jd, 'multicast-site-type')
    yang.gdata.maybe_add(children, 'multicast-site-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_site_type, child_multicast_site_type)
    child_multicast_address_family = yang.gdata.take_json_opt_cnt(jd, 'multicast-address-family')
    yang.gdata.maybe_add(children, 'multicast-address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family, child_multicast_address_family)
    child_protocol_type = yang.gdata.take_json_opt_str(jd, 'protocol-type')
    yang.gdata.maybe_add(children, 'protocol-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__protocol_type, child_protocol_type)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service(yang.adata.MNode):
    qos: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos
    carrierscarrier: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier
    multicast: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast

    mut def __init__(self, qos: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos=None, carrierscarrier: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier=None, multicast: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.qos = qos if qos is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos()
        self.carrierscarrier = carrierscarrier if carrierscarrier is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier()
        self.multicast = multicast if multicast is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _qos = self.qos
        if _qos is not None:
            children['qos'] = _qos.to_gdata()
        _carrierscarrier = self.carrierscarrier
        if _carrierscarrier is not None:
            children['carrierscarrier'] = _carrierscarrier.to_gdata()
        _multicast = self.multicast
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service(qos=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos.from_gdata(n.get_opt_container('qos')), carrierscarrier=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier.from_gdata(n.get_opt_container('carrierscarrier')), multicast=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast.from_gdata(n.get_opt_container('multicast')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service(qos=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos.from_xml(yang.gdata.get_xml_opt_child(n, 'qos')), carrierscarrier=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier.from_xml(yang.gdata.get_xml_opt_child(n, 'carrierscarrier')), multicast=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast.from_xml(yang.gdata.get_xml_opt_child(n, 'multicast')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'qos':
            child = {'qos': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'carrierscarrier':
            child = {'carrierscarrier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'multicast':
            child = {'multicast': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_qos = yang.gdata.take_json_opt_cnt(jd, 'qos')
    yang.gdata.maybe_add(children, 'qos', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos, child_qos)
    child_carrierscarrier = yang.gdata.take_json_opt_cnt(jd, 'carrierscarrier')
    yang.gdata.maybe_add(children, 'carrierscarrier', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier, child_carrierscarrier)
    child_multicast = yang.gdata.take_json_opt_cnt(jd, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast, child_multicast)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(yang.adata.MNode):
    enabled: ?bool

    mut def __init__(self, enabled: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(enabled=n.get_opt_bool('enabled'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(enabled=yang.gdata.from_xml_opt_bool(n, 'enabled'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection__enabled, child_enabled)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__area_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(yang.adata.MNode):
    target_site: str
    metric: ?int

    mut def __init__(self, target_site: str, metric: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.target_site = target_site
        self.metric = metric

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _target_site = self.target_site
        if _target_site is not None:
            children['target-site'] = yang.gdata.Leaf('string', _target_site)
        _metric = self.metric
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.target_site)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site=n.get_str('target-site'), metric=n.get_opt_int('metric'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site=yang.gdata.from_xml_str(n, 'target-site'), metric=yang.gdata.from_xml_opt_int(n, 'metric'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'sham-link'
        self.elements = elements

    mut def create(self, target_site):
        for e in self.elements:
            match = True
            if e.target_site != target_site:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['target-site'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['target-site'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(keys[0])
        if point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['target-site']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['target-site'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['target-site'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_target_site = yang.gdata.take_json_str(jd, 'target-site')
    yang.gdata.maybe_add(children, 'target-site', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site, child_target_site)
    child_metric = yang.gdata.take_json_opt_int(jd, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric, child_metric)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_target_site)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(e))
    return yang.gdata.List(keys=['target-site'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(yang.adata.MNode):
    sham_link: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link

    mut def __init__(self, sham_link: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.sham_link = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(elements=sham_link)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _sham_link = self.sham_link
        if _sham_link is not None:
            children['sham-link'] = _sham_link.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(sham_link=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link.from_gdata(n.get_opt_list('sham-link')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(sham_link=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link.from_xml(yang.gdata.get_xml_children(n, 'sham-link')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'sham-link':
            child = {'sham-link': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_sham_link = yang.gdata.take_json_opt_list(jd, 'sham-link')
    yang.gdata.maybe_add(children, 'sham-link', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link, child_sham_link)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(yang.adata.MNode):
    address_family: list[str]
    area_address: ?str
    metric: ?int
    sham_links: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links

    mut def __init__(self, address_family: ?list[str]=None, area_address: ?str, metric: ?int, sham_links: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []
        self.area_address = area_address
        self.metric = metric
        self.sham_links = sham_links if sham_links is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['address-family'] = yang.gdata.LeafList('enumeration', self.address_family)
        _area_address = self.area_address
        if _area_address is not None:
            children['area-address'] = yang.gdata.Leaf('string', _area_address)
        _metric = self.metric
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        _sham_links = self.sham_links
        if _sham_links is not None:
            children['sham-links'] = _sham_links.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(address_family=n.get_opt_strs('address-family'), area_address=n.get_opt_str('area-address'), metric=n.get_opt_int('metric'), sham_links=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links.from_gdata(n.get_opt_container('sham-links')))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(address_family=yang.gdata.from_xml_opt_strs(n, 'address-family'), area_address=yang.gdata.from_xml_opt_str(n, 'area-address'), metric=yang.gdata.from_xml_opt_int(n, 'metric'), sham_links=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links.from_xml(yang.gdata.get_xml_opt_child(n, 'sham-links')))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'area-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'sham-links':
            child = {'sham-links': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_opt_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__address_family, child_address_family)
    child_area_address = yang.gdata.take_json_str(jd, 'area-address')
    yang.gdata.maybe_add(children, 'area-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__area_address, child_area_address)
    child_metric = yang.gdata.take_json_opt_int(jd, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__metric, child_metric)
    child_sham_links = yang.gdata.take_json_opt_cnt(jd, 'sham-links')
    yang.gdata.maybe_add(children, 'sham-links', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links, child_sham_links)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__autonomous_system(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(yang.adata.MNode):
    autonomous_system: ?int
    address_family: list[str]

    mut def __init__(self, autonomous_system: ?int, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.autonomous_system = autonomous_system
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _autonomous_system = self.autonomous_system
        if _autonomous_system is not None:
            children['autonomous-system'] = yang.gdata.Leaf('uint32', _autonomous_system)
        children['address-family'] = yang.gdata.LeafList('enumeration', self.address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(autonomous_system=n.get_opt_int('autonomous-system'), address_family=n.get_opt_strs('address-family'))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(autonomous_system=yang.gdata.from_xml_opt_int(n, 'autonomous-system'), address_family=yang.gdata.from_xml_opt_strs(n, 'address-family'))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'autonomous-system':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_autonomous_system = yang.gdata.take_json_int(jd, 'autonomous-system')
    yang.gdata.maybe_add(children, 'autonomous-system', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__autonomous_system, child_autonomous_system)
    child_address_family = yang.gdata.take_json_opt_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__address_family, child_address_family)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        _next_hop = self.next_hop
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.lan), yang.gdata.yang_str(self.next_hop)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan=yang.gdata.from_xml_str(n, 'lan'), next_hop=yang.gdata.from_xml_str(n, 'next-hop'), lan_tag=yang.gdata.from_xml_opt_str(n, 'lan-tag'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv4-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self.elements:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(keys[0])
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(keys[1])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.take_json_str(jd, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.take_json_str(jd, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.take_json_opt_str(jd, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_lan), yang.gdata.yang_str(child_next_hop)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(e))
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        _next_hop = self.next_hop
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.lan), yang.gdata.yang_str(self.next_hop)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan=yang.gdata.from_xml_str(n, 'lan'), next_hop=yang.gdata.from_xml_str(n, 'next-hop'), lan_tag=yang.gdata.from_xml_opt_str(n, 'lan-tag'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv6-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self.elements:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(keys[0])
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(keys[1])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.take_json_str(jd, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.take_json_str(jd, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.take_json_opt_str(jd, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_lan), yang.gdata.yang_str(child_next_hop)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(e))
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.adata.MNode):
    ipv4_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes
    ipv6_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes

    mut def __init__(self, ipv4_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]=[], ipv6_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(elements=ipv4_lan_prefixes)
        self.ipv6_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(elements=ipv6_lan_prefixes)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4_lan_prefixes = self.ipv4_lan_prefixes
        if _ipv4_lan_prefixes is not None:
            children['ipv4-lan-prefixes'] = _ipv4_lan_prefixes.to_gdata()
        _ipv6_lan_prefixes = self.ipv6_lan_prefixes
        if _ipv6_lan_prefixes is not None:
            children['ipv6-lan-prefixes'] = _ipv6_lan_prefixes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(ipv4_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes.from_gdata(n.get_opt_list('ipv4-lan-prefixes')), ipv6_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes.from_gdata(n.get_opt_list('ipv6-lan-prefixes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(ipv4_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes.from_xml(yang.gdata.get_xml_children(n, 'ipv4-lan-prefixes')), ipv6_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes.from_xml(yang.gdata.get_xml_children(n, 'ipv6-lan-prefixes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'ipv4-lan-prefixes':
            child = {'ipv4-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'ipv6-lan-prefixes':
            child = {'ipv6-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4_lan_prefixes = yang.gdata.take_json_opt_list(jd, 'ipv4-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv4-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes, child_ipv4_lan_prefixes)
    child_ipv6_lan_prefixes = yang.gdata.take_json_opt_list(jd, 'ipv6-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv6-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes, child_ipv6_lan_prefixes)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(yang.adata.MNode):
    cascaded_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes

    mut def __init__(self, cascaded_lan_prefixes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cascaded_lan_prefixes = cascaded_lan_prefixes if cascaded_lan_prefixes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cascaded_lan_prefixes = self.cascaded_lan_prefixes
        if _cascaded_lan_prefixes is not None:
            children['cascaded-lan-prefixes'] = _cascaded_lan_prefixes.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(cascaded_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_gdata(n.get_opt_container('cascaded-lan-prefixes')))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(cascaded_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_xml(yang.gdata.get_xml_opt_child(n, 'cascaded-lan-prefixes')))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'cascaded-lan-prefixes':
            child = {'cascaded-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cascaded_lan_prefixes = yang.gdata.take_json_opt_cnt(jd, 'cascaded-lan-prefixes')
    yang.gdata.maybe_add(children, 'cascaded-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes, child_cascaded_lan_prefixes)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['address-family'] = yang.gdata.LeafList('enumeration', self.address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(address_family=n.get_opt_strs('address-family'))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(address_family=yang.gdata.from_xml_opt_strs(n, 'address-family'))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_opt_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip__address_family, child_address_family)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['address-family'] = yang.gdata.LeafList('enumeration', self.address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(address_family=n.get_opt_strs('address-family'))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(address_family=yang.gdata.from_xml_opt_strs(n, 'address-family'))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_opt_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp__address_family, child_address_family)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(yang.adata.MNode):
    type: str
    ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf
    bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp
    static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static
    rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip
    vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp

    mut def __init__(self, type: str, ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf=None, bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp=None, static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static=None, rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip=None, vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type
        self.ospf = ospf
        self.bgp = bgp
        self.static = static
        self.rip = rip
        self.vrrp = vrrp

    mut def create_ospf(self, area_address):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(area_address)
        self.ospf = res
        return res

    mut def create_bgp(self, autonomous_system):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(autonomous_system)
        self.bgp = res
        return res

    mut def create_static(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static()
        self.static = res
        return res

    mut def create_rip(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip()
        self.rip = res
        return res

    mut def create_vrrp(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp()
        self.vrrp = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        if _type is not None:
            children['type'] = yang.gdata.Leaf('identityref', _type)
        _ospf = self.ospf
        if _ospf is not None:
            children['ospf'] = _ospf.to_gdata()
        _bgp = self.bgp
        if _bgp is not None:
            children['bgp'] = _bgp.to_gdata()
        _static = self.static
        if _static is not None:
            children['static'] = _static.to_gdata()
        _rip = self.rip
        if _rip is not None:
            children['rip'] = _rip.to_gdata()
        _vrrp = self.vrrp
        if _vrrp is not None:
            children['vrrp'] = _vrrp.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.type)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(type=n.get_str('type'), ospf=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf.from_gdata(n.get_opt_container('ospf')), bgp=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp.from_gdata(n.get_opt_container('bgp')), static=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static.from_gdata(n.get_opt_container('static')), rip=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip.from_gdata(n.get_opt_container('rip')), vrrp=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp.from_gdata(n.get_opt_container('vrrp')))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(type=yang.gdata.from_xml_str(n, 'type'), ospf=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf.from_xml(yang.gdata.get_xml_opt_child(n, 'ospf')), bgp=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp.from_xml(yang.gdata.get_xml_opt_child(n, 'bgp')), static=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static.from_xml(yang.gdata.get_xml_opt_child(n, 'static')), rip=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip.from_xml(yang.gdata.get_xml_opt_child(n, 'rip')), vrrp=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp.from_xml(yang.gdata.get_xml_opt_child(n, 'vrrp')))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'routing-protocol'
        self.elements = elements

    mut def create(self, type):
        for e in self.elements:
            match = True
            if e.type != type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['type'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__type(keys[0])
        if point == 'ospf':
            children['ospf'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(jd, rest_path, op)
        if point == 'bgp':
            children['bgp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(jd, rest_path, op)
        if point == 'static':
            children['static'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(jd, rest_path, op)
        if point == 'rip':
            children['rip'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(jd, rest_path, op)
        if point == 'vrrp':
            children['vrrp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['type'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_type = yang.gdata.take_json_str(jd, 'type')
    yang.gdata.maybe_add(children, 'type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__type, child_type)
    child_ospf = yang.gdata.take_json_opt_cnt(jd, 'ospf')
    yang.gdata.maybe_add(children, 'ospf', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf, child_ospf)
    child_bgp = yang.gdata.take_json_opt_cnt(jd, 'bgp')
    yang.gdata.maybe_add(children, 'bgp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp, child_bgp)
    child_static = yang.gdata.take_json_opt_cnt(jd, 'static')
    yang.gdata.maybe_add(children, 'static', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static, child_static)
    child_rip = yang.gdata.take_json_opt_cnt(jd, 'rip')
    yang.gdata.maybe_add(children, 'rip', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip, child_rip)
    child_vrrp = yang.gdata.take_json_opt_cnt(jd, 'vrrp')
    yang.gdata.maybe_add(children, 'vrrp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp, child_vrrp)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_type)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(e))
    return yang.gdata.List(keys=['type'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(yang.adata.MNode):
    routing_protocol: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol

    mut def __init__(self, routing_protocol: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.routing_protocol = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(elements=routing_protocol)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _routing_protocol = self.routing_protocol
        if _routing_protocol is not None:
            children['routing-protocol'] = _routing_protocol.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(routing_protocol=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol.from_gdata(n.get_opt_list('routing-protocol')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(routing_protocol=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol.from_xml(yang.gdata.get_xml_children(n, 'routing-protocol')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'routing-protocol':
            child = {'routing-protocol': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_routing_protocol = yang.gdata.take_json_opt_list(jd, 'routing-protocol')
    yang.gdata.maybe_add(children, 'routing-protocol', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol, child_routing_protocol)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__location_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__device_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(yang.adata.MNode):
    group_id: str

    mut def __init__(self, group_id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.group_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(group_id=n.get_str('group-id'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(group_id=yang.gdata.from_xml_str(n, 'group-id'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self.elements:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group__group_id(keys[0])
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.take_json_str(jd, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group__group_id, child_group_id)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_group_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(e))
    return yang.gdata.List(keys=['group-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(elements=group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group.from_gdata(n.get_opt_list('group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group.from_xml(yang.gdata.get_xml_children(n, 'group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.take_json_opt_list(jd, 'group')
    yang.gdata.maybe_add(children, 'group', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group, child_group)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__constraint_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(yang.adata.MNode):
    group_id: str

    mut def __init__(self, group_id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.group_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(group_id=n.get_str('group-id'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(group_id=yang.gdata.from_xml_str(n, 'group-id'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self.elements:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group__group_id(keys[0])
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.take_json_str(jd, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group__group_id, child_group_id)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_group_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(e))
    return yang.gdata.List(keys=['group-id'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_accesses(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_groups(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group
    all_other_accesses: ?bool
    all_other_groups: ?bool

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]=[], all_other_accesses: ?bool, all_other_groups: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(elements=group)
        self.all_other_accesses = all_other_accesses
        self.all_other_groups = all_other_groups

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        _all_other_accesses = self.all_other_accesses
        if _all_other_accesses is not None:
            children['all-other-accesses'] = yang.gdata.Leaf('empty', _all_other_accesses)
        _all_other_groups = self.all_other_groups
        if _all_other_groups is not None:
            children['all-other-groups'] = yang.gdata.Leaf('empty', _all_other_groups)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group.from_gdata(n.get_opt_list('group')), all_other_accesses=n.get_opt_bool('all-other-accesses'), all_other_groups=n.get_opt_bool('all-other-groups'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group.from_xml(yang.gdata.get_xml_children(n, 'group')), all_other_accesses=yang.gdata.from_xml_opt_bool(n, 'all-other-accesses'), all_other_groups=yang.gdata.from_xml_opt_bool(n, 'all-other-groups'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'all-other-accesses':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'all-other-groups':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.take_json_opt_list(jd, 'group')
    yang.gdata.maybe_add(children, 'group', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group, child_group)
    child_all_other_accesses = yang.gdata.take_json_opt_bool(jd, 'all-other-accesses')
    yang.gdata.maybe_add(children, 'all-other-accesses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_accesses, child_all_other_accesses)
    child_all_other_groups = yang.gdata.take_json_opt_bool(jd, 'all-other-groups')
    yang.gdata.maybe_add(children, 'all-other-groups', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_groups, child_all_other_groups)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(yang.adata.MNode):
    constraint_type: str
    target: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target

    mut def __init__(self, constraint_type: str, target: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.constraint_type = constraint_type
        self.target = target if target is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _constraint_type = self.constraint_type
        if _constraint_type is not None:
            children['constraint-type'] = yang.gdata.Leaf('identityref', _constraint_type)
        _target = self.target
        if _target is not None:
            children['target'] = _target.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.constraint_type)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(constraint_type=n.get_str('constraint-type'), target=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target.from_gdata(n.get_opt_container('target')))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(constraint_type=yang.gdata.from_xml_str(n, 'constraint-type'), target=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target.from_xml(yang.gdata.get_xml_opt_child(n, 'target')))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'constraint'
        self.elements = elements

    mut def create(self, constraint_type):
        for e in self.elements:
            match = True
            if e.constraint_type != constraint_type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(constraint_type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['constraint-type'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['constraint-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__constraint_type(keys[0])
        if point == 'target':
            children['target'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['constraint-type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['constraint-type'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['constraint-type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_constraint_type = yang.gdata.take_json_str(jd, 'constraint-type')
    yang.gdata.maybe_add(children, 'constraint-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__constraint_type, child_constraint_type)
    child_target = yang.gdata.take_json_opt_cnt(jd, 'target')
    yang.gdata.maybe_add(children, 'target', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target, child_target)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_constraint_type)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(e))
    return yang.gdata.List(keys=['constraint-type'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(yang.adata.MNode):
    constraint: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint

    mut def __init__(self, constraint: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.constraint = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(elements=constraint)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _constraint = self.constraint
        if _constraint is not None:
            children['constraint'] = _constraint.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(constraint=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint.from_gdata(n.get_opt_list('constraint')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(constraint=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint.from_xml(yang.gdata.get_xml_children(n, 'constraint')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'constraint':
            child = {'constraint': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_constraint = yang.gdata.take_json_opt_list(jd, 'constraint')
    yang.gdata.maybe_add(children, 'constraint', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint, child_constraint)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(yang.adata.MNode):
    groups: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups
    constraints: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints

    mut def __init__(self, groups: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups=None, constraints: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.groups = groups if groups is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups()
        self.constraints = constraints if constraints is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _groups = self.groups
        if _groups is not None:
            children['groups'] = _groups.to_gdata()
        _constraints = self.constraints
        if _constraints is not None:
            children['constraints'] = _constraints.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(groups=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups.from_gdata(n.get_opt_container('groups')), constraints=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints.from_gdata(n.get_opt_container('constraints')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(groups=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups.from_xml(yang.gdata.get_xml_opt_child(n, 'groups')), constraints=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints.from_xml(yang.gdata.get_xml_opt_child(n, 'constraints')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'groups':
            child = {'groups': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'constraints':
            child = {'constraints': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_groups = yang.gdata.take_json_opt_cnt(jd, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups, child_groups)
    child_constraints = yang.gdata.take_json_opt_cnt(jd, 'constraints')
    yang.gdata.maybe_add(children, 'constraints', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints, child_constraints)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__requested_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__strict(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(yang.adata.MNode):
    requested_type: ?str
    strict: ?bool

    mut def __init__(self, requested_type: ?str, strict: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.requested_type = requested_type
        self.strict = strict

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _requested_type = self.requested_type
        if _requested_type is not None:
            children['requested-type'] = yang.gdata.Leaf('string', _requested_type)
        _strict = self.strict
        if _strict is not None:
            children['strict'] = yang.gdata.Leaf('boolean', _strict)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(requested_type=n.get_opt_str('requested-type'), strict=n.get_opt_bool('strict'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(requested_type=yang.gdata.from_xml_opt_str(n, 'requested-type'), strict=yang.gdata.from_xml_opt_bool(n, 'strict'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'requested-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'strict':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_requested_type = yang.gdata.take_json_opt_str(jd, 'requested-type')
    yang.gdata.maybe_add(children, 'requested-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__requested_type, child_requested_type)
    child_strict = yang.gdata.take_json_opt_bool(jd, 'strict')
    yang.gdata.maybe_add(children, 'strict', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__strict, child_strict)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__always_on(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__bearer_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(yang.adata.MNode):
    requested_type: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type
    always_on: ?bool
    bearer_reference: ?str

    mut def __init__(self, requested_type: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type=None, always_on: ?bool, bearer_reference: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.requested_type = requested_type if requested_type is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type()
        self.always_on = always_on
        self.bearer_reference = bearer_reference

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _requested_type = self.requested_type
        if _requested_type is not None:
            children['requested-type'] = _requested_type.to_gdata()
        _always_on = self.always_on
        if _always_on is not None:
            children['always-on'] = yang.gdata.Leaf('boolean', _always_on)
        _bearer_reference = self.bearer_reference
        if _bearer_reference is not None:
            children['bearer-reference'] = yang.gdata.Leaf('string', _bearer_reference)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(requested_type=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type.from_gdata(n.get_opt_container('requested-type')), always_on=n.get_opt_bool('always-on'), bearer_reference=n.get_opt_str('bearer-reference'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(requested_type=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type.from_xml(yang.gdata.get_xml_opt_child(n, 'requested-type')), always_on=yang.gdata.from_xml_opt_bool(n, 'always-on'), bearer_reference=yang.gdata.from_xml_opt_str(n, 'bearer-reference'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'requested-type':
            child = {'requested-type': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'always-on':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bearer-reference':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_requested_type = yang.gdata.take_json_opt_cnt(jd, 'requested-type')
    yang.gdata.maybe_add(children, 'requested-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type, child_requested_type)
    child_always_on = yang.gdata.take_json_opt_bool(jd, 'always-on')
    yang.gdata.maybe_add(children, 'always-on', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__always_on, child_always_on)
    child_bearer_reference = yang.gdata.take_json_opt_str(jd, 'bearer-reference')
    yang.gdata.maybe_add(children, 'bearer-reference', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__bearer_reference, child_bearer_reference)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__address_allocation_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__number_of_dynamic_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__start_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__end_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(yang.adata.MNode):
    group_id: str
    start_address: ?str
    end_address: ?str

    mut def __init__(self, group_id: str, start_address: ?str, end_address: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id
        self.start_address = start_address
        self.end_address = end_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        _start_address = self.start_address
        if _start_address is not None:
            children['start-address'] = yang.gdata.Leaf('string', _start_address)
        _end_address = self.end_address
        if _end_address is not None:
            children['end-address'] = yang.gdata.Leaf('string', _end_address)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.group_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(group_id=n.get_str('group-id'), start_address=n.get_opt_str('start-address'), end_address=n.get_opt_str('end-address'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(group_id=yang.gdata.from_xml_str(n, 'group-id'), start_address=yang.gdata.from_xml_opt_str(n, 'start-address'), end_address=yang.gdata.from_xml_opt_str(n, 'end-address'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'address-group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self.elements:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__group_id(keys[0])
        if point == 'start-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'end-address':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.take_json_str(jd, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__group_id, child_group_id)
    child_start_address = yang.gdata.take_json_opt_str(jd, 'start-address')
    yang.gdata.maybe_add(children, 'start-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__start_address, child_start_address)
    child_end_address = yang.gdata.take_json_opt_str(jd, 'end-address')
    yang.gdata.maybe_add(children, 'end-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__end_address, child_end_address)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_group_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(e))
    return yang.gdata.List(keys=['group-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(yang.adata.MNode):
    address_group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group

    mut def __init__(self, address_group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(elements=address_group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_group = self.address_group
        if _address_group is not None:
            children['address-group'] = _address_group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(address_group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group.from_gdata(n.get_opt_list('address-group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(address_group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group.from_xml(yang.gdata.get_xml_children(n, 'address-group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-group':
            child = {'address-group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_group = yang.gdata.take_json_opt_list(jd, 'address-group')
    yang.gdata.maybe_add(children, 'address-group', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group, child_address_group)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    number_of_dynamic_address: ?int
    customer_addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, number_of_dynamic_address: ?int, customer_addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.number_of_dynamic_address = number_of_dynamic_address
        self.customer_addresses = customer_addresses if customer_addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        _number_of_dynamic_address = self.number_of_dynamic_address
        if _number_of_dynamic_address is not None:
            children['number-of-dynamic-address'] = yang.gdata.Leaf('uint16', _number_of_dynamic_address)
        _customer_addresses = self.customer_addresses
        if _customer_addresses is not None:
            children['customer-addresses'] = _customer_addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_int('prefix-length'), number_of_dynamic_address=n.get_opt_int('number-of-dynamic-address'), customer_addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses.from_gdata(n.get_opt_container('customer-addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(provider_address=yang.gdata.from_xml_opt_str(n, 'provider-address'), prefix_length=yang.gdata.from_xml_opt_int(n, 'prefix-length'), number_of_dynamic_address=yang.gdata.from_xml_opt_int(n, 'number-of-dynamic-address'), customer_addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses.from_xml(yang.gdata.get_xml_opt_child(n, 'customer-addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'number-of-dynamic-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-addresses':
            child = {'customer-addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__prefix_length, child_prefix_length)
    child_number_of_dynamic_address = yang.gdata.take_json_opt_int(jd, 'number-of-dynamic-address')
    yang.gdata.maybe_add(children, 'number-of-dynamic-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__number_of_dynamic_address, child_number_of_dynamic_address)
    child_customer_addresses = yang.gdata.take_json_opt_cnt(jd, 'customer-addresses')
    yang.gdata.maybe_add(children, 'customer-addresses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses, child_customer_addresses)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers__server_ip_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(yang.adata.MNode):
    server_ip_address: list[str]

    mut def __init__(self, server_ip_address: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.server_ip_address = server_ip_address if server_ip_address is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['server-ip-address'] = yang.gdata.LeafList('string', self.server_ip_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(server_ip_address=n.get_opt_strs('server-ip-address'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(server_ip_address=yang.gdata.from_xml_opt_strs(n, 'server-ip-address'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'server-ip-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_server_ip_address = yang.gdata.take_json_opt_strs(jd, 'server-ip-address')
    yang.gdata.maybe_add(children, 'server-ip-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers__server_ip_address, child_server_ip_address)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    customer_dhcp_servers: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, customer_dhcp_servers: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.customer_dhcp_servers = customer_dhcp_servers if customer_dhcp_servers is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        _customer_dhcp_servers = self.customer_dhcp_servers
        if _customer_dhcp_servers is not None:
            children['customer-dhcp-servers'] = _customer_dhcp_servers.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_int('prefix-length'), customer_dhcp_servers=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers.from_gdata(n.get_opt_container('customer-dhcp-servers')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(provider_address=yang.gdata.from_xml_opt_str(n, 'provider-address'), prefix_length=yang.gdata.from_xml_opt_int(n, 'prefix-length'), customer_dhcp_servers=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers.from_xml(yang.gdata.get_xml_opt_child(n, 'customer-dhcp-servers')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-dhcp-servers':
            child = {'customer-dhcp-servers': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__prefix_length, child_prefix_length)
    child_customer_dhcp_servers = yang.gdata.take_json_opt_cnt(jd, 'customer-dhcp-servers')
    yang.gdata.maybe_add(children, 'customer-dhcp-servers', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers, child_customer_dhcp_servers)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(yang.adata.MNode):
    provider_address: ?str
    customer_address: ?str
    prefix_length: ?int

    mut def __init__(self, provider_address: ?str, customer_address: ?str, prefix_length: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.customer_address = customer_address
        self.prefix_length = prefix_length

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _customer_address = self.customer_address
        if _customer_address is not None:
            children['customer-address'] = yang.gdata.Leaf('string', _customer_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(provider_address=n.get_opt_str('provider-address'), customer_address=n.get_opt_str('customer-address'), prefix_length=n.get_opt_int('prefix-length'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(provider_address=yang.gdata.from_xml_opt_str(n, 'provider-address'), customer_address=yang.gdata.from_xml_opt_str(n, 'customer-address'), prefix_length=yang.gdata.from_xml_opt_int(n, 'prefix-length'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__provider_address, child_provider_address)
    child_customer_address = yang.gdata.take_json_opt_str(jd, 'customer-address')
    yang.gdata.maybe_add(children, 'customer-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__customer_address, child_customer_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__prefix_length, child_prefix_length)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(yang.adata.MNode):
    address_allocation_type: ?str
    provider_dhcp: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp
    dhcp_relay: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay
    addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses

    mut def __init__(self, address_allocation_type: ?str, provider_dhcp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp=None, dhcp_relay: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay=None, addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_allocation_type = address_allocation_type
        self.provider_dhcp = provider_dhcp if provider_dhcp is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp()
        self.dhcp_relay = dhcp_relay if dhcp_relay is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay()
        self.addresses = addresses if addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_allocation_type = self.address_allocation_type
        if _address_allocation_type is not None:
            children['address-allocation-type'] = yang.gdata.Leaf('identityref', _address_allocation_type)
        _provider_dhcp = self.provider_dhcp
        if _provider_dhcp is not None:
            children['provider-dhcp'] = _provider_dhcp.to_gdata()
        _dhcp_relay = self.dhcp_relay
        if _dhcp_relay is not None:
            children['dhcp-relay'] = _dhcp_relay.to_gdata()
        _addresses = self.addresses
        if _addresses is not None:
            children['addresses'] = _addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(address_allocation_type=n.get_opt_str('address-allocation-type'), provider_dhcp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp.from_gdata(n.get_opt_container('provider-dhcp')), dhcp_relay=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay.from_gdata(n.get_opt_container('dhcp-relay')), addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses.from_gdata(n.get_opt_container('addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(address_allocation_type=yang.gdata.from_xml_opt_str(n, 'address-allocation-type'), provider_dhcp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp.from_xml(yang.gdata.get_xml_opt_child(n, 'provider-dhcp')), dhcp_relay=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay.from_xml(yang.gdata.get_xml_opt_child(n, 'dhcp-relay')), addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses.from_xml(yang.gdata.get_xml_opt_child(n, 'addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-allocation-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'provider-dhcp':
            child = {'provider-dhcp': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'dhcp-relay':
            child = {'dhcp-relay': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'addresses':
            child = {'addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_allocation_type = yang.gdata.take_json_opt_str(jd, 'address-allocation-type')
    yang.gdata.maybe_add(children, 'address-allocation-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__address_allocation_type, child_address_allocation_type)
    child_provider_dhcp = yang.gdata.take_json_opt_cnt(jd, 'provider-dhcp')
    yang.gdata.maybe_add(children, 'provider-dhcp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp, child_provider_dhcp)
    child_dhcp_relay = yang.gdata.take_json_opt_cnt(jd, 'dhcp-relay')
    yang.gdata.maybe_add(children, 'dhcp-relay', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay, child_dhcp_relay)
    child_addresses = yang.gdata.take_json_opt_cnt(jd, 'addresses')
    yang.gdata.maybe_add(children, 'addresses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses, child_addresses)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__address_allocation_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__number_of_dynamic_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__start_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__end_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(yang.adata.MNode):
    group_id: str
    start_address: ?str
    end_address: ?str

    mut def __init__(self, group_id: str, start_address: ?str, end_address: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id
        self.start_address = start_address
        self.end_address = end_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        _start_address = self.start_address
        if _start_address is not None:
            children['start-address'] = yang.gdata.Leaf('string', _start_address)
        _end_address = self.end_address
        if _end_address is not None:
            children['end-address'] = yang.gdata.Leaf('string', _end_address)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.group_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(group_id=n.get_str('group-id'), start_address=n.get_opt_str('start-address'), end_address=n.get_opt_str('end-address'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(group_id=yang.gdata.from_xml_str(n, 'group-id'), start_address=yang.gdata.from_xml_opt_str(n, 'start-address'), end_address=yang.gdata.from_xml_opt_str(n, 'end-address'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'address-group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self.elements:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__group_id(keys[0])
        if point == 'start-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'end-address':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.take_json_str(jd, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__group_id, child_group_id)
    child_start_address = yang.gdata.take_json_opt_str(jd, 'start-address')
    yang.gdata.maybe_add(children, 'start-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__start_address, child_start_address)
    child_end_address = yang.gdata.take_json_opt_str(jd, 'end-address')
    yang.gdata.maybe_add(children, 'end-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__end_address, child_end_address)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_group_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(e))
    return yang.gdata.List(keys=['group-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(yang.adata.MNode):
    address_group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group

    mut def __init__(self, address_group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(elements=address_group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_group = self.address_group
        if _address_group is not None:
            children['address-group'] = _address_group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(address_group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group.from_gdata(n.get_opt_list('address-group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(address_group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group.from_xml(yang.gdata.get_xml_children(n, 'address-group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-group':
            child = {'address-group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_group = yang.gdata.take_json_opt_list(jd, 'address-group')
    yang.gdata.maybe_add(children, 'address-group', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group, child_address_group)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    number_of_dynamic_address: ?int
    customer_addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, number_of_dynamic_address: ?int, customer_addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.number_of_dynamic_address = number_of_dynamic_address
        self.customer_addresses = customer_addresses if customer_addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        _number_of_dynamic_address = self.number_of_dynamic_address
        if _number_of_dynamic_address is not None:
            children['number-of-dynamic-address'] = yang.gdata.Leaf('uint16', _number_of_dynamic_address)
        _customer_addresses = self.customer_addresses
        if _customer_addresses is not None:
            children['customer-addresses'] = _customer_addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_int('prefix-length'), number_of_dynamic_address=n.get_opt_int('number-of-dynamic-address'), customer_addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses.from_gdata(n.get_opt_container('customer-addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(provider_address=yang.gdata.from_xml_opt_str(n, 'provider-address'), prefix_length=yang.gdata.from_xml_opt_int(n, 'prefix-length'), number_of_dynamic_address=yang.gdata.from_xml_opt_int(n, 'number-of-dynamic-address'), customer_addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses.from_xml(yang.gdata.get_xml_opt_child(n, 'customer-addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'number-of-dynamic-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-addresses':
            child = {'customer-addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__prefix_length, child_prefix_length)
    child_number_of_dynamic_address = yang.gdata.take_json_opt_int(jd, 'number-of-dynamic-address')
    yang.gdata.maybe_add(children, 'number-of-dynamic-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__number_of_dynamic_address, child_number_of_dynamic_address)
    child_customer_addresses = yang.gdata.take_json_opt_cnt(jd, 'customer-addresses')
    yang.gdata.maybe_add(children, 'customer-addresses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses, child_customer_addresses)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers__server_ip_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(yang.adata.MNode):
    server_ip_address: list[str]

    mut def __init__(self, server_ip_address: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.server_ip_address = server_ip_address if server_ip_address is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['server-ip-address'] = yang.gdata.LeafList('string', self.server_ip_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(server_ip_address=n.get_opt_strs('server-ip-address'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(server_ip_address=yang.gdata.from_xml_opt_strs(n, 'server-ip-address'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'server-ip-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_server_ip_address = yang.gdata.take_json_opt_strs(jd, 'server-ip-address')
    yang.gdata.maybe_add(children, 'server-ip-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers__server_ip_address, child_server_ip_address)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    customer_dhcp_servers: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, customer_dhcp_servers: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.customer_dhcp_servers = customer_dhcp_servers if customer_dhcp_servers is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        _customer_dhcp_servers = self.customer_dhcp_servers
        if _customer_dhcp_servers is not None:
            children['customer-dhcp-servers'] = _customer_dhcp_servers.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_int('prefix-length'), customer_dhcp_servers=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers.from_gdata(n.get_opt_container('customer-dhcp-servers')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(provider_address=yang.gdata.from_xml_opt_str(n, 'provider-address'), prefix_length=yang.gdata.from_xml_opt_int(n, 'prefix-length'), customer_dhcp_servers=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers.from_xml(yang.gdata.get_xml_opt_child(n, 'customer-dhcp-servers')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-dhcp-servers':
            child = {'customer-dhcp-servers': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__prefix_length, child_prefix_length)
    child_customer_dhcp_servers = yang.gdata.take_json_opt_cnt(jd, 'customer-dhcp-servers')
    yang.gdata.maybe_add(children, 'customer-dhcp-servers', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers, child_customer_dhcp_servers)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(yang.adata.MNode):
    provider_address: ?str
    customer_address: ?str
    prefix_length: ?int

    mut def __init__(self, provider_address: ?str, customer_address: ?str, prefix_length: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.customer_address = customer_address
        self.prefix_length = prefix_length

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _customer_address = self.customer_address
        if _customer_address is not None:
            children['customer-address'] = yang.gdata.Leaf('string', _customer_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(provider_address=n.get_opt_str('provider-address'), customer_address=n.get_opt_str('customer-address'), prefix_length=n.get_opt_int('prefix-length'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(provider_address=yang.gdata.from_xml_opt_str(n, 'provider-address'), customer_address=yang.gdata.from_xml_opt_str(n, 'customer-address'), prefix_length=yang.gdata.from_xml_opt_int(n, 'prefix-length'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__provider_address, child_provider_address)
    child_customer_address = yang.gdata.take_json_opt_str(jd, 'customer-address')
    yang.gdata.maybe_add(children, 'customer-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__customer_address, child_customer_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__prefix_length, child_prefix_length)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(yang.adata.MNode):
    address_allocation_type: ?str
    provider_dhcp: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp
    dhcp_relay: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay
    addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses

    mut def __init__(self, address_allocation_type: ?str, provider_dhcp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp=None, dhcp_relay: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay=None, addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_allocation_type = address_allocation_type
        self.provider_dhcp = provider_dhcp if provider_dhcp is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp()
        self.dhcp_relay = dhcp_relay if dhcp_relay is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay()
        self.addresses = addresses if addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_allocation_type = self.address_allocation_type
        if _address_allocation_type is not None:
            children['address-allocation-type'] = yang.gdata.Leaf('identityref', _address_allocation_type)
        _provider_dhcp = self.provider_dhcp
        if _provider_dhcp is not None:
            children['provider-dhcp'] = _provider_dhcp.to_gdata()
        _dhcp_relay = self.dhcp_relay
        if _dhcp_relay is not None:
            children['dhcp-relay'] = _dhcp_relay.to_gdata()
        _addresses = self.addresses
        if _addresses is not None:
            children['addresses'] = _addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(address_allocation_type=n.get_opt_str('address-allocation-type'), provider_dhcp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp.from_gdata(n.get_opt_container('provider-dhcp')), dhcp_relay=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay.from_gdata(n.get_opt_container('dhcp-relay')), addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses.from_gdata(n.get_opt_container('addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(address_allocation_type=yang.gdata.from_xml_opt_str(n, 'address-allocation-type'), provider_dhcp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp.from_xml(yang.gdata.get_xml_opt_child(n, 'provider-dhcp')), dhcp_relay=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay.from_xml(yang.gdata.get_xml_opt_child(n, 'dhcp-relay')), addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses.from_xml(yang.gdata.get_xml_opt_child(n, 'addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-allocation-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'provider-dhcp':
            child = {'provider-dhcp': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'dhcp-relay':
            child = {'dhcp-relay': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'addresses':
            child = {'addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_allocation_type = yang.gdata.take_json_opt_str(jd, 'address-allocation-type')
    yang.gdata.maybe_add(children, 'address-allocation-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__address_allocation_type, child_address_allocation_type)
    child_provider_dhcp = yang.gdata.take_json_opt_cnt(jd, 'provider-dhcp')
    yang.gdata.maybe_add(children, 'provider-dhcp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp, child_provider_dhcp)
    child_dhcp_relay = yang.gdata.take_json_opt_cnt(jd, 'dhcp-relay')
    yang.gdata.maybe_add(children, 'dhcp-relay', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay, child_dhcp_relay)
    child_addresses = yang.gdata.take_json_opt_cnt(jd, 'addresses')
    yang.gdata.maybe_add(children, 'addresses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses, child_addresses)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__fixed_value(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(yang.adata.MNode):
    enabled: ?bool
    fixed_value: ?int
    profile_name: ?str

    mut def __init__(self, enabled: ?bool, fixed_value: ?int, profile_name: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled
        self.fixed_value = fixed_value
        self.profile_name = profile_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _fixed_value = self.fixed_value
        if _fixed_value is not None:
            children['fixed-value'] = yang.gdata.Leaf('uint32', _fixed_value)
        _profile_name = self.profile_name
        if _profile_name is not None:
            children['profile-name'] = yang.gdata.Leaf('leafref', _profile_name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(enabled=n.get_opt_bool('enabled'), fixed_value=n.get_opt_int('fixed-value'), profile_name=n.get_opt_str('profile-name'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(enabled=yang.gdata.from_xml_opt_bool(n, 'enabled'), fixed_value=yang.gdata.from_xml_opt_int(n, 'fixed-value'), profile_name=yang.gdata.from_xml_opt_str(n, 'profile-name'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'fixed-value':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'profile-name':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__enabled, child_enabled)
    child_fixed_value = yang.gdata.take_json_opt_int(jd, 'fixed-value')
    yang.gdata.maybe_add(children, 'fixed-value', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__fixed_value, child_fixed_value)
    child_profile_name = yang.gdata.take_json_opt_str(jd, 'profile-name')
    yang.gdata.maybe_add(children, 'profile-name', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__profile_name, child_profile_name)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(yang.adata.MNode):
    bfd: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd

    mut def __init__(self, bfd: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.bfd = bfd if bfd is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _bfd = self.bfd
        if _bfd is not None:
            children['bfd'] = _bfd.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(bfd=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd.from_gdata(n.get_opt_container('bfd')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(bfd=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd.from_xml(yang.gdata.get_xml_opt_child(n, 'bfd')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'bfd':
            child = {'bfd': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_bfd = yang.gdata.take_json_opt_cnt(jd, 'bfd')
    yang.gdata.maybe_add(children, 'bfd', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd, child_bfd)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(yang.adata.MNode):
    ipv4: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4
    ipv6: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6
    oam: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam

    mut def __init__(self, ipv4: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4=None, ipv6: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6=None, oam: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4 = ipv4 if ipv4 is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4()
        self.ipv6 = ipv6 if ipv6 is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6()
        self.oam = oam if oam is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            children['ipv4'] = _ipv4.to_gdata()
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            children['ipv6'] = _ipv6.to_gdata()
        _oam = self.oam
        if _oam is not None:
            children['oam'] = _oam.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(ipv4=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4.from_gdata(n.get_opt_container('ipv4')), ipv6=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6.from_gdata(n.get_opt_container('ipv6')), oam=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam.from_gdata(n.get_opt_container('oam')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(ipv4=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4.from_xml(yang.gdata.get_xml_opt_child(n, 'ipv4')), ipv6=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6.from_xml(yang.gdata.get_xml_opt_child(n, 'ipv6')), oam=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam.from_xml(yang.gdata.get_xml_opt_child(n, 'oam')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'ipv4':
            child = {'ipv4': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'ipv6':
            child = {'ipv6': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'oam':
            child = {'oam': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.take_json_opt_cnt(jd, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.take_json_opt_cnt(jd, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6, child_ipv6)
    child_oam = yang.gdata.take_json_opt_cnt(jd, 'oam')
    yang.gdata.maybe_add(children, 'oam', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam, child_oam)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__layer(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__preshared_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(yang.adata.MNode):
    profile_name: ?str
    algorithm: ?str
    preshared_key: ?str

    mut def __init__(self, profile_name: ?str, algorithm: ?str, preshared_key: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile_name = profile_name
        self.algorithm = algorithm
        self.preshared_key = preshared_key

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile_name = self.profile_name
        if _profile_name is not None:
            children['profile-name'] = yang.gdata.Leaf('leafref', _profile_name)
        _algorithm = self.algorithm
        if _algorithm is not None:
            children['algorithm'] = yang.gdata.Leaf('string', _algorithm)
        _preshared_key = self.preshared_key
        if _preshared_key is not None:
            children['preshared-key'] = yang.gdata.Leaf('string', _preshared_key)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(profile_name=n.get_opt_str('profile-name'), algorithm=n.get_opt_str('algorithm'), preshared_key=n.get_opt_str('preshared-key'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(profile_name=yang.gdata.from_xml_opt_str(n, 'profile-name'), algorithm=yang.gdata.from_xml_opt_str(n, 'algorithm'), preshared_key=yang.gdata.from_xml_opt_str(n, 'preshared-key'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'profile-name':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'algorithm':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'preshared-key':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile_name = yang.gdata.take_json_opt_str(jd, 'profile-name')
    yang.gdata.maybe_add(children, 'profile-name', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__profile_name, child_profile_name)
    child_algorithm = yang.gdata.take_json_opt_str(jd, 'algorithm')
    yang.gdata.maybe_add(children, 'algorithm', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__algorithm, child_algorithm)
    child_preshared_key = yang.gdata.take_json_opt_str(jd, 'preshared-key')
    yang.gdata.maybe_add(children, 'preshared-key', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__preshared_key, child_preshared_key)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(yang.adata.MNode):
    enabled: ?bool
    layer: ?str
    encryption_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile

    mut def __init__(self, enabled: ?bool, layer: ?str, encryption_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled
        self.layer = layer
        self.encryption_profile = encryption_profile if encryption_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _layer = self.layer
        if _layer is not None:
            children['layer'] = yang.gdata.Leaf('enumeration', _layer)
        _encryption_profile = self.encryption_profile
        if _encryption_profile is not None:
            children['encryption-profile'] = _encryption_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(enabled=n.get_opt_bool('enabled'), layer=n.get_opt_str('layer'), encryption_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile.from_gdata(n.get_opt_container('encryption-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(enabled=yang.gdata.from_xml_opt_bool(n, 'enabled'), layer=yang.gdata.from_xml_opt_str(n, 'layer'), encryption_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile.from_xml(yang.gdata.get_xml_opt_child(n, 'encryption-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'layer':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'encryption-profile':
            child = {'encryption-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__enabled, child_enabled)
    child_layer = yang.gdata.take_json_opt_str(jd, 'layer')
    yang.gdata.maybe_add(children, 'layer', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__layer, child_layer)
    child_encryption_profile = yang.gdata.take_json_opt_cnt(jd, 'encryption-profile')
    yang.gdata.maybe_add(children, 'encryption-profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile, child_encryption_profile)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(yang.adata.MNode):
    authentication: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication
    encryption: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption

    mut def __init__(self, authentication: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication=None, encryption: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.authentication = authentication if authentication is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()
        self.encryption = encryption if encryption is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _authentication = self.authentication
        if _authentication is not None:
            children['authentication'] = _authentication.to_gdata()
        _encryption = self.encryption
        if _encryption is not None:
            children['encryption'] = _encryption.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(authentication=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication.from_gdata(n.get_opt_container('authentication')), encryption=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption.from_gdata(n.get_opt_container('encryption')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(authentication=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication.from_xml(yang.gdata.get_xml_opt_child(n, 'authentication')), encryption=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption.from_xml(yang.gdata.get_xml_opt_child(n, 'encryption')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'authentication':
            child = {'authentication': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'encryption':
            child = {'encryption': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_authentication = yang.gdata.take_json_opt_cnt(jd, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication, child_authentication)
    child_encryption = yang.gdata.take_json_opt_cnt(jd, 'encryption')
    yang.gdata.maybe_add(children, 'encryption', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption, child_encryption)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_input_bandwidth(val: value) -> yang.gdata.Leaf:
    if isinstance(val, str):
        return yang.gdata.Leaf('uint64', int(val))
    return yang.gdata.Leaf('uint64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_output_bandwidth(val: value) -> yang.gdata.Leaf:
    if isinstance(val, str):
        return yang.gdata.Leaf('uint64', int(val))
    return yang.gdata.Leaf('uint64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_mtu(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dscp(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dot1p(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__target_sites(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        _upper_port = self.upper_port
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(lower_port=n.get_opt_int('lower-port'), upper_port=n.get_opt_int('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(lower_port=yang.gdata.from_xml_opt_int(n, 'lower-port'), upper_port=yang.gdata.from_xml_opt_int(n, 'upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.take_json_opt_int(jd, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.take_json_opt_int(jd, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        _upper_port = self.upper_port
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(lower_port=n.get_opt_int('lower-port'), upper_port=n.get_opt_int('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(lower_port=yang.gdata.from_xml_opt_int(n, 'lower-port'), upper_port=yang.gdata.from_xml_opt_int(n, 'upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.take_json_opt_int(jd, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.take_json_opt_int(jd, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__protocol_field(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(yang.adata.MNode):
    dscp: ?int
    dot1p: ?int
    ipv4_src_prefix: ?str
    ipv6_src_prefix: ?str
    ipv4_dst_prefix: ?str
    ipv6_dst_prefix: ?str
    l4_src_port: ?int
    target_sites: list[str]
    l4_src_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range
    l4_dst_port: ?int
    l4_dst_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range
    protocol_field: ?value

    mut def __init__(self, dscp: ?int, dot1p: ?int, ipv4_src_prefix: ?str, ipv6_src_prefix: ?str, ipv4_dst_prefix: ?str, ipv6_dst_prefix: ?str, l4_src_port: ?int, target_sites: ?list[str]=None, l4_src_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range=None, l4_dst_port: ?int, l4_dst_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range=None, protocol_field: ?value):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.dscp = dscp
        self.dot1p = dot1p
        self.ipv4_src_prefix = ipv4_src_prefix
        self.ipv6_src_prefix = ipv6_src_prefix
        self.ipv4_dst_prefix = ipv4_dst_prefix
        self.ipv6_dst_prefix = ipv6_dst_prefix
        self.l4_src_port = l4_src_port
        self.target_sites = target_sites if target_sites is not None else []
        self.l4_src_port_range = l4_src_port_range if l4_src_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()
        self.l4_dst_port = l4_dst_port
        self.l4_dst_port_range = l4_dst_port_range if l4_dst_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()
        self.protocol_field = protocol_field

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _dscp = self.dscp
        if _dscp is not None:
            children['dscp'] = yang.gdata.Leaf('uint8', _dscp)
        _dot1p = self.dot1p
        if _dot1p is not None:
            children['dot1p'] = yang.gdata.Leaf('uint8', _dot1p)
        _ipv4_src_prefix = self.ipv4_src_prefix
        if _ipv4_src_prefix is not None:
            children['ipv4-src-prefix'] = yang.gdata.Leaf('string', _ipv4_src_prefix)
        _ipv6_src_prefix = self.ipv6_src_prefix
        if _ipv6_src_prefix is not None:
            children['ipv6-src-prefix'] = yang.gdata.Leaf('string', _ipv6_src_prefix)
        _ipv4_dst_prefix = self.ipv4_dst_prefix
        if _ipv4_dst_prefix is not None:
            children['ipv4-dst-prefix'] = yang.gdata.Leaf('string', _ipv4_dst_prefix)
        _ipv6_dst_prefix = self.ipv6_dst_prefix
        if _ipv6_dst_prefix is not None:
            children['ipv6-dst-prefix'] = yang.gdata.Leaf('string', _ipv6_dst_prefix)
        _l4_src_port = self.l4_src_port
        if _l4_src_port is not None:
            children['l4-src-port'] = yang.gdata.Leaf('uint16', _l4_src_port)
        children['target-sites'] = yang.gdata.LeafList('string', self.target_sites)
        _l4_src_port_range = self.l4_src_port_range
        if _l4_src_port_range is not None:
            children['l4-src-port-range'] = _l4_src_port_range.to_gdata()
        _l4_dst_port = self.l4_dst_port
        if _l4_dst_port is not None:
            children['l4-dst-port'] = yang.gdata.Leaf('uint16', _l4_dst_port)
        _l4_dst_port_range = self.l4_dst_port_range
        if _l4_dst_port_range is not None:
            children['l4-dst-port-range'] = _l4_dst_port_range.to_gdata()
        _protocol_field = self.protocol_field
        if _protocol_field is not None:
            children['protocol-field'] = yang.gdata.Leaf('union', _protocol_field)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(dscp=n.get_opt_int('dscp'), dot1p=n.get_opt_int('dot1p'), ipv4_src_prefix=n.get_opt_str('ipv4-src-prefix'), ipv6_src_prefix=n.get_opt_str('ipv6-src-prefix'), ipv4_dst_prefix=n.get_opt_str('ipv4-dst-prefix'), ipv6_dst_prefix=n.get_opt_str('ipv6-dst-prefix'), l4_src_port=n.get_opt_int('l4-src-port'), target_sites=n.get_opt_strs('target-sites'), l4_src_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_gdata(n.get_opt_container('l4-src-port-range')), l4_dst_port=n.get_opt_int('l4-dst-port'), l4_dst_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_gdata(n.get_opt_container('l4-dst-port-range')), protocol_field=n.get_opt_value('protocol-field'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(dscp=yang.gdata.from_xml_opt_int(n, 'dscp'), dot1p=yang.gdata.from_xml_opt_int(n, 'dot1p'), ipv4_src_prefix=yang.gdata.from_xml_opt_str(n, 'ipv4-src-prefix'), ipv6_src_prefix=yang.gdata.from_xml_opt_str(n, 'ipv6-src-prefix'), ipv4_dst_prefix=yang.gdata.from_xml_opt_str(n, 'ipv4-dst-prefix'), ipv6_dst_prefix=yang.gdata.from_xml_opt_str(n, 'ipv6-dst-prefix'), l4_src_port=yang.gdata.from_xml_opt_int(n, 'l4-src-port'), target_sites=yang.gdata.from_xml_opt_strs(n, 'target-sites'), l4_src_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_xml(yang.gdata.get_xml_opt_child(n, 'l4-src-port-range')), l4_dst_port=yang.gdata.from_xml_opt_int(n, 'l4-dst-port'), l4_dst_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_xml(yang.gdata.get_xml_opt_child(n, 'l4-dst-port-range')), protocol_field=yang.gdata.from_xml_opt_value(n, 'protocol-field'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'dscp':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'dot1p':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-src-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'target-sites':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-src-port-range':
            child = {'l4-src-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l4-dst-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-dst-port-range':
            child = {'l4-dst-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'protocol-field':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_dscp = yang.gdata.take_json_opt_int(jd, 'dscp')
    yang.gdata.maybe_add(children, 'dscp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dscp, child_dscp)
    child_dot1p = yang.gdata.take_json_opt_int(jd, 'dot1p')
    yang.gdata.maybe_add(children, 'dot1p', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dot1p, child_dot1p)
    child_ipv4_src_prefix = yang.gdata.take_json_opt_str(jd, 'ipv4-src-prefix')
    yang.gdata.maybe_add(children, 'ipv4-src-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix, child_ipv4_src_prefix)
    child_ipv6_src_prefix = yang.gdata.take_json_opt_str(jd, 'ipv6-src-prefix')
    yang.gdata.maybe_add(children, 'ipv6-src-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix, child_ipv6_src_prefix)
    child_ipv4_dst_prefix = yang.gdata.take_json_opt_str(jd, 'ipv4-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv4-dst-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix, child_ipv4_dst_prefix)
    child_ipv6_dst_prefix = yang.gdata.take_json_opt_str(jd, 'ipv6-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv6-dst-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix, child_ipv6_dst_prefix)
    child_l4_src_port = yang.gdata.take_json_opt_int(jd, 'l4-src-port')
    yang.gdata.maybe_add(children, 'l4-src-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port, child_l4_src_port)
    child_target_sites = yang.gdata.take_json_opt_strs(jd, 'target-sites')
    yang.gdata.maybe_add(children, 'target-sites', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__target_sites, child_target_sites)
    child_l4_src_port_range = yang.gdata.take_json_opt_cnt(jd, 'l4-src-port-range')
    yang.gdata.maybe_add(children, 'l4-src-port-range', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range, child_l4_src_port_range)
    child_l4_dst_port = yang.gdata.take_json_opt_int(jd, 'l4-dst-port')
    yang.gdata.maybe_add(children, 'l4-dst-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port, child_l4_dst_port)
    child_l4_dst_port_range = yang.gdata.take_json_opt_cnt(jd, 'l4-dst-port-range')
    yang.gdata.maybe_add(children, 'l4-dst-port-range', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range, child_l4_dst_port_range)
    child_protocol_field = yang.gdata.take_json_opt_value(jd, 'protocol-field')
    yang.gdata.maybe_add(children, 'protocol-field', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__protocol_field, child_protocol_field)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_application(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__target_class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(yang.adata.MNode):
    id: str
    match_flow: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow
    match_application: ?str
    target_class_id: ?str

    mut def __init__(self, id: str, match_flow: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow=None, match_application: ?str, target_class_id: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.match_flow = match_flow if match_flow is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow()
        self.match_application = match_application
        self.target_class_id = target_class_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        _match_flow = self.match_flow
        if _match_flow is not None:
            children['match-flow'] = _match_flow.to_gdata()
        _match_application = self.match_application
        if _match_application is not None:
            children['match-application'] = yang.gdata.Leaf('identityref', _match_application)
        _target_class_id = self.target_class_id
        if _target_class_id is not None:
            children['target-class-id'] = yang.gdata.Leaf('string', _target_class_id)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(id=n.get_str('id'), match_flow=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow.from_gdata(n.get_opt_container('match-flow')), match_application=n.get_opt_str('match-application'), target_class_id=n.get_opt_str('target-class-id'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(id=yang.gdata.from_xml_str(n, 'id'), match_flow=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow.from_xml(yang.gdata.get_xml_opt_child(n, 'match-flow')), match_application=yang.gdata.from_xml_opt_str(n, 'match-application'), target_class_id=yang.gdata.from_xml_opt_str(n, 'target-class-id'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'rule'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements, user_order=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__id(keys[0])
        if point == 'match-flow':
            children['match-flow'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(jd, rest_path, op)
        if point == 'match-application':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'target-class-id':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['id'], elements, user_order=True)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd, path, op)], user_order=True)
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__id, child_id)
    child_match_flow = yang.gdata.take_json_opt_cnt(jd, 'match-flow')
    yang.gdata.maybe_add(children, 'match-flow', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow, child_match_flow)
    child_match_application = yang.gdata.take_json_opt_str(jd, 'match-application')
    yang.gdata.maybe_add(children, 'match-application', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_application, child_match_application)
    child_target_class_id = yang.gdata.take_json_opt_str(jd, 'target-class-id')
    yang.gdata.maybe_add(children, 'target-class-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__target_class_id, child_target_class_id)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(e))
    return yang.gdata.List(keys=['id'], elements=elements, user_order=True)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(yang.adata.MNode):
    rule: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule

    mut def __init__(self, rule: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rule = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(elements=rule)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rule = self.rule
        if _rule is not None:
            children['rule'] = _rule.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(rule=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule.from_gdata(n.get_opt_list('rule')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(rule=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule.from_xml(yang.gdata.get_xml_children(n, 'rule')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'rule':
            child = {'rule': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rule = yang.gdata.take_json_opt_list(jd, 'rule')
    yang.gdata.maybe_add(children, 'rule', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule, child_rule)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__profile(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__direction(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__rate_limit(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__use_lowest_latency(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(yang.adata.MNode):
    use_lowest_latency: ?bool
    latency_boundary: ?int

    mut def __init__(self, use_lowest_latency: ?bool, latency_boundary: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_latency = use_lowest_latency
        self.latency_boundary = latency_boundary

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_latency = self.use_lowest_latency
        if _use_lowest_latency is not None:
            children['use-lowest-latency'] = yang.gdata.Leaf('empty', _use_lowest_latency)
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint16', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(use_lowest_latency=n.get_opt_bool('use-lowest-latency'), latency_boundary=n.get_opt_int('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(use_lowest_latency=yang.gdata.from_xml_opt_bool(n, 'use-lowest-latency'), latency_boundary=yang.gdata.from_xml_opt_int(n, 'latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'use-lowest-latency':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_latency = yang.gdata.take_json_opt_bool(jd, 'use-lowest-latency')
    yang.gdata.maybe_add(children, 'use-lowest-latency', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__use_lowest_latency, child_use_lowest_latency)
    child_latency_boundary = yang.gdata.take_json_opt_int(jd, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(yang.adata.MNode):
    use_lowest_jitter: ?bool
    latency_boundary: ?int

    mut def __init__(self, use_lowest_jitter: ?bool, latency_boundary: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_jitter = use_lowest_jitter
        self.latency_boundary = latency_boundary

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_jitter = self.use_lowest_jitter
        if _use_lowest_jitter is not None:
            children['use-lowest-jitter'] = yang.gdata.Leaf('empty', _use_lowest_jitter)
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint32', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(use_lowest_jitter=n.get_opt_bool('use-lowest-jitter'), latency_boundary=n.get_opt_int('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(use_lowest_jitter=yang.gdata.from_xml_opt_bool(n, 'use-lowest-jitter'), latency_boundary=yang.gdata.from_xml_opt_int(n, 'latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'use-lowest-jitter':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_jitter = yang.gdata.take_json_opt_bool(jd, 'use-lowest-jitter')
    yang.gdata.maybe_add(children, 'use-lowest-jitter', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter, child_use_lowest_jitter)
    child_latency_boundary = yang.gdata.take_json_opt_int(jd, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__end_to_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(yang.adata.MNode):
    guaranteed_bw_percent: ?float
    end_to_end: ?bool

    mut def __init__(self, guaranteed_bw_percent: ?float, end_to_end: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.guaranteed_bw_percent = guaranteed_bw_percent
        self.end_to_end = end_to_end

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _guaranteed_bw_percent = self.guaranteed_bw_percent
        if _guaranteed_bw_percent is not None:
            children['guaranteed-bw-percent'] = yang.gdata.Leaf('decimal64', _guaranteed_bw_percent)
        _end_to_end = self.end_to_end
        if _end_to_end is not None:
            children['end-to-end'] = yang.gdata.Leaf('empty', _end_to_end)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(guaranteed_bw_percent=n.get_opt_float('guaranteed-bw-percent'), end_to_end=n.get_opt_bool('end-to-end'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth')

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(guaranteed_bw_percent=yang.gdata.from_xml_opt_float(n, 'guaranteed-bw-percent'), end_to_end=yang.gdata.from_xml_opt_bool(n, 'end-to-end'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth')


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'guaranteed-bw-percent':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'end-to-end':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_guaranteed_bw_percent = yang.gdata.take_json_float(jd, 'guaranteed-bw-percent')
    yang.gdata.maybe_add(children, 'guaranteed-bw-percent', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent, child_guaranteed_bw_percent)
    child_end_to_end = yang.gdata.take_json_opt_bool(jd, 'end-to-end')
    yang.gdata.maybe_add(children, 'end-to-end', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__end_to_end, child_end_to_end)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(yang.adata.MNode):
    class_id: str
    direction: ?str
    rate_limit: ?float
    latency: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency
    jitter: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter
    bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth

    mut def __init__(self, class_id: str, direction: ?str, rate_limit: ?float, latency: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency=None, jitter: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter=None, bandwidth: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_id = class_id
        self.direction = direction
        self.rate_limit = rate_limit
        self.latency = latency if latency is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency()
        self.jitter = jitter if jitter is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter()
        self.bandwidth = bandwidth if bandwidth is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_id = self.class_id
        if _class_id is not None:
            children['class-id'] = yang.gdata.Leaf('string', _class_id)
        _direction = self.direction
        if _direction is not None:
            children['direction'] = yang.gdata.Leaf('identityref', _direction)
        _rate_limit = self.rate_limit
        if _rate_limit is not None:
            children['rate-limit'] = yang.gdata.Leaf('decimal64', _rate_limit)
        _latency = self.latency
        if _latency is not None:
            children['latency'] = _latency.to_gdata()
        _jitter = self.jitter
        if _jitter is not None:
            children['jitter'] = _jitter.to_gdata()
        _bandwidth = self.bandwidth
        if _bandwidth is not None:
            children['bandwidth'] = _bandwidth.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.class_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(class_id=n.get_str('class-id'), direction=n.get_opt_str('direction'), rate_limit=n.get_opt_float('rate-limit'), latency=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency.from_gdata(n.get_opt_container('latency')), jitter=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter.from_gdata(n.get_opt_container('jitter')), bandwidth=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth.from_gdata(n.get_opt_container('bandwidth')))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(class_id=yang.gdata.from_xml_str(n, 'class-id'), direction=yang.gdata.from_xml_opt_str(n, 'direction'), rate_limit=yang.gdata.from_xml_opt_float(n, 'rate-limit'), latency=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency.from_xml(yang.gdata.get_xml_opt_child(n, 'latency')), jitter=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter.from_xml(yang.gdata.get_xml_opt_child(n, 'jitter')), bandwidth=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth.from_xml(yang.gdata.get_xml_opt_child(n, 'bandwidth')))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'class'
        self.elements = elements

    mut def create(self, class_id):
        for e in self.elements:
            match = True
            if e.class_id != class_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(class_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['class-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['class-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__class_id(keys[0])
        if point == 'direction':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'rate-limit':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency':
            children['latency'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(jd, rest_path, op)
        if point == 'jitter':
            children['jitter'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(jd, rest_path, op)
        if point == 'bandwidth':
            children['bandwidth'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['class-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['class-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['class-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_class_id = yang.gdata.take_json_str(jd, 'class-id')
    yang.gdata.maybe_add(children, 'class-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__class_id, child_class_id)
    child_direction = yang.gdata.take_json_opt_str(jd, 'direction')
    yang.gdata.maybe_add(children, 'direction', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__direction, child_direction)
    child_rate_limit = yang.gdata.take_json_opt_float(jd, 'rate-limit')
    yang.gdata.maybe_add(children, 'rate-limit', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__rate_limit, child_rate_limit)
    child_latency = yang.gdata.take_json_opt_cnt(jd, 'latency')
    yang.gdata.maybe_add(children, 'latency', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency, child_latency)
    child_jitter = yang.gdata.take_json_opt_cnt(jd, 'jitter')
    yang.gdata.maybe_add(children, 'jitter', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter, child_jitter)
    child_bandwidth = yang.gdata.take_json_opt_cnt(jd, 'bandwidth')
    yang.gdata.maybe_add(children, 'bandwidth', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth, child_bandwidth)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_class_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(e))
    return yang.gdata.List(keys=['class-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(yang.adata.MNode):
    class_: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class

    mut def __init__(self, class_: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_ = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(elements=class_)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_ = self.class_
        if _class_ is not None:
            children['class'] = _class_.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(class_=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class.from_gdata(n.get_opt_list('class')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(class_=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class.from_xml(yang.gdata.get_xml_children(n, 'class')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'class':
            child = {'class': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_class_ = yang.gdata.take_json_opt_list(jd, 'class')
    yang.gdata.maybe_add(children, 'class', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class, child_class_)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(yang.adata.MNode):
    profile: ?str
    classes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes

    mut def __init__(self, profile: ?str, classes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile = profile
        self.classes = classes if classes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile = self.profile
        if _profile is not None:
            children['profile'] = yang.gdata.Leaf('leafref', _profile)
        _classes = self.classes
        if _classes is not None:
            children['classes'] = _classes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(profile=n.get_opt_str('profile'), classes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes.from_gdata(n.get_opt_container('classes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(profile=yang.gdata.from_xml_opt_str(n, 'profile'), classes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes.from_xml(yang.gdata.get_xml_opt_child(n, 'classes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'profile':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'classes':
            child = {'classes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile = yang.gdata.take_json_opt_str(jd, 'profile')
    yang.gdata.maybe_add(children, 'profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__profile, child_profile)
    child_classes = yang.gdata.take_json_opt_cnt(jd, 'classes')
    yang.gdata.maybe_add(children, 'classes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes, child_classes)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(yang.adata.MNode):
    qos_classification_policy: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy
    qos_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile

    mut def __init__(self, qos_classification_policy: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy=None, qos_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.qos_classification_policy = qos_classification_policy if qos_classification_policy is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy()
        self.qos_profile = qos_profile if qos_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _qos_classification_policy = self.qos_classification_policy
        if _qos_classification_policy is not None:
            children['qos-classification-policy'] = _qos_classification_policy.to_gdata()
        _qos_profile = self.qos_profile
        if _qos_profile is not None:
            children['qos-profile'] = _qos_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(qos_classification_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy.from_gdata(n.get_opt_container('qos-classification-policy')), qos_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile.from_gdata(n.get_opt_container('qos-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(qos_classification_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy.from_xml(yang.gdata.get_xml_opt_child(n, 'qos-classification-policy')), qos_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile.from_xml(yang.gdata.get_xml_opt_child(n, 'qos-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'qos-classification-policy':
            child = {'qos-classification-policy': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'qos-profile':
            child = {'qos-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_qos_classification_policy = yang.gdata.take_json_opt_cnt(jd, 'qos-classification-policy')
    yang.gdata.maybe_add(children, 'qos-classification-policy', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy, child_qos_classification_policy)
    child_qos_profile = yang.gdata.take_json_opt_cnt(jd, 'qos-profile')
    yang.gdata.maybe_add(children, 'qos-profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile, child_qos_profile)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier__signalling_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(yang.adata.MNode):
    signalling_type: ?str

    mut def __init__(self, signalling_type: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.signalling_type = signalling_type

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _signalling_type = self.signalling_type
        if _signalling_type is not None:
            children['signalling-type'] = yang.gdata.Leaf('enumeration', _signalling_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(signalling_type=n.get_opt_str('signalling-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(signalling_type=yang.gdata.from_xml_opt_str(n, 'signalling-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'signalling-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_signalling_type = yang.gdata.take_json_opt_str(jd, 'signalling-type')
    yang.gdata.maybe_add(children, 'signalling-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier__signalling_type, child_signalling_type)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_site_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv4(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv6(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(yang.adata.MNode):
    ipv4: ?bool
    ipv6: ?bool

    mut def __init__(self, ipv4: ?bool, ipv6: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4 = ipv4
        self.ipv6 = ipv6

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            children['ipv4'] = yang.gdata.Leaf('boolean', _ipv4)
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            children['ipv6'] = yang.gdata.Leaf('boolean', _ipv6)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(ipv4=n.get_opt_bool('ipv4'), ipv6=n.get_opt_bool('ipv6'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(ipv4=yang.gdata.from_xml_opt_bool(n, 'ipv4'), ipv6=yang.gdata.from_xml_opt_bool(n, 'ipv6'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'ipv4':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.take_json_opt_bool(jd, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.take_json_opt_bool(jd, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv6, child_ipv6)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__protocol_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(yang.adata.MNode):
    multicast_site_type: ?str
    multicast_address_family: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family
    protocol_type: ?str

    mut def __init__(self, multicast_site_type: ?str, multicast_address_family: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family=None, protocol_type: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.multicast_site_type = multicast_site_type
        self.multicast_address_family = multicast_address_family if multicast_address_family is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family()
        self.protocol_type = protocol_type

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _multicast_site_type = self.multicast_site_type
        if _multicast_site_type is not None:
            children['multicast-site-type'] = yang.gdata.Leaf('enumeration', _multicast_site_type)
        _multicast_address_family = self.multicast_address_family
        if _multicast_address_family is not None:
            children['multicast-address-family'] = _multicast_address_family.to_gdata()
        _protocol_type = self.protocol_type
        if _protocol_type is not None:
            children['protocol-type'] = yang.gdata.Leaf('enumeration', _protocol_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(multicast_site_type=n.get_opt_str('multicast-site-type'), multicast_address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family.from_gdata(n.get_opt_container('multicast-address-family')), protocol_type=n.get_opt_str('protocol-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(multicast_site_type=yang.gdata.from_xml_opt_str(n, 'multicast-site-type'), multicast_address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family.from_xml(yang.gdata.get_xml_opt_child(n, 'multicast-address-family')), protocol_type=yang.gdata.from_xml_opt_str(n, 'protocol-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'multicast-site-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'multicast-address-family':
            child = {'multicast-address-family': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'protocol-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_multicast_site_type = yang.gdata.take_json_opt_str(jd, 'multicast-site-type')
    yang.gdata.maybe_add(children, 'multicast-site-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_site_type, child_multicast_site_type)
    child_multicast_address_family = yang.gdata.take_json_opt_cnt(jd, 'multicast-address-family')
    yang.gdata.maybe_add(children, 'multicast-address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family, child_multicast_address_family)
    child_protocol_type = yang.gdata.take_json_opt_str(jd, 'protocol-type')
    yang.gdata.maybe_add(children, 'protocol-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__protocol_type, child_protocol_type)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(yang.adata.MNode):
    svc_input_bandwidth: ?int
    svc_output_bandwidth: ?int
    svc_mtu: ?int
    qos: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos
    carrierscarrier: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier
    multicast: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast

    mut def __init__(self, svc_input_bandwidth: ?int, svc_output_bandwidth: ?int, svc_mtu: ?int, qos: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos=None, carrierscarrier: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier=None, multicast: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.svc_input_bandwidth = svc_input_bandwidth
        self.svc_output_bandwidth = svc_output_bandwidth
        self.svc_mtu = svc_mtu
        self.qos = qos if qos is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos()
        self.carrierscarrier = carrierscarrier if carrierscarrier is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier()
        self.multicast = multicast if multicast is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _svc_input_bandwidth = self.svc_input_bandwidth
        if _svc_input_bandwidth is not None:
            children['svc-input-bandwidth'] = yang.gdata.Leaf('uint64', _svc_input_bandwidth)
        _svc_output_bandwidth = self.svc_output_bandwidth
        if _svc_output_bandwidth is not None:
            children['svc-output-bandwidth'] = yang.gdata.Leaf('uint64', _svc_output_bandwidth)
        _svc_mtu = self.svc_mtu
        if _svc_mtu is not None:
            children['svc-mtu'] = yang.gdata.Leaf('uint16', _svc_mtu)
        _qos = self.qos
        if _qos is not None:
            children['qos'] = _qos.to_gdata()
        _carrierscarrier = self.carrierscarrier
        if _carrierscarrier is not None:
            children['carrierscarrier'] = _carrierscarrier.to_gdata()
        _multicast = self.multicast
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(svc_input_bandwidth=n.get_opt_int('svc-input-bandwidth'), svc_output_bandwidth=n.get_opt_int('svc-output-bandwidth'), svc_mtu=n.get_opt_int('svc-mtu'), qos=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos.from_gdata(n.get_opt_container('qos')), carrierscarrier=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier.from_gdata(n.get_opt_container('carrierscarrier')), multicast=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast.from_gdata(n.get_opt_container('multicast')))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service')

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(svc_input_bandwidth=yang.gdata.from_xml_opt_int(n, 'svc-input-bandwidth'), svc_output_bandwidth=yang.gdata.from_xml_opt_int(n, 'svc-output-bandwidth'), svc_mtu=yang.gdata.from_xml_opt_int(n, 'svc-mtu'), qos=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos.from_xml(yang.gdata.get_xml_opt_child(n, 'qos')), carrierscarrier=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier.from_xml(yang.gdata.get_xml_opt_child(n, 'carrierscarrier')), multicast=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast.from_xml(yang.gdata.get_xml_opt_child(n, 'multicast')))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service')


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'svc-input-bandwidth':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'svc-output-bandwidth':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'svc-mtu':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'qos':
            child = {'qos': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'carrierscarrier':
            child = {'carrierscarrier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'multicast':
            child = {'multicast': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_svc_input_bandwidth = yang.gdata.take_json_int(jd, 'svc-input-bandwidth')
    yang.gdata.maybe_add(children, 'svc-input-bandwidth', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_input_bandwidth, child_svc_input_bandwidth)
    child_svc_output_bandwidth = yang.gdata.take_json_int(jd, 'svc-output-bandwidth')
    yang.gdata.maybe_add(children, 'svc-output-bandwidth', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_output_bandwidth, child_svc_output_bandwidth)
    child_svc_mtu = yang.gdata.take_json_int(jd, 'svc-mtu')
    yang.gdata.maybe_add(children, 'svc-mtu', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_mtu, child_svc_mtu)
    child_qos = yang.gdata.take_json_opt_cnt(jd, 'qos')
    yang.gdata.maybe_add(children, 'qos', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos, child_qos)
    child_carrierscarrier = yang.gdata.take_json_opt_cnt(jd, 'carrierscarrier')
    yang.gdata.maybe_add(children, 'carrierscarrier', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier, child_carrierscarrier)
    child_multicast = yang.gdata.take_json_opt_cnt(jd, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast, child_multicast)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__area_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(yang.adata.MNode):
    target_site: str
    metric: ?int

    mut def __init__(self, target_site: str, metric: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.target_site = target_site
        self.metric = metric

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _target_site = self.target_site
        if _target_site is not None:
            children['target-site'] = yang.gdata.Leaf('string', _target_site)
        _metric = self.metric
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.target_site)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site=n.get_str('target-site'), metric=n.get_opt_int('metric'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site=yang.gdata.from_xml_str(n, 'target-site'), metric=yang.gdata.from_xml_opt_int(n, 'metric'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'sham-link'
        self.elements = elements

    mut def create(self, target_site):
        for e in self.elements:
            match = True
            if e.target_site != target_site:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['target-site'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['target-site'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(keys[0])
        if point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['target-site']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['target-site'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['target-site'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_target_site = yang.gdata.take_json_str(jd, 'target-site')
    yang.gdata.maybe_add(children, 'target-site', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site, child_target_site)
    child_metric = yang.gdata.take_json_opt_int(jd, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric, child_metric)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_target_site)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(e))
    return yang.gdata.List(keys=['target-site'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(yang.adata.MNode):
    sham_link: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link

    mut def __init__(self, sham_link: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.sham_link = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(elements=sham_link)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _sham_link = self.sham_link
        if _sham_link is not None:
            children['sham-link'] = _sham_link.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(sham_link=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link.from_gdata(n.get_opt_list('sham-link')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(sham_link=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link.from_xml(yang.gdata.get_xml_children(n, 'sham-link')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'sham-link':
            child = {'sham-link': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_sham_link = yang.gdata.take_json_opt_list(jd, 'sham-link')
    yang.gdata.maybe_add(children, 'sham-link', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link, child_sham_link)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(yang.adata.MNode):
    address_family: list[str]
    area_address: ?str
    metric: ?int
    sham_links: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links

    mut def __init__(self, address_family: ?list[str]=None, area_address: ?str, metric: ?int, sham_links: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []
        self.area_address = area_address
        self.metric = metric
        self.sham_links = sham_links if sham_links is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['address-family'] = yang.gdata.LeafList('enumeration', self.address_family)
        _area_address = self.area_address
        if _area_address is not None:
            children['area-address'] = yang.gdata.Leaf('string', _area_address)
        _metric = self.metric
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        _sham_links = self.sham_links
        if _sham_links is not None:
            children['sham-links'] = _sham_links.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(address_family=n.get_opt_strs('address-family'), area_address=n.get_opt_str('area-address'), metric=n.get_opt_int('metric'), sham_links=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links.from_gdata(n.get_opt_container('sham-links')))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(address_family=yang.gdata.from_xml_opt_strs(n, 'address-family'), area_address=yang.gdata.from_xml_opt_str(n, 'area-address'), metric=yang.gdata.from_xml_opt_int(n, 'metric'), sham_links=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links.from_xml(yang.gdata.get_xml_opt_child(n, 'sham-links')))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'area-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'sham-links':
            child = {'sham-links': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_opt_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__address_family, child_address_family)
    child_area_address = yang.gdata.take_json_str(jd, 'area-address')
    yang.gdata.maybe_add(children, 'area-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__area_address, child_area_address)
    child_metric = yang.gdata.take_json_opt_int(jd, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__metric, child_metric)
    child_sham_links = yang.gdata.take_json_opt_cnt(jd, 'sham-links')
    yang.gdata.maybe_add(children, 'sham-links', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links, child_sham_links)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__autonomous_system(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(yang.adata.MNode):
    autonomous_system: ?int
    address_family: list[str]

    mut def __init__(self, autonomous_system: ?int, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.autonomous_system = autonomous_system
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _autonomous_system = self.autonomous_system
        if _autonomous_system is not None:
            children['autonomous-system'] = yang.gdata.Leaf('uint32', _autonomous_system)
        children['address-family'] = yang.gdata.LeafList('enumeration', self.address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(autonomous_system=n.get_opt_int('autonomous-system'), address_family=n.get_opt_strs('address-family'))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(autonomous_system=yang.gdata.from_xml_opt_int(n, 'autonomous-system'), address_family=yang.gdata.from_xml_opt_strs(n, 'address-family'))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'autonomous-system':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_autonomous_system = yang.gdata.take_json_int(jd, 'autonomous-system')
    yang.gdata.maybe_add(children, 'autonomous-system', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__autonomous_system, child_autonomous_system)
    child_address_family = yang.gdata.take_json_opt_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__address_family, child_address_family)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        _next_hop = self.next_hop
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.lan), yang.gdata.yang_str(self.next_hop)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan=yang.gdata.from_xml_str(n, 'lan'), next_hop=yang.gdata.from_xml_str(n, 'next-hop'), lan_tag=yang.gdata.from_xml_opt_str(n, 'lan-tag'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv4-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self.elements:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(keys[0])
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(keys[1])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.take_json_str(jd, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.take_json_str(jd, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.take_json_opt_str(jd, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_lan), yang.gdata.yang_str(child_next_hop)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(e))
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        _next_hop = self.next_hop
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.lan), yang.gdata.yang_str(self.next_hop)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan=yang.gdata.from_xml_str(n, 'lan'), next_hop=yang.gdata.from_xml_str(n, 'next-hop'), lan_tag=yang.gdata.from_xml_opt_str(n, 'lan-tag'))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv6-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self.elements:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(keys[0])
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(keys[1])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.take_json_str(jd, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.take_json_str(jd, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.take_json_opt_str(jd, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_lan), yang.gdata.yang_str(child_next_hop)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(e))
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.adata.MNode):
    ipv4_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes
    ipv6_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes

    mut def __init__(self, ipv4_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]=[], ipv6_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(elements=ipv4_lan_prefixes)
        self.ipv6_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(elements=ipv6_lan_prefixes)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4_lan_prefixes = self.ipv4_lan_prefixes
        if _ipv4_lan_prefixes is not None:
            children['ipv4-lan-prefixes'] = _ipv4_lan_prefixes.to_gdata()
        _ipv6_lan_prefixes = self.ipv6_lan_prefixes
        if _ipv6_lan_prefixes is not None:
            children['ipv6-lan-prefixes'] = _ipv6_lan_prefixes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(ipv4_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes.from_gdata(n.get_opt_list('ipv4-lan-prefixes')), ipv6_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes.from_gdata(n.get_opt_list('ipv6-lan-prefixes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(ipv4_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes.from_xml(yang.gdata.get_xml_children(n, 'ipv4-lan-prefixes')), ipv6_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes.from_xml(yang.gdata.get_xml_children(n, 'ipv6-lan-prefixes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'ipv4-lan-prefixes':
            child = {'ipv4-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'ipv6-lan-prefixes':
            child = {'ipv6-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4_lan_prefixes = yang.gdata.take_json_opt_list(jd, 'ipv4-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv4-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes, child_ipv4_lan_prefixes)
    child_ipv6_lan_prefixes = yang.gdata.take_json_opt_list(jd, 'ipv6-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv6-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes, child_ipv6_lan_prefixes)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(yang.adata.MNode):
    cascaded_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes

    mut def __init__(self, cascaded_lan_prefixes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cascaded_lan_prefixes = cascaded_lan_prefixes if cascaded_lan_prefixes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cascaded_lan_prefixes = self.cascaded_lan_prefixes
        if _cascaded_lan_prefixes is not None:
            children['cascaded-lan-prefixes'] = _cascaded_lan_prefixes.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(cascaded_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_gdata(n.get_opt_container('cascaded-lan-prefixes')))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(cascaded_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_xml(yang.gdata.get_xml_opt_child(n, 'cascaded-lan-prefixes')))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'cascaded-lan-prefixes':
            child = {'cascaded-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cascaded_lan_prefixes = yang.gdata.take_json_opt_cnt(jd, 'cascaded-lan-prefixes')
    yang.gdata.maybe_add(children, 'cascaded-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes, child_cascaded_lan_prefixes)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['address-family'] = yang.gdata.LeafList('enumeration', self.address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(address_family=n.get_opt_strs('address-family'))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(address_family=yang.gdata.from_xml_opt_strs(n, 'address-family'))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_opt_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip__address_family, child_address_family)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['address-family'] = yang.gdata.LeafList('enumeration', self.address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(address_family=n.get_opt_strs('address-family'))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(address_family=yang.gdata.from_xml_opt_strs(n, 'address-family'))
        return None


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_opt_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp__address_family, child_address_family)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(yang.adata.MNode):
    type: str
    ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf
    bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp
    static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static
    rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip
    vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp

    mut def __init__(self, type: str, ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf=None, bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp=None, static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static=None, rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip=None, vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type
        self.ospf = ospf
        self.bgp = bgp
        self.static = static
        self.rip = rip
        self.vrrp = vrrp

    mut def create_ospf(self, area_address):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(area_address)
        self.ospf = res
        return res

    mut def create_bgp(self, autonomous_system):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(autonomous_system)
        self.bgp = res
        return res

    mut def create_static(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static()
        self.static = res
        return res

    mut def create_rip(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip()
        self.rip = res
        return res

    mut def create_vrrp(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp()
        self.vrrp = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        if _type is not None:
            children['type'] = yang.gdata.Leaf('identityref', _type)
        _ospf = self.ospf
        if _ospf is not None:
            children['ospf'] = _ospf.to_gdata()
        _bgp = self.bgp
        if _bgp is not None:
            children['bgp'] = _bgp.to_gdata()
        _static = self.static
        if _static is not None:
            children['static'] = _static.to_gdata()
        _rip = self.rip
        if _rip is not None:
            children['rip'] = _rip.to_gdata()
        _vrrp = self.vrrp
        if _vrrp is not None:
            children['vrrp'] = _vrrp.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.type)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(type=n.get_str('type'), ospf=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf.from_gdata(n.get_opt_container('ospf')), bgp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp.from_gdata(n.get_opt_container('bgp')), static=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static.from_gdata(n.get_opt_container('static')), rip=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip.from_gdata(n.get_opt_container('rip')), vrrp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp.from_gdata(n.get_opt_container('vrrp')))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(type=yang.gdata.from_xml_str(n, 'type'), ospf=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf.from_xml(yang.gdata.get_xml_opt_child(n, 'ospf')), bgp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp.from_xml(yang.gdata.get_xml_opt_child(n, 'bgp')), static=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static.from_xml(yang.gdata.get_xml_opt_child(n, 'static')), rip=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip.from_xml(yang.gdata.get_xml_opt_child(n, 'rip')), vrrp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp.from_xml(yang.gdata.get_xml_opt_child(n, 'vrrp')))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'routing-protocol'
        self.elements = elements

    mut def create(self, type):
        for e in self.elements:
            match = True
            if e.type != type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['type'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__type(keys[0])
        if point == 'ospf':
            children['ospf'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(jd, rest_path, op)
        if point == 'bgp':
            children['bgp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(jd, rest_path, op)
        if point == 'static':
            children['static'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(jd, rest_path, op)
        if point == 'rip':
            children['rip'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(jd, rest_path, op)
        if point == 'vrrp':
            children['vrrp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['type'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_type = yang.gdata.take_json_str(jd, 'type')
    yang.gdata.maybe_add(children, 'type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__type, child_type)
    child_ospf = yang.gdata.take_json_opt_cnt(jd, 'ospf')
    yang.gdata.maybe_add(children, 'ospf', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf, child_ospf)
    child_bgp = yang.gdata.take_json_opt_cnt(jd, 'bgp')
    yang.gdata.maybe_add(children, 'bgp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp, child_bgp)
    child_static = yang.gdata.take_json_opt_cnt(jd, 'static')
    yang.gdata.maybe_add(children, 'static', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static, child_static)
    child_rip = yang.gdata.take_json_opt_cnt(jd, 'rip')
    yang.gdata.maybe_add(children, 'rip', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip, child_rip)
    child_vrrp = yang.gdata.take_json_opt_cnt(jd, 'vrrp')
    yang.gdata.maybe_add(children, 'vrrp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp, child_vrrp)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_type)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(e))
    return yang.gdata.List(keys=['type'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(yang.adata.MNode):
    routing_protocol: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol

    mut def __init__(self, routing_protocol: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.routing_protocol = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(elements=routing_protocol)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _routing_protocol = self.routing_protocol
        if _routing_protocol is not None:
            children['routing-protocol'] = _routing_protocol.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(routing_protocol=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol.from_gdata(n.get_opt_list('routing-protocol')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(routing_protocol=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol.from_xml(yang.gdata.get_xml_children(n, 'routing-protocol')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'routing-protocol':
            child = {'routing-protocol': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_routing_protocol = yang.gdata.take_json_opt_list(jd, 'routing-protocol')
    yang.gdata.maybe_add(children, 'routing-protocol', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol, child_routing_protocol)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability__access_priority(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(yang.adata.MNode):
    access_priority: ?int

    mut def __init__(self, access_priority: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.access_priority = access_priority

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _access_priority = self.access_priority
        if _access_priority is not None:
            children['access-priority'] = yang.gdata.Leaf('uint32', _access_priority)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(access_priority=n.get_opt_int('access-priority'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(access_priority=yang.gdata.from_xml_opt_int(n, 'access-priority'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'access-priority':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_access_priority = yang.gdata.take_json_opt_int(jd, 'access-priority')
    yang.gdata.maybe_add(children, 'access-priority', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability__access_priority, child_access_priority)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_policy_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__site_role(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('identityref', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(yang.adata.MNode):
    vpn_policy_id: ?str
    vpn_id: ?str
    site_role: ?str

    mut def __init__(self, vpn_policy_id: ?str, vpn_id: ?str, site_role: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_policy_id = vpn_policy_id
        self.vpn_id = vpn_id
        self.site_role = site_role

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_policy_id = self.vpn_policy_id
        if _vpn_policy_id is not None:
            children['vpn-policy-id'] = yang.gdata.Leaf('leafref', _vpn_policy_id)
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('leafref', _vpn_id)
        _site_role = self.site_role
        if _site_role is not None:
            children['site-role'] = yang.gdata.Leaf('identityref', _site_role)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(vpn_policy_id=n.get_opt_str('vpn-policy-id'), vpn_id=n.get_opt_str('vpn-id'), site_role=n.get_opt_str('site-role'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(vpn_policy_id=yang.gdata.from_xml_opt_str(n, 'vpn-policy-id'), vpn_id=yang.gdata.from_xml_opt_str(n, 'vpn-id'), site_role=yang.gdata.from_xml_opt_str(n, 'site-role'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'vpn-policy-id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'vpn-id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'site-role':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_policy_id = yang.gdata.take_json_opt_str(jd, 'vpn-policy-id')
    yang.gdata.maybe_add(children, 'vpn-policy-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_policy_id, child_vpn_policy_id)
    child_vpn_id = yang.gdata.take_json_opt_str(jd, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_id, child_vpn_id)
    child_site_role = yang.gdata.take_json_opt_str(jd, 'site-role')
    yang.gdata.maybe_add(children, 'site-role', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__site_role, child_site_role)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(yang.adata.MNode):
    site_network_access_id: str
    site_network_access_type: ?str
    location_reference: ?str
    device_reference: ?str
    access_diversity: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity
    bearer: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer
    ip_connection: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection
    security: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security
    service: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service
    routing_protocols: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols
    availability: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability
    vpn_attachment: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment

    mut def __init__(self, site_network_access_id: str, site_network_access_type: ?str, location_reference: ?str, device_reference: ?str, access_diversity: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity=None, bearer: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer=None, ip_connection: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection=None, security: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security=None, service: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service=None, routing_protocols: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols=None, availability: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability=None, vpn_attachment: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site_network_access_id = site_network_access_id
        self.site_network_access_type = site_network_access_type
        self.location_reference = location_reference
        self.device_reference = device_reference
        self.access_diversity = access_diversity if access_diversity is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity()
        self.bearer = bearer if bearer is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer()
        self.ip_connection = ip_connection if ip_connection is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection()
        self.security = security if security is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security()
        self.service = service if service is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service()
        self.routing_protocols = routing_protocols if routing_protocols is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols()
        self.availability = availability if availability is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability()
        self.vpn_attachment = vpn_attachment if vpn_attachment is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site_network_access_id = self.site_network_access_id
        if _site_network_access_id is not None:
            children['site-network-access-id'] = yang.gdata.Leaf('string', _site_network_access_id)
        _site_network_access_type = self.site_network_access_type
        if _site_network_access_type is not None:
            children['site-network-access-type'] = yang.gdata.Leaf('identityref', _site_network_access_type)
        _location_reference = self.location_reference
        if _location_reference is not None:
            children['location-reference'] = yang.gdata.Leaf('leafref', _location_reference)
        _device_reference = self.device_reference
        if _device_reference is not None:
            children['device-reference'] = yang.gdata.Leaf('leafref', _device_reference)
        _access_diversity = self.access_diversity
        if _access_diversity is not None:
            children['access-diversity'] = _access_diversity.to_gdata()
        _bearer = self.bearer
        if _bearer is not None:
            children['bearer'] = _bearer.to_gdata()
        _ip_connection = self.ip_connection
        if _ip_connection is not None:
            children['ip-connection'] = _ip_connection.to_gdata()
        _security = self.security
        if _security is not None:
            children['security'] = _security.to_gdata()
        _service = self.service
        if _service is not None:
            children['service'] = _service.to_gdata()
        _routing_protocols = self.routing_protocols
        if _routing_protocols is not None:
            children['routing-protocols'] = _routing_protocols.to_gdata()
        _availability = self.availability
        if _availability is not None:
            children['availability'] = _availability.to_gdata()
        _vpn_attachment = self.vpn_attachment
        if _vpn_attachment is not None:
            children['vpn-attachment'] = _vpn_attachment.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.site_network_access_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(site_network_access_id=n.get_str('site-network-access-id'), site_network_access_type=n.get_opt_str('site-network-access-type'), location_reference=n.get_opt_str('location-reference'), device_reference=n.get_opt_str('device-reference'), access_diversity=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity.from_gdata(n.get_opt_container('access-diversity')), bearer=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer.from_gdata(n.get_opt_container('bearer')), ip_connection=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection.from_gdata(n.get_opt_container('ip-connection')), security=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security.from_gdata(n.get_opt_container('security')), service=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service.from_gdata(n.get_opt_container('service')), routing_protocols=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols.from_gdata(n.get_opt_container('routing-protocols')), availability=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability.from_gdata(n.get_opt_container('availability')), vpn_attachment=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment.from_gdata(n.get_opt_container('vpn-attachment')))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(site_network_access_id=yang.gdata.from_xml_str(n, 'site-network-access-id'), site_network_access_type=yang.gdata.from_xml_opt_str(n, 'site-network-access-type'), location_reference=yang.gdata.from_xml_opt_str(n, 'location-reference'), device_reference=yang.gdata.from_xml_opt_str(n, 'device-reference'), access_diversity=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity.from_xml(yang.gdata.get_xml_opt_child(n, 'access-diversity')), bearer=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer.from_xml(yang.gdata.get_xml_opt_child(n, 'bearer')), ip_connection=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection.from_xml(yang.gdata.get_xml_opt_child(n, 'ip-connection')), security=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security.from_xml(yang.gdata.get_xml_opt_child(n, 'security')), service=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service.from_xml(yang.gdata.get_xml_opt_child(n, 'service')), routing_protocols=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols.from_xml(yang.gdata.get_xml_opt_child(n, 'routing-protocols')), availability=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability.from_xml(yang.gdata.get_xml_opt_child(n, 'availability')), vpn_attachment=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment.from_xml(yang.gdata.get_xml_opt_child(n, 'vpn-attachment')))

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'site-network-access'
        self.elements = elements

    mut def create(self, site_network_access_id):
        for e in self.elements:
            match = True
            if e.site_network_access_id != site_network_access_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(site_network_access_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['site-network-access-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['site-network-access-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_id(keys[0])
        if point == 'site-network-access-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'location-reference':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'device-reference':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'access-diversity':
            children['access-diversity'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(jd, rest_path, op)
        if point == 'bearer':
            children['bearer'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(jd, rest_path, op)
        if point == 'ip-connection':
            children['ip-connection'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(jd, rest_path, op)
        if point == 'security':
            children['security'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(jd, rest_path, op)
        if point == 'service':
            children['service'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(jd, rest_path, op)
        if point == 'routing-protocols':
            children['routing-protocols'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(jd, rest_path, op)
        if point == 'availability':
            children['availability'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(jd, rest_path, op)
        if point == 'vpn-attachment':
            children['vpn-attachment'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['site-network-access-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['site-network-access-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['site-network-access-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_site_network_access_id = yang.gdata.take_json_str(jd, 'site-network-access-id')
    yang.gdata.maybe_add(children, 'site-network-access-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_id, child_site_network_access_id)
    child_site_network_access_type = yang.gdata.take_json_opt_str(jd, 'site-network-access-type')
    yang.gdata.maybe_add(children, 'site-network-access-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_type, child_site_network_access_type)
    child_location_reference = yang.gdata.take_json_opt_str(jd, 'location-reference')
    yang.gdata.maybe_add(children, 'location-reference', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__location_reference, child_location_reference)
    child_device_reference = yang.gdata.take_json_opt_str(jd, 'device-reference')
    yang.gdata.maybe_add(children, 'device-reference', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__device_reference, child_device_reference)
    child_access_diversity = yang.gdata.take_json_opt_cnt(jd, 'access-diversity')
    yang.gdata.maybe_add(children, 'access-diversity', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity, child_access_diversity)
    child_bearer = yang.gdata.take_json_opt_cnt(jd, 'bearer')
    yang.gdata.maybe_add(children, 'bearer', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer, child_bearer)
    child_ip_connection = yang.gdata.take_json_opt_cnt(jd, 'ip-connection')
    yang.gdata.maybe_add(children, 'ip-connection', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection, child_ip_connection)
    child_security = yang.gdata.take_json_opt_cnt(jd, 'security')
    yang.gdata.maybe_add(children, 'security', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security, child_security)
    child_service = yang.gdata.take_json_opt_cnt(jd, 'service')
    yang.gdata.maybe_add(children, 'service', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service, child_service)
    child_routing_protocols = yang.gdata.take_json_opt_cnt(jd, 'routing-protocols')
    yang.gdata.maybe_add(children, 'routing-protocols', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols, child_routing_protocols)
    child_availability = yang.gdata.take_json_opt_cnt(jd, 'availability')
    yang.gdata.maybe_add(children, 'availability', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability, child_availability)
    child_vpn_attachment = yang.gdata.take_json_opt_cnt(jd, 'vpn-attachment')
    yang.gdata.maybe_add(children, 'vpn-attachment', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment, child_vpn_attachment)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_site_network_access_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(e))
    return yang.gdata.List(keys=['site-network-access-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(yang.adata.MNode):
    site_network_access: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access

    mut def __init__(self, site_network_access: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site_network_access = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(elements=site_network_access)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site_network_access = self.site_network_access
        if _site_network_access is not None:
            children['site-network-access'] = _site_network_access.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(site_network_access=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access.from_gdata(n.get_opt_list('site-network-access')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(site_network_access=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access.from_xml(yang.gdata.get_xml_children(n, 'site-network-access')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'site-network-access':
            child = {'site-network-access': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_site_network_access = yang.gdata.take_json_opt_list(jd, 'site-network-access')
    yang.gdata.maybe_add(children, 'site-network-access', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access, child_site_network_access)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(yang.adata.MNode):
    site_id: str
    requested_site_start: ?str
    requested_site_stop: ?str
    locations: ietf_l3vpn_svc__l3vpn_svc__sites__site__locations
    devices: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices
    site_diversity: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity
    management: ietf_l3vpn_svc__l3vpn_svc__sites__site__management
    vpn_policies: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies
    site_vpn_flavor: ?str
    maximum_routes: ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes
    security: ietf_l3vpn_svc__l3vpn_svc__sites__site__security
    service: ietf_l3vpn_svc__l3vpn_svc__sites__site__service
    traffic_protection: ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection
    routing_protocols: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols
    site_network_accesses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses

    mut def __init__(self, site_id: str, requested_site_start: ?str, requested_site_stop: ?str, locations: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__locations=None, devices: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__devices=None, site_diversity: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity=None, management: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__management=None, vpn_policies: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies=None, site_vpn_flavor: ?str, maximum_routes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes=None, security: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security=None, service: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service=None, traffic_protection: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection=None, routing_protocols: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols=None, site_network_accesses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site_id = site_id
        self.requested_site_start = requested_site_start
        self.requested_site_stop = requested_site_stop
        self.locations = locations if locations is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__locations()
        self.devices = devices if devices is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__devices()
        self.site_diversity = site_diversity if site_diversity is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity()
        self.management = management if management is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__management()
        self.vpn_policies = vpn_policies if vpn_policies is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies()
        self.site_vpn_flavor = site_vpn_flavor
        self.maximum_routes = maximum_routes if maximum_routes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes()
        self.security = security if security is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security()
        self.service = service if service is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service()
        self.traffic_protection = traffic_protection if traffic_protection is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection()
        self.routing_protocols = routing_protocols if routing_protocols is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols()
        self.site_network_accesses = site_network_accesses if site_network_accesses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site_id = self.site_id
        if _site_id is not None:
            children['site-id'] = yang.gdata.Leaf('string', _site_id)
        _requested_site_start = self.requested_site_start
        if _requested_site_start is not None:
            children['requested-site-start'] = yang.gdata.Leaf('string', _requested_site_start)
        _requested_site_stop = self.requested_site_stop
        if _requested_site_stop is not None:
            children['requested-site-stop'] = yang.gdata.Leaf('string', _requested_site_stop)
        _locations = self.locations
        if _locations is not None:
            children['locations'] = _locations.to_gdata()
        _devices = self.devices
        if _devices is not None:
            children['devices'] = _devices.to_gdata()
        _site_diversity = self.site_diversity
        if _site_diversity is not None:
            children['site-diversity'] = _site_diversity.to_gdata()
        _management = self.management
        if _management is not None:
            children['management'] = _management.to_gdata()
        _vpn_policies = self.vpn_policies
        if _vpn_policies is not None:
            children['vpn-policies'] = _vpn_policies.to_gdata()
        _site_vpn_flavor = self.site_vpn_flavor
        if _site_vpn_flavor is not None:
            children['site-vpn-flavor'] = yang.gdata.Leaf('identityref', _site_vpn_flavor)
        _maximum_routes = self.maximum_routes
        if _maximum_routes is not None:
            children['maximum-routes'] = _maximum_routes.to_gdata()
        _security = self.security
        if _security is not None:
            children['security'] = _security.to_gdata()
        _service = self.service
        if _service is not None:
            children['service'] = _service.to_gdata()
        _traffic_protection = self.traffic_protection
        if _traffic_protection is not None:
            children['traffic-protection'] = _traffic_protection.to_gdata()
        _routing_protocols = self.routing_protocols
        if _routing_protocols is not None:
            children['routing-protocols'] = _routing_protocols.to_gdata()
        _site_network_accesses = self.site_network_accesses
        if _site_network_accesses is not None:
            children['site-network-accesses'] = _site_network_accesses.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.site_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(site_id=n.get_str('site-id'), requested_site_start=n.get_opt_str('requested-site-start'), requested_site_stop=n.get_opt_str('requested-site-stop'), locations=ietf_l3vpn_svc__l3vpn_svc__sites__site__locations.from_gdata(n.get_opt_container('locations')), devices=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices.from_gdata(n.get_opt_container('devices')), site_diversity=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity.from_gdata(n.get_opt_container('site-diversity')), management=ietf_l3vpn_svc__l3vpn_svc__sites__site__management.from_gdata(n.get_opt_container('management')), vpn_policies=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies.from_gdata(n.get_opt_container('vpn-policies')), site_vpn_flavor=n.get_opt_str('site-vpn-flavor'), maximum_routes=ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes.from_gdata(n.get_opt_container('maximum-routes')), security=ietf_l3vpn_svc__l3vpn_svc__sites__site__security.from_gdata(n.get_opt_container('security')), service=ietf_l3vpn_svc__l3vpn_svc__sites__site__service.from_gdata(n.get_opt_container('service')), traffic_protection=ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection.from_gdata(n.get_opt_container('traffic-protection')), routing_protocols=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols.from_gdata(n.get_opt_container('routing-protocols')), site_network_accesses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses.from_gdata(n.get_opt_container('site-network-accesses')))

    @staticmethod
    mut def from_xml(n: xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(site_id=yang.gdata.from_xml_str(n, 'site-id'), requested_site_start=yang.gdata.from_xml_opt_str(n, 'requested-site-start'), requested_site_stop=yang.gdata.from_xml_opt_str(n, 'requested-site-stop'), locations=ietf_l3vpn_svc__l3vpn_svc__sites__site__locations.from_xml(yang.gdata.get_xml_opt_child(n, 'locations')), devices=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices.from_xml(yang.gdata.get_xml_opt_child(n, 'devices')), site_diversity=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity.from_xml(yang.gdata.get_xml_opt_child(n, 'site-diversity')), management=ietf_l3vpn_svc__l3vpn_svc__sites__site__management.from_xml(yang.gdata.get_xml_opt_child(n, 'management')), vpn_policies=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies.from_xml(yang.gdata.get_xml_opt_child(n, 'vpn-policies')), site_vpn_flavor=yang.gdata.from_xml_opt_str(n, 'site-vpn-flavor'), maximum_routes=ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes.from_xml(yang.gdata.get_xml_opt_child(n, 'maximum-routes')), security=ietf_l3vpn_svc__l3vpn_svc__sites__site__security.from_xml(yang.gdata.get_xml_opt_child(n, 'security')), service=ietf_l3vpn_svc__l3vpn_svc__sites__site__service.from_xml(yang.gdata.get_xml_opt_child(n, 'service')), traffic_protection=ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection.from_xml(yang.gdata.get_xml_opt_child(n, 'traffic-protection')), routing_protocols=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols.from_xml(yang.gdata.get_xml_opt_child(n, 'routing-protocols')), site_network_accesses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses.from_xml(yang.gdata.get_xml_opt_child(n, 'site-network-accesses')))

class ietf_l3vpn_svc__l3vpn_svc__sites__site(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'site'
        self.elements = elements

    mut def create(self, site_id):
        for e in self.elements:
            match = True
            if e.site_id != site_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(site_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['site-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]:
        res = []
        for node in nodes:
            res.append(ietf_l3vpn_svc__l3vpn_svc__sites__site_entry.from_xml(node))
        return res


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['site-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_id(keys[0])
        if point == 'requested-site-start':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'requested-site-stop':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'locations':
            children['locations'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(jd, rest_path, op)
        if point == 'devices':
            children['devices'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(jd, rest_path, op)
        if point == 'site-diversity':
            children['site-diversity'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(jd, rest_path, op)
        if point == 'management':
            children['management'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(jd, rest_path, op)
        if point == 'vpn-policies':
            children['vpn-policies'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(jd, rest_path, op)
        if point == 'site-vpn-flavor':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'maximum-routes':
            children['maximum-routes'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(jd, rest_path, op)
        if point == 'security':
            children['security'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(jd, rest_path, op)
        if point == 'service':
            children['service'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(jd, rest_path, op)
        if point == 'traffic-protection':
            children['traffic-protection'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(jd, rest_path, op)
        if point == 'routing-protocols':
            children['routing-protocols'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(jd, rest_path, op)
        if point == 'site-network-accesses':
            children['site-network-accesses'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['site-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['site-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['site-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_site_id = yang.gdata.take_json_str(jd, 'site-id')
    yang.gdata.maybe_add(children, 'site-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_id, child_site_id)
    child_requested_site_start = yang.gdata.take_json_opt_str(jd, 'requested-site-start')
    yang.gdata.maybe_add(children, 'requested-site-start', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_start, child_requested_site_start)
    child_requested_site_stop = yang.gdata.take_json_opt_str(jd, 'requested-site-stop')
    yang.gdata.maybe_add(children, 'requested-site-stop', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_stop, child_requested_site_stop)
    child_locations = yang.gdata.take_json_opt_cnt(jd, 'locations')
    yang.gdata.maybe_add(children, 'locations', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations, child_locations)
    child_devices = yang.gdata.take_json_opt_cnt(jd, 'devices')
    yang.gdata.maybe_add(children, 'devices', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices, child_devices)
    child_site_diversity = yang.gdata.take_json_opt_cnt(jd, 'site-diversity')
    yang.gdata.maybe_add(children, 'site-diversity', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity, child_site_diversity)
    child_management = yang.gdata.take_json_opt_cnt(jd, 'management')
    yang.gdata.maybe_add(children, 'management', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management, child_management)
    child_vpn_policies = yang.gdata.take_json_opt_cnt(jd, 'vpn-policies')
    yang.gdata.maybe_add(children, 'vpn-policies', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies, child_vpn_policies)
    child_site_vpn_flavor = yang.gdata.take_json_opt_str(jd, 'site-vpn-flavor')
    yang.gdata.maybe_add(children, 'site-vpn-flavor', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_vpn_flavor, child_site_vpn_flavor)
    child_maximum_routes = yang.gdata.take_json_opt_cnt(jd, 'maximum-routes')
    yang.gdata.maybe_add(children, 'maximum-routes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes, child_maximum_routes)
    child_security = yang.gdata.take_json_opt_cnt(jd, 'security')
    yang.gdata.maybe_add(children, 'security', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security, child_security)
    child_service = yang.gdata.take_json_opt_cnt(jd, 'service')
    yang.gdata.maybe_add(children, 'service', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service, child_service)
    child_traffic_protection = yang.gdata.take_json_opt_cnt(jd, 'traffic-protection')
    yang.gdata.maybe_add(children, 'traffic-protection', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection, child_traffic_protection)
    child_routing_protocols = yang.gdata.take_json_opt_cnt(jd, 'routing-protocols')
    yang.gdata.maybe_add(children, 'routing-protocols', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols, child_routing_protocols)
    child_site_network_accesses = yang.gdata.take_json_opt_cnt(jd, 'site-network-accesses')
    yang.gdata.maybe_add(children, 'site-network-accesses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses, child_site_network_accesses)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_site_id)])

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(e))
    return yang.gdata.List(keys=['site-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites(yang.adata.MNode):
    site: ietf_l3vpn_svc__l3vpn_svc__sites__site

    mut def __init__(self, site: list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site = ietf_l3vpn_svc__l3vpn_svc__sites__site(elements=site)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site = self.site
        if _site is not None:
            children['site'] = _site.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites(site=ietf_l3vpn_svc__l3vpn_svc__sites__site.from_gdata(n.get_opt_list('site')))
        return ietf_l3vpn_svc__l3vpn_svc__sites()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc__sites(site=ietf_l3vpn_svc__l3vpn_svc__sites__site.from_xml(yang.gdata.get_xml_children(n, 'site')))
        return ietf_l3vpn_svc__l3vpn_svc__sites()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'site':
            child = {'site': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_site = yang.gdata.take_json_opt_list(jd, 'site')
    yang.gdata.maybe_add(children, 'site', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site, child_site)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc(yang.adata.MNode):
    vpn_profiles: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles
    vpn_services: ietf_l3vpn_svc__l3vpn_svc__vpn_services
    sites: ietf_l3vpn_svc__l3vpn_svc__sites

    mut def __init__(self, vpn_profiles: ?ietf_l3vpn_svc__l3vpn_svc__vpn_profiles=None, vpn_services: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services=None, sites: ?ietf_l3vpn_svc__l3vpn_svc__sites=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_profiles = vpn_profiles if vpn_profiles is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_profiles()
        self.vpn_services = vpn_services if vpn_services is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services()
        self.sites = sites if sites is not None else ietf_l3vpn_svc__l3vpn_svc__sites()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_profiles = self.vpn_profiles
        if _vpn_profiles is not None:
            children['vpn-profiles'] = _vpn_profiles.to_gdata()
        _vpn_services = self.vpn_services
        if _vpn_services is not None:
            children['vpn-services'] = _vpn_services.to_gdata()
        _sites = self.sites
        if _sites is not None:
            children['sites'] = _sites.to_gdata()
        return yang.gdata.Container(children, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc(vpn_profiles=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles.from_gdata(n.get_opt_container('vpn-profiles')), vpn_services=ietf_l3vpn_svc__l3vpn_svc__vpn_services.from_gdata(n.get_opt_container('vpn-services')), sites=ietf_l3vpn_svc__l3vpn_svc__sites.from_gdata(n.get_opt_container('sites')))
        return ietf_l3vpn_svc__l3vpn_svc()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ietf_l3vpn_svc__l3vpn_svc:
        if n != None:
            return ietf_l3vpn_svc__l3vpn_svc(vpn_profiles=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles.from_xml(yang.gdata.get_xml_opt_child(n, 'vpn-profiles')), vpn_services=ietf_l3vpn_svc__l3vpn_svc__vpn_services.from_xml(yang.gdata.get_xml_opt_child(n, 'vpn-services')), sites=ietf_l3vpn_svc__l3vpn_svc__sites.from_xml(yang.gdata.get_xml_opt_child(n, 'sites')))
        return ietf_l3vpn_svc__l3vpn_svc()


mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'vpn-profiles':
            child = {'vpn-profiles': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')
        if point == 'vpn-services':
            child = {'vpn-services': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')
        if point == 'sites':
            child = {'sites': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_profiles = yang.gdata.take_json_opt_cnt(jd, 'vpn-profiles')
    yang.gdata.maybe_add(children, 'vpn-profiles', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles, child_vpn_profiles)
    child_vpn_services = yang.gdata.take_json_opt_cnt(jd, 'vpn-services')
    yang.gdata.maybe_add(children, 'vpn-services', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services, child_vpn_services)
    child_sites = yang.gdata.take_json_opt_cnt(jd, 'sites')
    yang.gdata.maybe_add(children, 'sites', from_json_ietf_l3vpn_svc__l3vpn_svc__sites, child_sites)
    return yang.gdata.Container(children, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')

class root(yang.adata.MNode):
    netinfra: netinfra__netinfra
    l3vpn_svc: ietf_l3vpn_svc__l3vpn_svc

    mut def __init__(self, netinfra: ?netinfra__netinfra=None, l3vpn_svc: ?ietf_l3vpn_svc__l3vpn_svc=None):
        self._ns = ''
        self.netinfra = netinfra if netinfra is not None else netinfra__netinfra()
        self.l3vpn_svc = l3vpn_svc if l3vpn_svc is not None else ietf_l3vpn_svc__l3vpn_svc()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _netinfra = self.netinfra
        if _netinfra is not None:
            children['netinfra'] = _netinfra.to_gdata()
        _l3vpn_svc = self.l3vpn_svc
        if _l3vpn_svc is not None:
            children['l3vpn-svc'] = _l3vpn_svc.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> root:
        if n != None:
            return root(netinfra=netinfra__netinfra.from_gdata(n.get_opt_container('netinfra')), l3vpn_svc=ietf_l3vpn_svc__l3vpn_svc.from_gdata(n.get_opt_container('l3vpn-svc')))
        return root()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> root:
        if n != None:
            return root(netinfra=netinfra__netinfra.from_xml(yang.gdata.get_xml_opt_child(n, 'netinfra', 'http://example.com/netinfra')), l3vpn_svc=ietf_l3vpn_svc__l3vpn_svc.from_xml(yang.gdata.get_xml_opt_child(n, 'l3vpn-svc', 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc')))
        return root()


mut def from_json_path(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'netinfra:netinfra':
            child = {'netinfra': from_json_path_netinfra__netinfra(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'ietf-l3vpn-svc:l3vpn-svc':
            child = {'l3vpn-svc': from_json_path_ietf_l3vpn_svc__l3vpn_svc(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_netinfra = yang.gdata.take_json_opt_cnt(jd, 'netinfra', 'netinfra')
    yang.gdata.maybe_add(children, 'netinfra', from_json_netinfra__netinfra, child_netinfra)
    child_l3vpn_svc = yang.gdata.take_json_opt_cnt(jd, 'l3vpn-svc', 'ietf-l3vpn-svc')
    yang.gdata.maybe_add(children, 'l3vpn-svc', from_json_ietf_l3vpn_svc__l3vpn_svc, child_l3vpn_svc)
    return yang.gdata.Container(children)

schema_namespaces: set[str] = {
    'http://example.com/netinfra',
    'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc',
}
