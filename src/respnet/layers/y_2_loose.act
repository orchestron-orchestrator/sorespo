import base64
import json
import xml
import yang.adata
import yang.gdata

# == This file is generated ==


mut def from_json_orchestron_rfs__device__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__device__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__device__type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__device__address__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__address__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__device__address__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_orchestron_rfs__device__address__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_json_orchestron_rfs__device__address__port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__address__port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__device__address__initial_credentials__username(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__address__initial_credentials__username(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__device__address__initial_credentials__password(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__address__initial_credentials__password(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__device__address__initial_credentials__key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__address__initial_credentials__key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class orchestron_rfs__device__address__initial_credentials_entry(yang.adata.MNode):
    username: str
    password: str
    key: str

    mut def __init__(self, username: str, password: str, key: str):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self.username = username
        self.password = password
        self.key = key

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _username = self.username
        if _username is not None:
            children['username'] = yang.gdata.Leaf('string', _username)
        _password = self.password
        if _password is not None:
            children['password'] = yang.gdata.Leaf('string', _password)
        _key = self.key
        if _key is not None:
            children['key'] = yang.gdata.Leaf('string', _key)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_rfs__device__address__initial_credentials_entry:
        return orchestron_rfs__device__address__initial_credentials_entry(username=n.get_str('username'), password=n.get_str('password'), key=n.get_str('key'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /device/address/initial-credentials')
            res.append(f'{self_name} = orchestron_rfs__device__address__initial_credentials({repr(self.username)}, {repr(self.password)}, {repr(self.key)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /device/address/initial-credentials'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class orchestron_rfs__device__address__initial_credentials(yang.adata.MNode):
    elements: list[orchestron_rfs__device__address__initial_credentials_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self._name = 'initial-credentials'
        self.elements = elements

    mut def create(self, username, password, key):
        for e in self.elements:
            match = True
            if e.username != username:
                match = False
                continue
            if e.password != password:
                match = False
                continue
            if e.key != key:
                match = False
                continue
            if match:
                return e

        res = orchestron_rfs__device__address__initial_credentials_entry(username, password, key)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['username', 'password', 'key'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_rfs__device__address__initial_credentials_entry]:
        if n is not None:
            return [orchestron_rfs__device__address__initial_credentials_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_orchestron_rfs__device__address__initial_credentials_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_username = yang.gdata.from_xml_str(node, 'username')
    yang.gdata.maybe_add(children, 'username', from_xml_orchestron_rfs__device__address__initial_credentials__username, child_username)
    child_password = yang.gdata.from_xml_str(node, 'password')
    yang.gdata.maybe_add(children, 'password', from_xml_orchestron_rfs__device__address__initial_credentials__password, child_password)
    child_key = yang.gdata.from_xml_str(node, 'key')
    yang.gdata.maybe_add(children, 'key', from_xml_orchestron_rfs__device__address__initial_credentials__key, child_key)
    return yang.gdata.Container(children)

mut def from_xml_orchestron_rfs__device__address__initial_credentials(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_orchestron_rfs__device__address__initial_credentials_element(e) for e in nodes]
    return yang.gdata.List(keys=['username', 'password', 'key'], elements=elements)

mut def from_json_path_orchestron_rfs__device__address__initial_credentials_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_orchestron_rfs__device__address__initial_credentials_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['username', 'password', 'key']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['username'] = from_json_orchestron_rfs__device__address__initial_credentials__username(keys[0])
        children['password'] = from_json_orchestron_rfs__device__address__initial_credentials__password(keys[1])
        children['key'] = from_json_orchestron_rfs__device__address__initial_credentials__key(keys[2])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_orchestron_rfs__device__address__initial_credentials(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['username', 'password', 'key']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_orchestron_rfs__device__address__initial_credentials_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['username', 'password', 'key'])))
        return yang.gdata.List(['username', 'password', 'key'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['username', 'password', 'key'], [from_json_path_orchestron_rfs__device__address__initial_credentials_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_orchestron_rfs__device__address__initial_credentials_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_username = yang.gdata.take_json_str(jd, 'username')
    yang.gdata.maybe_add(children, 'username', from_json_orchestron_rfs__device__address__initial_credentials__username, child_username)
    child_password = yang.gdata.take_json_str(jd, 'password')
    yang.gdata.maybe_add(children, 'password', from_json_orchestron_rfs__device__address__initial_credentials__password, child_password)
    child_key = yang.gdata.take_json_str(jd, 'key')
    yang.gdata.maybe_add(children, 'key', from_json_orchestron_rfs__device__address__initial_credentials__key, child_key)
    return yang.gdata.Container(children)

mut def from_json_orchestron_rfs__device__address__initial_credentials(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_orchestron_rfs__device__address__initial_credentials_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['username', 'password', 'key'], elements=elements)

class orchestron_rfs__device__address_entry(yang.adata.MNode):
    name: str
    address: ?str
    port: ?str
    initial_credentials: orchestron_rfs__device__address__initial_credentials

    mut def __init__(self, name: str, address: ?str, port: ?str, initial_credentials: list[orchestron_rfs__device__address__initial_credentials_entry]=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self.name = name
        self.address = address
        self.port = port
        self.initial_credentials = orchestron_rfs__device__address__initial_credentials(elements=initial_credentials)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _address = self.address
        if _address is not None:
            children['address'] = yang.gdata.Leaf('union', _address)
        _port = self.port
        if _port is not None:
            children['port'] = yang.gdata.Leaf('string', _port)
        _initial_credentials = self.initial_credentials
        if _initial_credentials is not None:
            children['initial-credentials'] = _initial_credentials.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_rfs__device__address_entry:
        return orchestron_rfs__device__address_entry(name=n.get_str('name'), address=n.get_opt_str('address'), port=n.get_opt_str('port'), initial_credentials=orchestron_rfs__device__address__initial_credentials.from_gdata(n.get_opt_list('initial-credentials')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /device/address')
            res.append(f'{self_name} = orchestron_rfs__device__address({repr(self.name)})')
        leaves = []
        _address = self.address
        if _address is not None:
            leaves.append(f'{self_name}.address = {repr(_address)}')
        _port = self.port
        if _port is not None:
            leaves.append(f'{self_name}.port = {repr(_port)}')
        _initial_credentials = self.initial_credentials
        for _element in _initial_credentials.elements:
            res.append('')
            res.append("# List /device/address/initial-credentials element: {_element.to_gdata().key_str(['username', 'password', 'key'])}")
            list_elem = f'initial_credentials_element = {self_name}.initial_credentials.create({repr(_element.username)}, {repr(_element.password)}, {repr(_element.key)})'
            res.append(list_elem)
            res.extend(_element.prsrc(f'initial_credentials_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /device/address'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class orchestron_rfs__device__address(yang.adata.MNode):
    elements: list[orchestron_rfs__device__address_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self._name = 'address'
        self.elements = elements

    mut def create(self, name, address):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = orchestron_rfs__device__address_entry(name, address)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_rfs__device__address_entry]:
        if n is not None:
            return [orchestron_rfs__device__address_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_orchestron_rfs__device__address_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_orchestron_rfs__device__address__name, child_name)
    child_address = yang.gdata.from_xml_opt_str(node, 'address')
    yang.gdata.maybe_add(children, 'address', from_xml_orchestron_rfs__device__address__address, child_address)
    child_port = yang.gdata.from_xml_opt_str(node, 'port')
    yang.gdata.maybe_add(children, 'port', from_xml_orchestron_rfs__device__address__port, child_port)
    child_initial_credentials = yang.gdata.from_xml_opt_list(node, 'initial-credentials')
    yang.gdata.maybe_add(children, 'initial-credentials', from_xml_orchestron_rfs__device__address__initial_credentials, child_initial_credentials)
    return yang.gdata.Container(children)

mut def from_xml_orchestron_rfs__device__address(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_orchestron_rfs__device__address_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_json_path_orchestron_rfs__device__address_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_orchestron_rfs__device__address_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['name']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_orchestron_rfs__device__address__name(keys[0])
        if point == 'address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'initial-credentials':
            children['initial-credentials'] = from_json_path_orchestron_rfs__device__address__initial_credentials(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_orchestron_rfs__device__address(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_orchestron_rfs__device__address_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['name'])))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_orchestron_rfs__device__address_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_orchestron_rfs__device__address_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_orchestron_rfs__device__address__name, child_name)
    child_address = yang.gdata.take_json_opt_str(jd, 'address')
    yang.gdata.maybe_add(children, 'address', from_json_orchestron_rfs__device__address__address, child_address)
    child_port = yang.gdata.take_json_opt_str(jd, 'port')
    yang.gdata.maybe_add(children, 'port', from_json_orchestron_rfs__device__address__port, child_port)
    child_initial_credentials = yang.gdata.take_json_opt_list(jd, 'initial-credentials')
    yang.gdata.maybe_add(children, 'initial-credentials', from_json_orchestron_rfs__device__address__initial_credentials, child_initial_credentials)
    return yang.gdata.Container(children)

mut def from_json_orchestron_rfs__device__address(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_orchestron_rfs__device__address_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_json_orchestron_rfs__device__credentials__username(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__credentials__username(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__device__credentials__password(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__credentials__password(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__device__credentials__key__key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__credentials__key__key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__device__credentials__key__private_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__credentials__key__private_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class orchestron_rfs__device__credentials__key_entry(yang.adata.MNode):
    key: str
    private_key: ?str

    mut def __init__(self, key: str, private_key: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self.key = key
        self.private_key = private_key

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _key = self.key
        if _key is not None:
            children['key'] = yang.gdata.Leaf('string', _key)
        _private_key = self.private_key
        if _private_key is not None:
            children['private-key'] = yang.gdata.Leaf('string', _private_key)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_rfs__device__credentials__key_entry:
        return orchestron_rfs__device__credentials__key_entry(key=n.get_str('key'), private_key=n.get_opt_str('private-key'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /device/credentials/key')
            res.append(f'{self_name} = orchestron_rfs__device__credentials__key({repr(self.key)})')
        leaves = []
        _private_key = self.private_key
        if _private_key is not None:
            leaves.append(f'{self_name}.private_key = {repr(_private_key)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /device/credentials/key'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class orchestron_rfs__device__credentials__key(yang.adata.MNode):
    elements: list[orchestron_rfs__device__credentials__key_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self._name = 'key'
        self.elements = elements

    mut def create(self, key):
        for e in self.elements:
            match = True
            if e.key != key:
                match = False
                continue
            if match:
                return e

        res = orchestron_rfs__device__credentials__key_entry(key)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['key'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_rfs__device__credentials__key_entry]:
        if n is not None:
            return [orchestron_rfs__device__credentials__key_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_orchestron_rfs__device__credentials__key_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_key = yang.gdata.from_xml_str(node, 'key')
    yang.gdata.maybe_add(children, 'key', from_xml_orchestron_rfs__device__credentials__key__key, child_key)
    child_private_key = yang.gdata.from_xml_opt_str(node, 'private-key')
    yang.gdata.maybe_add(children, 'private-key', from_xml_orchestron_rfs__device__credentials__key__private_key, child_private_key)
    return yang.gdata.Container(children)

mut def from_xml_orchestron_rfs__device__credentials__key(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_orchestron_rfs__device__credentials__key_element(e) for e in nodes]
    return yang.gdata.List(keys=['key'], elements=elements)

mut def from_json_path_orchestron_rfs__device__credentials__key_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_orchestron_rfs__device__credentials__key_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['key']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['key'] = from_json_orchestron_rfs__device__credentials__key__key(keys[0])
        if point == 'private-key':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_orchestron_rfs__device__credentials__key(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['key']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_orchestron_rfs__device__credentials__key_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['key'])))
        return yang.gdata.List(['key'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['key'], [from_json_path_orchestron_rfs__device__credentials__key_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_orchestron_rfs__device__credentials__key_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_key = yang.gdata.take_json_str(jd, 'key')
    yang.gdata.maybe_add(children, 'key', from_json_orchestron_rfs__device__credentials__key__key, child_key)
    child_private_key = yang.gdata.take_json_opt_str(jd, 'private-key')
    yang.gdata.maybe_add(children, 'private-key', from_json_orchestron_rfs__device__credentials__key__private_key, child_private_key)
    return yang.gdata.Container(children)

mut def from_json_orchestron_rfs__device__credentials__key(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_orchestron_rfs__device__credentials__key_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['key'], elements=elements)

class orchestron_rfs__device__credentials(yang.adata.MNode):
    username: ?str
    password: ?str
    key: orchestron_rfs__device__credentials__key

    mut def __init__(self, username: ?str, password: ?str, key: list[orchestron_rfs__device__credentials__key_entry]=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self.username = username
        self.password = password
        self.key = orchestron_rfs__device__credentials__key(elements=key)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _username = self.username
        if _username is not None:
            children['username'] = yang.gdata.Leaf('string', _username)
        _password = self.password
        if _password is not None:
            children['password'] = yang.gdata.Leaf('string', _password)
        _key = self.key
        if _key is not None:
            children['key'] = _key.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> orchestron_rfs__device__credentials:
        if n != None:
            return orchestron_rfs__device__credentials(username=n.get_opt_str('username'), password=n.get_opt_str('password'), key=orchestron_rfs__device__credentials__key.from_gdata(n.get_opt_list('key')))
        raise ValueError('Missing required subtree orchestron_rfs__device__credentials')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /device/credentials')
            res.append(f'{self_name} = orchestron_rfs__device__credentials()')
        leaves = []
        _username = self.username
        if _username is not None:
            leaves.append(f'{self_name}.username = {repr(_username)}')
        _password = self.password
        if _password is not None:
            leaves.append(f'{self_name}.password = {repr(_password)}')
        _key = self.key
        for _element in _key.elements:
            res.append('')
            res.append("# List /device/credentials/key element: {_element.to_gdata().key_str(['key'])}")
            list_elem = f'key_element = {self_name}.key.create({repr(_element.key)})'
            res.append(list_elem)
            res.extend(_element.prsrc(f'key_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /device/credentials'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_orchestron_rfs__device__credentials(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_username = yang.gdata.from_xml_opt_str(node, 'username')
    yang.gdata.maybe_add(children, 'username', from_xml_orchestron_rfs__device__credentials__username, child_username)
    child_password = yang.gdata.from_xml_opt_str(node, 'password')
    yang.gdata.maybe_add(children, 'password', from_xml_orchestron_rfs__device__credentials__password, child_password)
    child_key = yang.gdata.from_xml_opt_list(node, 'key')
    yang.gdata.maybe_add(children, 'key', from_xml_orchestron_rfs__device__credentials__key, child_key)
    return yang.gdata.Container(children)

mut def from_json_path_orchestron_rfs__device__credentials(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'username':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'password':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'key':
            child = {'key': from_json_path_orchestron_rfs__device__credentials__key(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_orchestron_rfs__device__credentials(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_orchestron_rfs__device__credentials(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_username = yang.gdata.take_json_opt_str(jd, 'username')
    yang.gdata.maybe_add(children, 'username', from_json_orchestron_rfs__device__credentials__username, child_username)
    child_password = yang.gdata.take_json_opt_str(jd, 'password')
    yang.gdata.maybe_add(children, 'password', from_json_orchestron_rfs__device__credentials__password, child_password)
    child_key = yang.gdata.take_json_opt_list(jd, 'key')
    yang.gdata.maybe_add(children, 'key', from_json_orchestron_rfs__device__credentials__key, child_key)
    return yang.gdata.Container(children)

mut def from_json_orchestron_rfs__device__initial_credentials__username(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__initial_credentials__username(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__device__initial_credentials__password(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__initial_credentials__password(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__device__initial_credentials__key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__initial_credentials__key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class orchestron_rfs__device__initial_credentials_entry(yang.adata.MNode):
    username: str
    password: str
    key: str

    mut def __init__(self, username: str, password: str, key: str):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self.username = username
        self.password = password
        self.key = key

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _username = self.username
        if _username is not None:
            children['username'] = yang.gdata.Leaf('string', _username)
        _password = self.password
        if _password is not None:
            children['password'] = yang.gdata.Leaf('string', _password)
        _key = self.key
        if _key is not None:
            children['key'] = yang.gdata.Leaf('string', _key)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_rfs__device__initial_credentials_entry:
        return orchestron_rfs__device__initial_credentials_entry(username=n.get_str('username'), password=n.get_str('password'), key=n.get_str('key'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /device/initial-credentials')
            res.append(f'{self_name} = orchestron_rfs__device__initial_credentials({repr(self.username)}, {repr(self.password)}, {repr(self.key)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /device/initial-credentials'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class orchestron_rfs__device__initial_credentials(yang.adata.MNode):
    elements: list[orchestron_rfs__device__initial_credentials_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self._name = 'initial-credentials'
        self.elements = elements

    mut def create(self, username, password, key):
        for e in self.elements:
            match = True
            if e.username != username:
                match = False
                continue
            if e.password != password:
                match = False
                continue
            if e.key != key:
                match = False
                continue
            if match:
                return e

        res = orchestron_rfs__device__initial_credentials_entry(username, password, key)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['username', 'password', 'key'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_rfs__device__initial_credentials_entry]:
        if n is not None:
            return [orchestron_rfs__device__initial_credentials_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_orchestron_rfs__device__initial_credentials_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_username = yang.gdata.from_xml_str(node, 'username')
    yang.gdata.maybe_add(children, 'username', from_xml_orchestron_rfs__device__initial_credentials__username, child_username)
    child_password = yang.gdata.from_xml_str(node, 'password')
    yang.gdata.maybe_add(children, 'password', from_xml_orchestron_rfs__device__initial_credentials__password, child_password)
    child_key = yang.gdata.from_xml_str(node, 'key')
    yang.gdata.maybe_add(children, 'key', from_xml_orchestron_rfs__device__initial_credentials__key, child_key)
    return yang.gdata.Container(children)

mut def from_xml_orchestron_rfs__device__initial_credentials(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_orchestron_rfs__device__initial_credentials_element(e) for e in nodes]
    return yang.gdata.List(keys=['username', 'password', 'key'], elements=elements)

mut def from_json_path_orchestron_rfs__device__initial_credentials_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_orchestron_rfs__device__initial_credentials_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['username', 'password', 'key']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['username'] = from_json_orchestron_rfs__device__initial_credentials__username(keys[0])
        children['password'] = from_json_orchestron_rfs__device__initial_credentials__password(keys[1])
        children['key'] = from_json_orchestron_rfs__device__initial_credentials__key(keys[2])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_orchestron_rfs__device__initial_credentials(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['username', 'password', 'key']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_orchestron_rfs__device__initial_credentials_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['username', 'password', 'key'])))
        return yang.gdata.List(['username', 'password', 'key'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['username', 'password', 'key'], [from_json_path_orchestron_rfs__device__initial_credentials_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_orchestron_rfs__device__initial_credentials_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_username = yang.gdata.take_json_str(jd, 'username')
    yang.gdata.maybe_add(children, 'username', from_json_orchestron_rfs__device__initial_credentials__username, child_username)
    child_password = yang.gdata.take_json_str(jd, 'password')
    yang.gdata.maybe_add(children, 'password', from_json_orchestron_rfs__device__initial_credentials__password, child_password)
    child_key = yang.gdata.take_json_str(jd, 'key')
    yang.gdata.maybe_add(children, 'key', from_json_orchestron_rfs__device__initial_credentials__key, child_key)
    return yang.gdata.Container(children)

mut def from_json_orchestron_rfs__device__initial_credentials(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_orchestron_rfs__device__initial_credentials_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['username', 'password', 'key'], elements=elements)

mut def from_json_orchestron_rfs__device__mock__preset(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_orchestron_rfs__device__mock__preset(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_json_orchestron_rfs__device__mock__module__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__mock__module__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__device__mock__module__namespace(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__mock__module__namespace(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__device__mock__module__revision(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__device__mock__module__revision(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__device__mock__module__feature(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_orchestron_rfs__device__mock__module__feature(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

class orchestron_rfs__device__mock__module_entry(yang.adata.MNode):
    name: str
    namespace: ?str
    revision: ?str
    feature: list[str]

    mut def __init__(self, name: str, namespace: ?str, revision: ?str, feature: ?list[str]=None):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self.name = name
        self.namespace = namespace
        self.revision = revision
        self.feature = feature if feature is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _namespace = self.namespace
        if _namespace is not None:
            children['namespace'] = yang.gdata.Leaf('string', _namespace)
        _revision = self.revision
        if _revision is not None:
            children['revision'] = yang.gdata.Leaf('string', _revision)
        children['feature'] = yang.gdata.LeafList('string', self.feature)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_rfs__device__mock__module_entry:
        return orchestron_rfs__device__mock__module_entry(name=n.get_str('name'), namespace=n.get_opt_str('namespace'), revision=n.get_opt_str('revision'), feature=n.get_opt_strs('feature'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /device/mock/module')
            res.append(f'{self_name} = orchestron_rfs__device__mock__module({repr(self.name)})')
        leaves = []
        _namespace = self.namespace
        if _namespace is not None:
            leaves.append(f'{self_name}.namespace = {repr(_namespace)}')
        _revision = self.revision
        if _revision is not None:
            leaves.append(f'{self_name}.revision = {repr(_revision)}')
        _feature = self.feature
        if _feature is not None:
            leaves.append(f'{self_name}.feature = {repr(_feature)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /device/mock/module'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class orchestron_rfs__device__mock__module(yang.adata.MNode):
    elements: list[orchestron_rfs__device__mock__module_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self._name = 'module'
        self.elements = elements

    mut def create(self, name, namespace):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = orchestron_rfs__device__mock__module_entry(name, namespace)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_rfs__device__mock__module_entry]:
        if n is not None:
            return [orchestron_rfs__device__mock__module_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_orchestron_rfs__device__mock__module_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_orchestron_rfs__device__mock__module__name, child_name)
    child_namespace = yang.gdata.from_xml_opt_str(node, 'namespace')
    yang.gdata.maybe_add(children, 'namespace', from_xml_orchestron_rfs__device__mock__module__namespace, child_namespace)
    child_revision = yang.gdata.from_xml_opt_str(node, 'revision')
    yang.gdata.maybe_add(children, 'revision', from_xml_orchestron_rfs__device__mock__module__revision, child_revision)
    child_feature = yang.gdata.from_xml_opt_strs(node, 'feature')
    yang.gdata.maybe_add(children, 'feature', from_xml_orchestron_rfs__device__mock__module__feature, child_feature)
    return yang.gdata.Container(children)

mut def from_xml_orchestron_rfs__device__mock__module(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_orchestron_rfs__device__mock__module_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_json_path_orchestron_rfs__device__mock__module_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_orchestron_rfs__device__mock__module_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['name']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_orchestron_rfs__device__mock__module__name(keys[0])
        if point == 'namespace':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'revision':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'feature':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_orchestron_rfs__device__mock__module(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_orchestron_rfs__device__mock__module_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['name'])))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_orchestron_rfs__device__mock__module_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_orchestron_rfs__device__mock__module_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_orchestron_rfs__device__mock__module__name, child_name)
    child_namespace = yang.gdata.take_json_opt_str(jd, 'namespace')
    yang.gdata.maybe_add(children, 'namespace', from_json_orchestron_rfs__device__mock__module__namespace, child_namespace)
    child_revision = yang.gdata.take_json_opt_str(jd, 'revision')
    yang.gdata.maybe_add(children, 'revision', from_json_orchestron_rfs__device__mock__module__revision, child_revision)
    child_feature = yang.gdata.take_json_opt_strs(jd, 'feature')
    yang.gdata.maybe_add(children, 'feature', from_json_orchestron_rfs__device__mock__module__feature, child_feature)
    return yang.gdata.Container(children)

mut def from_json_orchestron_rfs__device__mock__module(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_orchestron_rfs__device__mock__module_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['name'], elements=elements)

class orchestron_rfs__device__mock(yang.adata.MNode):
    preset: list[str]
    module: orchestron_rfs__device__mock__module

    mut def __init__(self, preset: ?list[str]=None, module: list[orchestron_rfs__device__mock__module_entry]=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self.preset = preset if preset is not None else []
        self.module = orchestron_rfs__device__mock__module(elements=module)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        children['preset'] = yang.gdata.LeafList('enumeration', self.preset)
        _module = self.module
        if _module is not None:
            children['module'] = _module.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> orchestron_rfs__device__mock:
        if n != None:
            return orchestron_rfs__device__mock(preset=n.get_opt_strs('preset'), module=orchestron_rfs__device__mock__module.from_gdata(n.get_opt_list('module')))
        return orchestron_rfs__device__mock()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /device/mock')
            res.append(f'{self_name} = orchestron_rfs__device__mock()')
        leaves = []
        _preset = self.preset
        if _preset is not None:
            leaves.append(f'{self_name}.preset = {repr(_preset)}')
        _module = self.module
        for _element in _module.elements:
            res.append('')
            res.append("# List /device/mock/module element: {_element.to_gdata().key_str(['name'])}")
            list_elem = f'module_element = {self_name}.module.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc(f'module_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /device/mock'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_orchestron_rfs__device__mock(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_preset = yang.gdata.from_xml_opt_strs(node, 'preset')
    yang.gdata.maybe_add(children, 'preset', from_xml_orchestron_rfs__device__mock__preset, child_preset)
    child_module = yang.gdata.from_xml_opt_list(node, 'module')
    yang.gdata.maybe_add(children, 'module', from_xml_orchestron_rfs__device__mock__module, child_module)
    return yang.gdata.Container(children)

mut def from_json_path_orchestron_rfs__device__mock(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'preset':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'module':
            child = {'module': from_json_path_orchestron_rfs__device__mock__module(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_orchestron_rfs__device__mock(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_orchestron_rfs__device__mock(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_preset = yang.gdata.take_json_opt_strs(jd, 'preset')
    yang.gdata.maybe_add(children, 'preset', from_json_orchestron_rfs__device__mock__preset, child_preset)
    child_module = yang.gdata.take_json_opt_list(jd, 'module')
    yang.gdata.maybe_add(children, 'module', from_json_orchestron_rfs__device__mock__module, child_module)
    return yang.gdata.Container(children)

class orchestron_rfs__device_entry(yang.adata.MNode):
    name: str
    description: ?str
    type: ?str
    address: orchestron_rfs__device__address
    credentials: orchestron_rfs__device__credentials
    initial_credentials: orchestron_rfs__device__initial_credentials
    mock: orchestron_rfs__device__mock

    mut def __init__(self, name: str, description: ?str, type: ?str, address: list[orchestron_rfs__device__address_entry]=[], credentials: ?orchestron_rfs__device__credentials=None, initial_credentials: list[orchestron_rfs__device__initial_credentials_entry]=[], mock: ?orchestron_rfs__device__mock=None):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self.name = name
        self.description = description
        self.type = type
        self.address = orchestron_rfs__device__address(elements=address)
        self.credentials = credentials if credentials is not None else orchestron_rfs__device__credentials()
        self.initial_credentials = orchestron_rfs__device__initial_credentials(elements=initial_credentials)
        self.mock = mock if mock is not None else orchestron_rfs__device__mock()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        _type = self.type
        if _type is not None:
            children['type'] = yang.gdata.Leaf('string', _type)
        _address = self.address
        if _address is not None:
            children['address'] = _address.to_gdata()
        _credentials = self.credentials
        if _credentials is not None:
            children['credentials'] = _credentials.to_gdata()
        _initial_credentials = self.initial_credentials
        if _initial_credentials is not None:
            children['initial-credentials'] = _initial_credentials.to_gdata()
        _mock = self.mock
        if _mock is not None:
            children['mock'] = _mock.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_rfs__device_entry:
        return orchestron_rfs__device_entry(name=n.get_str('name'), description=n.get_opt_str('description'), type=n.get_opt_str('type'), address=orchestron_rfs__device__address.from_gdata(n.get_opt_list('address')), credentials=orchestron_rfs__device__credentials.from_gdata(n.get_opt_container('credentials')), initial_credentials=orchestron_rfs__device__initial_credentials.from_gdata(n.get_opt_list('initial-credentials')), mock=orchestron_rfs__device__mock.from_gdata(n.get_opt_container('mock')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /device')
            res.append(f'{self_name} = orchestron_rfs__device({repr(self.name)})')
        leaves = []
        _description = self.description
        if _description is not None:
            leaves.append(f'{self_name}.description = {repr(_description)}')
        _type = self.type
        if _type is not None:
            leaves.append(f'{self_name}.type = {repr(_type)}')
        _address = self.address
        for _element in _address.elements:
            res.append('')
            res.append("# List /device/address element: {_element.to_gdata().key_str(['name'])}")
            list_elem = f'address_element = {self_name}.address.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc(f'address_element', False, list_element=True).splitlines())
        _credentials = self.credentials
        if _credentials is not None:
            res.extend(_credentials.prsrc(f'{self_name}.credentials', False).splitlines())
        _initial_credentials = self.initial_credentials
        for _element in _initial_credentials.elements:
            res.append('')
            res.append("# List /device/initial-credentials element: {_element.to_gdata().key_str(['username', 'password', 'key'])}")
            list_elem = f'initial_credentials_element = {self_name}.initial_credentials.create({repr(_element.username)}, {repr(_element.password)}, {repr(_element.key)})'
            res.append(list_elem)
            res.extend(_element.prsrc(f'initial_credentials_element', False, list_element=True).splitlines())
        _mock = self.mock
        if _mock is not None:
            res.extend(_mock.prsrc(f'{self_name}.mock', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /device'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class orchestron_rfs__device(yang.adata.MNode):
    elements: list[orchestron_rfs__device_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self._name = 'device'
        self.elements = elements

    mut def create(self, name):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = orchestron_rfs__device_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements, ns='http://orchestron.org/yang/orchestron-rfs.yang', module='orchestron-rfs')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_rfs__device_entry]:
        if n is not None:
            return [orchestron_rfs__device_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_orchestron_rfs__device_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_orchestron_rfs__device__name, child_name)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_xml_orchestron_rfs__device__description, child_description)
    child_type = yang.gdata.from_xml_opt_str(node, 'type')
    yang.gdata.maybe_add(children, 'type', from_xml_orchestron_rfs__device__type, child_type)
    child_address = yang.gdata.from_xml_opt_list(node, 'address')
    yang.gdata.maybe_add(children, 'address', from_xml_orchestron_rfs__device__address, child_address)
    child_credentials = yang.gdata.from_xml_opt_cnt(node, 'credentials')
    yang.gdata.maybe_add(children, 'credentials', from_xml_orchestron_rfs__device__credentials, child_credentials)
    child_initial_credentials = yang.gdata.from_xml_opt_list(node, 'initial-credentials')
    yang.gdata.maybe_add(children, 'initial-credentials', from_xml_orchestron_rfs__device__initial_credentials, child_initial_credentials)
    child_mock = yang.gdata.from_xml_opt_cnt(node, 'mock')
    yang.gdata.maybe_add(children, 'mock', from_xml_orchestron_rfs__device__mock, child_mock)
    return yang.gdata.Container(children)

mut def from_xml_orchestron_rfs__device(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_orchestron_rfs__device_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements, ns='http://orchestron.org/yang/orchestron-rfs.yang', module='orchestron-rfs')

mut def from_json_path_orchestron_rfs__device_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_orchestron_rfs__device_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['name']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_orchestron_rfs__device__name(keys[0])
        if point == 'description':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'address':
            children['address'] = from_json_path_orchestron_rfs__device__address(jd, rest_path, op)
        if point == 'credentials':
            children['credentials'] = from_json_path_orchestron_rfs__device__credentials(jd, rest_path, op)
        if point == 'initial-credentials':
            children['initial-credentials'] = from_json_path_orchestron_rfs__device__initial_credentials(jd, rest_path, op)
        if point == 'mock':
            children['mock'] = from_json_path_orchestron_rfs__device__mock(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_orchestron_rfs__device(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_orchestron_rfs__device_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['name'])))
        return yang.gdata.List(['name'], elements, ns='http://orchestron.org/yang/orchestron-rfs.yang', module='orchestron-rfs')
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_orchestron_rfs__device_element(jd, path, op)], ns='http://orchestron.org/yang/orchestron-rfs.yang', module='orchestron-rfs')
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_orchestron_rfs__device_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_orchestron_rfs__device__name, child_name)
    child_description = yang.gdata.take_json_opt_str(jd, 'description')
    yang.gdata.maybe_add(children, 'description', from_json_orchestron_rfs__device__description, child_description)
    child_type = yang.gdata.take_json_opt_str(jd, 'type')
    yang.gdata.maybe_add(children, 'type', from_json_orchestron_rfs__device__type, child_type)
    child_address = yang.gdata.take_json_opt_list(jd, 'address')
    yang.gdata.maybe_add(children, 'address', from_json_orchestron_rfs__device__address, child_address)
    child_credentials = yang.gdata.take_json_opt_cnt(jd, 'credentials')
    yang.gdata.maybe_add(children, 'credentials', from_json_orchestron_rfs__device__credentials, child_credentials)
    child_initial_credentials = yang.gdata.take_json_opt_list(jd, 'initial-credentials')
    yang.gdata.maybe_add(children, 'initial-credentials', from_json_orchestron_rfs__device__initial_credentials, child_initial_credentials)
    child_mock = yang.gdata.take_json_opt_cnt(jd, 'mock')
    yang.gdata.maybe_add(children, 'mock', from_json_orchestron_rfs__device__mock, child_mock)
    return yang.gdata.Container(children)

mut def from_json_orchestron_rfs__device(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_orchestron_rfs__device_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['name'], elements=elements, ns='http://orchestron.org/yang/orchestron-rfs.yang', module='orchestron-rfs')

mut def from_json_orchestron_rfs__rfs__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__base_config__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__base_config__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__base_config__ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__base_config__ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__base_config__ipv6_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__base_config__ipv6_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__base_config__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_orchestron_rfs__rfs__base_config__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_orchestron_rfs__rfs__base_config__ibgp_authentication_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__base_config__ibgp_authentication_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class orchestron_rfs__rfs__base_config_entry(yang.adata.MNode):
    name: str
    ipv4_address: ?str
    ipv6_address: ?str
    asn: ?int
    ibgp_authentication_key: ?str

    mut def __init__(self, name: str, ipv4_address: ?str, ipv6_address: ?str, asn: ?int, ibgp_authentication_key: ?str):
        self._ns = 'http://example.com/respnet-rfs'
        self.name = name
        self.ipv4_address = ipv4_address
        self.ipv6_address = ipv6_address
        self.asn = asn
        self.ibgp_authentication_key = ibgp_authentication_key

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _ipv4_address = self.ipv4_address
        if _ipv4_address is not None:
            children['ipv4-address'] = yang.gdata.Leaf('string', _ipv4_address)
        _ipv6_address = self.ipv6_address
        if _ipv6_address is not None:
            children['ipv6-address'] = yang.gdata.Leaf('string', _ipv6_address)
        _asn = self.asn
        if _asn is not None:
            children['asn'] = yang.gdata.Leaf('uint32', _asn)
        _ibgp_authentication_key = self.ibgp_authentication_key
        if _ibgp_authentication_key is not None:
            children['ibgp-authentication-key'] = yang.gdata.Leaf('string', _ibgp_authentication_key)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_rfs__rfs__base_config_entry:
        return orchestron_rfs__rfs__base_config_entry(name=n.get_str('name'), ipv4_address=n.get_opt_str('ipv4-address'), ipv6_address=n.get_opt_str('ipv6-address'), asn=n.get_opt_int('asn'), ibgp_authentication_key=n.get_opt_str('ibgp-authentication-key'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /rfs/base-config')
            res.append(f'{self_name} = orchestron_rfs__rfs__base_config({repr(self.name)})')
        leaves = []
        _ipv4_address = self.ipv4_address
        if _ipv4_address is not None:
            leaves.append(f'{self_name}.ipv4_address = {repr(_ipv4_address)}')
        _ipv6_address = self.ipv6_address
        if _ipv6_address is not None:
            leaves.append(f'{self_name}.ipv6_address = {repr(_ipv6_address)}')
        _asn = self.asn
        if _asn is not None:
            leaves.append(f'{self_name}.asn = {repr(_asn)}')
        _ibgp_authentication_key = self.ibgp_authentication_key
        if _ibgp_authentication_key is not None:
            leaves.append(f'{self_name}.ibgp_authentication_key = {repr(_ibgp_authentication_key)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /rfs/base-config'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class orchestron_rfs__rfs__base_config(yang.adata.MNode):
    elements: list[orchestron_rfs__rfs__base_config_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/respnet-rfs'
        self._name = 'base-config'
        self.elements = elements

    mut def create(self, name, ipv4_address, ipv6_address, asn, ibgp_authentication_key):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = orchestron_rfs__rfs__base_config_entry(name, ipv4_address, ipv6_address, asn, ibgp_authentication_key)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_rfs__rfs__base_config_entry]:
        if n is not None:
            return [orchestron_rfs__rfs__base_config_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_orchestron_rfs__rfs__base_config_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_orchestron_rfs__rfs__base_config__name, child_name)
    child_ipv4_address = yang.gdata.from_xml_opt_str(node, 'ipv4-address')
    yang.gdata.maybe_add(children, 'ipv4-address', from_xml_orchestron_rfs__rfs__base_config__ipv4_address, child_ipv4_address)
    child_ipv6_address = yang.gdata.from_xml_opt_str(node, 'ipv6-address')
    yang.gdata.maybe_add(children, 'ipv6-address', from_xml_orchestron_rfs__rfs__base_config__ipv6_address, child_ipv6_address)
    child_asn = yang.gdata.from_xml_opt_int(node, 'asn')
    yang.gdata.maybe_add(children, 'asn', from_xml_orchestron_rfs__rfs__base_config__asn, child_asn)
    child_ibgp_authentication_key = yang.gdata.from_xml_opt_str(node, 'ibgp-authentication-key')
    yang.gdata.maybe_add(children, 'ibgp-authentication-key', from_xml_orchestron_rfs__rfs__base_config__ibgp_authentication_key, child_ibgp_authentication_key)
    return yang.gdata.Container(children)

mut def from_xml_orchestron_rfs__rfs__base_config(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_orchestron_rfs__rfs__base_config_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

mut def from_json_path_orchestron_rfs__rfs__base_config_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_orchestron_rfs__rfs__base_config_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['name']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_orchestron_rfs__rfs__base_config__name(keys[0])
        if point == 'ipv4-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'asn':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ibgp-authentication-key':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_orchestron_rfs__rfs__base_config(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_orchestron_rfs__rfs__base_config_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['name'])))
        return yang.gdata.List(['name'], elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_orchestron_rfs__rfs__base_config_element(jd, path, op)], ns='http://example.com/respnet-rfs', module='respnet-rfs')
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_orchestron_rfs__rfs__base_config_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_orchestron_rfs__rfs__base_config__name, child_name)
    child_ipv4_address = yang.gdata.take_json_opt_str(jd, 'ipv4-address')
    yang.gdata.maybe_add(children, 'ipv4-address', from_json_orchestron_rfs__rfs__base_config__ipv4_address, child_ipv4_address)
    child_ipv6_address = yang.gdata.take_json_opt_str(jd, 'ipv6-address')
    yang.gdata.maybe_add(children, 'ipv6-address', from_json_orchestron_rfs__rfs__base_config__ipv6_address, child_ipv6_address)
    child_asn = yang.gdata.take_json_opt_int(jd, 'asn')
    yang.gdata.maybe_add(children, 'asn', from_json_orchestron_rfs__rfs__base_config__asn, child_asn)
    child_ibgp_authentication_key = yang.gdata.take_json_opt_str(jd, 'ibgp-authentication-key')
    yang.gdata.maybe_add(children, 'ibgp-authentication-key', from_json_orchestron_rfs__rfs__base_config__ibgp_authentication_key, child_ibgp_authentication_key)
    return yang.gdata.Container(children)

mut def from_json_orchestron_rfs__rfs__base_config(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_orchestron_rfs__rfs__base_config_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['name'], elements=elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

mut def from_json_orchestron_rfs__rfs__backbone_interface__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__backbone_interface__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__backbone_interface__ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__backbone_interface__ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__backbone_interface__ipv4_prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_orchestron_rfs__rfs__backbone_interface__ipv4_prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_orchestron_rfs__rfs__backbone_interface__ipv6_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__backbone_interface__ipv6_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__backbone_interface__ipv6_prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_orchestron_rfs__rfs__backbone_interface__ipv6_prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_orchestron_rfs__rfs__backbone_interface__remote__device(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__backbone_interface__remote__device(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__backbone_interface__remote__interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__backbone_interface__remote__interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class orchestron_rfs__rfs__backbone_interface__remote(yang.adata.MNode):
    device: ?str
    interface: ?str

    mut def __init__(self, device: ?str, interface: ?str):
        self._ns = 'http://example.com/respnet-rfs'
        self.device = device
        self.interface = interface

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _device = self.device
        if _device is not None:
            children['device'] = yang.gdata.Leaf('string', _device)
        _interface = self.interface
        if _interface is not None:
            children['interface'] = yang.gdata.Leaf('string', _interface)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> orchestron_rfs__rfs__backbone_interface__remote:
        if n != None:
            return orchestron_rfs__rfs__backbone_interface__remote(device=n.get_opt_str('device'), interface=n.get_opt_str('interface'))
        raise ValueError('Missing required subtree orchestron_rfs__rfs__backbone_interface__remote')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /rfs/backbone-interface/remote')
            res.append(f'{self_name} = orchestron_rfs__rfs__backbone_interface__remote()')
        leaves = []
        _device = self.device
        if _device is not None:
            leaves.append(f'{self_name}.device = {repr(_device)}')
        _interface = self.interface
        if _interface is not None:
            leaves.append(f'{self_name}.interface = {repr(_interface)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /rfs/backbone-interface/remote'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_orchestron_rfs__rfs__backbone_interface__remote(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_device = yang.gdata.from_xml_opt_str(node, 'device')
    yang.gdata.maybe_add(children, 'device', from_xml_orchestron_rfs__rfs__backbone_interface__remote__device, child_device)
    child_interface = yang.gdata.from_xml_opt_str(node, 'interface')
    yang.gdata.maybe_add(children, 'interface', from_xml_orchestron_rfs__rfs__backbone_interface__remote__interface, child_interface)
    return yang.gdata.Container(children)

mut def from_json_path_orchestron_rfs__rfs__backbone_interface__remote(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'device':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'interface':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_orchestron_rfs__rfs__backbone_interface__remote(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_orchestron_rfs__rfs__backbone_interface__remote(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_device = yang.gdata.take_json_opt_str(jd, 'device')
    yang.gdata.maybe_add(children, 'device', from_json_orchestron_rfs__rfs__backbone_interface__remote__device, child_device)
    child_interface = yang.gdata.take_json_opt_str(jd, 'interface')
    yang.gdata.maybe_add(children, 'interface', from_json_orchestron_rfs__rfs__backbone_interface__remote__interface, child_interface)
    return yang.gdata.Container(children)

class orchestron_rfs__rfs__backbone_interface_entry(yang.adata.MNode):
    name: str
    ipv4_address: ?str
    ipv4_prefix_length: ?int
    ipv6_address: ?str
    ipv6_prefix_length: ?int
    remote: orchestron_rfs__rfs__backbone_interface__remote

    mut def __init__(self, name: str, ipv4_address: ?str, ipv4_prefix_length: ?int, ipv6_address: ?str, ipv6_prefix_length: ?int, remote: ?orchestron_rfs__rfs__backbone_interface__remote=None):
        self._ns = 'http://example.com/respnet-rfs'
        self.name = name
        self.ipv4_address = ipv4_address
        self.ipv4_prefix_length = ipv4_prefix_length
        self.ipv6_address = ipv6_address
        self.ipv6_prefix_length = ipv6_prefix_length
        self.remote = remote if remote is not None else orchestron_rfs__rfs__backbone_interface__remote()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _ipv4_address = self.ipv4_address
        if _ipv4_address is not None:
            children['ipv4-address'] = yang.gdata.Leaf('string', _ipv4_address)
        _ipv4_prefix_length = self.ipv4_prefix_length
        if _ipv4_prefix_length is not None:
            children['ipv4-prefix-length'] = yang.gdata.Leaf('uint8', _ipv4_prefix_length)
        _ipv6_address = self.ipv6_address
        if _ipv6_address is not None:
            children['ipv6-address'] = yang.gdata.Leaf('string', _ipv6_address)
        _ipv6_prefix_length = self.ipv6_prefix_length
        if _ipv6_prefix_length is not None:
            children['ipv6-prefix-length'] = yang.gdata.Leaf('uint8', _ipv6_prefix_length)
        _remote = self.remote
        if _remote is not None:
            children['remote'] = _remote.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_rfs__rfs__backbone_interface_entry:
        return orchestron_rfs__rfs__backbone_interface_entry(name=n.get_str('name'), ipv4_address=n.get_opt_str('ipv4-address'), ipv4_prefix_length=n.get_opt_int('ipv4-prefix-length'), ipv6_address=n.get_opt_str('ipv6-address'), ipv6_prefix_length=n.get_opt_int('ipv6-prefix-length'), remote=orchestron_rfs__rfs__backbone_interface__remote.from_gdata(n.get_opt_container('remote')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /rfs/backbone-interface')
            res.append(f'{self_name} = orchestron_rfs__rfs__backbone_interface({repr(self.name)})')
        leaves = []
        _ipv4_address = self.ipv4_address
        if _ipv4_address is not None:
            leaves.append(f'{self_name}.ipv4_address = {repr(_ipv4_address)}')
        _ipv4_prefix_length = self.ipv4_prefix_length
        if _ipv4_prefix_length is not None:
            leaves.append(f'{self_name}.ipv4_prefix_length = {repr(_ipv4_prefix_length)}')
        _ipv6_address = self.ipv6_address
        if _ipv6_address is not None:
            leaves.append(f'{self_name}.ipv6_address = {repr(_ipv6_address)}')
        _ipv6_prefix_length = self.ipv6_prefix_length
        if _ipv6_prefix_length is not None:
            leaves.append(f'{self_name}.ipv6_prefix_length = {repr(_ipv6_prefix_length)}')
        _remote = self.remote
        if _remote is not None:
            res.extend(_remote.prsrc(f'{self_name}.remote', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /rfs/backbone-interface'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class orchestron_rfs__rfs__backbone_interface(yang.adata.MNode):
    elements: list[orchestron_rfs__rfs__backbone_interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/respnet-rfs'
        self._name = 'backbone-interface'
        self.elements = elements

    mut def create(self, name):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = orchestron_rfs__rfs__backbone_interface_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_rfs__rfs__backbone_interface_entry]:
        if n is not None:
            return [orchestron_rfs__rfs__backbone_interface_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_orchestron_rfs__rfs__backbone_interface_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_orchestron_rfs__rfs__backbone_interface__name, child_name)
    child_ipv4_address = yang.gdata.from_xml_opt_str(node, 'ipv4-address')
    yang.gdata.maybe_add(children, 'ipv4-address', from_xml_orchestron_rfs__rfs__backbone_interface__ipv4_address, child_ipv4_address)
    child_ipv4_prefix_length = yang.gdata.from_xml_opt_int(node, 'ipv4-prefix-length')
    yang.gdata.maybe_add(children, 'ipv4-prefix-length', from_xml_orchestron_rfs__rfs__backbone_interface__ipv4_prefix_length, child_ipv4_prefix_length)
    child_ipv6_address = yang.gdata.from_xml_opt_str(node, 'ipv6-address')
    yang.gdata.maybe_add(children, 'ipv6-address', from_xml_orchestron_rfs__rfs__backbone_interface__ipv6_address, child_ipv6_address)
    child_ipv6_prefix_length = yang.gdata.from_xml_opt_int(node, 'ipv6-prefix-length')
    yang.gdata.maybe_add(children, 'ipv6-prefix-length', from_xml_orchestron_rfs__rfs__backbone_interface__ipv6_prefix_length, child_ipv6_prefix_length)
    child_remote = yang.gdata.from_xml_opt_cnt(node, 'remote')
    yang.gdata.maybe_add(children, 'remote', from_xml_orchestron_rfs__rfs__backbone_interface__remote, child_remote)
    return yang.gdata.Container(children)

mut def from_xml_orchestron_rfs__rfs__backbone_interface(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_orchestron_rfs__rfs__backbone_interface_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

mut def from_json_path_orchestron_rfs__rfs__backbone_interface_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_orchestron_rfs__rfs__backbone_interface_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['name']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_orchestron_rfs__rfs__backbone_interface__name(keys[0])
        if point == 'ipv4-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'remote':
            children['remote'] = from_json_path_orchestron_rfs__rfs__backbone_interface__remote(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_orchestron_rfs__rfs__backbone_interface(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_orchestron_rfs__rfs__backbone_interface_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['name'])))
        return yang.gdata.List(['name'], elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_orchestron_rfs__rfs__backbone_interface_element(jd, path, op)], ns='http://example.com/respnet-rfs', module='respnet-rfs')
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_orchestron_rfs__rfs__backbone_interface_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_orchestron_rfs__rfs__backbone_interface__name, child_name)
    child_ipv4_address = yang.gdata.take_json_opt_str(jd, 'ipv4-address')
    yang.gdata.maybe_add(children, 'ipv4-address', from_json_orchestron_rfs__rfs__backbone_interface__ipv4_address, child_ipv4_address)
    child_ipv4_prefix_length = yang.gdata.take_json_opt_int(jd, 'ipv4-prefix-length')
    yang.gdata.maybe_add(children, 'ipv4-prefix-length', from_json_orchestron_rfs__rfs__backbone_interface__ipv4_prefix_length, child_ipv4_prefix_length)
    child_ipv6_address = yang.gdata.take_json_opt_str(jd, 'ipv6-address')
    yang.gdata.maybe_add(children, 'ipv6-address', from_json_orchestron_rfs__rfs__backbone_interface__ipv6_address, child_ipv6_address)
    child_ipv6_prefix_length = yang.gdata.take_json_opt_int(jd, 'ipv6-prefix-length')
    yang.gdata.maybe_add(children, 'ipv6-prefix-length', from_json_orchestron_rfs__rfs__backbone_interface__ipv6_prefix_length, child_ipv6_prefix_length)
    child_remote = yang.gdata.take_json_opt_cnt(jd, 'remote')
    yang.gdata.maybe_add(children, 'remote', from_json_orchestron_rfs__rfs__backbone_interface__remote, child_remote)
    return yang.gdata.Container(children)

mut def from_json_orchestron_rfs__rfs__backbone_interface(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_orchestron_rfs__rfs__backbone_interface_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['name'], elements=elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

mut def from_json_orchestron_rfs__rfs__ibgp_neighbor__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_orchestron_rfs__rfs__ibgp_neighbor__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_json_orchestron_rfs__rfs__ibgp_neighbor__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_orchestron_rfs__rfs__ibgp_neighbor__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_orchestron_rfs__rfs__ibgp_neighbor__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__ibgp_neighbor__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class orchestron_rfs__rfs__ibgp_neighbor_entry(yang.adata.MNode):
    address: str
    asn: ?int
    description: ?str

    mut def __init__(self, address: str, asn: ?int, description: ?str):
        self._ns = 'http://example.com/respnet-rfs'
        self.address = address
        self.asn = asn
        self.description = description

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address = self.address
        if _address is not None:
            children['address'] = yang.gdata.Leaf('union', _address)
        _asn = self.asn
        if _asn is not None:
            children['asn'] = yang.gdata.Leaf('uint32', _asn)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_rfs__rfs__ibgp_neighbor_entry:
        return orchestron_rfs__rfs__ibgp_neighbor_entry(address=n.get_str('address'), asn=n.get_opt_int('asn'), description=n.get_opt_str('description'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /rfs/ibgp-neighbor')
            res.append(f'{self_name} = orchestron_rfs__rfs__ibgp_neighbor({repr(self.address)})')
        leaves = []
        _asn = self.asn
        if _asn is not None:
            leaves.append(f'{self_name}.asn = {repr(_asn)}')
        _description = self.description
        if _description is not None:
            leaves.append(f'{self_name}.description = {repr(_description)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /rfs/ibgp-neighbor'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class orchestron_rfs__rfs__ibgp_neighbor(yang.adata.MNode):
    elements: list[orchestron_rfs__rfs__ibgp_neighbor_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/respnet-rfs'
        self._name = 'ibgp-neighbor'
        self.elements = elements

    mut def create(self, address, asn, description):
        for e in self.elements:
            match = True
            if e.address != address:
                match = False
                continue
            if match:
                return e

        res = orchestron_rfs__rfs__ibgp_neighbor_entry(address, asn, description)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['address'], elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_rfs__rfs__ibgp_neighbor_entry]:
        if n is not None:
            return [orchestron_rfs__rfs__ibgp_neighbor_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_orchestron_rfs__rfs__ibgp_neighbor_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_address = yang.gdata.from_xml_str(node, 'address')
    yang.gdata.maybe_add(children, 'address', from_xml_orchestron_rfs__rfs__ibgp_neighbor__address, child_address)
    child_asn = yang.gdata.from_xml_opt_int(node, 'asn')
    yang.gdata.maybe_add(children, 'asn', from_xml_orchestron_rfs__rfs__ibgp_neighbor__asn, child_asn)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_xml_orchestron_rfs__rfs__ibgp_neighbor__description, child_description)
    return yang.gdata.Container(children)

mut def from_xml_orchestron_rfs__rfs__ibgp_neighbor(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_orchestron_rfs__rfs__ibgp_neighbor_element(e) for e in nodes]
    return yang.gdata.List(keys=['address'], elements=elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

mut def from_json_path_orchestron_rfs__rfs__ibgp_neighbor_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_orchestron_rfs__rfs__ibgp_neighbor_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['address']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['address'] = from_json_orchestron_rfs__rfs__ibgp_neighbor__address(keys[0])
        if point == 'asn':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'description':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_orchestron_rfs__rfs__ibgp_neighbor(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['address']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_orchestron_rfs__rfs__ibgp_neighbor_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['address'])))
        return yang.gdata.List(['address'], elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')
    elif len(path) > 1:
        return yang.gdata.List(['address'], [from_json_path_orchestron_rfs__rfs__ibgp_neighbor_element(jd, path, op)], ns='http://example.com/respnet-rfs', module='respnet-rfs')
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_orchestron_rfs__rfs__ibgp_neighbor_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_address = yang.gdata.take_json_str(jd, 'address')
    yang.gdata.maybe_add(children, 'address', from_json_orchestron_rfs__rfs__ibgp_neighbor__address, child_address)
    child_asn = yang.gdata.take_json_opt_int(jd, 'asn')
    yang.gdata.maybe_add(children, 'asn', from_json_orchestron_rfs__rfs__ibgp_neighbor__asn, child_asn)
    child_description = yang.gdata.take_json_opt_str(jd, 'description')
    yang.gdata.maybe_add(children, 'description', from_json_orchestron_rfs__rfs__ibgp_neighbor__description, child_description)
    return yang.gdata.Container(children)

mut def from_json_orchestron_rfs__rfs__ibgp_neighbor(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_orchestron_rfs__rfs__ibgp_neighbor_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['address'], elements=elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

mut def from_json_orchestron_rfs__rfs__vrf__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__vrf__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__vrf__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__vrf__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__vrf__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_orchestron_rfs__rfs__vrf__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_orchestron_rfs__rfs__vrf__router_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_orchestron_rfs__rfs__vrf__router_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_orchestron_rfs__rfs__vrf__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_orchestron_rfs__rfs__vrf__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class orchestron_rfs__rfs__vrf_entry(yang.adata.MNode):
    name: str
    description: ?str
    id: ?int
    router_id: ?int
    asn: ?int

    mut def __init__(self, name: str, description: ?str, id: ?int, router_id: ?int, asn: ?int):
        self._ns = 'http://example.com/respnet-rfs'
        self.name = name
        self.description = description
        self.id = id
        self.router_id = router_id
        self.asn = asn

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint32', _id)
        _router_id = self.router_id
        if _router_id is not None:
            children['router-id'] = yang.gdata.Leaf('uint32', _router_id)
        _asn = self.asn
        if _asn is not None:
            children['asn'] = yang.gdata.Leaf('uint32', _asn)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_rfs__rfs__vrf_entry:
        return orchestron_rfs__rfs__vrf_entry(name=n.get_str('name'), description=n.get_opt_str('description'), id=n.get_opt_int('id'), router_id=n.get_opt_int('router-id'), asn=n.get_opt_int('asn'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /rfs/vrf')
            res.append(f'{self_name} = orchestron_rfs__rfs__vrf({repr(self.name)})')
        leaves = []
        _description = self.description
        if _description is not None:
            leaves.append(f'{self_name}.description = {repr(_description)}')
        _id = self.id
        if _id is not None:
            leaves.append(f'{self_name}.id = {repr(_id)}')
        _router_id = self.router_id
        if _router_id is not None:
            leaves.append(f'{self_name}.router_id = {repr(_router_id)}')
        _asn = self.asn
        if _asn is not None:
            leaves.append(f'{self_name}.asn = {repr(_asn)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /rfs/vrf'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class orchestron_rfs__rfs__vrf(yang.adata.MNode):
    elements: list[orchestron_rfs__rfs__vrf_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/respnet-rfs'
        self._name = 'vrf'
        self.elements = elements

    mut def create(self, name, id, router_id, asn):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = orchestron_rfs__rfs__vrf_entry(name, id, router_id, asn)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_rfs__rfs__vrf_entry]:
        if n is not None:
            return [orchestron_rfs__rfs__vrf_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_orchestron_rfs__rfs__vrf_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_orchestron_rfs__rfs__vrf__name, child_name)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_xml_orchestron_rfs__rfs__vrf__description, child_description)
    child_id = yang.gdata.from_xml_opt_int(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_orchestron_rfs__rfs__vrf__id, child_id)
    child_router_id = yang.gdata.from_xml_opt_int(node, 'router-id')
    yang.gdata.maybe_add(children, 'router-id', from_xml_orchestron_rfs__rfs__vrf__router_id, child_router_id)
    child_asn = yang.gdata.from_xml_opt_int(node, 'asn')
    yang.gdata.maybe_add(children, 'asn', from_xml_orchestron_rfs__rfs__vrf__asn, child_asn)
    return yang.gdata.Container(children)

mut def from_xml_orchestron_rfs__rfs__vrf(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_orchestron_rfs__rfs__vrf_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

mut def from_json_path_orchestron_rfs__rfs__vrf_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_orchestron_rfs__rfs__vrf_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['name']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_orchestron_rfs__rfs__vrf__name(keys[0])
        if point == 'description':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'router-id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'asn':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_orchestron_rfs__rfs__vrf(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_orchestron_rfs__rfs__vrf_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['name'])))
        return yang.gdata.List(['name'], elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_orchestron_rfs__rfs__vrf_element(jd, path, op)], ns='http://example.com/respnet-rfs', module='respnet-rfs')
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_orchestron_rfs__rfs__vrf_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_orchestron_rfs__rfs__vrf__name, child_name)
    child_description = yang.gdata.take_json_opt_str(jd, 'description')
    yang.gdata.maybe_add(children, 'description', from_json_orchestron_rfs__rfs__vrf__description, child_description)
    child_id = yang.gdata.take_json_opt_int(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_orchestron_rfs__rfs__vrf__id, child_id)
    child_router_id = yang.gdata.take_json_opt_int(jd, 'router-id')
    yang.gdata.maybe_add(children, 'router-id', from_json_orchestron_rfs__rfs__vrf__router_id, child_router_id)
    child_asn = yang.gdata.take_json_opt_int(jd, 'asn')
    yang.gdata.maybe_add(children, 'asn', from_json_orchestron_rfs__rfs__vrf__asn, child_asn)
    return yang.gdata.Container(children)

mut def from_json_orchestron_rfs__rfs__vrf(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_orchestron_rfs__rfs__vrf_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['name'], elements=elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

mut def from_json_orchestron_rfs__rfs__vrf_interface__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__vrf_interface__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__vrf_interface__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__vrf_interface__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__vrf_interface__vrf(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__vrf_interface__vrf(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__vrf_interface__ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__vrf_interface__ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__vrf_interface__ipv4_prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_orchestron_rfs__rfs__vrf_interface__ipv4_prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

class orchestron_rfs__rfs__vrf_interface_entry(yang.adata.MNode):
    name: str
    description: ?str
    vrf: ?str
    ipv4_address: ?str
    ipv4_prefix_length: ?int

    mut def __init__(self, name: str, description: ?str, vrf: ?str, ipv4_address: ?str, ipv4_prefix_length: ?int):
        self._ns = 'http://example.com/respnet-rfs'
        self.name = name
        self.description = description
        self.vrf = vrf
        self.ipv4_address = ipv4_address
        self.ipv4_prefix_length = ipv4_prefix_length

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        _vrf = self.vrf
        if _vrf is not None:
            children['vrf'] = yang.gdata.Leaf('string', _vrf)
        _ipv4_address = self.ipv4_address
        if _ipv4_address is not None:
            children['ipv4-address'] = yang.gdata.Leaf('string', _ipv4_address)
        _ipv4_prefix_length = self.ipv4_prefix_length
        if _ipv4_prefix_length is not None:
            children['ipv4-prefix-length'] = yang.gdata.Leaf('uint8', _ipv4_prefix_length)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_rfs__rfs__vrf_interface_entry:
        return orchestron_rfs__rfs__vrf_interface_entry(name=n.get_str('name'), description=n.get_opt_str('description'), vrf=n.get_opt_str('vrf'), ipv4_address=n.get_opt_str('ipv4-address'), ipv4_prefix_length=n.get_opt_int('ipv4-prefix-length'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /rfs/vrf-interface')
            res.append(f'{self_name} = orchestron_rfs__rfs__vrf_interface({repr(self.name)})')
        leaves = []
        _description = self.description
        if _description is not None:
            leaves.append(f'{self_name}.description = {repr(_description)}')
        _vrf = self.vrf
        if _vrf is not None:
            leaves.append(f'{self_name}.vrf = {repr(_vrf)}')
        _ipv4_address = self.ipv4_address
        if _ipv4_address is not None:
            leaves.append(f'{self_name}.ipv4_address = {repr(_ipv4_address)}')
        _ipv4_prefix_length = self.ipv4_prefix_length
        if _ipv4_prefix_length is not None:
            leaves.append(f'{self_name}.ipv4_prefix_length = {repr(_ipv4_prefix_length)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /rfs/vrf-interface'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class orchestron_rfs__rfs__vrf_interface(yang.adata.MNode):
    elements: list[orchestron_rfs__rfs__vrf_interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/respnet-rfs'
        self._name = 'vrf-interface'
        self.elements = elements

    mut def create(self, name, vrf):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = orchestron_rfs__rfs__vrf_interface_entry(name, vrf)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_rfs__rfs__vrf_interface_entry]:
        if n is not None:
            return [orchestron_rfs__rfs__vrf_interface_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_orchestron_rfs__rfs__vrf_interface_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_orchestron_rfs__rfs__vrf_interface__name, child_name)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_xml_orchestron_rfs__rfs__vrf_interface__description, child_description)
    child_vrf = yang.gdata.from_xml_opt_str(node, 'vrf')
    yang.gdata.maybe_add(children, 'vrf', from_xml_orchestron_rfs__rfs__vrf_interface__vrf, child_vrf)
    child_ipv4_address = yang.gdata.from_xml_opt_str(node, 'ipv4-address')
    yang.gdata.maybe_add(children, 'ipv4-address', from_xml_orchestron_rfs__rfs__vrf_interface__ipv4_address, child_ipv4_address)
    child_ipv4_prefix_length = yang.gdata.from_xml_opt_int(node, 'ipv4-prefix-length')
    yang.gdata.maybe_add(children, 'ipv4-prefix-length', from_xml_orchestron_rfs__rfs__vrf_interface__ipv4_prefix_length, child_ipv4_prefix_length)
    return yang.gdata.Container(children)

mut def from_xml_orchestron_rfs__rfs__vrf_interface(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_orchestron_rfs__rfs__vrf_interface_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

mut def from_json_path_orchestron_rfs__rfs__vrf_interface_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_orchestron_rfs__rfs__vrf_interface_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['name']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_orchestron_rfs__rfs__vrf_interface__name(keys[0])
        if point == 'description':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'vrf':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_orchestron_rfs__rfs__vrf_interface(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_orchestron_rfs__rfs__vrf_interface_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['name'])))
        return yang.gdata.List(['name'], elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_orchestron_rfs__rfs__vrf_interface_element(jd, path, op)], ns='http://example.com/respnet-rfs', module='respnet-rfs')
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_orchestron_rfs__rfs__vrf_interface_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_orchestron_rfs__rfs__vrf_interface__name, child_name)
    child_description = yang.gdata.take_json_opt_str(jd, 'description')
    yang.gdata.maybe_add(children, 'description', from_json_orchestron_rfs__rfs__vrf_interface__description, child_description)
    child_vrf = yang.gdata.take_json_opt_str(jd, 'vrf')
    yang.gdata.maybe_add(children, 'vrf', from_json_orchestron_rfs__rfs__vrf_interface__vrf, child_vrf)
    child_ipv4_address = yang.gdata.take_json_opt_str(jd, 'ipv4-address')
    yang.gdata.maybe_add(children, 'ipv4-address', from_json_orchestron_rfs__rfs__vrf_interface__ipv4_address, child_ipv4_address)
    child_ipv4_prefix_length = yang.gdata.take_json_opt_int(jd, 'ipv4-prefix-length')
    yang.gdata.maybe_add(children, 'ipv4-prefix-length', from_json_orchestron_rfs__rfs__vrf_interface__ipv4_prefix_length, child_ipv4_prefix_length)
    return yang.gdata.Container(children)

mut def from_json_orchestron_rfs__rfs__vrf_interface(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_orchestron_rfs__rfs__vrf_interface_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['name'], elements=elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

mut def from_json_orchestron_rfs__rfs__ebgp_customer__vrf(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__ebgp_customer__vrf(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__ebgp_customer__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_orchestron_rfs__rfs__ebgp_customer__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_json_orchestron_rfs__rfs__ebgp_customer__local_asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_orchestron_rfs__rfs__ebgp_customer__local_asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_orchestron_rfs__rfs__ebgp_customer__peer_asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_orchestron_rfs__rfs__ebgp_customer__peer_asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_orchestron_rfs__rfs__ebgp_customer__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__ebgp_customer__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_orchestron_rfs__rfs__ebgp_customer__authentication_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_orchestron_rfs__rfs__ebgp_customer__authentication_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class orchestron_rfs__rfs__ebgp_customer_entry(yang.adata.MNode):
    vrf: str
    address: str
    local_asn: ?int
    peer_asn: ?int
    description: ?str
    authentication_key: ?str

    mut def __init__(self, vrf: str, address: str, local_asn: ?int, peer_asn: ?int, description: ?str, authentication_key: ?str):
        self._ns = 'http://example.com/respnet-rfs'
        self.vrf = vrf
        self.address = address
        self.local_asn = local_asn
        self.peer_asn = peer_asn
        self.description = description
        self.authentication_key = authentication_key

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vrf = self.vrf
        if _vrf is not None:
            children['vrf'] = yang.gdata.Leaf('string', _vrf)
        _address = self.address
        if _address is not None:
            children['address'] = yang.gdata.Leaf('union', _address)
        _local_asn = self.local_asn
        if _local_asn is not None:
            children['local-asn'] = yang.gdata.Leaf('uint32', _local_asn)
        _peer_asn = self.peer_asn
        if _peer_asn is not None:
            children['peer-asn'] = yang.gdata.Leaf('uint32', _peer_asn)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        _authentication_key = self.authentication_key
        if _authentication_key is not None:
            children['authentication-key'] = yang.gdata.Leaf('string', _authentication_key)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_rfs__rfs__ebgp_customer_entry:
        return orchestron_rfs__rfs__ebgp_customer_entry(vrf=n.get_str('vrf'), address=n.get_str('address'), local_asn=n.get_opt_int('local-asn'), peer_asn=n.get_opt_int('peer-asn'), description=n.get_opt_str('description'), authentication_key=n.get_opt_str('authentication-key'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /rfs/ebgp-customer')
            res.append(f'{self_name} = orchestron_rfs__rfs__ebgp_customer({repr(self.vrf)}, {repr(self.address)})')
        leaves = []
        _local_asn = self.local_asn
        if _local_asn is not None:
            leaves.append(f'{self_name}.local_asn = {repr(_local_asn)}')
        _peer_asn = self.peer_asn
        if _peer_asn is not None:
            leaves.append(f'{self_name}.peer_asn = {repr(_peer_asn)}')
        _description = self.description
        if _description is not None:
            leaves.append(f'{self_name}.description = {repr(_description)}')
        _authentication_key = self.authentication_key
        if _authentication_key is not None:
            leaves.append(f'{self_name}.authentication_key = {repr(_authentication_key)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /rfs/ebgp-customer'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class orchestron_rfs__rfs__ebgp_customer(yang.adata.MNode):
    elements: list[orchestron_rfs__rfs__ebgp_customer_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/respnet-rfs'
        self._name = 'ebgp-customer'
        self.elements = elements

    mut def create(self, vrf, address, local_asn, peer_asn, authentication_key):
        for e in self.elements:
            match = True
            if e.vrf != vrf:
                match = False
                continue
            if e.address != address:
                match = False
                continue
            if match:
                return e

        res = orchestron_rfs__rfs__ebgp_customer_entry(vrf, address, local_asn, peer_asn, authentication_key)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vrf', 'address'], elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_rfs__rfs__ebgp_customer_entry]:
        if n is not None:
            return [orchestron_rfs__rfs__ebgp_customer_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_orchestron_rfs__rfs__ebgp_customer_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_vrf = yang.gdata.from_xml_str(node, 'vrf')
    yang.gdata.maybe_add(children, 'vrf', from_xml_orchestron_rfs__rfs__ebgp_customer__vrf, child_vrf)
    child_address = yang.gdata.from_xml_str(node, 'address')
    yang.gdata.maybe_add(children, 'address', from_xml_orchestron_rfs__rfs__ebgp_customer__address, child_address)
    child_local_asn = yang.gdata.from_xml_opt_int(node, 'local-asn')
    yang.gdata.maybe_add(children, 'local-asn', from_xml_orchestron_rfs__rfs__ebgp_customer__local_asn, child_local_asn)
    child_peer_asn = yang.gdata.from_xml_opt_int(node, 'peer-asn')
    yang.gdata.maybe_add(children, 'peer-asn', from_xml_orchestron_rfs__rfs__ebgp_customer__peer_asn, child_peer_asn)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_xml_orchestron_rfs__rfs__ebgp_customer__description, child_description)
    child_authentication_key = yang.gdata.from_xml_opt_str(node, 'authentication-key')
    yang.gdata.maybe_add(children, 'authentication-key', from_xml_orchestron_rfs__rfs__ebgp_customer__authentication_key, child_authentication_key)
    return yang.gdata.Container(children)

mut def from_xml_orchestron_rfs__rfs__ebgp_customer(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_orchestron_rfs__rfs__ebgp_customer_element(e) for e in nodes]
    return yang.gdata.List(keys=['vrf', 'address'], elements=elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

mut def from_json_path_orchestron_rfs__rfs__ebgp_customer_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_orchestron_rfs__rfs__ebgp_customer_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['vrf', 'address']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['vrf'] = from_json_orchestron_rfs__rfs__ebgp_customer__vrf(keys[0])
        children['address'] = from_json_orchestron_rfs__rfs__ebgp_customer__address(keys[1])
        if point == 'local-asn':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'peer-asn':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'description':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'authentication-key':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_orchestron_rfs__rfs__ebgp_customer(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vrf', 'address']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_orchestron_rfs__rfs__ebgp_customer_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['vrf', 'address'])))
        return yang.gdata.List(['vrf', 'address'], elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')
    elif len(path) > 1:
        return yang.gdata.List(['vrf', 'address'], [from_json_path_orchestron_rfs__rfs__ebgp_customer_element(jd, path, op)], ns='http://example.com/respnet-rfs', module='respnet-rfs')
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_orchestron_rfs__rfs__ebgp_customer_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_vrf = yang.gdata.take_json_str(jd, 'vrf')
    yang.gdata.maybe_add(children, 'vrf', from_json_orchestron_rfs__rfs__ebgp_customer__vrf, child_vrf)
    child_address = yang.gdata.take_json_str(jd, 'address')
    yang.gdata.maybe_add(children, 'address', from_json_orchestron_rfs__rfs__ebgp_customer__address, child_address)
    child_local_asn = yang.gdata.take_json_opt_int(jd, 'local-asn')
    yang.gdata.maybe_add(children, 'local-asn', from_json_orchestron_rfs__rfs__ebgp_customer__local_asn, child_local_asn)
    child_peer_asn = yang.gdata.take_json_opt_int(jd, 'peer-asn')
    yang.gdata.maybe_add(children, 'peer-asn', from_json_orchestron_rfs__rfs__ebgp_customer__peer_asn, child_peer_asn)
    child_description = yang.gdata.take_json_opt_str(jd, 'description')
    yang.gdata.maybe_add(children, 'description', from_json_orchestron_rfs__rfs__ebgp_customer__description, child_description)
    child_authentication_key = yang.gdata.take_json_opt_str(jd, 'authentication-key')
    yang.gdata.maybe_add(children, 'authentication-key', from_json_orchestron_rfs__rfs__ebgp_customer__authentication_key, child_authentication_key)
    return yang.gdata.Container(children)

mut def from_json_orchestron_rfs__rfs__ebgp_customer(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_orchestron_rfs__rfs__ebgp_customer_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['vrf', 'address'], elements=elements, ns='http://example.com/respnet-rfs', module='respnet-rfs')

class orchestron_rfs__rfs_entry(yang.adata.MNode):
    name: str
    base_config: orchestron_rfs__rfs__base_config
    backbone_interface: orchestron_rfs__rfs__backbone_interface
    ibgp_neighbor: orchestron_rfs__rfs__ibgp_neighbor
    vrf: orchestron_rfs__rfs__vrf
    vrf_interface: orchestron_rfs__rfs__vrf_interface
    ebgp_customer: orchestron_rfs__rfs__ebgp_customer

    mut def __init__(self, name: str, base_config: list[orchestron_rfs__rfs__base_config_entry]=[], backbone_interface: list[orchestron_rfs__rfs__backbone_interface_entry]=[], ibgp_neighbor: list[orchestron_rfs__rfs__ibgp_neighbor_entry]=[], vrf: list[orchestron_rfs__rfs__vrf_entry]=[], vrf_interface: list[orchestron_rfs__rfs__vrf_interface_entry]=[], ebgp_customer: list[orchestron_rfs__rfs__ebgp_customer_entry]=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self.name = name
        self.base_config = orchestron_rfs__rfs__base_config(elements=base_config)
        self.backbone_interface = orchestron_rfs__rfs__backbone_interface(elements=backbone_interface)
        self.ibgp_neighbor = orchestron_rfs__rfs__ibgp_neighbor(elements=ibgp_neighbor)
        self.vrf = orchestron_rfs__rfs__vrf(elements=vrf)
        self.vrf_interface = orchestron_rfs__rfs__vrf_interface(elements=vrf_interface)
        self.ebgp_customer = orchestron_rfs__rfs__ebgp_customer(elements=ebgp_customer)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _base_config = self.base_config
        if _base_config is not None:
            children['base-config'] = _base_config.to_gdata()
        _backbone_interface = self.backbone_interface
        if _backbone_interface is not None:
            children['backbone-interface'] = _backbone_interface.to_gdata()
        _ibgp_neighbor = self.ibgp_neighbor
        if _ibgp_neighbor is not None:
            children['ibgp-neighbor'] = _ibgp_neighbor.to_gdata()
        _vrf = self.vrf
        if _vrf is not None:
            children['vrf'] = _vrf.to_gdata()
        _vrf_interface = self.vrf_interface
        if _vrf_interface is not None:
            children['vrf-interface'] = _vrf_interface.to_gdata()
        _ebgp_customer = self.ebgp_customer
        if _ebgp_customer is not None:
            children['ebgp-customer'] = _ebgp_customer.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_rfs__rfs_entry:
        return orchestron_rfs__rfs_entry(name=n.get_str('name'), base_config=orchestron_rfs__rfs__base_config.from_gdata(n.get_opt_list('base-config')), backbone_interface=orchestron_rfs__rfs__backbone_interface.from_gdata(n.get_opt_list('backbone-interface')), ibgp_neighbor=orchestron_rfs__rfs__ibgp_neighbor.from_gdata(n.get_opt_list('ibgp-neighbor')), vrf=orchestron_rfs__rfs__vrf.from_gdata(n.get_opt_list('vrf')), vrf_interface=orchestron_rfs__rfs__vrf_interface.from_gdata(n.get_opt_list('vrf-interface')), ebgp_customer=orchestron_rfs__rfs__ebgp_customer.from_gdata(n.get_opt_list('ebgp-customer')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /rfs')
            res.append(f'{self_name} = orchestron_rfs__rfs({repr(self.name)})')
        leaves = []
        _base_config = self.base_config
        for _element in _base_config.elements:
            res.append('')
            res.append("# List /rfs/base-config element: {_element.to_gdata().key_str(['name'])}")
            list_elem = f'base_config_element = {self_name}.base_config.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc(f'base_config_element', False, list_element=True).splitlines())
        _backbone_interface = self.backbone_interface
        for _element in _backbone_interface.elements:
            res.append('')
            res.append("# List /rfs/backbone-interface element: {_element.to_gdata().key_str(['name'])}")
            list_elem = f'backbone_interface_element = {self_name}.backbone_interface.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc(f'backbone_interface_element', False, list_element=True).splitlines())
        _ibgp_neighbor = self.ibgp_neighbor
        for _element in _ibgp_neighbor.elements:
            res.append('')
            res.append("# List /rfs/ibgp-neighbor element: {_element.to_gdata().key_str(['address'])}")
            list_elem = f'ibgp_neighbor_element = {self_name}.ibgp_neighbor.create({repr(_element.address)})'
            res.append(list_elem)
            res.extend(_element.prsrc(f'ibgp_neighbor_element', False, list_element=True).splitlines())
        _vrf = self.vrf
        for _element in _vrf.elements:
            res.append('')
            res.append("# List /rfs/vrf element: {_element.to_gdata().key_str(['name'])}")
            list_elem = f'vrf_element = {self_name}.vrf.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc(f'vrf_element', False, list_element=True).splitlines())
        _vrf_interface = self.vrf_interface
        for _element in _vrf_interface.elements:
            res.append('')
            res.append("# List /rfs/vrf-interface element: {_element.to_gdata().key_str(['name'])}")
            list_elem = f'vrf_interface_element = {self_name}.vrf_interface.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc(f'vrf_interface_element', False, list_element=True).splitlines())
        _ebgp_customer = self.ebgp_customer
        for _element in _ebgp_customer.elements:
            res.append('')
            res.append("# List /rfs/ebgp-customer element: {_element.to_gdata().key_str(['vrf', 'address'])}")
            list_elem = f'ebgp_customer_element = {self_name}.ebgp_customer.create({repr(_element.vrf)}, {repr(_element.address)})'
            res.append(list_elem)
            res.extend(_element.prsrc(f'ebgp_customer_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /rfs'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class orchestron_rfs__rfs(yang.adata.MNode):
    elements: list[orchestron_rfs__rfs_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-rfs.yang'
        self._name = 'rfs'
        self.elements = elements

    mut def create(self, name):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = orchestron_rfs__rfs_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements, ns='http://orchestron.org/yang/orchestron-rfs.yang', module='orchestron-rfs')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_rfs__rfs_entry]:
        if n is not None:
            return [orchestron_rfs__rfs_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_orchestron_rfs__rfs_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_orchestron_rfs__rfs__name, child_name)
    child_base_config = yang.gdata.from_xml_opt_list(node, 'base-config', 'http://example.com/respnet-rfs')
    yang.gdata.maybe_add(children, 'base-config', from_xml_orchestron_rfs__rfs__base_config, child_base_config)
    child_backbone_interface = yang.gdata.from_xml_opt_list(node, 'backbone-interface', 'http://example.com/respnet-rfs')
    yang.gdata.maybe_add(children, 'backbone-interface', from_xml_orchestron_rfs__rfs__backbone_interface, child_backbone_interface)
    child_ibgp_neighbor = yang.gdata.from_xml_opt_list(node, 'ibgp-neighbor', 'http://example.com/respnet-rfs')
    yang.gdata.maybe_add(children, 'ibgp-neighbor', from_xml_orchestron_rfs__rfs__ibgp_neighbor, child_ibgp_neighbor)
    child_vrf = yang.gdata.from_xml_opt_list(node, 'vrf', 'http://example.com/respnet-rfs')
    yang.gdata.maybe_add(children, 'vrf', from_xml_orchestron_rfs__rfs__vrf, child_vrf)
    child_vrf_interface = yang.gdata.from_xml_opt_list(node, 'vrf-interface', 'http://example.com/respnet-rfs')
    yang.gdata.maybe_add(children, 'vrf-interface', from_xml_orchestron_rfs__rfs__vrf_interface, child_vrf_interface)
    child_ebgp_customer = yang.gdata.from_xml_opt_list(node, 'ebgp-customer', 'http://example.com/respnet-rfs')
    yang.gdata.maybe_add(children, 'ebgp-customer', from_xml_orchestron_rfs__rfs__ebgp_customer, child_ebgp_customer)
    return yang.gdata.Container(children)

mut def from_xml_orchestron_rfs__rfs(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_orchestron_rfs__rfs_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements, ns='http://orchestron.org/yang/orchestron-rfs.yang', module='orchestron-rfs')

mut def from_json_path_orchestron_rfs__rfs_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_orchestron_rfs__rfs_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['name']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_orchestron_rfs__rfs__name(keys[0])
        if point == 'respnet-rfs:base-config':
            children['base-config'] = from_json_path_orchestron_rfs__rfs__base_config(jd, rest_path, op)
        if point == 'respnet-rfs:backbone-interface':
            children['backbone-interface'] = from_json_path_orchestron_rfs__rfs__backbone_interface(jd, rest_path, op)
        if point == 'respnet-rfs:ibgp-neighbor':
            children['ibgp-neighbor'] = from_json_path_orchestron_rfs__rfs__ibgp_neighbor(jd, rest_path, op)
        if point == 'respnet-rfs:vrf':
            children['vrf'] = from_json_path_orchestron_rfs__rfs__vrf(jd, rest_path, op)
        if point == 'respnet-rfs:vrf-interface':
            children['vrf-interface'] = from_json_path_orchestron_rfs__rfs__vrf_interface(jd, rest_path, op)
        if point == 'respnet-rfs:ebgp-customer':
            children['ebgp-customer'] = from_json_path_orchestron_rfs__rfs__ebgp_customer(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_orchestron_rfs__rfs(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_orchestron_rfs__rfs_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['name'])))
        return yang.gdata.List(['name'], elements, ns='http://orchestron.org/yang/orchestron-rfs.yang', module='orchestron-rfs')
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_orchestron_rfs__rfs_element(jd, path, op)], ns='http://orchestron.org/yang/orchestron-rfs.yang', module='orchestron-rfs')
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_orchestron_rfs__rfs_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_orchestron_rfs__rfs__name, child_name)
    child_base_config = yang.gdata.take_json_opt_list(jd, 'base-config', 'respnet-rfs')
    yang.gdata.maybe_add(children, 'base-config', from_json_orchestron_rfs__rfs__base_config, child_base_config)
    child_backbone_interface = yang.gdata.take_json_opt_list(jd, 'backbone-interface', 'respnet-rfs')
    yang.gdata.maybe_add(children, 'backbone-interface', from_json_orchestron_rfs__rfs__backbone_interface, child_backbone_interface)
    child_ibgp_neighbor = yang.gdata.take_json_opt_list(jd, 'ibgp-neighbor', 'respnet-rfs')
    yang.gdata.maybe_add(children, 'ibgp-neighbor', from_json_orchestron_rfs__rfs__ibgp_neighbor, child_ibgp_neighbor)
    child_vrf = yang.gdata.take_json_opt_list(jd, 'vrf', 'respnet-rfs')
    yang.gdata.maybe_add(children, 'vrf', from_json_orchestron_rfs__rfs__vrf, child_vrf)
    child_vrf_interface = yang.gdata.take_json_opt_list(jd, 'vrf-interface', 'respnet-rfs')
    yang.gdata.maybe_add(children, 'vrf-interface', from_json_orchestron_rfs__rfs__vrf_interface, child_vrf_interface)
    child_ebgp_customer = yang.gdata.take_json_opt_list(jd, 'ebgp-customer', 'respnet-rfs')
    yang.gdata.maybe_add(children, 'ebgp-customer', from_json_orchestron_rfs__rfs__ebgp_customer, child_ebgp_customer)
    return yang.gdata.Container(children)

mut def from_json_orchestron_rfs__rfs(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_orchestron_rfs__rfs_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['name'], elements=elements, ns='http://orchestron.org/yang/orchestron-rfs.yang', module='orchestron-rfs')

class root(yang.adata.MNode):
    device: orchestron_rfs__device
    rfs: orchestron_rfs__rfs

    mut def __init__(self, device: list[orchestron_rfs__device_entry]=[], rfs: list[orchestron_rfs__rfs_entry]=[]):
        self._ns = ''
        self.device = orchestron_rfs__device(elements=device)
        self.rfs = orchestron_rfs__rfs(elements=rfs)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _device = self.device
        if _device is not None:
            children['device'] = _device.to_gdata()
        _rfs = self.rfs
        if _rfs is not None:
            children['rfs'] = _rfs.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> root:
        if n != None:
            return root(device=orchestron_rfs__device.from_gdata(n.get_opt_list('device')), rfs=orchestron_rfs__rfs.from_gdata(n.get_opt_list('rfs')))
        return root()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append(f'# Top node: /root')
            res.append(f'{self_name} = root()')
        leaves = []
        _device = self.device
        for _element in _device.elements:
            res.append('')
            res.append("# List /device element: {_element.to_gdata().key_str(['name'])}")
            list_elem = f'device_element = {self_name}.device.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc(f'device_element', False, list_element=True).splitlines())
        _rfs = self.rfs
        for _element in _rfs.elements:
            res.append('')
            res.append("# List /rfs element: {_element.to_gdata().key_str(['name'])}")
            list_elem = f'rfs_element = {self_name}.rfs.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc(f'rfs_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /root'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_device = yang.gdata.from_xml_opt_list(node, 'device', 'http://orchestron.org/yang/orchestron-rfs.yang')
    yang.gdata.maybe_add(children, 'device', from_xml_orchestron_rfs__device, child_device)
    child_rfs = yang.gdata.from_xml_opt_list(node, 'rfs', 'http://orchestron.org/yang/orchestron-rfs.yang')
    yang.gdata.maybe_add(children, 'rfs', from_xml_orchestron_rfs__rfs, child_rfs)
    return yang.gdata.Container(children)

mut def from_json_path(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'orchestron-rfs:device':
            child = {'device': from_json_path_orchestron_rfs__device(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'orchestron-rfs:rfs':
            child = {'rfs': from_json_path_orchestron_rfs__rfs(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_device = yang.gdata.take_json_opt_list(jd, 'device', 'orchestron-rfs')
    yang.gdata.maybe_add(children, 'device', from_json_orchestron_rfs__device, child_device)
    child_rfs = yang.gdata.take_json_opt_list(jd, 'rfs', 'orchestron-rfs')
    yang.gdata.maybe_add(children, 'rfs', from_json_orchestron_rfs__rfs, child_rfs)
    return yang.gdata.Container(children)

schema_namespaces: set[str] = {
    'http://example.com/respnet-rfs',
    'http://orchestron.org/yang/orchestron-rfs.yang',
}
