import base64
import json
import xml
import yang.adata
import yang.gdata

# == This file is generated ==


mut def from_json_netinfra_inter__netinfra__router__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra_inter__netinfra__router__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra_inter__netinfra__router__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_netinfra_inter__netinfra__router__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_netinfra_inter__netinfra__router__role(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra_inter__netinfra__router__role(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra_inter__netinfra__router__mock(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_netinfra_inter__netinfra__router__mock(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_netinfra_inter__netinfra__router__base_config__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_netinfra_inter__netinfra__router__base_config__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_netinfra_inter__netinfra__router__base_config__ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra_inter__netinfra__router__base_config__ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra_inter__netinfra__router__base_config__ipv6_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra_inter__netinfra__router__base_config__ipv6_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class netinfra_inter__netinfra__router__base_config(yang.adata.MNode):
    asn: ?int
    ipv4_address: ?str
    ipv6_address: ?str

    mut def __init__(self, asn: ?int, ipv4_address: ?str, ipv6_address: ?str):
        self._ns = 'http://example.com/netinfra-inter'
        self.asn = asn
        self.ipv4_address = ipv4_address
        self.ipv6_address = ipv6_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _asn = self.asn
        if _asn is not None:
            children['asn'] = yang.gdata.Leaf('uint32', _asn)
        _ipv4_address = self.ipv4_address
        if _ipv4_address is not None:
            children['ipv4-address'] = yang.gdata.Leaf('string', _ipv4_address)
        _ipv6_address = self.ipv6_address
        if _ipv6_address is not None:
            children['ipv6-address'] = yang.gdata.Leaf('string', _ipv6_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> netinfra_inter__netinfra__router__base_config:
        if n != None:
            return netinfra_inter__netinfra__router__base_config(asn=n.get_opt_int('asn'), ipv4_address=n.get_opt_str('ipv4-address'), ipv6_address=n.get_opt_str('ipv6-address'))
        raise ValueError('Missing required subtree netinfra_inter__netinfra__router__base_config')


mut def from_xml_netinfra_inter__netinfra__router__base_config(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_asn = yang.gdata.from_xml_int(node, 'asn')
    yang.gdata.maybe_add(children, 'asn', from_xml_netinfra_inter__netinfra__router__base_config__asn, child_asn)
    child_ipv4_address = yang.gdata.from_xml_str(node, 'ipv4-address')
    yang.gdata.maybe_add(children, 'ipv4-address', from_xml_netinfra_inter__netinfra__router__base_config__ipv4_address, child_ipv4_address)
    child_ipv6_address = yang.gdata.from_xml_str(node, 'ipv6-address')
    yang.gdata.maybe_add(children, 'ipv6-address', from_xml_netinfra_inter__netinfra__router__base_config__ipv6_address, child_ipv6_address)
    return yang.gdata.Container(children)

mut def from_json_path_netinfra_inter__netinfra__router__base_config(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'asn':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_netinfra_inter__netinfra__router__base_config(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_netinfra_inter__netinfra__router__base_config(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_asn = yang.gdata.take_json_int(jd, 'asn')
    yang.gdata.maybe_add(children, 'asn', from_json_netinfra_inter__netinfra__router__base_config__asn, child_asn)
    child_ipv4_address = yang.gdata.take_json_str(jd, 'ipv4-address')
    yang.gdata.maybe_add(children, 'ipv4-address', from_json_netinfra_inter__netinfra__router__base_config__ipv4_address, child_ipv4_address)
    child_ipv6_address = yang.gdata.take_json_str(jd, 'ipv6-address')
    yang.gdata.maybe_add(children, 'ipv6-address', from_json_netinfra_inter__netinfra__router__base_config__ipv6_address, child_ipv6_address)
    return yang.gdata.Container(children)

mut def from_json_netinfra_inter__netinfra__router__l3vpn_vrf__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra_inter__netinfra__router__l3vpn_vrf__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra_inter__netinfra__router__l3vpn_vrf__ebgp_customer_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('union', val)

mut def from_xml_netinfra_inter__netinfra__router__l3vpn_vrf__ebgp_customer_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('union', val)

class netinfra_inter__netinfra__router__l3vpn_vrf_entry(yang.adata.MNode):
    vpn_id: str
    ebgp_customer_address: list[str]

    mut def __init__(self, vpn_id: str, ebgp_customer_address: ?list[str]=None):
        self._ns = 'http://example.com/netinfra-inter'
        self.vpn_id = vpn_id
        self.ebgp_customer_address = ebgp_customer_address if ebgp_customer_address is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('string', _vpn_id)
        children['ebgp-customer-address'] = yang.gdata.LeafList('union', self.ebgp_customer_address)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.vpn_id)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra_inter__netinfra__router__l3vpn_vrf_entry:
        return netinfra_inter__netinfra__router__l3vpn_vrf_entry(vpn_id=n.get_str('vpn-id'), ebgp_customer_address=n.get_opt_strs('ebgp-customer-address'))

class netinfra_inter__netinfra__router__l3vpn_vrf(yang.adata.MNode):
    elements: list[netinfra_inter__netinfra__router__l3vpn_vrf_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/netinfra-inter'
        self._name = 'l3vpn-vrf'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self.elements:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = netinfra_inter__netinfra__router__l3vpn_vrf_entry(vpn_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra_inter__netinfra__router__l3vpn_vrf_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(netinfra_inter__netinfra__router__l3vpn_vrf_entry.from_gdata(e))
        return res


mut def from_xml_netinfra_inter__netinfra__router__l3vpn_vrf_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.from_xml_str(node, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_xml_netinfra_inter__netinfra__router__l3vpn_vrf__vpn_id, child_vpn_id)
    child_ebgp_customer_address = yang.gdata.from_xml_opt_strs(node, 'ebgp-customer-address')
    yang.gdata.maybe_add(children, 'ebgp-customer-address', from_xml_netinfra_inter__netinfra__router__l3vpn_vrf__ebgp_customer_address, child_ebgp_customer_address)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_vpn_id)])

mut def from_xml_netinfra_inter__netinfra__router__l3vpn_vrf(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = []
    for e in nodes:
        elements.append(from_xml_netinfra_inter__netinfra__router__l3vpn_vrf_element(e))
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

mut def from_json_path_netinfra_inter__netinfra__router__l3vpn_vrf_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra_inter__netinfra__router__l3vpn_vrf_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['vpn-id'] = from_json_netinfra_inter__netinfra__router__l3vpn_vrf__vpn_id(keys[0])
        if point == 'ebgp-customer-address':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra_inter__netinfra__router__l3vpn_vrf(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra_inter__netinfra__router__l3vpn_vrf_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['vpn-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-id'], [from_json_path_netinfra_inter__netinfra__router__l3vpn_vrf_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra_inter__netinfra__router__l3vpn_vrf_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.take_json_str(jd, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_json_netinfra_inter__netinfra__router__l3vpn_vrf__vpn_id, child_vpn_id)
    child_ebgp_customer_address = yang.gdata.take_json_opt_strs(jd, 'ebgp-customer-address')
    yang.gdata.maybe_add(children, 'ebgp-customer-address', from_json_netinfra_inter__netinfra__router__l3vpn_vrf__ebgp_customer_address, child_ebgp_customer_address)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_vpn_id)])

mut def from_json_netinfra_inter__netinfra__router__l3vpn_vrf(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_netinfra_inter__netinfra__router__l3vpn_vrf_element(e))
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

class netinfra_inter__netinfra__router_entry(yang.adata.MNode):
    name: str
    id: ?int
    role: ?str
    mock: ?str
    base_config: netinfra_inter__netinfra__router__base_config
    l3vpn_vrf: netinfra_inter__netinfra__router__l3vpn_vrf

    mut def __init__(self, name: str, id: ?int, role: ?str, mock: ?str, base_config: ?netinfra_inter__netinfra__router__base_config=None, l3vpn_vrf: list[netinfra_inter__netinfra__router__l3vpn_vrf_entry]=[]):
        self._ns = 'http://example.com/netinfra-inter'
        self.name = name
        self.id = id
        self.role = role
        self.mock = mock
        self.base_config = base_config if base_config is not None else netinfra_inter__netinfra__router__base_config()
        self.l3vpn_vrf = netinfra_inter__netinfra__router__l3vpn_vrf(elements=l3vpn_vrf)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint32', _id)
        _role = self.role
        if _role is not None:
            children['role'] = yang.gdata.Leaf('string', _role)
        _mock = self.mock
        if _mock is not None:
            children['mock'] = yang.gdata.Leaf('enumeration', _mock)
        _base_config = self.base_config
        if _base_config is not None:
            children['base-config'] = _base_config.to_gdata()
        _l3vpn_vrf = self.l3vpn_vrf
        if _l3vpn_vrf is not None:
            children['l3vpn-vrf'] = _l3vpn_vrf.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.name)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra_inter__netinfra__router_entry:
        return netinfra_inter__netinfra__router_entry(name=n.get_str('name'), id=n.get_opt_int('id'), role=n.get_opt_str('role'), mock=n.get_opt_str('mock'), base_config=netinfra_inter__netinfra__router__base_config.from_gdata(n.get_opt_container('base-config')), l3vpn_vrf=netinfra_inter__netinfra__router__l3vpn_vrf.from_gdata(n.get_opt_list('l3vpn-vrf')))

class netinfra_inter__netinfra__router(yang.adata.MNode):
    elements: list[netinfra_inter__netinfra__router_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/netinfra-inter'
        self._name = 'router'
        self.elements = elements

    mut def create(self, name, id):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = netinfra_inter__netinfra__router_entry(name, id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra_inter__netinfra__router_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(netinfra_inter__netinfra__router_entry.from_gdata(e))
        return res


mut def from_xml_netinfra_inter__netinfra__router_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_netinfra_inter__netinfra__router__name, child_name)
    child_id = yang.gdata.from_xml_int(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_netinfra_inter__netinfra__router__id, child_id)
    child_role = yang.gdata.from_xml_opt_str(node, 'role')
    yang.gdata.maybe_add(children, 'role', from_xml_netinfra_inter__netinfra__router__role, child_role)
    child_mock = yang.gdata.from_xml_opt_str(node, 'mock')
    yang.gdata.maybe_add(children, 'mock', from_xml_netinfra_inter__netinfra__router__mock, child_mock)
    child_base_config = yang.gdata.from_xml_opt_cnt(node, 'base-config')
    yang.gdata.maybe_add(children, 'base-config', from_xml_netinfra_inter__netinfra__router__base_config, child_base_config)
    child_l3vpn_vrf = yang.gdata.from_xml_opt_list(node, 'l3vpn-vrf')
    yang.gdata.maybe_add(children, 'l3vpn-vrf', from_xml_netinfra_inter__netinfra__router__l3vpn_vrf, child_l3vpn_vrf)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_name)])

mut def from_xml_netinfra_inter__netinfra__router(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = []
    for e in nodes:
        elements.append(from_xml_netinfra_inter__netinfra__router_element(e))
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_json_path_netinfra_inter__netinfra__router_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra_inter__netinfra__router_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_netinfra_inter__netinfra__router__name(keys[0])
        if point == 'id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'role':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'mock':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'base-config':
            children['base-config'] = from_json_path_netinfra_inter__netinfra__router__base_config(jd, rest_path, op)
        if point == 'l3vpn-vrf':
            children['l3vpn-vrf'] = from_json_path_netinfra_inter__netinfra__router__l3vpn_vrf(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra_inter__netinfra__router(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra_inter__netinfra__router_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_netinfra_inter__netinfra__router_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra_inter__netinfra__router_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_netinfra_inter__netinfra__router__name, child_name)
    child_id = yang.gdata.take_json_int(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_netinfra_inter__netinfra__router__id, child_id)
    child_role = yang.gdata.take_json_opt_str(jd, 'role')
    yang.gdata.maybe_add(children, 'role', from_json_netinfra_inter__netinfra__router__role, child_role)
    child_mock = yang.gdata.take_json_opt_str(jd, 'mock')
    yang.gdata.maybe_add(children, 'mock', from_json_netinfra_inter__netinfra__router__mock, child_mock)
    child_base_config = yang.gdata.take_json_opt_cnt(jd, 'base-config')
    yang.gdata.maybe_add(children, 'base-config', from_json_netinfra_inter__netinfra__router__base_config, child_base_config)
    child_l3vpn_vrf = yang.gdata.take_json_opt_list(jd, 'l3vpn-vrf')
    yang.gdata.maybe_add(children, 'l3vpn-vrf', from_json_netinfra_inter__netinfra__router__l3vpn_vrf, child_l3vpn_vrf)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_name)])

mut def from_json_netinfra_inter__netinfra__router(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_netinfra_inter__netinfra__router_element(e))
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_json_netinfra_inter__netinfra__backbone_link__left_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra_inter__netinfra__backbone_link__left_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra_inter__netinfra__backbone_link__left_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra_inter__netinfra__backbone_link__left_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra_inter__netinfra__backbone_link__right_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra_inter__netinfra__backbone_link__right_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra_inter__netinfra__backbone_link__right_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra_inter__netinfra__backbone_link__right_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class netinfra_inter__netinfra__backbone_link_entry(yang.adata.MNode):
    left_router: str
    left_interface: str
    right_router: str
    right_interface: str

    mut def __init__(self, left_router: str, left_interface: str, right_router: str, right_interface: str):
        self._ns = 'http://example.com/netinfra-inter'
        self.left_router = left_router
        self.left_interface = left_interface
        self.right_router = right_router
        self.right_interface = right_interface

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _left_router = self.left_router
        if _left_router is not None:
            children['left-router'] = yang.gdata.Leaf('string', _left_router)
        _left_interface = self.left_interface
        if _left_interface is not None:
            children['left-interface'] = yang.gdata.Leaf('string', _left_interface)
        _right_router = self.right_router
        if _right_router is not None:
            children['right-router'] = yang.gdata.Leaf('string', _right_router)
        _right_interface = self.right_interface
        if _right_interface is not None:
            children['right-interface'] = yang.gdata.Leaf('string', _right_interface)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.left_router), yang.gdata.yang_str(self.left_interface), yang.gdata.yang_str(self.right_router), yang.gdata.yang_str(self.right_interface)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra_inter__netinfra__backbone_link_entry:
        return netinfra_inter__netinfra__backbone_link_entry(left_router=n.get_str('left-router'), left_interface=n.get_str('left-interface'), right_router=n.get_str('right-router'), right_interface=n.get_str('right-interface'))

class netinfra_inter__netinfra__backbone_link(yang.adata.MNode):
    elements: list[netinfra_inter__netinfra__backbone_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/netinfra-inter'
        self._name = 'backbone-link'
        self.elements = elements

    mut def create(self, left_router, left_interface, right_router, right_interface):
        for e in self.elements:
            match = True
            if e.left_router != left_router:
                match = False
                continue
            if e.left_interface != left_interface:
                match = False
                continue
            if e.right_router != right_router:
                match = False
                continue
            if e.right_interface != right_interface:
                match = False
                continue
            if match:
                return e

        res = netinfra_inter__netinfra__backbone_link_entry(left_router, left_interface, right_router, right_interface)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra_inter__netinfra__backbone_link_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(netinfra_inter__netinfra__backbone_link_entry.from_gdata(e))
        return res


mut def from_xml_netinfra_inter__netinfra__backbone_link_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_left_router = yang.gdata.from_xml_str(node, 'left-router')
    yang.gdata.maybe_add(children, 'left-router', from_xml_netinfra_inter__netinfra__backbone_link__left_router, child_left_router)
    child_left_interface = yang.gdata.from_xml_str(node, 'left-interface')
    yang.gdata.maybe_add(children, 'left-interface', from_xml_netinfra_inter__netinfra__backbone_link__left_interface, child_left_interface)
    child_right_router = yang.gdata.from_xml_str(node, 'right-router')
    yang.gdata.maybe_add(children, 'right-router', from_xml_netinfra_inter__netinfra__backbone_link__right_router, child_right_router)
    child_right_interface = yang.gdata.from_xml_str(node, 'right-interface')
    yang.gdata.maybe_add(children, 'right-interface', from_xml_netinfra_inter__netinfra__backbone_link__right_interface, child_right_interface)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_left_router), yang.gdata.yang_str(child_left_interface), yang.gdata.yang_str(child_right_router), yang.gdata.yang_str(child_right_interface)])

mut def from_xml_netinfra_inter__netinfra__backbone_link(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = []
    for e in nodes:
        elements.append(from_xml_netinfra_inter__netinfra__backbone_link_element(e))
    return yang.gdata.List(keys=['left-router', 'left-interface', 'right-router', 'right-interface'], elements=elements)

mut def from_json_path_netinfra_inter__netinfra__backbone_link_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra_inter__netinfra__backbone_link_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['left-router'] = from_json_netinfra_inter__netinfra__backbone_link__left_router(keys[0])
        children['left-interface'] = from_json_netinfra_inter__netinfra__backbone_link__left_interface(keys[1])
        children['right-router'] = from_json_netinfra_inter__netinfra__backbone_link__right_router(keys[2])
        children['right-interface'] = from_json_netinfra_inter__netinfra__backbone_link__right_interface(keys[3])
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra_inter__netinfra__backbone_link(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['left-router', 'left-interface', 'right-router', 'right-interface']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra_inter__netinfra__backbone_link_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], [from_json_path_netinfra_inter__netinfra__backbone_link_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra_inter__netinfra__backbone_link_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_left_router = yang.gdata.take_json_str(jd, 'left-router')
    yang.gdata.maybe_add(children, 'left-router', from_json_netinfra_inter__netinfra__backbone_link__left_router, child_left_router)
    child_left_interface = yang.gdata.take_json_str(jd, 'left-interface')
    yang.gdata.maybe_add(children, 'left-interface', from_json_netinfra_inter__netinfra__backbone_link__left_interface, child_left_interface)
    child_right_router = yang.gdata.take_json_str(jd, 'right-router')
    yang.gdata.maybe_add(children, 'right-router', from_json_netinfra_inter__netinfra__backbone_link__right_router, child_right_router)
    child_right_interface = yang.gdata.take_json_str(jd, 'right-interface')
    yang.gdata.maybe_add(children, 'right-interface', from_json_netinfra_inter__netinfra__backbone_link__right_interface, child_right_interface)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_left_router), yang.gdata.yang_str(child_left_interface), yang.gdata.yang_str(child_right_router), yang.gdata.yang_str(child_right_interface)])

mut def from_json_netinfra_inter__netinfra__backbone_link(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_netinfra_inter__netinfra__backbone_link_element(e))
    return yang.gdata.List(keys=['left-router', 'left-interface', 'right-router', 'right-interface'], elements=elements)

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_netinfra_inter__netinfra__ibgp_fullmesh__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh__authentication_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra_inter__netinfra__ibgp_fullmesh__authentication_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh__router__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra_inter__netinfra__ibgp_fullmesh__router__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh__router__ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra_inter__netinfra__ibgp_fullmesh__router__ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class netinfra_inter__netinfra__ibgp_fullmesh__router_entry(yang.adata.MNode):
    name: str
    ipv4_address: ?str

    mut def __init__(self, name: str, ipv4_address: ?str):
        self._ns = 'http://example.com/netinfra-inter'
        self.name = name
        self.ipv4_address = ipv4_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _ipv4_address = self.ipv4_address
        if _ipv4_address is not None:
            children['ipv4-address'] = yang.gdata.Leaf('string', _ipv4_address)
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.name)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra_inter__netinfra__ibgp_fullmesh__router_entry:
        return netinfra_inter__netinfra__ibgp_fullmesh__router_entry(name=n.get_str('name'), ipv4_address=n.get_opt_str('ipv4-address'))

class netinfra_inter__netinfra__ibgp_fullmesh__router(yang.adata.MNode):
    elements: list[netinfra_inter__netinfra__ibgp_fullmesh__router_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/netinfra-inter'
        self._name = 'router'
        self.elements = elements

    mut def create(self, name, ipv4_address):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = netinfra_inter__netinfra__ibgp_fullmesh__router_entry(name, ipv4_address)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra_inter__netinfra__ibgp_fullmesh__router_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(netinfra_inter__netinfra__ibgp_fullmesh__router_entry.from_gdata(e))
        return res


mut def from_xml_netinfra_inter__netinfra__ibgp_fullmesh__router_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_netinfra_inter__netinfra__ibgp_fullmesh__router__name, child_name)
    child_ipv4_address = yang.gdata.from_xml_str(node, 'ipv4-address')
    yang.gdata.maybe_add(children, 'ipv4-address', from_xml_netinfra_inter__netinfra__ibgp_fullmesh__router__ipv4_address, child_ipv4_address)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_name)])

mut def from_xml_netinfra_inter__netinfra__ibgp_fullmesh__router(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = []
    for e in nodes:
        elements.append(from_xml_netinfra_inter__netinfra__ibgp_fullmesh__router_element(e))
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_json_path_netinfra_inter__netinfra__ibgp_fullmesh__router_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra_inter__netinfra__ibgp_fullmesh__router_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_netinfra_inter__netinfra__ibgp_fullmesh__router__name(keys[0])
        if point == 'ipv4-address':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra_inter__netinfra__ibgp_fullmesh__router(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra_inter__netinfra__ibgp_fullmesh__router_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_netinfra_inter__netinfra__ibgp_fullmesh__router_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh__router_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_netinfra_inter__netinfra__ibgp_fullmesh__router__name, child_name)
    child_ipv4_address = yang.gdata.take_json_str(jd, 'ipv4-address')
    yang.gdata.maybe_add(children, 'ipv4-address', from_json_netinfra_inter__netinfra__ibgp_fullmesh__router__ipv4_address, child_ipv4_address)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_name)])

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh__router(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_netinfra_inter__netinfra__ibgp_fullmesh__router_element(e))
    return yang.gdata.List(keys=['name'], elements=elements)

class netinfra_inter__netinfra__ibgp_fullmesh_entry(yang.adata.MNode):
    asn: int
    authentication_key: ?str
    router: netinfra_inter__netinfra__ibgp_fullmesh__router

    mut def __init__(self, asn: int, authentication_key: ?str, router: list[netinfra_inter__netinfra__ibgp_fullmesh__router_entry]=[]):
        self._ns = 'http://example.com/netinfra-inter'
        self.asn = asn
        self.authentication_key = authentication_key
        self.router = netinfra_inter__netinfra__ibgp_fullmesh__router(elements=router)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _asn = self.asn
        if _asn is not None:
            children['asn'] = yang.gdata.Leaf('uint32', _asn)
        _authentication_key = self.authentication_key
        if _authentication_key is not None:
            children['authentication-key'] = yang.gdata.Leaf('string', _authentication_key)
        _router = self.router
        if _router is not None:
            children['router'] = _router.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.asn)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra_inter__netinfra__ibgp_fullmesh_entry:
        return netinfra_inter__netinfra__ibgp_fullmesh_entry(asn=n.get_int('asn'), authentication_key=n.get_opt_str('authentication-key'), router=netinfra_inter__netinfra__ibgp_fullmesh__router.from_gdata(n.get_opt_list('router')))

class netinfra_inter__netinfra__ibgp_fullmesh(yang.adata.MNode):
    elements: list[netinfra_inter__netinfra__ibgp_fullmesh_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/netinfra-inter'
        self._name = 'ibgp-fullmesh'
        self.elements = elements

    mut def create(self, asn, authentication_key):
        for e in self.elements:
            match = True
            if e.asn != asn:
                match = False
                continue
            if match:
                return e

        res = netinfra_inter__netinfra__ibgp_fullmesh_entry(asn, authentication_key)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['asn'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra_inter__netinfra__ibgp_fullmesh_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(netinfra_inter__netinfra__ibgp_fullmesh_entry.from_gdata(e))
        return res


mut def from_xml_netinfra_inter__netinfra__ibgp_fullmesh_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_asn = yang.gdata.from_xml_int(node, 'asn')
    yang.gdata.maybe_add(children, 'asn', from_xml_netinfra_inter__netinfra__ibgp_fullmesh__asn, child_asn)
    child_authentication_key = yang.gdata.from_xml_str(node, 'authentication-key')
    yang.gdata.maybe_add(children, 'authentication-key', from_xml_netinfra_inter__netinfra__ibgp_fullmesh__authentication_key, child_authentication_key)
    child_router = yang.gdata.from_xml_opt_list(node, 'router')
    yang.gdata.maybe_add(children, 'router', from_xml_netinfra_inter__netinfra__ibgp_fullmesh__router, child_router)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_asn)])

mut def from_xml_netinfra_inter__netinfra__ibgp_fullmesh(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = []
    for e in nodes:
        elements.append(from_xml_netinfra_inter__netinfra__ibgp_fullmesh_element(e))
    return yang.gdata.List(keys=['asn'], elements=elements)

mut def from_json_path_netinfra_inter__netinfra__ibgp_fullmesh_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra_inter__netinfra__ibgp_fullmesh_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['asn'] = from_json_netinfra_inter__netinfra__ibgp_fullmesh__asn(keys[0])
        if point == 'authentication-key':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'router':
            children['router'] = from_json_path_netinfra_inter__netinfra__ibgp_fullmesh__router(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra_inter__netinfra__ibgp_fullmesh(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['asn']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra_inter__netinfra__ibgp_fullmesh_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['asn'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['asn'], [from_json_path_netinfra_inter__netinfra__ibgp_fullmesh_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_asn = yang.gdata.take_json_int(jd, 'asn')
    yang.gdata.maybe_add(children, 'asn', from_json_netinfra_inter__netinfra__ibgp_fullmesh__asn, child_asn)
    child_authentication_key = yang.gdata.take_json_str(jd, 'authentication-key')
    yang.gdata.maybe_add(children, 'authentication-key', from_json_netinfra_inter__netinfra__ibgp_fullmesh__authentication_key, child_authentication_key)
    child_router = yang.gdata.take_json_opt_list(jd, 'router')
    yang.gdata.maybe_add(children, 'router', from_json_netinfra_inter__netinfra__ibgp_fullmesh__router, child_router)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_asn)])

mut def from_json_netinfra_inter__netinfra__ibgp_fullmesh(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_netinfra_inter__netinfra__ibgp_fullmesh_element(e))
    return yang.gdata.List(keys=['asn'], elements=elements)

class netinfra_inter__netinfra(yang.adata.MNode):
    router: netinfra_inter__netinfra__router
    backbone_link: netinfra_inter__netinfra__backbone_link
    ibgp_fullmesh: netinfra_inter__netinfra__ibgp_fullmesh

    mut def __init__(self, router: list[netinfra_inter__netinfra__router_entry]=[], backbone_link: list[netinfra_inter__netinfra__backbone_link_entry]=[], ibgp_fullmesh: list[netinfra_inter__netinfra__ibgp_fullmesh_entry]=[]):
        self._ns = 'http://example.com/netinfra-inter'
        self.router = netinfra_inter__netinfra__router(elements=router)
        self.backbone_link = netinfra_inter__netinfra__backbone_link(elements=backbone_link)
        self.ibgp_fullmesh = netinfra_inter__netinfra__ibgp_fullmesh(elements=ibgp_fullmesh)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _router = self.router
        if _router is not None:
            children['router'] = _router.to_gdata()
        _backbone_link = self.backbone_link
        if _backbone_link is not None:
            children['backbone-link'] = _backbone_link.to_gdata()
        _ibgp_fullmesh = self.ibgp_fullmesh
        if _ibgp_fullmesh is not None:
            children['ibgp-fullmesh'] = _ibgp_fullmesh.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/netinfra-inter', module='netinfra-inter')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> netinfra_inter__netinfra:
        if n != None:
            return netinfra_inter__netinfra(router=netinfra_inter__netinfra__router.from_gdata(n.get_opt_list('router')), backbone_link=netinfra_inter__netinfra__backbone_link.from_gdata(n.get_opt_list('backbone-link')), ibgp_fullmesh=netinfra_inter__netinfra__ibgp_fullmesh.from_gdata(n.get_opt_list('ibgp-fullmesh')))
        return netinfra_inter__netinfra()


mut def from_xml_netinfra_inter__netinfra(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_router = yang.gdata.from_xml_opt_list(node, 'router')
    yang.gdata.maybe_add(children, 'router', from_xml_netinfra_inter__netinfra__router, child_router)
    child_backbone_link = yang.gdata.from_xml_opt_list(node, 'backbone-link')
    yang.gdata.maybe_add(children, 'backbone-link', from_xml_netinfra_inter__netinfra__backbone_link, child_backbone_link)
    child_ibgp_fullmesh = yang.gdata.from_xml_opt_list(node, 'ibgp-fullmesh')
    yang.gdata.maybe_add(children, 'ibgp-fullmesh', from_xml_netinfra_inter__netinfra__ibgp_fullmesh, child_ibgp_fullmesh)
    return yang.gdata.Container(children, ns='http://example.com/netinfra-inter', module='netinfra-inter')

mut def from_json_path_netinfra_inter__netinfra(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'router':
            child = {'router': from_json_path_netinfra_inter__netinfra__router(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/netinfra-inter', module='netinfra-inter')
        if point == 'backbone-link':
            child = {'backbone-link': from_json_path_netinfra_inter__netinfra__backbone_link(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/netinfra-inter', module='netinfra-inter')
        if point == 'ibgp-fullmesh':
            child = {'ibgp-fullmesh': from_json_path_netinfra_inter__netinfra__ibgp_fullmesh(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/netinfra-inter', module='netinfra-inter')
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_netinfra_inter__netinfra(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_netinfra_inter__netinfra(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_router = yang.gdata.take_json_opt_list(jd, 'router')
    yang.gdata.maybe_add(children, 'router', from_json_netinfra_inter__netinfra__router, child_router)
    child_backbone_link = yang.gdata.take_json_opt_list(jd, 'backbone-link')
    yang.gdata.maybe_add(children, 'backbone-link', from_json_netinfra_inter__netinfra__backbone_link, child_backbone_link)
    child_ibgp_fullmesh = yang.gdata.take_json_opt_list(jd, 'ibgp-fullmesh')
    yang.gdata.maybe_add(children, 'ibgp-fullmesh', from_json_netinfra_inter__netinfra__ibgp_fullmesh, child_ibgp_fullmesh)
    return yang.gdata.Container(children, ns='http://example.com/netinfra-inter', module='netinfra-inter')

mut def from_json_l3vpn_inter__l3vpns__l3vpn__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_l3vpn_inter__l3vpns__l3vpn__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_l3vpn_inter__l3vpns__l3vpn__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__device(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__device(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__site(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__site(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__site_network_access(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__site_network_access(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__provider_ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__provider_ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__customer_ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__customer_ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__ipv4_prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__ipv4_prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp__as_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp__as_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(yang.adata.MNode):
    as_number: ?int

    mut def __init__(self, as_number: ?int):
        self._ns = 'http://example.com/l3vpn-inter'
        self.as_number = as_number

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _as_number = self.as_number
        if _as_number is not None:
            children['as-number'] = yang.gdata.Leaf('uint32', _as_number)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?l3vpn_inter__l3vpns__l3vpn__endpoint__bgp:
        if n != None:
            return l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(as_number=n.get_opt_int('as-number'))
        return None


mut def from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_as_number = yang.gdata.from_xml_int(node, 'as-number')
    yang.gdata.maybe_add(children, 'as-number', from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp__as_number, child_as_number)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'as-number':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_as_number = yang.gdata.take_json_int(jd, 'as-number')
    yang.gdata.maybe_add(children, 'as-number', from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp__as_number, child_as_number)
    return yang.gdata.Container(children, presence=True)

class l3vpn_inter__l3vpns__l3vpn__endpoint_entry(yang.adata.MNode):
    device: str
    interface: str
    site: ?str
    site_network_access: ?str
    provider_ipv4_address: ?str
    customer_ipv4_address: ?str
    ipv4_prefix_length: ?int
    bgp: ?l3vpn_inter__l3vpns__l3vpn__endpoint__bgp

    mut def __init__(self, device: str, interface: str, site: ?str, site_network_access: ?str, provider_ipv4_address: ?str, customer_ipv4_address: ?str, ipv4_prefix_length: ?int, bgp: ?l3vpn_inter__l3vpns__l3vpn__endpoint__bgp=None):
        self._ns = 'http://example.com/l3vpn-inter'
        self.device = device
        self.interface = interface
        self.site = site
        self.site_network_access = site_network_access
        self.provider_ipv4_address = provider_ipv4_address
        self.customer_ipv4_address = customer_ipv4_address
        self.ipv4_prefix_length = ipv4_prefix_length
        self.bgp = bgp

    mut def create_bgp(self, as_number):
        res = l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(as_number)
        self.bgp = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _device = self.device
        if _device is not None:
            children['device'] = yang.gdata.Leaf('string', _device)
        _interface = self.interface
        if _interface is not None:
            children['interface'] = yang.gdata.Leaf('string', _interface)
        _site = self.site
        if _site is not None:
            children['site'] = yang.gdata.Leaf('string', _site)
        _site_network_access = self.site_network_access
        if _site_network_access is not None:
            children['site-network-access'] = yang.gdata.Leaf('string', _site_network_access)
        _provider_ipv4_address = self.provider_ipv4_address
        if _provider_ipv4_address is not None:
            children['provider-ipv4-address'] = yang.gdata.Leaf('string', _provider_ipv4_address)
        _customer_ipv4_address = self.customer_ipv4_address
        if _customer_ipv4_address is not None:
            children['customer-ipv4-address'] = yang.gdata.Leaf('string', _customer_ipv4_address)
        _ipv4_prefix_length = self.ipv4_prefix_length
        if _ipv4_prefix_length is not None:
            children['ipv4-prefix-length'] = yang.gdata.Leaf('uint8', _ipv4_prefix_length)
        _bgp = self.bgp
        if _bgp is not None:
            children['bgp'] = _bgp.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.device), yang.gdata.yang_str(self.interface)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> l3vpn_inter__l3vpns__l3vpn__endpoint_entry:
        return l3vpn_inter__l3vpns__l3vpn__endpoint_entry(device=n.get_str('device'), interface=n.get_str('interface'), site=n.get_opt_str('site'), site_network_access=n.get_opt_str('site-network-access'), provider_ipv4_address=n.get_opt_str('provider-ipv4-address'), customer_ipv4_address=n.get_opt_str('customer-ipv4-address'), ipv4_prefix_length=n.get_opt_int('ipv4-prefix-length'), bgp=l3vpn_inter__l3vpns__l3vpn__endpoint__bgp.from_gdata(n.get_opt_container('bgp')))

class l3vpn_inter__l3vpns__l3vpn__endpoint(yang.adata.MNode):
    elements: list[l3vpn_inter__l3vpns__l3vpn__endpoint_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/l3vpn-inter'
        self._name = 'endpoint'
        self.elements = elements

    mut def create(self, device, interface, site, site_network_access, provider_ipv4_address, ipv4_prefix_length):
        for e in self.elements:
            match = True
            if e.device != device:
                match = False
                continue
            if e.interface != interface:
                match = False
                continue
            if match:
                return e

        res = l3vpn_inter__l3vpns__l3vpn__endpoint_entry(device, interface, site, site_network_access, provider_ipv4_address, ipv4_prefix_length)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['device', 'interface'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[l3vpn_inter__l3vpns__l3vpn__endpoint_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(l3vpn_inter__l3vpns__l3vpn__endpoint_entry.from_gdata(e))
        return res


mut def from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_device = yang.gdata.from_xml_str(node, 'device')
    yang.gdata.maybe_add(children, 'device', from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__device, child_device)
    child_interface = yang.gdata.from_xml_str(node, 'interface')
    yang.gdata.maybe_add(children, 'interface', from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__interface, child_interface)
    child_site = yang.gdata.from_xml_str(node, 'site')
    yang.gdata.maybe_add(children, 'site', from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__site, child_site)
    child_site_network_access = yang.gdata.from_xml_str(node, 'site-network-access')
    yang.gdata.maybe_add(children, 'site-network-access', from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__site_network_access, child_site_network_access)
    child_provider_ipv4_address = yang.gdata.from_xml_str(node, 'provider-ipv4-address')
    yang.gdata.maybe_add(children, 'provider-ipv4-address', from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__provider_ipv4_address, child_provider_ipv4_address)
    child_customer_ipv4_address = yang.gdata.from_xml_opt_str(node, 'customer-ipv4-address')
    yang.gdata.maybe_add(children, 'customer-ipv4-address', from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__customer_ipv4_address, child_customer_ipv4_address)
    child_ipv4_prefix_length = yang.gdata.from_xml_int(node, 'ipv4-prefix-length')
    yang.gdata.maybe_add(children, 'ipv4-prefix-length', from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__ipv4_prefix_length, child_ipv4_prefix_length)
    child_bgp = yang.gdata.from_xml_opt_cnt(node, 'bgp')
    yang.gdata.maybe_add(children, 'bgp', from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp, child_bgp)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_device), yang.gdata.yang_str(child_interface)])

mut def from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = []
    for e in nodes:
        elements.append(from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint_element(e))
    return yang.gdata.List(keys=['device', 'interface'], elements=elements)

mut def from_json_path_l3vpn_inter__l3vpns__l3vpn__endpoint_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['device'] = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__device(keys[0])
        children['interface'] = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__interface(keys[1])
        if point == 'site':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'site-network-access':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'provider-ipv4-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-ipv4-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bgp':
            children['bgp'] = from_json_path_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_l3vpn_inter__l3vpns__l3vpn__endpoint(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['device', 'interface']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_l3vpn_inter__l3vpns__l3vpn__endpoint_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['device', 'interface'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['device', 'interface'], [from_json_path_l3vpn_inter__l3vpns__l3vpn__endpoint_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_device = yang.gdata.take_json_str(jd, 'device')
    yang.gdata.maybe_add(children, 'device', from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__device, child_device)
    child_interface = yang.gdata.take_json_str(jd, 'interface')
    yang.gdata.maybe_add(children, 'interface', from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__interface, child_interface)
    child_site = yang.gdata.take_json_str(jd, 'site')
    yang.gdata.maybe_add(children, 'site', from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__site, child_site)
    child_site_network_access = yang.gdata.take_json_str(jd, 'site-network-access')
    yang.gdata.maybe_add(children, 'site-network-access', from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__site_network_access, child_site_network_access)
    child_provider_ipv4_address = yang.gdata.take_json_str(jd, 'provider-ipv4-address')
    yang.gdata.maybe_add(children, 'provider-ipv4-address', from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__provider_ipv4_address, child_provider_ipv4_address)
    child_customer_ipv4_address = yang.gdata.take_json_opt_str(jd, 'customer-ipv4-address')
    yang.gdata.maybe_add(children, 'customer-ipv4-address', from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__customer_ipv4_address, child_customer_ipv4_address)
    child_ipv4_prefix_length = yang.gdata.take_json_int(jd, 'ipv4-prefix-length')
    yang.gdata.maybe_add(children, 'ipv4-prefix-length', from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__ipv4_prefix_length, child_ipv4_prefix_length)
    child_bgp = yang.gdata.take_json_opt_cnt(jd, 'bgp')
    yang.gdata.maybe_add(children, 'bgp', from_json_l3vpn_inter__l3vpns__l3vpn__endpoint__bgp, child_bgp)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_device), yang.gdata.yang_str(child_interface)])

mut def from_json_l3vpn_inter__l3vpns__l3vpn__endpoint(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_l3vpn_inter__l3vpns__l3vpn__endpoint_element(e))
    return yang.gdata.List(keys=['device', 'interface'], elements=elements)

class l3vpn_inter__l3vpns__l3vpn_entry(yang.adata.MNode):
    name: str
    description: ?str
    endpoint: l3vpn_inter__l3vpns__l3vpn__endpoint

    mut def __init__(self, name: str, description: ?str, endpoint: list[l3vpn_inter__l3vpns__l3vpn__endpoint_entry]=[]):
        self._ns = 'http://example.com/l3vpn-inter'
        self.name = name
        self.description = description
        self.endpoint = l3vpn_inter__l3vpns__l3vpn__endpoint(elements=endpoint)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        _endpoint = self.endpoint
        if _endpoint is not None:
            children['endpoint'] = _endpoint.to_gdata()
        return yang.gdata.Container(children, [yang.gdata.yang_str(self.name)])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> l3vpn_inter__l3vpns__l3vpn_entry:
        return l3vpn_inter__l3vpns__l3vpn_entry(name=n.get_str('name'), description=n.get_opt_str('description'), endpoint=l3vpn_inter__l3vpns__l3vpn__endpoint.from_gdata(n.get_opt_list('endpoint')))

class l3vpn_inter__l3vpns__l3vpn(yang.adata.MNode):
    elements: list[l3vpn_inter__l3vpns__l3vpn_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/l3vpn-inter'
        self._name = 'l3vpn'
        self.elements = elements

    mut def create(self, name):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = l3vpn_inter__l3vpns__l3vpn_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[l3vpn_inter__l3vpns__l3vpn_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(l3vpn_inter__l3vpns__l3vpn_entry.from_gdata(e))
        return res


mut def from_xml_l3vpn_inter__l3vpns__l3vpn_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_l3vpn_inter__l3vpns__l3vpn__name, child_name)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_xml_l3vpn_inter__l3vpns__l3vpn__description, child_description)
    child_endpoint = yang.gdata.from_xml_opt_list(node, 'endpoint')
    yang.gdata.maybe_add(children, 'endpoint', from_xml_l3vpn_inter__l3vpns__l3vpn__endpoint, child_endpoint)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_name)])

mut def from_xml_l3vpn_inter__l3vpns__l3vpn(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = []
    for e in nodes:
        elements.append(from_xml_l3vpn_inter__l3vpns__l3vpn_element(e))
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_json_path_l3vpn_inter__l3vpns__l3vpn_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_l3vpn_inter__l3vpns__l3vpn_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_l3vpn_inter__l3vpns__l3vpn__name(keys[0])
        if point == 'description':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'endpoint':
            children['endpoint'] = from_json_path_l3vpn_inter__l3vpns__l3vpn__endpoint(jd, rest_path, op)
        return yang.gdata.Container(children, keys)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_l3vpn_inter__l3vpns__l3vpn(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_l3vpn_inter__l3vpns__l3vpn_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_l3vpn_inter__l3vpns__l3vpn_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_l3vpn_inter__l3vpns__l3vpn_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_l3vpn_inter__l3vpns__l3vpn__name, child_name)
    child_description = yang.gdata.take_json_opt_str(jd, 'description')
    yang.gdata.maybe_add(children, 'description', from_json_l3vpn_inter__l3vpns__l3vpn__description, child_description)
    child_endpoint = yang.gdata.take_json_opt_list(jd, 'endpoint')
    yang.gdata.maybe_add(children, 'endpoint', from_json_l3vpn_inter__l3vpns__l3vpn__endpoint, child_endpoint)
    return yang.gdata.Container(children, [yang.gdata.yang_str(child_name)])

mut def from_json_l3vpn_inter__l3vpns__l3vpn(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_l3vpn_inter__l3vpns__l3vpn_element(e))
    return yang.gdata.List(keys=['name'], elements=elements)

class l3vpn_inter__l3vpns(yang.adata.MNode):
    l3vpn: l3vpn_inter__l3vpns__l3vpn

    mut def __init__(self, l3vpn: list[l3vpn_inter__l3vpns__l3vpn_entry]=[]):
        self._ns = 'http://example.com/l3vpn-inter'
        self.l3vpn = l3vpn_inter__l3vpns__l3vpn(elements=l3vpn)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _l3vpn = self.l3vpn
        if _l3vpn is not None:
            children['l3vpn'] = _l3vpn.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/l3vpn-inter', module='l3vpn-inter')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> l3vpn_inter__l3vpns:
        if n != None:
            return l3vpn_inter__l3vpns(l3vpn=l3vpn_inter__l3vpns__l3vpn.from_gdata(n.get_opt_list('l3vpn')))
        return l3vpn_inter__l3vpns()


mut def from_xml_l3vpn_inter__l3vpns(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_l3vpn = yang.gdata.from_xml_opt_list(node, 'l3vpn')
    yang.gdata.maybe_add(children, 'l3vpn', from_xml_l3vpn_inter__l3vpns__l3vpn, child_l3vpn)
    return yang.gdata.Container(children, ns='http://example.com/l3vpn-inter', module='l3vpn-inter')

mut def from_json_path_l3vpn_inter__l3vpns(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'l3vpn':
            child = {'l3vpn': from_json_path_l3vpn_inter__l3vpns__l3vpn(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/l3vpn-inter', module='l3vpn-inter')
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_l3vpn_inter__l3vpns(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_l3vpn_inter__l3vpns(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l3vpn = yang.gdata.take_json_opt_list(jd, 'l3vpn')
    yang.gdata.maybe_add(children, 'l3vpn', from_json_l3vpn_inter__l3vpns__l3vpn, child_l3vpn)
    return yang.gdata.Container(children, ns='http://example.com/l3vpn-inter', module='l3vpn-inter')

class root(yang.adata.MNode):
    netinfra: netinfra_inter__netinfra
    l3vpns: l3vpn_inter__l3vpns

    mut def __init__(self, netinfra: ?netinfra_inter__netinfra=None, l3vpns: ?l3vpn_inter__l3vpns=None):
        self._ns = ''
        self.netinfra = netinfra if netinfra is not None else netinfra_inter__netinfra()
        self.l3vpns = l3vpns if l3vpns is not None else l3vpn_inter__l3vpns()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _netinfra = self.netinfra
        if _netinfra is not None:
            children['netinfra'] = _netinfra.to_gdata()
        _l3vpns = self.l3vpns
        if _l3vpns is not None:
            children['l3vpns'] = _l3vpns.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> root:
        if n != None:
            return root(netinfra=netinfra_inter__netinfra.from_gdata(n.get_opt_container('netinfra')), l3vpns=l3vpn_inter__l3vpns.from_gdata(n.get_opt_container('l3vpns')))
        return root()


mut def from_xml(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_netinfra = yang.gdata.from_xml_opt_cnt(node, 'netinfra', 'http://example.com/netinfra-inter')
    yang.gdata.maybe_add(children, 'netinfra', from_xml_netinfra_inter__netinfra, child_netinfra)
    child_l3vpns = yang.gdata.from_xml_opt_cnt(node, 'l3vpns', 'http://example.com/l3vpn-inter')
    yang.gdata.maybe_add(children, 'l3vpns', from_xml_l3vpn_inter__l3vpns, child_l3vpns)
    return yang.gdata.Container(children)

mut def from_json_path(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'netinfra-inter:netinfra':
            child = {'netinfra': from_json_path_netinfra_inter__netinfra(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l3vpn-inter:l3vpns':
            child = {'l3vpns': from_json_path_l3vpn_inter__l3vpns(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_netinfra = yang.gdata.take_json_opt_cnt(jd, 'netinfra', 'netinfra-inter')
    yang.gdata.maybe_add(children, 'netinfra', from_json_netinfra_inter__netinfra, child_netinfra)
    child_l3vpns = yang.gdata.take_json_opt_cnt(jd, 'l3vpns', 'l3vpn-inter')
    yang.gdata.maybe_add(children, 'l3vpns', from_json_l3vpn_inter__l3vpns, child_l3vpns)
    return yang.gdata.Container(children)

schema_namespaces: set[str] = {
    'http://example.com/netinfra-inter',
    'http://example.com/l3vpn-inter',
}
