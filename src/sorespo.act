import argparse
import file
import json
import logging
import http
import net
import xml

import http_router.router

import orchestron.device as odev
import orchestron.http as orch_http
import orchestron.ttt as ttt
import orchestron.device_meta_config    # TODO: remove https://github.com/actonlang/acton/issues/2390

import yang
import yang.adata
import yang.gdata
import yang.gen3

import tmf.http as tmf_http
import tmf.tmf633
import tmf.tmf640

import sorespo.layers
import sorespo.layers.y_0_loose as cfs_layer
import sorespo.layers.y_0
import sorespo.layers.y_1
import sorespo.layers.y_2
import sorespo.layers.y_3

import sorespo.layers.y_0_loose
import sorespo.layers.y_1_loose
import sorespo.layers.y_2_loose
import sorespo.layers.y_3_loose

import sorespo.sysspec
import sorespo.tmf

import testing

class Unreachable(Exception):
    """Exception raised when code is unreachable."""
    pass

def rfs_for_device(dev):
    return yang.gdata.Container({
        'rfs': yang.gdata.List(["name"], [
            yang.gdata.Container({
                "name": yang.gdata.Leaf("string", dev)
            })
        ])
    })

def adata_for_layer(layer, gdata):
    if layer == 0:
        return sorespo.layers.y_0_loose.root.from_gdata(gdata)
    elif layer == 1:
        return sorespo.layers.y_1_loose.root.from_gdata(gdata)
    elif layer == 2:
        return sorespo.layers.y_2_loose.root.from_gdata(gdata)
    elif layer == 3:
        # Layer 3 (device) is a bit special, in that there is more than one adata tree:
        # 1. The device manager, defined in orchestron-device.yang
        # 2. The device configuration, defined in the device's own YANG model
        # The contents of layer 3 (gdata) is a combination of both, but to
        # reconstruct adata, we must pick whether we want the internal device
        # manager or the device configuration. Here we return the device manager tree.
        return sorespo.layers.y_3_loose.root.from_gdata(gdata)
    else:
        raise ValueError("Invalid layer: {layer}")

actor main(env):
    rfcap = file.ReadFileCap(file.FileCap(env.cap))
    tcpl_cap = net.TCPListenCap(net.TCPCap(net.NetCap(env.cap)))

    logh = logging.Handler("Otron")
    logh.add_sink(logging.StdoutSink())
    logh.set_output_level(logging.TRACE)

    logh_http = logging.Handler("HTTP")
    logh_http.set_handler(logh)
    logh_http.set_output_level(logging.DEBUG)

    logh_ttt = logging.Handler("TTT")
    logh_ttt.set_handler(logh)
    logh_ttt.set_output_level(logging.INFO)

    logh_dev = logging.Handler("Dev")
    logh_dev.set_handler(logh)

    log = logging.Logger(logh)

    print("Compiling schema...")
    top_schema = yang.compile(sorespo.layers.y_0.src_yang())
    print("Schema compile done")

    dev_registry = odev.DeviceRegistry(sorespo.sysspec.device_types, env.cap, logh_dev)
    cfs = sorespo.layers.get_layers(dev_registry, logh_ttt)
    rfs = cfs.below().below()
    dev_registry.on_reconf(lambda dev: rfs.edit_config(rfs_for_device(dev), force=True))

    # Initialize HTTP router
    router = http_router.router.Router(logh_http)

    # TMF service creation handler
    # TODO: Move this over to TMF http as well?
    def handle_tmf_service_create(request, respond):
        """POST /tmf-api/ServiceActivationAndConfiguration/v4/service
        
        This handler requires nested callbacks for async config operations,
        which causes compiler issues when defined inside an actor method.
        """
        tmf_id = ""
        
        def config_done(result):
            if isinstance(result, Exception):
                respond(400, {}, json.encode({"status": "error", "message": str(result)}))
            else:
                tmf_id_str = str(tmf_id)
                if tmf_id_str != "":
                    respond(201, {"Location": f"/tmf-api/ServiceActivationAndConfiguration/v4/service/{tmf_id_str}"}, 
                           json.encode({"id": tmf_id_str, "status": "created"}))
                else:
                    respond(404, {}, "Service not found")
        
        try:
            data = json.decode(request.body.decode())
            gd, tmf_id = tmf.tmf640.json_to_gdata(sorespo.tmf.tmf_spec, data, top_schema)
            session = cfs.newsession()
            session.edit_config(gd, config_done)
        except Exception as e:
            respond(400, {}, f"Error creating service: {e}")

    # Device Router - pass main router for context access
    device_router_actor = orch_http.DeviceRouter(dev_registry, router)
    device_subrouter = device_router_actor.create_device_router()
    router.mount("/device", device_subrouter)    
    config_queue_subrouter = device_router_actor.create_config_queue_router()
    router.mount("/config-queue", config_queue_subrouter)
    
    # Layer Router - pass main router for context access
    layer_router_actor = orch_http.LayerRouter(cfs, router)
    layer_subrouter = layer_router_actor.create_router()
    router.mount("/layer", layer_subrouter)

    # Restconf Router
    restconf_router_actor = orch_http.RestconfRouter(cfs, top_schema)
    restconf_subrouter = restconf_router_actor.create_router()
    router.mount("/restconf", restconf_subrouter)
    
    # TMF Router - pass main router for context access
    tmf_router_actor = tmf_http.TMFRouter(sorespo.tmf.tmf_spec, top_schema, cfs, handle_tmf_service_create, router)
    tmf_subrouter = tmf_router_actor.create_router()
    router.mount("/tmf-api", tmf_subrouter)

    # HTTP server callbacks
    def on_request(server, request, respond):
        path_without_query = http_router.router.strip_query_string(request.path)
        clean_request = http.Request(request.method, path_without_query, request.version, request.headers, request.body)
        if router.handle_request(server, clean_request, respond):
            return
        respond(404, {}, "Not found")

    def on_error(server, error):
        log.error("HTTP server error", {"error": str(error)})

    def on_accept(server):
        server.cb_install(on_request, on_error)
    
    http.Listener(tcpl_cap, "::", 80, on_accept, log_handler=logh_http)

    configs = []
    env_exit_on_done = env.getenv("EXIT_ON_DONE")
    exit_on_done = env_exit_on_done if env_exit_on_done is not None else ""

    def _conf_file(session):

        def _conf_file_done(config, result):
            if isinstance(result, str):
                log.info("Config file successfully applied", {"config_file": config.filename})
                _conf_file(session)
            else:
                log.error("Error applying config file", {"config_file": config.filename})

        try:
            config = configs.pop(0)
            # Grab the first config
            log.info("Applying config file...", {"config_file": config.filename})
            input_config = yang.gen3.from_data(top_schema, config.config, loose=True)
            session.edit_config(input_config, None, lambda result: _conf_file_done(config, result))
        except IndexError:
            log.info("All config files applied")
            # TODO: exit_on_done.lower() once Acton bug is fixed!?
            if exit_on_done in ["1", "true", "yes"]:
                log.info("No more config files to apply, exiting..")
                after 3: _exit()

    def _exit():
        env.exit(0)

    if len(env.argv) > 1:
        # Read and apply config files, but paced
        for i in range(1, len(env.argv)):
            if i > 0:
                filename = env.argv[i]
                f = file.ReadFile(rfcap, filename)
                nb_input = await async f.read()
                f.close()
                try:
                    configs.append((filename=filename, config=xml.decode(nb_input.decode())))
                except Exception as e:
                    print("Error reading config file {filename}: {e}")
                    env.exit(1)

        # start to apply..
        after 0.5: _conf_file(cfs.newsession())

    print("Orchestron/sorespo running..")
