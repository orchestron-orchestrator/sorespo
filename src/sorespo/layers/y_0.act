import base64
import json
import xml
import yang
import yang.adata
import yang.gdata
import yang.gen3
from yang.identity import complete_and_validate_identityref
from yang.identityref import Identityref, PartialIdentityref
from yang.schema import DIdentity

# == This file is generated ==


_base_ietf_l3vpn_svc_site_network_access_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-network-access-type', base=[])
_base_ietf_l3vpn_svc_placement_diversity = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='placement-diversity', base=[])
_base_ietf_l3vpn_svc_customer_application = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application', base=[])
_base_ietf_l3vpn_svc_site_vpn_flavor = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor', base=[])
_base_ietf_l3vpn_svc_management = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='management', base=[])
_base_ietf_l3vpn_svc_address_allocation_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-allocation-type', base=[])
_base_ietf_l3vpn_svc_site_role = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-role', base=[])
_base_ietf_l3vpn_svc_vpn_topology = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-topology', base=[])
_base_ietf_l3vpn_svc_multicast_tree_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-tree-type', base=[])
_base_ietf_l3vpn_svc_multicast_rp_discovery_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-rp-discovery-type', base=[])
_base_ietf_l3vpn_svc_routing_protocol_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing-protocol-type', base=[])
_base_ietf_l3vpn_svc_protocol_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type', base=[])
_base_ietf_l3vpn_svc_vpn_policy_filter_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-policy-filter-type', base=[])
_base_ietf_l3vpn_svc_qos_profile_direction = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='qos-profile-direction', base=[])
_identities = [
    _base_ietf_l3vpn_svc_site_network_access_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='point-to-point', base=[_base_ietf_l3vpn_svc_site_network_access_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multipoint', base=[_base_ietf_l3vpn_svc_site_network_access_type]),
    _base_ietf_l3vpn_svc_placement_diversity,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bearer-diverse', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='pe-diverse', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='pop-diverse', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='linecard-diverse', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='same-pe', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='same-bearer', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    _base_ietf_l3vpn_svc_customer_application,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='web', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='mail', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='file-transfer', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='database', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='social', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='games', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='p2p', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='network-management', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='voice', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='video', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='embb', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='urllc', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='mmtc', base=[_base_ietf_l3vpn_svc_customer_application]),
    _base_ietf_l3vpn_svc_site_vpn_flavor,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-single', base=[_base_ietf_l3vpn_svc_site_vpn_flavor]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-multi', base=[_base_ietf_l3vpn_svc_site_vpn_flavor]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-sub', base=[_base_ietf_l3vpn_svc_site_vpn_flavor]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-nni', base=[_base_ietf_l3vpn_svc_site_vpn_flavor]),
    _base_ietf_l3vpn_svc_management,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='co-managed', base=[_base_ietf_l3vpn_svc_management]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-managed', base=[_base_ietf_l3vpn_svc_management]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-managed', base=[_base_ietf_l3vpn_svc_management]),
    _base_ietf_l3vpn_svc_address_allocation_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-dhcp', base=[_base_ietf_l3vpn_svc_address_allocation_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-dhcp-relay', base=[_base_ietf_l3vpn_svc_address_allocation_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-dhcp-slaac', base=[_base_ietf_l3vpn_svc_address_allocation_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='static-address', base=[_base_ietf_l3vpn_svc_address_allocation_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='slaac', base=[_base_ietf_l3vpn_svc_address_allocation_type]),
    _base_ietf_l3vpn_svc_site_role,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='any-to-any-role', base=[_base_ietf_l3vpn_svc_site_role]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='spoke-role', base=[_base_ietf_l3vpn_svc_site_role]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hub-role', base=[_base_ietf_l3vpn_svc_site_role]),
    _base_ietf_l3vpn_svc_vpn_topology,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='any-to-any', base=[_base_ietf_l3vpn_svc_vpn_topology]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hub-spoke', base=[_base_ietf_l3vpn_svc_vpn_topology]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hub-spoke-disjoint', base=[_base_ietf_l3vpn_svc_vpn_topology]),
    _base_ietf_l3vpn_svc_multicast_tree_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ssm-tree-type', base=[_base_ietf_l3vpn_svc_multicast_tree_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='asm-tree-type', base=[_base_ietf_l3vpn_svc_multicast_tree_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bidir-tree-type', base=[_base_ietf_l3vpn_svc_multicast_tree_type]),
    _base_ietf_l3vpn_svc_multicast_rp_discovery_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='auto-rp', base=[_base_ietf_l3vpn_svc_multicast_rp_discovery_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='static-rp', base=[_base_ietf_l3vpn_svc_multicast_rp_discovery_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bsr-rp', base=[_base_ietf_l3vpn_svc_multicast_rp_discovery_type]),
    _base_ietf_l3vpn_svc_routing_protocol_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ospf', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bgp', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='static', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rip', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vrrp', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='direct', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    _base_ietf_l3vpn_svc_protocol_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='tcp', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='udp', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='icmp', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='icmp6', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='gre', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipip', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hop-by-hop', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='esp', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ah', base=[_base_ietf_l3vpn_svc_protocol_type]),
    _base_ietf_l3vpn_svc_vpn_policy_filter_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv4', base=[_base_ietf_l3vpn_svc_vpn_policy_filter_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv6', base=[_base_ietf_l3vpn_svc_vpn_policy_filter_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lan', base=[_base_ietf_l3vpn_svc_vpn_policy_filter_type]),
    _base_ietf_l3vpn_svc_qos_profile_direction,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-to-wan', base=[_base_ietf_l3vpn_svc_qos_profile_direction]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='wan-to-site', base=[_base_ietf_l3vpn_svc_qos_profile_direction]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='both', base=[_base_ietf_l3vpn_svc_qos_profile_direction]),
]


# Identityref constants
ietf_l3vpn_svc_site_network_access_type = Identityref('site-network-access-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_point_to_point = Identityref('point-to-point', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_multipoint = Identityref('multipoint', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_placement_diversity = Identityref('placement-diversity', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_bearer_diverse = Identityref('bearer-diverse', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_pe_diverse = Identityref('pe-diverse', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_pop_diverse = Identityref('pop-diverse', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_linecard_diverse = Identityref('linecard-diverse', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_same_pe = Identityref('same-pe', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_same_bearer = Identityref('same-bearer', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_customer_application = Identityref('customer-application', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_web = Identityref('web', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_mail = Identityref('mail', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_file_transfer = Identityref('file-transfer', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_database = Identityref('database', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_social = Identityref('social', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_games = Identityref('games', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_p2p = Identityref('p2p', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_network_management = Identityref('network-management', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_voice = Identityref('voice', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_video = Identityref('video', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_embb = Identityref('embb', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_urllc = Identityref('urllc', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_mmtc = Identityref('mmtc', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_vpn_flavor = Identityref('site-vpn-flavor', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_vpn_flavor_single = Identityref('site-vpn-flavor-single', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_vpn_flavor_multi = Identityref('site-vpn-flavor-multi', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_vpn_flavor_sub = Identityref('site-vpn-flavor-sub', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_vpn_flavor_nni = Identityref('site-vpn-flavor-nni', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_management = Identityref('management', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_co_managed = Identityref('co-managed', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_customer_managed = Identityref('customer-managed', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_provider_managed = Identityref('provider-managed', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_address_allocation_type = Identityref('address-allocation-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_provider_dhcp = Identityref('provider-dhcp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_provider_dhcp_relay = Identityref('provider-dhcp-relay', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_provider_dhcp_slaac = Identityref('provider-dhcp-slaac', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_static_address = Identityref('static-address', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_slaac = Identityref('slaac', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_role = Identityref('site-role', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_any_to_any_role = Identityref('any-to-any-role', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_spoke_role = Identityref('spoke-role', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_hub_role = Identityref('hub-role', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_vpn_topology = Identityref('vpn-topology', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_any_to_any = Identityref('any-to-any', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_hub_spoke = Identityref('hub-spoke', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_hub_spoke_disjoint = Identityref('hub-spoke-disjoint', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_multicast_tree_type = Identityref('multicast-tree-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ssm_tree_type = Identityref('ssm-tree-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_asm_tree_type = Identityref('asm-tree-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_bidir_tree_type = Identityref('bidir-tree-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_multicast_rp_discovery_type = Identityref('multicast-rp-discovery-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_auto_rp = Identityref('auto-rp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_static_rp = Identityref('static-rp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_bsr_rp = Identityref('bsr-rp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_routing_protocol_type = Identityref('routing-protocol-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ospf = Identityref('ospf', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_bgp = Identityref('bgp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_static = Identityref('static', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_rip = Identityref('rip', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_vrrp = Identityref('vrrp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_direct = Identityref('direct', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_protocol_type = Identityref('protocol-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_tcp = Identityref('tcp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_udp = Identityref('udp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_icmp = Identityref('icmp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_icmp6 = Identityref('icmp6', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_gre = Identityref('gre', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ipip = Identityref('ipip', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_hop_by_hop = Identityref('hop-by-hop', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_routing = Identityref('routing', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_esp = Identityref('esp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ah = Identityref('ah', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_vpn_policy_filter_type = Identityref('vpn-policy-filter-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ipv4 = Identityref('ipv4', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ipv6 = Identityref('ipv6', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_lan = Identityref('lan', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_qos_profile_direction = Identityref('qos-profile-direction', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_to_wan = Identityref('site-to-wan', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_wan_to_site = Identityref('wan-to-site', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_both = Identityref('both', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')


def src_yang():
    res = []
    res.append(r"""module ietf-l3vpn-svc {
 yang-version 1.1;
 namespace "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc";
 prefix l3vpn-svc;
 import ietf-inet-types {
  prefix inet;
 }
 import ietf-yang-types {
  prefix yang;
 }
 organization
  "IETF L3SM Working Group";
 contact
  "WG List: <mailto:l3sm@ietf.org>
   Editor:
    L3SM WG
   Chairs:
    Adrian Farrel, Qin Wu
  ";
 description
 "This YANG module defines a generic service configuration
 model for Layer 3 VPNs. This model is common across all
 vendor implementations.

 Copyright (c) 2018 IETF Trust and the persons
 identified as authors of the code.  All rights reserved.

 Redistribution and use in source and binary forms, with or
 without modification, is permitted pursuant to, and subject
 to the license terms contained in, the Simplified BSD License
 set forth in Section 4.c of the IETF Trust's Legal Provisions
 Relating to IETF Documents
 (https://trustee.ietf.org/license-info).

 This version of this YANG module is part of RFC 8299; see
 the RFC itself for full legal notices.";

 revision 2018-01-19 {
  description
   "Revision of RFC 8049 to fix implementation issues.";
  reference
   "RFC 8299";
  }
 revision 2017-01-27 {
  description
  "Initial document.";
  reference
    "RFC 8049.";
  }
 /* Features */
 feature cloud-access {
  description
  "Allows the VPN to connect to a CSP.";
 }
 feature multicast {
  description
  "Enables multicast capabilities in a VPN.";
 }
 feature ipv4 {
  description
  "Enables IPv4 support in a VPN.";
 }
 feature ipv6 {
  description
  "Enables IPv6 support in a VPN.";
 }
 feature lan-tag {
  description
  "Enables LAN Tag support in a VPN Policy filter.";
 }
 feature carrierscarrier {
  description
  "Enables support of CsC.";
 }
 feature extranet-vpn {
  description
  "Enables support of extranet VPNs.";
 }
 feature site-diversity {
  description
  "Enables support of site diversity constraints.";
 }
 feature encryption {
  description
  "Enables support of encryption.";
 }
 feature qos {
  description
  "Enables support of classes of services.";
 }
 feature qos-custom {
  description
  "Enables support of the custom QoS profile.";
 }
 feature rtg-bgp {
  description
  "Enables support of the BGP routing protocol.";
 }
 feature rtg-rip {
  description
  "Enables support of the RIP routing protocol.";
 }
 feature rtg-ospf {
  description
  "Enables support of the OSPF routing protocol.";
 }
 feature rtg-ospf-sham-link {
  description
  "Enables support of OSPF sham links.";
 }
 feature rtg-vrrp {
  description
  "Enables support of the VRRP routing protocol.";
 }
 feature fast-reroute {
  description
  "Enables support of Fast Reroute.";
 }
 feature bfd {
  description
  "Enables support of BFD.";
 }
 feature always-on {
  description
  "Enables support of the 'always-on' access constraint.";
 }
 feature requested-type {
  description
  "Enables support of the 'requested-type' access constraint.";
 }
 feature bearer-reference {
  description
  "Enables support of the 'bearer-reference' access constraint.";
 }
 feature target-sites {
  description
  "Enables support of the 'target-sites' match flow parameter.";
 }
 /* Typedefs */
 typedef svc-id {
  type string;
  description
  "Defines a type of service component identifier.";
 }
 typedef template-id {
  type string;
  description
  "Defines a type of service template identifier.";
 }
 typedef address-family {
  type enumeration {
   enum ipv4 {
    description
    "IPv4 address family.";
   }
   enum ipv6 {
    description
    "IPv6 address family.";
   }
  }
  description
  "Defines a type for the address family.";
 }
 /* Identities */
 identity site-network-access-type {
  description
  "Base identity for site-network-access type.";
 }
 identity point-to-point {
  base site-network-access-type;
  description
  "Identity for point-to-point connection.";
 }
 identity multipoint {
  base site-network-access-type;
  description
  "Identity for multipoint connection.
  Example: Ethernet broadcast segment.";
 }
 identity placement-diversity {
  description
  "Base identity for site placement constraints.";
 }
 identity bearer-diverse {
  base placement-diversity;
  description
  "Identity for bearer diversity.
  The bearers should not use common elements.";
 }
 identity pe-diverse {
  base placement-diversity;
  description
  "Identity for PE diversity.";
 }
 identity pop-diverse {
  base placement-diversity;
  description
  "Identity for POP diversity.";
 }
 identity linecard-diverse {
  base placement-diversity;
  description
  "Identity for linecard diversity.";
 }
 identity same-pe {
  base placement-diversity;
  description
  "Identity for having sites connected on the same PE.";
 }
 identity same-bearer {
  base placement-diversity;
  description
  "Identity for having sites connected using the same bearer.";
 }
 identity customer-application {
  description
  "Base identity for customer application.";
 }
 identity web {
  base customer-application;
  description
  "Identity for Web application (e.g., HTTP, HTTPS).";
 }
 identity mail {
  base customer-application;
  description
  "Identity for mail application.";
 }
 identity file-transfer {
  base customer-application;
  description
  "Identity for file transfer application (e.g., FTP, SFTP).";
 }
 identity database {
  base customer-application;
  description
  "Identity for database application.";
 }
 identity social {
  base customer-application;
  description
  "Identity for social-network application.";
 }
 identity games {
  base customer-application;
  description
  "Identity for gaming application.";
 }
 identity p2p {
  base customer-application;
  description
  "Identity for peer-to-peer application.";
 }
 identity network-management {
  base customer-application;
  description
  "Identity for management application
  (e.g., Telnet, syslog, SNMP).";
 }
 identity voice {
  base customer-application;
  description
  "Identity for voice application.";
 }
 identity video {
  base customer-application;
  description
  "Identity for video conference application.";
 }
 identity embb {
  base customer-application;
  description
  "Identity for an enhanced Mobile Broadband (eMBB)
  application.  Note that an eMBB application demands
  network performance with a wide variety of
  characteristics, such as data rate, latency,
  loss rate, reliability, and many other parameters.";
}
identity urllc {
  base customer-application;
  description
  "Identity for an Ultra-Reliable and Low Latency
  Communications (URLLC) application.  Note that a
  URLLC application demands network performance
  with a wide variety of characteristics, such as latency,
  reliability, and many other parameters.";
 }
 identity mmtc {
   base customer-application;
   description
   "Identity for a massive Machine Type
   Communications (mMTC) application.  Note that an
   mMTC application demands network performance
   with a wide variety of characteristics, such as data
   rate, latency, loss rate, reliability, and many
   other parameters.";
 }
 identity site-vpn-flavor {
  description
  "Base identity for the site VPN service flavor.";
 }
 identity site-vpn-flavor-single {
  base site-vpn-flavor;
  description
  "Base identity for the site VPN service flavor.
  Used when the site belongs to only one VPN.";
 }
 identity site-vpn-flavor-multi {
  base site-vpn-flavor;
  description
  "Base identity for the site VPN service flavor.
  Used when a logical connection of a site
  belongs to multiple VPNs.";
 }
 identity site-vpn-flavor-sub {
  base site-vpn-flavor;
  description
  "Base identity for the site VPN service flavor.
  Used when a site has multiple logical connections.
  Each connection may belong to different multiple VPNs.";
 }
 identity site-vpn-flavor-nni {
  base site-vpn-flavor;
  description
  "Base identity for the site VPN service flavor.
  Used to describe an NNI option A connection.";
 }
 identity management {
  description
  "Base identity for site management scheme.";
 }
 identity co-managed {
  base management;
  description
  "Base identity for co-managed site.";
 }
 identity customer-managed {
  base management;
  description
  "Base identity for customer-managed site.";
 }
 identity provider-managed {
  base management;
  description
  "Base identity for provider-managed site.";
 }
 identity address-allocation-type {
  description
  "Base identity for address-allocation-type for PE-CE link.";
 }
 identity provider-dhcp {
  base address-allocation-type;
  description
  "Provider network provides DHCP service to customer.";
 }
 identity provider-dhcp-relay {
  base address-allocation-type;
  description
  "Provider network provides DHCP relay service to customer.";
 }
 identity provider-dhcp-slaac {
  base address-allocation-type;
  description
  "Provider network provides DHCP service to customer,
  as well as SLAAC.";
 }
 identity static-address {
  base address-allocation-type;
  description
  "Provider-to-customer addressing is static.";
 }
 identity slaac {
  base address-allocation-type;
  description
  "Use IPv6 SLAAC.";
 }
 identity site-role {
  description
  "Base identity for site type.";
 }
 identity any-to-any-role {
  base site-role;
  description
  "Site in an any-to-any IP VPN.";
 }
 identity spoke-role {
  base site-role;
  description
  "Spoke site in a Hub-and-Spoke IP VPN.";
 }
 identity hub-role {
  base site-role;
  description
  "Hub site in a Hub-and-Spoke IP VPN.";
 }
 identity vpn-topology {
  description
  "Base identity for VPN topology.";
 }
 identity any-to-any {
  base vpn-topology;
  description
  "Identity for any-to-any VPN topology.";
 }
 identity hub-spoke {
  base vpn-topology;
  description
  "Identity for Hub-and-Spoke VPN topology.";
 }
 identity hub-spoke-disjoint {
  base vpn-topology;
  description
  "Identity for Hub-and-Spoke VPN topology
  where Hubs cannot communicate with each other.";
 }
 identity multicast-tree-type {
  description
  "Base identity for multicast tree type.";
 }
 identity ssm-tree-type {
  base multicast-tree-type;
  description
  "Identity for SSM tree type.";
 }
 identity asm-tree-type {
  base multicast-tree-type;
  description
  "Identity for ASM tree type.";
 }
 identity bidir-tree-type {
  base multicast-tree-type;
  description
  "Identity for bidirectional tree type.";
 }
 identity multicast-rp-discovery-type {
  description
  "Base identity for RP discovery type.";
 }
 identity auto-rp {
  base multicast-rp-discovery-type;
  description
  "Base identity for Auto-RP discovery type.";
 }
 identity static-rp {
  base multicast-rp-discovery-type;
  description
  "Base identity for static type.";
 }
 identity bsr-rp {
  base multicast-rp-discovery-type;
  description
  "Base identity for BSR discovery type.";
 }
 identity routing-protocol-type {
  description
  "Base identity for routing protocol type.";
 }
 identity ospf {
  base routing-protocol-type;
  description
  "Identity for OSPF protocol type.";
 }
 identity bgp {
  base routing-protocol-type;
  description
  "Identity for BGP protocol type.";
 }
 identity static {
  base routing-protocol-type;
  description
  "Identity for static routing protocol type.";
 }
 identity rip {
  base routing-protocol-type;
  description
  "Identity for RIP protocol type.";
 }
 identity vrrp {
  base routing-protocol-type;
  description
  "Identity for VRRP protocol type.
  This is to be used when LANs are directly connected
  to PE routers.";
 }
 identity direct {
  base routing-protocol-type;
  description
  "Identity for direct protocol type.";
 }
 identity protocol-type {
  description
  "Base identity for protocol field type.";
 }
 identity tcp {
  base protocol-type;
  description
  "TCP protocol type.";
 }
 identity udp {
  base protocol-type;
  description
  "UDP protocol type.";
 }

 identity icmp {
  base protocol-type;
  description
  "ICMP protocol type.";
 }
 identity icmp6 {
  base protocol-type;
  description
  "ICMPv6 protocol type.";
 }
 identity gre {
  base protocol-type;
  description
  "GRE protocol type.";
 }
 identity ipip {
  base protocol-type;
  description
  "IP-in-IP protocol type.";
 }
 identity hop-by-hop {
  base protocol-type;
  description
  "Hop-by-Hop IPv6 header type.";
 }
 identity routing {
  base protocol-type;
  description
  "Routing IPv6 header type.";
 }
 identity esp {
  base protocol-type;
  description
  "ESP header type.";
 }
 identity ah {
  base protocol-type;
  description
  "AH header type.";
 }
 identity vpn-policy-filter-type {
  description
  "Base identity for VPN Policy filter type.";
 }
 identity ipv4 {
   base vpn-policy-filter-type;
   description
   "Identity for IPv4 Prefix filter type.";
 }
 identity ipv6 {
   base vpn-policy-filter-type;
   description
   "Identity for IPv6 Prefix filter type.";
}
 identity lan {
   base vpn-policy-filter-type;
   description
   "Identity for LAN Tag filter type.";
}

 identity qos-profile-direction {
  description
  "Base identity for QoS profile direction.";
 }

 identity site-to-wan {
   base qos-profile-direction;
   description
   "Identity for Site-to-WAN direction.";
 }
 identity wan-to-site {
   base qos-profile-direction;
   description
   "Identity for WAN-to-Site direction.";
 }
 identity both {
   base qos-profile-direction;
   description
   "Identity for both WAN-to-Site direction
   and Site-to-WAN direction.";
 }
 /* Groupings */
 grouping vpn-service-cloud-access {
  container cloud-accesses {
   if-feature cloud-access;
   list cloud-access {
    key cloud-identifier;
    leaf cloud-identifier {
     type leafref {
      path "/l3vpn-svc/vpn-profiles/"+
      "valid-provider-identifiers/cloud-identifier/id";
     }
     description
     "Identification of cloud service.
     Local administration meaning.";
    }
    choice list-flavor {
     case permit-any {
      leaf permit-any {
       type empty;
       description
       "Allows all sites.";
      }
     }
     case deny-any-except {
      leaf-list permit-site {
       type leafref {
        path "/l3vpn-svc/sites/site/site-id";
       }
       description
       "Site ID to be authorized.";
      }
     }
     case permit-any-except {
      leaf-list deny-site {
       type leafref {
       path "/l3vpn-svc/sites/site/site-id";
      }
      description
      "Site ID to be denied.";
      }
     }
     description
     "Choice for cloud access policy.  By
     default, all sites in the IP VPN MUST
     be authorized to access the cloud.";
    }
    container address-translation {
     container nat44 {
      leaf enabled {
       type boolean;
        default false;
        description
        "Controls whether or not Network address
        translation from IPv4 to IPv4 (NAT44)
        [RFC3022] is required.";
      }
      leaf nat44-customer-address {
       type inet:ipv4-address;
        description
        "Address to be used for network address
        translation from IPv4 to IPv4.  This is
        to be used if the customer is providing
        the IPv4 address.  If the customer address
        is not set, the model assumes that the
        provider will allocate the address.";
      }
      description
      "IPv4-to-IPv4 translation.";
     }
     description
     "Container for NAT.";
    }
    description
    "Cloud access configuration.";
   }
   description
   "Container for cloud access configurations.";
  }
  description
  "Grouping for VPN cloud definition.";
 }
 grouping multicast-rp-group-cfg {
  choice group-format {
   mandatory true;
   case singleaddress {
    leaf group-address {
     type inet:ip-address;
     description
     "A single multicast group address.";
    }
   }
   case startend {
    leaf group-start {
     type inet:ip-address;
     description
     "The first multicast group address in
     the multicast group address range.";
    }
    leaf group-end {
     type inet:ip-address;
     description
     "The last multicast group address in
     the multicast group address range.";
    }
   }
   description
   "Choice for multicast group format.";
  }
  description
  "This grouping defines multicast group or
  multicast groups for RP-to-group mapping.";
 }
 grouping vpn-service-multicast {
  container multicast {
   if-feature multicast;
   leaf enabled {
    type boolean;
    default false;
    description
    "Enables multicast.";
   }
   container customer-tree-flavors {
    leaf-list tree-flavor {
     type identityref {
      base multicast-tree-type;
     }
     description
      "Type of tree to be used.";
    }
    description
    "Type of trees used by customer.";
   }
   container rp {
    container rp-group-mappings {
     list rp-group-mapping {
      key id;
      leaf id {
       type uint16;
       description
       "Unique identifier for the mapping.";
      }
      container provider-managed {
       leaf enabled {
        type boolean;
        default false;
        description
        "Set to true if the Rendezvous Point (RP)
        must be a provider-managed node.  Set to false
        if it is a customer-managed node.";
       }
       leaf rp-redundancy {
        type boolean;
        default false;
        description
        "If true, a redundancy mechanism for the RP
        is required.";
       }
       leaf optimal-traffic-delivery {
        type boolean;
        default false;
        description
        "If true, the SP must ensure that
        traffic uses an optimal path.  An SP may use
        Anycast RP or RP-tree-to-SPT switchover
        architectures.";
       }
       description
       "Parameters for a provider-managed RP.";
      }
      leaf rp-address {
       when "../provider-managed/enabled = 'false'" {
        description
        "Relevant when the RP is not provider-managed.";
       }
       type inet:ip-address;
         mandatory true;
       description
       "Defines the address of the RP.
       Used if the RP is customer-managed.";
      }
      container groups {
       list group {
        key id;
        leaf id {
         type uint16;
         description
         "Identifier for the group.";
        }
        uses multicast-rp-group-cfg;
        description
        "List of multicast groups.";
       }
       description
       "Multicast groups associated with the RP.";
      }
      description
      "List of RP-to-group mappings.";
     }
     description
     "RP-to-group mappings parameters.";
    }
    container rp-discovery {
     leaf rp-discovery-type {
      type identityref {
       base multicast-rp-discovery-type;
       }
      default static-rp;
      description
      "Type of RP discovery used.";
     }
     container bsr-candidates {
       when "derived-from-or-self(../rp-discovery-type, "+
           "'l3vpn-svc:bsr-rp')" {
       description
       "Only applicable if discovery type
       is BSR-RP.";
      }
      leaf-list bsr-candidate-address {
       type inet:ip-address;
        description
        "Address of BSR candidate.";
      }
      description
      "Container for List of Customer
      BSR candidate's addresses.";
     }
     description
     "RP discovery parameters.";
    }
    description
    "RP parameters.";
   }
   description
   "Multicast global parameters for the VPN service.";
  }
  description
  "Grouping for multicast VPN definition.";
 }
 grouping vpn-service-mpls {
  leaf carrierscarrier {
   if-feature carrierscarrier;
    type boolean;
    default false;
    description
    "The VPN is using CsC, and so MPLS is required.";
  }
  description
  "Grouping for MPLS CsC definition.";
 }
 grouping customer-location-info {
  container locations {
   list location {
    key location-id;
    leaf location-id {
     type svc-id;
     description
     "Identifier for a particular location.";
    }
    leaf address {
     type string;
     description
     "Address (number and street) of the site.";
    }
    leaf postal-code {
     type string;
     description
     "Postal code of the site.";
    }
    leaf state {
     type string;
     description
     "State of the site.  This leaf can also be
     used to describe a region for a country that
     does not have states.";
    }
    leaf city {
     type string;
     description
     "City of the site.";
    }
    leaf country-code {
     type string {
      pattern '[A-Z]{2}';
     }
     description
     "Country of the site.
     Expressed as ISO ALPHA-2 code.";
    }
    description
    "Location of the site.";
   }
   description
   "List of locations for the site.";
  }
  description
  "This grouping defines customer location parameters.";
 }
 grouping site-group {
  container groups {
   list group {
    key group-id;
    leaf group-id {
     type string;
     description
     "Group-id the site belongs to.";
    }
    description
    "List of group-ids.";
   }
   description
   "Groups the site or site-network-access belongs to.";
  }
  description
  "Grouping definition to assign
  group-ids to site or site-network-access.";
 }
 grouping site-diversity {
  container site-diversity {
   if-feature site-diversity;
   uses site-group;
   description
   "Diversity constraint type.  All
   site-network-accesses will inherit
   the group values defined here.";
  }
  description
  "This grouping defines site
  diversity parameters.";
 }
 grouping access-diversity {
  container access-diversity {
   if-feature site-diversity;
   uses site-group;
   container constraints {
    list constraint {
     key constraint-type;
     leaf constraint-type {
      type identityref {
       base placement-diversity;
      }
      description
      "Diversity constraint type.";
     }
     container target {
      choice target-flavor {
       default id;
       case id {
        list group {
         key group-id;
         leaf group-id {
          type string;
          description
          "The constraint will be applied against
          this particular group-id for this site
          network access level.";
         }
         description
         "List of group-ids associated with one specific
         constraint for this site network access level.";
        }
       }
       case all-accesses {
        leaf all-other-accesses {
         type empty;
         description
         "The constraint will be applied against
         all other site network accesses of this site.";
        }
       }
       case all-groups {
        leaf all-other-groups {
         type empty;
         description
         "The constraint will be applied against
         all other groups managed by the customer.";
        }
       }
       description
       "Choice for the target flavor definition.";
      }
      description
      "The constraint will be applied against a
      Specific target, and the target can be a list
      of group-ids,all other site network accesses of
      this site, or all other groups managed by the
      customer.";
     }
     description
     "List of constraints.";
    }
    description
    "Placement constraints for this site network access.";
   }
   description
   "Diversity parameters.";
  }
  description
  "This grouping defines access diversity parameters.";
 }
 grouping operational-requirements {
   leaf requested-site-start {
    type yang:date-and-time;
     description
     "Optional leaf indicating requested date and
     time when the service at a particular site is
     expected to start.";
  }

  leaf requested-site-stop {
    type yang:date-and-time;
     description
     "Optional leaf indicating requested date and
     time when the service at a particular site is
     expected to stop.";
  }
  description
  "This grouping defines some operational
  parameters.";
 }
 grouping operational-requirements-ops {
   leaf actual-site-start {
    type yang:date-and-time;
    config false;
     description
     "Optional leaf indicating actual date and
     time when the service at a particular site
     actually started.";
  }
  leaf actual-site-stop {
   type yang:date-and-time;
   config false;
     description
     "Optional leaf indicating actual date and
     time when the service at a particular site
     actually stopped.";
  }
  description
  "This grouping defines some operational
  parameters.";
 }
 grouping flow-definition {
  container match-flow {
   leaf dscp {
    type inet:dscp;
     description
     "DSCP value.";
   }
   leaf dot1p {
    type uint8 {
     range "0..7";
    }
    description
    "802.1p matching.";
   }
   leaf ipv4-src-prefix {
    type inet:ipv4-prefix;
     description
     "Match on IPv4 src address.";
   }
   leaf ipv6-src-prefix {
    type inet:ipv6-prefix;
     description
     "Match on IPv6 src address.";
   }
   leaf ipv4-dst-prefix {
    type inet:ipv4-prefix;
     description
     "Match on IPv4 dst address.";
   }
   leaf ipv6-dst-prefix {
    type inet:ipv6-prefix;
    description
    "Match on IPv6 dst address.";
   }
   leaf l4-src-port {
    type inet:port-number;
        must "current() < ../l4-src-port-range/lower-port or "+
        "current() > ../l4-src-port-range/upper-port" {
     description
     "If l4-src-port and l4-src-port-range/lower-port and
     upper-port are set at the same time, l4-src-port
     should not overlap with l4-src-port-range.";
     }
     description
     "Match on Layer 4 src port.";
   }
   leaf-list target-sites {
     if-feature target-sites;
     type svc-id;
     description
     "Identify a site as traffic destination.";
   }
   container l4-src-port-range {
     leaf lower-port {
     type inet:port-number;
     description
     "Lower boundary for port.";
    }
    leaf upper-port {
     type inet:port-number;
     must ". >= ../lower-port" {
      description
      "Upper boundary for port.  If it
      exists, the upper boundary must be
      higher than the lower boundary.";
     }
     description
     "Upper boundary for port.";
    }
     description
     "Match on Layer 4 src port range.  When
     only the lower-port is present, it represents
     a single port.  When both the lower-port and
     upper-port are specified, it implies
     a range inclusive of both values.";
   }
   leaf l4-dst-port {
    type inet:port-number;
         must "current() < ../l4-dst-port-range/lower-port or "+
         "current() > ../l4-dst-port-range/upper-port" {
     description
     "If l4-dst-port and l4-dst-port-range/lower-port
     and upper-port are set at the same time,
     l4-dst-port should not overlap with
     l4-src-port-range.";
     }
     description
     "Match on Layer 4 dst port.";
   }
   container l4-dst-port-range {
    leaf lower-port {
     type inet:port-number;
     description
     "Lower boundary for port.";
    }
    leaf upper-port {
     type inet:port-number;
     must ". >= ../lower-port" {
     description
     "Upper boundary must be
     higher than lower boundary.";
     }
     description
     "Upper boundary for port.  If it exists,
     upper boundary must be higher than lower
     boundary.";
    }
    description
    "Match on Layer 4 dst port range.  When only
    lower-port is present, it represents a single
    port.  When both lower-port and upper-port are
    specified, it implies a range inclusive of both
    values.";
   }
   leaf protocol-field {
    type union {
     type uint8;
     type identityref {
      base protocol-type;
     }
    }
    description
    "Match on IPv4 protocol or IPv6 Next Header field.";
   }
   description
   "Describes flow-matching criteria.";
  }
  description
  "Flow definition based on criteria.";
 }
 grouping site-service-basic {
  leaf svc-input-bandwidth {
    type uint64;
    units bps;
    mandatory true;
     description
     "From the customer site's perspective, the service
     input bandwidth of the connection or download
     bandwidth from the SP to the site.";
  }
  leaf svc-output-bandwidth {
   type uint64;
   units bps;
   mandatory true;
     description
     "From the customer site's perspective, the service
     output bandwidth of the connection or upload
     bandwidth from the site to the SP.";
  }
  leaf svc-mtu {
   type uint16;
   units bytes;
   mandatory true;
    description
    "MTU at service level.  If the service is IP,
    it refers to the IP MTU.  If CsC is enabled,
    the requested 'svc-mtu' leaf will refer to the
    MPLS MTU and not to the IP MTU.";
  }
  description
  "Defines basic service parameters for a site.";
 }
 grouping site-protection {
  container traffic-protection {
   if-feature fast-reroute;
   leaf enabled {
    type boolean;
    default false;
     description
     "Enables traffic protection of access link.";
   }
   description
   "Fast Reroute service parameters for the site.";
  }
  description
  "Defines protection service parameters for a site.";
 }
 grouping site-service-mpls {
  container carrierscarrier {
   if-feature carrierscarrier;
   leaf signalling-type {
    type enumeration {
    enum ldp {
     description
     "Use LDP as the signalling protocol
     between the PE and the CE.  In this case,
     an IGP routing protocol must also be activated.";
     }
    enum bgp {
     description
     "Use BGP (as per RFC 8277) as the signalling protocol
     between the PE and the CE.
     In this case, BGP must also be configured as
     the routing protocol.";
     }
    }
    default bgp;
    description
    "MPLS signalling type.";
   }
     description
     "This container is used when the customer provides
     MPLS-based services.  This is only used in the case
     of CsC (i.e., a customer builds an MPLS service using
     an IP VPN to carry its traffic).";
  }
     description
     "Defines MPLS service parameters for a site.";
 }
 grouping site-service-qos-profile {
  container qos {
   if-feature qos;
   container qos-classification-policy {
    list rule {
     key id;
     ordered-by user;
     leaf id {
      type string;
      description
      "A description identifying the
       qos-classification-policy rule.";
     }
     choice match-type {
      default match-flow;
      case match-flow {
      uses flow-definition;
      }
      case match-application {
       leaf match-application {
        type identityref {
         base customer-application;
        }
         description
         "Defines the application to match.";
       }
      }
      description
      "Choice for classification.";
     }
     leaf target-class-id {
      type string;
      description
      "Identification of the class of service.
      This identifier is internal to the administration.";
     }
     description
     "List of marking rules.";
    }
    description
    "Configuration of the traffic classification policy.";
   }
   container qos-profile {
    choice qos-profile {
     description
     "Choice for QoS profile.
     Can be standard profile or customized profile.";
     case standard {
      description
      "Standard QoS profile.";
      leaf profile {
       type leafref {
       path "/l3vpn-svc/vpn-profiles/valid-provider-identifiers"+
           "/qos-profile-identifier/id";
       }
       description
       "QoS profile to be used.";
      }
     }
     case custom {
      description
      "Customized QoS profile.";
       container classes {
        if-feature qos-custom;
        list class {
         key class-id;
         leaf class-id {
         type string;
                  description
                  "Identification of the class of service.
                  This identifier is internal to the
                  administration.";
         }
         leaf direction {
                  type identityref {
                   base qos-profile-direction;
                   }
                  default both;
                   description
                   "The direction to which the QoS profile
                   is applied.";
                }
                 leaf rate-limit {
                  type decimal64 {
                   fraction-digits 5;
                   range "0..100";
          }
                  units percent;
                   description
                   "To be used if the class must be rate-limited.
                   Expressed as percentage of the service
                   bandwidth.";
        }
        container latency {
         choice flavor {
          case lowest {
           leaf use-lowest-latency {
            type empty;
             description
             "The traffic class should use the path with the
             lowest latency.";
           }
          }
          case boundary {
           leaf latency-boundary {
            type uint16;
            units msec;
            default 400;
             description
             "The traffic class should use a path with a
             defined maximum latency.";
           }
          }
          description
          "Latency constraint on the traffic class.";
         }
         description
         "Latency constraint on the traffic class.";
        }
        container jitter {
         choice flavor {
          case lowest {
           leaf use-lowest-jitter {
            type empty;
             description
             "The traffic class should use the path with the
             lowest jitter.";
           }
          }
          case boundary {
           leaf latency-boundary {
            type uint32;
            units usec;
            default 40000;
             description
             "The traffic class should use a path with a
             defined maximum jitter.";
           }
          }
          description
          "Jitter constraint on the traffic class.";
         }
         description
         "Jitter constraint on the traffic class.";
        }
        container bandwidth {
         leaf guaranteed-bw-percent {
          type decimal64 {
                  fraction-digits 5;
                  range "0..100";
          }
          units percent;
          mandatory true;
           description
           "To be used to define the guaranteed bandwidth
           as a percentage of the available service bandwidth.";
         }
         leaf end-to-end {
          type empty;
           description
           "Used if the bandwidth reservation
           must be done on the MPLS network too.";
         }
         description
         "Bandwidth constraint on the traffic class.";
        }
        description
        "List of classes of services.";
       }
       description
       "Container for list of classes of services.";
      }
     }
    }
    description
    "QoS profile configuration.";
   }
   description
   "QoS configuration.";
  }
  description
  "This grouping defines QoS parameters for a site.";
 }
 grouping site-security-authentication {
  container authentication {
     description
     "Authentication parameters.";
  }
  description
  "This grouping defines authentication parameters for a site.";
 }
 grouping site-security-encryption {
  container encryption {
   if-feature encryption;
   leaf enabled {
    type boolean;
    default false;
     description
     "If true, traffic encryption on the connection is required.";
   }
   leaf layer {
      when "../enabled = 'true'" {
         description
         "Require a value for layer when enabled is true.";
       }
    type enumeration {
     enum layer2 {
      description
      "Encryption will occur at Layer 2.";
     }
     enum layer3 {
      description
      "Encryption will occur at Layer 3.
      For example, IPsec may be used when
      a customer requests Layer 3 encryption.";
     }
    }
    description
     "Layer on which encryption is applied.";
   }
   container encryption-profile {
    choice profile {
     case provider-profile {
      leaf profile-name {
       type leafref {
        path "/l3vpn-svc/vpn-profiles/valid-provider-identifiers"+
                "/encryption-profile-identifier/id";
       }
         description
         "Name of the SP profile to be applied.";
      }
     }
     case customer-profile {
      leaf algorithm {
       type string;
         description
         "Encryption algorithm to be used.";
      }
      choice key-type {
       default psk;
       case psk {
        leaf preshared-key {
         type string;
         description
         "Pre-Shared Key (PSK) coming from the customer.";
        }
       }
       description
       "Type of keys to be used.";
      }
     }
     description
     "Choice of encryption profile.  The encryption
     profile can be the provider profile or customer profile.";
    }
    description
    "Profile of encryption to be applied.";
   }
   description
   "Encryption parameters.";
  }
  description
  "This grouping defines encryption parameters for a site.";
 }
 grouping site-attachment-bearer {
  container bearer {
   container requested-type {
    if-feature requested-type;
    leaf requested-type {
     type string;
     description
     "Type of requested bearer: Ethernet, DSL,
     Wireless, etc. Operator specific.";
    }
    leaf strict {
     type boolean;
     default false;
     description
     "Defines whether requested-type is a preference
     or a strict requirement.";
    }
     description
     "Container for requested-type.";
   }
   leaf always-on {
    if-feature always-on;
    type boolean;
    default true;
     description
     "Request for an always-on access type.
     For example, this could mean no dial access type.";
   }
   leaf bearer-reference {
    if-feature bearer-reference;
    type string;
     description
     "This is an internal reference for the SP.";
   }
     description
     "Bearer-specific parameters.
     To be augmented.";
  }
  description
  "Defines physical properties of a site attachment.";
 }
 grouping site-routing {
  container routing-protocols {
   list routing-protocol {
    key type;
    leaf type {
     type identityref {
      base routing-protocol-type;
     }
     description
     "Type of routing protocol.";
    }
    container ospf {
     presence "acton-yang doesn't support when clause";
     when "derived-from-or-self(../type, 'l3vpn-svc:ospf')" {
     description
     "Only applies when protocol is OSPF.";
     }
     if-feature rtg-ospf;
     leaf-list address-family {
      type address-family;
          min-elements "1";
         description
         "If OSPF is used on this site, this node
         contains a configured value.  This node
         contains at least one address family
         to be activated.";
     }
     leaf area-address {
      type yang:dotted-quad;
      mandatory true;
         description
         "Area address.";
     }
     leaf metric {
      type uint16;
      default 1;
         description
         "Metric of the PE-CE link.  It is used
         in the routing state calculation and
         path selection.";
     }
     container sham-links {
      if-feature rtg-ospf-sham-link;
      list sham-link {
       key target-site;
       leaf target-site {
        type svc-id;
         description
         "Target site for the sham link connection.
         The site is referred to by its ID.";
       }
       leaf metric {
        type uint16;
        default 1;
         description
         "Metric of the sham link.  It is used in
         the routing state calculation and path
         selection.  The default value is set
         to 1.";
       }
         description
         "Creates a sham link with another site.";
      }
      description
      "List of sham links.";
     }
     description
     "OSPF-specific configuration.";
    }
    container bgp {
     presence "acton-yang doesn't support when clause";
     when "derived-from-or-self(../type, 'l3vpn-svc:bgp')" {
      description
      "Only applies when protocol is BGP.";
     }
     if-feature rtg-bgp;
     leaf autonomous-system {
      type uint32;
      mandatory true;
         description
         "Customer AS number in case the customer
         requests BGP routing.";
     }
     leaf-list address-family {
      type address-family;
          min-elements "1";
         description
         "If BGP is used on this site, this node
         contains a configured value.  This node
         contains at least one address family
         to be activated.";
     }
     description
     "BGP-specific configuration.";
    }
    container static {
     presence "acton-yang doesn't support when clause";
     when "derived-from-or-self(../type, 'l3vpn-svc:static')" {
       description
       "Only applies when protocol is static.
       BGP activation requires the SP to know
       the address of the customer peer.  When
       BGP is enabled, the 'static-address'
       allocation type for the IP connection
       MUST be used.";
     }
     container cascaded-lan-prefixes {
      list ipv4-lan-prefixes {
       if-feature ipv4;
       key "lan next-hop";
       leaf lan {
        type inet:ipv4-prefix;
        description
        "LAN prefixes.";
       }
       leaf lan-tag {
        type string;
         description
         "Internal tag to be used in VPN policies.";
       }
       leaf next-hop {
        type inet:ipv4-address;
         description
         "Next-hop address to use on the customer side.";
       }
       description
       "List of LAN prefixes for the site.";
      }
      list ipv6-lan-prefixes {
       if-feature ipv6;
       key "lan next-hop";
       leaf lan {
        type inet:ipv6-prefix;
         description
         "LAN prefixes.";
       }
       leaf lan-tag {
        type string;
        description
        "Internal tag to be used in VPN policies.";
       }
       leaf next-hop {
        type inet:ipv6-address;
         description
         "Next-hop address to use on the customer side.";
       }
       description
       "List of LAN prefixes for the site.";
      }
      description
      "LAN prefixes from the customer.";
     }
     description
     "Configuration specific to static routing.";
    }
    container rip {
     presence "acton-yang doesn't support when clause";
     when "derived-from-or-self(../type, 'l3vpn-svc:rip')" {
      description
      "Only applies when the protocol is RIP.  For IPv4,
      the model assumes that RIP version 2 is used.";
     }
     if-feature rtg-rip;
     leaf-list address-family {
      type address-family;
          min-elements "1";
         description
         "If RIP is used on this site, this node
         contains a configured value.  This node
         contains at least one address family
         to be activated.";
     }
     description
     "Configuration specific to RIP routing.";
    }
    container vrrp {
     presence "acton-yang doesn't support when clause";
     when "derived-from-or-self(../type, 'l3vpn-svc:vrrp')" {
      description
      "Only applies when protocol is VRRP.";
     }
     if-feature rtg-vrrp;
     leaf-list address-family {
      type address-family;
          min-elements "1";
         description
         "If VRRP is used on this site, this node
         contains a configured value.  This node contains
         at least one address family to be activated.";
     }
     description
     "Configuration specific to VRRP routing.";
    }
    description
    "List of routing protocols used on
    the site.  This list can be augmented.";
   }
   description
   "Defines routing protocols.";
  }
  description
  "Grouping for routing protocols.";
 }
 grouping site-attachment-ip-connection {
   container ip-connection {
     container ipv4 {
     if-feature ipv4;
      leaf address-allocation-type {
      type identityref {
       base address-allocation-type;
     }
     must "not(derived-from-or-self(current(), 'l3vpn-svc:slaac') or "+
         "derived-from-or-self(current(), "+
         "'l3vpn-svc:provider-dhcp-slaac'))" {
     error-message "SLAAC is only applicable to IPv6";
     }
     description
     "Defines how addresses are allocated.
     If there is no value for the address
     allocation type, then IPv4 is not enabled.";
    }
   container provider-dhcp {
     when "derived-from-or-self(../address-allocation-type, "+
     "'l3vpn-svc:provider-dhcp')" {
     description
     "Only applies when addresses are allocated by DHCP.";
   }
     leaf provider-address {
      type inet:ipv4-address;
         description
         "Address of provider side.  If provider-address is not
         specified, then prefix length should not be specified
         either.  It also implies provider-dhcp allocation is
         not enabled.  If provider-address is specified, then
         the prefix length may or may not be specified.";
     }
     leaf prefix-length {
      type uint8 {
      range "0..32";
      }
         must "(../provider-address)" {
          error-message
          "If the prefix length is specified, provider-address
          must also be specified.";
             description
             "If the prefix length is specified, provider-address
             must also be specified.";
        }
     description
     "Subnet prefix length expressed in bits.
     If not specified, or specified as zero,
     this means the customer leaves the actual
     prefix length value to the provider.";
     }
     choice address-assign {
      default number;
      case number {
       leaf number-of-dynamic-address {
        type uint16;
        default 1;
         description
         "Describes the number of IP addresses
         the customer requires.";
       }
      }
      case explicit {
       container customer-addresses {
        list address-group {
         key "group-id";
         leaf group-id {
         type string;
         description
         "Group-id for the address range from
         start-address to end-address.";
         }
        leaf start-address {
         type inet:ipv4-address;
          description
          "First address.";
         }
        leaf end-address {
         type inet:ipv4-address;
         description
         "Last address.";
         }
         description
         "Describes IP addresses allocated by DHCP.
         When only start-address or only end-address
         is present, it represents a single address.
         When both start-address and end-address are
         specified, it implies a range inclusive of both
         addresses.  If no address is specified, it implies
         customer addresses group is not supported.";
        }
         description
         "Container for customer addresses is allocated by DHCP.";
       }
     }
         description
         "Choice for the way to assign addresses.";
     }
         description
         "DHCP allocated addresses related parameters.";
    }
 container dhcp-relay {
   when "derived-from-or-self(../address-allocation-type, "+
   "'l3vpn-svc:provider-dhcp-relay')" {
     description
     "Only applies when provider is required to implement
     DHCP relay function.";
  }
 leaf provider-address {
  type inet:ipv4-address;
     description
     "Address of provider side.  If provider-address is not
     specified, then prefix length should not be specified
     either.  It also implies provider-dhcp allocation is
     not enabled.  If provider-address is specified, then
     prefix length may or may not be specified.";
 }
 leaf prefix-length {
  type uint8 {
  range "0..32";
  }
 must "(../provider-address)" {
  error-message
     "If prefix length is specified, provider-address
      must also be specified.";
     description
     "If prefix length is specified, provider-address
     must also be specified.";
}
     description
     "Subnet prefix length expressed in bits.  If not
     specified, or specified as zero, this means the
     customer leaves the actual prefix length value
     to the provider.";
 }
 container customer-dhcp-servers {
  leaf-list server-ip-address {
  type inet:ipv4-address;
     description
     "IP address of customer DHCP server.";
 }
 description
 "Container for list of customer DHCP servers.";
 }
 description
 "DHCP relay provided by operator.";
}
 container addresses {
   when "derived-from-or-self(../address-allocation-type, "+
   "'l3vpn-svc:static-address')" {
   description
   "Only applies when protocol allocation type is static.";
    }
     leaf provider-address {
      type inet:ipv4-address;
         description
         "IPv4 Address List of the provider side.
         When the protocol allocation type is static,
         the provider address must be configured.";
     }
     leaf customer-address {
      type inet:ipv4-address;
         description
         "IPv4 Address of customer side.";
     }
     leaf prefix-length {
      type uint8 {
       range "0..32";
      }
     description
     "Subnet prefix length expressed in bits.
     It is applied to both provider-address
     and customer-address.";
     }
     description
     "Describes IPv4 addresses used.";
    }
    description
    "IPv4-specific parameters.";
   }
   container ipv6 {
    if-feature ipv6;
    leaf address-allocation-type {
     type identityref {
      base address-allocation-type;
     }
     description
     "Defines how addresses are allocated.
     If there is no value for the address
     allocation type, then IPv6 is
     not enabled.";
    }

   container provider-dhcp {
      when "derived-from-or-self(../address-allocation-type, "+
      "'l3vpn-svc:provider-dhcp') "+
      "or derived-from-or-self(../address-allocation-type, "+
      "'l3vpn-svc:provider-dhcp-slaac')" {
      description
      "Only applies when addresses are allocated by DHCP.";
       }
          leaf provider-address {
           type inet:ipv6-address;
           description
           "Address of the provider side.  If provider-address
           is not specified, then prefix length should not be
           specified either.  It also implies provider-dhcp
           allocation is not enabled.  If provider-address is
           specified, then prefix length may or may
           not be specified.";
         }
      leaf prefix-length {
       type uint8 {
       range "0..128";
       }
           must "(../provider-address)" {
             error-message
             "If prefix length is specified, provider-address
             must also be specified.";
             description
             "If prefix length is specified, provider-address
             must also be specified.";
            }
       description
       "Subnet prefix length expressed in bits.  If not
       specified, or specified as zero, this means the
       customer leaves the actual prefix length value
       to the provider.";
     }
        choice address-assign {
         default number;
         case number {
          leaf number-of-dynamic-address {
           type uint16;
           default 1;
           description
           "Describes the number of IP addresses the customer
           requires.";
          }
         }
         case explicit {
          container customer-addresses {
           list address-group {
                 key "group-id";
                 leaf group-id {
                 type string;
                 description
                 "Group-id for the address range from
                 start-address to end-address.";
             }
                 leaf start-address {
                  type inet:ipv6-address;
                  description
                  "First address.";
                  }
                 leaf end-address {
                  type inet:ipv6-address;
                  description
                  "Last address.";
                  }
                 description
                 "Describes IP addresses allocated by DHCP.  When only
                 start-address or only end-address is present, it
                 represents a single address.  When both start-address
                 and end-address are specified, it implies a range
                 inclusive of both addresses.  If no address is
                 specified, it implies customer addresses group is
                 not supported.";
          }
           description
           "Container for customer addresses allocated by DHCP.";
         }
        }
         description
         "Choice for the way to assign addresses.";
        }
         description
         "DHCP allocated addresses related parameters.";
        }
   container dhcp-relay {
    when "derived-from-or-self(../address-allocation-type, "+
         "'l3vpn-svc:provider-dhcp-relay')" {
      description
      "Only applies when the provider is required
      to implement DHCP relay function.";
      }
        leaf provider-address {
         type inet:ipv6-address;
          description
          "Address of the provider side.  If provider-address is
          not specified, then prefix length should not be
          specified either.  It also implies provider-dhcp
          allocation is not enabled.  If provider address
          is specified, then prefix length may or may
          not be specified.";
          }
        leaf prefix-length {
         type uint8 {
          range "0..128";
          }
         must "(../provider-address)" {
          error-message
           "If prefix length is specified, provider-address
           must also be specified.";
          description
          "If prefix length is specified, provider-address
          must also be specified.";
           }
         description
         "Subnet prefix length expressed in bits.  If not
         specified, or specified as zero, this means the
         customer leaves the actual prefix length value
         to the provider.";
         }
    container customer-dhcp-servers {
     leaf-list server-ip-address {
      type inet:ipv6-address;
       description
       "This node contains the IP address of
       the customer DHCP server.  If the DHCP relay
       function is implemented by the
       provider, this node contains the
       configured value.";
     }
      description
      "Container for list of customer DHCP servers.";
     }
    description
    "DHCP relay provided by operator.";
    }
   container addresses {
    when "derived-from-or-self(../address-allocation-type, "+
        "'l3vpn-svc:static-address')" {
     description
     "Only applies when protocol allocation type is static.";
     }
    leaf provider-address {
     type inet:ipv6-address;
      description
      "IPv6 Address of the provider side.  When the protocol
      allocation type is static, the provider address
      must be configured.";
     }
    leaf customer-address {
     type inet:ipv6-address;
      description
      "The IPv6 Address of the customer side.";
     }
    leaf prefix-length {
     type uint8 {
      range "0..128";
     }
     description
     "Subnet prefix length expressed in bits.
     It is applied to both provider-address and
     customer-address.";
    }
    description
    "Describes IPv6 addresses used.";
    }
    description
    "IPv6-specific parameters.";
   }
   container oam {
    container bfd {
     if-feature bfd;
     leaf enabled {
      type boolean;
      default false;
      description
      "If true, BFD activation is required.";
     }
     choice holdtime {
      default fixed;
      case fixed {
       leaf fixed-value {
        type uint32;
        units msec;
         description
         "Expected BFD holdtime expressed in msec.  The customer
         may impose some fixed values for the holdtime period
         if the provider allows the customer use this function.
         If the provider doesn't allow the customer to use this
         function, the fixed-value will not be set.";
       }
      }
      case profile {
       leaf profile-name {
        type leafref {
         path "/l3vpn-svc/vpn-profiles/valid-provider-identifiers/"+
                 "bfd-profile-identifier/id";
        }
        description
        "Well-known SP profile name.  The provider can propose
        some profiles to the customer, depending on the service
        level the customer wants to achieve.  Profile names
        must be communicated to the customer.";
       }
       description
       "Well-known SP profile.";
      }
      description
      "Choice for holdtime flavor.";
     }
     description
     "Container for BFD.";
    }
    description
    "Defines the Operations, Administration, and Maintenance (OAM)
    mechanisms used on the connection.  BFD is set as a fault
    detection mechanism, but the 'oam' container can easily
    be augmented by other mechanisms";
   }
   description
   "Defines connection parameters.";
  }
  description
  "This grouping defines IP connection parameters.";
 }
 grouping site-service-multicast {
  container multicast {
   if-feature multicast;
   leaf multicast-site-type {
    type enumeration {
     enum receiver-only {
      description
      "The site only has receivers.";
     }
     enum source-only {
      description
      "The site only has sources.";
     }
     enum source-receiver {
      description
      "The site has both sources and receivers.";
     }
    }
    default source-receiver;
    description
    "Type of multicast site.";
   }
   container multicast-address-family {
    leaf ipv4 {
     if-feature ipv4;
     type boolean;
     default false;
     description
     "Enables IPv4 multicast.";
    }
    leaf ipv6 {
     if-feature ipv6;
     type boolean;
     default false;
     description
     "Enables IPv6 multicast.";
    }
    description
    "Defines protocol to carry multicast.";
    }
   leaf protocol-type {
    type enumeration {
     enum host {
      description
      "Hosts are directly connected to the provider network.
      Host protocols such as IGMP or MLD are required.";
     }
     enum router {
      description
      "Hosts are behind a customer router.
      PIM will be implemented.";
     }
     enum both {
      description
      "Some hosts are behind a customer router, and
      some others are directly connected to the
      provider network.  Both host and routing protocols
      must be used.  Typically, IGMP and PIM will be
      implemented.";
     }
    }
    default "both";
    description
    "Multicast protocol type to be used with the customer site.";
   }
   description
   "Multicast parameters for the site.";
  }
  description
  "Multicast parameters for the site.";
 }
 grouping site-management {
  container management {
   leaf type {
    type identityref {
     base management;
    }
    mandatory true;
    description
    "Management type of the connection.";
   }
   description
   "Management configuration.";
  }
  description
  "Management parameters for the site.";
 }
 grouping site-devices {
  container devices {
   when "derived-from-or-self(../management/type, "+
   "'l3vpn-svc:provider-managed') or "+
   "derived-from-or-self(../management/type, 'l3vpn-svc:co-managed')" {
   description
   "Applicable only for provider-managed or
   co-managed device.";
  }
  list device {
   key device-id;
   leaf device-id {
    type svc-id;
    description
    "Identifier for the device.";
   }
   leaf location {
    type leafref {
     path "../../../locations/"+
     "location/location-id";
    }
    mandatory true;
    description
     "Location of the device.";
    }
   container management {
    when "derived-from-or-self(../../../management/type,"+
      "'l3vpn-svc:co-managed')" {
      description
       "Applicable only for co-managed device.";
     }
    leaf address-family {
     type address-family;
     description
     "Address family used for management.";
    }
    leaf address {
         when "(../address-family)" {
           description
           "If address-family is specified, then address should
           also be specified.  If address-family is not specified,
           then address should also not be specified.";
           }
         type inet:ip-address;
         mandatory true;
     description
     "Management address.";
     }
    description
     "Management configuration.  Applicable only for
      co-managed device.";
    }
    description
    "List of devices requested by customer.";
   }
   description
   "Device configuration.";
  }
  description
  "Grouping for device allocation.";
 }
 grouping site-vpn-flavor {
  leaf site-vpn-flavor {
   type identityref {
    base site-vpn-flavor;
   }
   default site-vpn-flavor-single;
   description
   "Defines the way the VPN multiplexing is done, e.g., whether
   the site belongs to a single VPN site or a multiVPN; or, in the case
   of a multiVPN, whether the logical accesses of the sites belong
   to the same set of VPNs or each logical access maps to
   different VPNs.";
  }
  description
  "Grouping for site VPN flavor.";
 }
 grouping site-vpn-policy {
  container vpn-policies {
   list vpn-policy {
    key vpn-policy-id;
    leaf vpn-policy-id {
     type svc-id;
     description
     "Unique identifier for the VPN policy.";
    }
    list entries {
     key id;
     leaf id {
      type svc-id;
      description
      "Unique identifier for the policy entry.";
     }
     container filters {
      list filter {
       key type;
       ordered-by user;
       leaf type {
        type identityref {
         base vpn-policy-filter-type;
         }
        description
        "Type of VPN Policy filter.";
        }
        leaf-list lan-tag {
        when "derived-from-or-self(../type, 'l3vpn-svc:lan')" {
         description
         "Only applies when the VPN Policy filter is a
         LAN Tag filter.";
        }
         if-feature lan-tag;
         type string;
         description
         "List of 'lan-tag' items to be matched.  LAN Tag
         is an Internal tag to be used in VPN policies ";
        }
        leaf-list ipv4-lan-prefix {
        when "derived-from-or-self(../type, 'l3vpn-svc:ipv4')" {
          description
          "Only applies when VPN Policy filter is IPv4 Prefix filter.";
         }
         if-feature ipv4;
         type inet:ipv4-prefix;
         description
         "List of IPv4 prefixes as LAN Prefixes to be matched.";
        }
        leaf-list ipv6-lan-prefix {
        when "derived-from-or-self(../type, 'l3vpn-svc:ipv6')" {
        description
        "Only applies when VPN Policy filter is IPv6 Prefix filter.";
         }
         if-feature ipv6;
         type inet:ipv6-prefix;
         description
         "List of IPv6 prefixes as LAN prefixes to be matched.";
        }
         description
         "List of filters used on the site.  This list can
         be augmented.";
      }
      description
      "If a more-granular VPN attachment is necessary, filtering can
      be used.  If used, it permits the splitting of site LANs among
      multiple VPNs.  The Site LAN can be split based on either LAN
      Tag or LAN prefix.  If no filter is used, all the LANs will be
      part of the same VPNs with the same role.";
     }
     list vpn {
      key vpn-id;
      leaf vpn-id {
       type leafref {
        path "/l3vpn-svc/vpn-services/"+
         "vpn-service/vpn-id";
       }
       description
       "Reference to an IP VPN.";
      }
      leaf site-role {
       type identityref {
        base site-role;
       }
       default any-to-any-role;
       description
       "Role of the site in the IP VPN.";
      }
      description
      "List of VPNs the LAN is associated with.";
     }
     description
     "List of entries for export policy.";
    }
    description
    "List of VPN policies.";
   }
   description
   "VPN policy.";
  }
  description
  "VPN policy parameters for the site.";
 }
 grouping site-maximum-routes {
  container maximum-routes {
   list address-family {
    key af;
    leaf af {
     type address-family;
     description
     "Address family.";
    }
    leaf maximum-routes {
     type uint32;
     description
     "Maximum prefixes the VRF can accept
     for this address family.";
    }
    description
    "List of address families.";
   }
   description
   "Defines 'maximum-routes' for the VRF.";
  }
  description
  "Defines 'maximum-routes' for the site.";
 }
 grouping site-security {
  container security {
   uses site-security-authentication;
   uses site-security-encryption;
   description
   "Site-specific security parameters.";
  }
  description
  "Grouping for security parameters.";
 }
 grouping site-service {
  container service {
   uses site-service-qos-profile;
   uses site-service-mpls;
   uses site-service-multicast;
   description
   "Service parameters on the attachment.";
  }
  description
  "Grouping for service parameters.";
 }
 grouping site-network-access-service {
  container service {
   uses site-service-basic;
   uses site-service-qos-profile;
   uses site-service-mpls;
   uses site-service-multicast;
   description
   "Service parameters on the attachment.";
  }
  description
  "Grouping for service parameters.";
 }
 grouping vpn-extranet {
  container extranet-vpns {
   if-feature extranet-vpn;
   list extranet-vpn {
    key vpn-id;
    leaf vpn-id {
     type svc-id;
     description
     "Identifies the target VPN the local VPN want to access.";
    }
    leaf local-sites-role {
     type identityref {
      base site-role;
     }
     default any-to-any-role;
     description
     "This describes the role of the
     local sites in the target VPN topology.  In the any-to-any VPN
     service topology, the local sites must have the same role, which
     will be 'any-to-any-role'.  In the Hub-and-Spoke VPN service
     topology or the Hub-and-Spoke disjoint VPN service topology,
     the local sites must have a Hub role or a Spoke role.";
    }
    description
    "List of extranet VPNs or target VPNs the local VPN is
    attached to.";
   }
   description
   "Container for extranet VPN configuration.";
  }
  description
  "Grouping for extranet VPN configuration.
  This provides an easy way to interconnect
  all sites from two VPNs.";
 }
 grouping site-attachment-availability {
  container availability {
   leaf access-priority {
    type uint32;
    default 100;
    description
    "Defines the priority for the access.
    The higher the access-priority value,
    the higher the preference of the
    access will be.";
   }
   description
   "Availability parameters (used for multihoming).";
  }
  description
  "Defines availability parameters for a site.";
 }
 grouping access-vpn-policy {
  container vpn-attachment {
   choice attachment-flavor {
    case vpn-policy-id {
     leaf vpn-policy-id {
      type leafref {
       path "../../../../"+
        "vpn-policies/vpn-policy/"+
        "vpn-policy-id";
      }
      description
      "Reference to a VPN policy.  When referencing VPN
      policy for attachment, the vpn-policy-id must be
      configured.";
     }
    }
    case vpn-id {
     leaf vpn-id {
      type leafref {
       path "/l3vpn-svc/vpn-services"+
        "/vpn-service/vpn-id";
      }
      description
      "Reference to an IP VPN.  Referencing a vpn-id provides
      an easy way to attach a particular logical access to
      a VPN.  In this case, vpn-id must be configured.";
     }
     leaf site-role {
      type identityref {
       base site-role;
      }
      default any-to-any-role;
      description
      "Role of the site in the IP VPN.  When referencing a vpn-id,
      the site-role setting must be added to express the role of
      the site in the target VPN service topology.";
     }
    }
    mandatory true;
    description
    "Choice for VPN attachment flavor.  A choice is implemented
    to allow the user to choose the flavor that provides the
    best fit.";
   }
   description
   "Defines VPN attachment of a site.";
  }
  description
  "Defines the VPN attachment rules for
  a site's logical access.";
 }
 grouping vpn-profile-cfg {
  container valid-provider-identifiers {
   list cloud-identifier {
    if-feature cloud-access;
    key id;
    leaf id {
     type string;
     description
     "Identification of cloud service.
     Local administration meaning.";
    }
    description
    "List for Cloud Identifiers.";
   }
   list encryption-profile-identifier {
    key id;
    leaf id {
     type string;
     description
     "Identification of the SP encryption profile
     to be used.  Local administration meaning.";
    }
    description
    "List for encryption profile identifiers.";
   }
   list qos-profile-identifier {
    key id;
    leaf id {
     type string;
     description
     "Identification of the QoS Profile to be used.
     Local administration meaning.";
    }
    description
    "List for QoS Profile Identifiers.";
   }
   list bfd-profile-identifier {
    key id;
    leaf id {
     type string;
     description
     "Identification of the SP BFD Profile to be used.
     Local administration meaning.";
    }
    description
    "List for BFD Profile identifiers.";
   }
     description
     "Container for Valid Provider Identifies.";
  }
   description
   "Grouping for VPN Profile configuration.";
 }
 grouping vpn-svc-cfg {
  leaf vpn-id {
   type svc-id;
   description
   "VPN identifier.  Local administration meaning.";
  }
  leaf customer-name {
   type string;
   description
   "Name of the customer that actually uses the VPN service.
   In the case that any intermediary (e.g., Tier-2 provider
   or partner) sells the VPN service to their end user
   on behalf of the original service provider (e.g., Tier-1
   provider), the original service provider may require the
   customer name to provide smooth activation/commissioning
   and operation for the service.";
  }
  leaf vpn-service-topology {
   type identityref {
    base vpn-topology;
   }
   default any-to-any;
   description
   "VPN service topology.";
  }
  uses vpn-service-cloud-access;
  uses vpn-service-multicast;
  uses vpn-service-mpls;
  uses vpn-extranet;
  description
  "Grouping for VPN service configuration.";
 }
 grouping site-top-level-cfg {
  uses operational-requirements;
  uses customer-location-info;
  uses site-devices;
  uses site-diversity;
  uses site-management;
  uses site-vpn-policy;
  uses site-vpn-flavor;
  uses site-maximum-routes;
  uses site-security;
  uses site-service;
  uses site-protection;
  uses site-routing;
  description
  "Grouping for site top-level configuration.";
 }
 grouping site-network-access-top-level-cfg {
  leaf site-network-access-type {
   type identityref {
    base site-network-access-type;
   }
   default point-to-point;
   description
   "Describes the type of connection, e.g.,
   point-to-point or multipoint.";
  }
  choice location-flavor {
   case location {
    when "derived-from-or-self(../../management/type, "+
     "'l3vpn-svc:customer-managed')" {
     description
     "Applicable only for customer-managed device.";
    }
    leaf location-reference {
     type leafref {
      path "../../../locations/location/location-id";
     }
     description
     "Location of the site-network-access.";
    }
   }
   case device {
    when "derived-from-or-self(../../management/type, "+
     "'l3vpn-svc:provider-managed') or "+
     "derived-from-or-self(../../management/type, "+
     "'l3vpn-svc:co-managed')" {
     description
     "Applicable only for provider-managed or co-managed device.";
    }
    leaf device-reference {
     type leafref {
      path "../../../devices/device/device-id";
     }
     description
     "Identifier of CE to use.";
    }
   }
   mandatory true;
   description
   "Choice of how to describe the site's location.";
  }
  uses access-diversity;
  uses site-attachment-bearer;
  uses site-attachment-ip-connection;
  uses site-security;
  uses site-network-access-service;
  uses site-routing;
  uses site-attachment-availability;
  uses access-vpn-policy;
  description
  "Grouping for site network access top-level configuration.";
 }
 /* Main blocks */
 container l3vpn-svc {
  container vpn-profiles {
   uses vpn-profile-cfg;
    description
    "Container for VPN Profiles.";
  }
  container vpn-services {
   list vpn-service {
    key vpn-id;
    orchestron:transform sorespo.cfs.L3VpnVpnService;
    uses vpn-svc-cfg;
    description
    "List of VPN services.";
   }
   description
   "Top-level container for the VPN services.";
  }
  container sites {
   list site {
    key site-id;
    orchestron:transform sorespo.cfs.L3VpnSite;
    leaf site-id {
     type svc-id;
     description
     "Identifier of the site.";
    }
    uses site-top-level-cfg;
    uses operational-requirements-ops;
    container site-network-accesses {
     list site-network-access {
      key site-network-access-id;
      leaf site-network-access-id {
       type svc-id;
       description
       "Identifier for the access.";
      }
      uses site-network-access-top-level-cfg;
      description
      "List of accesses for a site.";
     }
     description
     "List of accesses for a site.";
    }
    description
    "List of sites.";
   }
   description
   "Container for sites.";
  }
  description
  "Main container for L3VPN service configuration.";
 }
}
""")
    res.append(r"""module ietf-yang-types {

  namespace "urn:ietf:params:xml:ns:yang:ietf-yang-types";
  prefix "yang";

  organization
   "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
   "WG Web:   <http://tools.ietf.org/wg/netmod/>
    WG List:  <mailto:netmod@ietf.org>

    WG Chair: David Kessens
              <mailto:david.kessens@nsn.com>

    WG Chair: Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>

    Editor:   Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>";

  description
   "This module contains a collection of generally useful derived
    YANG data types.

    Copyright (c) 2013 IETF Trust and the persons identified as
    authors of the code.  All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, is permitted pursuant to, and subject
    to the license terms contained in, the Simplified BSD License
    set forth in Section 4.c of the IETF Trust's Legal Provisions
    Relating to IETF Documents
    (http://trustee.ietf.org/license-info).

    This version of this YANG module is part of RFC 6991; see
    the RFC itself for full legal notices.";

  revision 2013-07-15 {
    description
     "This revision adds the following new data types:
      - yang-identifier
      - hex-string
      - uuid
      - dotted-quad";
    reference
     "RFC 6991: Common YANG Data Types";
  }

  revision 2010-09-24 {
    description
     "Initial revision.";
    reference
     "RFC 6021: Common YANG Data Types";
  }

  /*** collection of counter and gauge types ***/

  typedef counter32 {
    type uint32;
    description
     "The counter32 type represents a non-negative integer
      that monotonically increases until it reaches a
      maximum value of 2^32-1 (4294967295 decimal), when it
      wraps around and starts increasing again from zero.

      Counters have no defined 'initial' value, and thus, a
      single value of a counter has (in general) no information
      content.  Discontinuities in the monotonically increasing
      value normally occur at re-initialization of the
      management system, and at other times as specified in the
      description of a schema node using this type.  If such
      other times can occur, for example, the creation of
      a schema node of type counter32 at times other than
      re-initialization, then a corresponding schema node
      should be defined, with an appropriate type, to indicate
      the last discontinuity.

      The counter32 type should not be used for configuration
      schema nodes.  A default statement SHOULD NOT be used in
      combination with the type counter32.

      In the value set and its semantics, this type is equivalent
      to the Counter32 type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef zero-based-counter32 {
    type yang:counter32;
    default "0";
    description
     "The zero-based-counter32 type represents a counter32
      that has the defined 'initial' value zero.

      A schema node of this type will be set to zero (0) on creation
      and will thereafter increase monotonically until it reaches
      a maximum value of 2^32-1 (4294967295 decimal), when it
      wraps around and starts increasing again from zero.

      Provided that an application discovers a new schema node
      of this type within the minimum time to wrap, it can use the
      'initial' value as a delta.  It is important for a management
      station to be aware of this minimum time and the actual time
      between polls, and to discard data if the actual time is too
      long or there is no defined minimum time.

      In the value set and its semantics, this type is equivalent
      to the ZeroBasedCounter32 textual convention of the SMIv2.";
    reference
      "RFC 4502: Remote Network Monitoring Management Information
                 Base Version 2";
  }

  typedef counter64 {
    type uint64;
    description
     "The counter64 type represents a non-negative integer
      that monotonically increases until it reaches a
      maximum value of 2^64-1 (18446744073709551615 decimal),
      when it wraps around and starts increasing again from zero.

      Counters have no defined 'initial' value, and thus, a
      single value of a counter has (in general) no information
      content.  Discontinuities in the monotonically increasing
      value normally occur at re-initialization of the
      management system, and at other times as specified in the
      description of a schema node using this type.  If such
      other times can occur, for example, the creation of
      a schema node of type counter64 at times other than
      re-initialization, then a corresponding schema node
      should be defined, with an appropriate type, to indicate
      the last discontinuity.

      The counter64 type should not be used for configuration
      schema nodes.  A default statement SHOULD NOT be used in
      combination with the type counter64.

      In the value set and its semantics, this type is equivalent
      to the Counter64 type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef zero-based-counter64 {
    type yang:counter64;
    default "0";
    description
     "The zero-based-counter64 type represents a counter64 that
      has the defined 'initial' value zero.

      A schema node of this type will be set to zero (0) on creation
      and will thereafter increase monotonically until it reaches
      a maximum value of 2^64-1 (18446744073709551615 decimal),
      when it wraps around and starts increasing again from zero.

      Provided that an application discovers a new schema node
      of this type within the minimum time to wrap, it can use the
      'initial' value as a delta.  It is important for a management
      station to be aware of this minimum time and the actual time
      between polls, and to discard data if the actual time is too
      long or there is no defined minimum time.

      In the value set and its semantics, this type is equivalent
      to the ZeroBasedCounter64 textual convention of the SMIv2.";
    reference
     "RFC 2856: Textual Conventions for Additional High Capacity
                Data Types";
  }

  typedef gauge32 {
    type uint32;
    description
     "The gauge32 type represents a non-negative integer, which
      may increase or decrease, but shall never exceed a maximum
      value, nor fall below a minimum value.  The maximum value
      cannot be greater than 2^32-1 (4294967295 decimal), and
      the minimum value cannot be smaller than 0.  The value of
      a gauge32 has its maximum value whenever the information
      being modeled is greater than or equal to its maximum
      value, and has its minimum value whenever the information
      being modeled is smaller than or equal to its minimum value.
      If the information being modeled subsequently decreases
      below (increases above) the maximum (minimum) value, the
      gauge32 also decreases (increases).

      In the value set and its semantics, this type is equivalent
      to the Gauge32 type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef gauge64 {
    type uint64;
    description
     "The gauge64 type represents a non-negative integer, which
      may increase or decrease, but shall never exceed a maximum
      value, nor fall below a minimum value.  The maximum value
      cannot be greater than 2^64-1 (18446744073709551615), and
      the minimum value cannot be smaller than 0.  The value of
      a gauge64 has its maximum value whenever the information
      being modeled is greater than or equal to its maximum
      value, and has its minimum value whenever the information
      being modeled is smaller than or equal to its minimum value.
      If the information being modeled subsequently decreases
      below (increases above) the maximum (minimum) value, the
      gauge64 also decreases (increases).

      In the value set and its semantics, this type is equivalent
      to the CounterBasedGauge64 SMIv2 textual convention defined
      in RFC 2856";
    reference
     "RFC 2856: Textual Conventions for Additional High Capacity
                Data Types";
  }

  /*** collection of identifier-related types ***/

  typedef object-identifier {
    type string {
      pattern '(([0-1](\\.[1-3]?[0-9]))|(2\\.(0|([1-9]\\d*))))'
            + '(\\.(0|([1-9]\\d*)))*';
    }
    description
     "The object-identifier type represents administratively
      assigned names in a registration-hierarchical-name tree.

      Values of this type are denoted as a sequence of numerical
      non-negative sub-identifier values.  Each sub-identifier
      value MUST NOT exceed 2^32-1 (4294967295).  Sub-identifiers
      are separated by single dots and without any intermediate
      whitespace.

      The ASN.1 standard restricts the value space of the first
      sub-identifier to 0, 1, or 2.  Furthermore, the value space
      of the second sub-identifier is restricted to the range
      0 to 39 if the first sub-identifier is 0 or 1.  Finally,
      the ASN.1 standard requires that an object identifier
      has always at least two sub-identifiers.  The pattern
      captures these restrictions.

      Although the number of sub-identifiers is not limited,
      module designers should realize that there may be
      implementations that stick with the SMIv2 limit of 128
      sub-identifiers.

      This type is a superset of the SMIv2 OBJECT IDENTIFIER type
      since it is not restricted to 128 sub-identifiers.  Hence,
      this type SHOULD NOT be used to represent the SMIv2 OBJECT
      IDENTIFIER type; the object-identifier-128 type SHOULD be
      used instead.";
    reference
     "ISO9834-1: Information technology -- Open Systems
      Interconnection -- Procedures for the operation of OSI
      Registration Authorities: General procedures and top
      arcs of the ASN.1 Object Identifier tree";
  }

  typedef object-identifier-128 {
    type object-identifier {
      pattern '\\d*(\\.\\d*){1,127}';
    }
    description
     "This type represents object-identifiers restricted to 128
      sub-identifiers.

      In the value set and its semantics, this type is equivalent
      to the OBJECT IDENTIFIER type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef yang-identifier {
    type string {
      length "1..max";
      pattern '[a-zA-Z_][a-zA-Z0-9\\-_.]*';
      pattern '.|..|[^xX].*|.[^mM].*|..[^lL].*';
    }
    description
      "A YANG identifier string as defined by the 'identifier'
       rule in Section 12 of RFC 6020.  An identifier must
       start with an alphabetic character or an underscore
       followed by an arbitrary sequence of alphabetic or
       numeric characters, underscores, hyphens, or dots.

       A YANG identifier MUST NOT start with any possible
       combination of the lowercase or uppercase character
       sequence 'xml'.";
    reference
      "RFC 6020: YANG - A Data Modeling Language for the Network
                 Configuration Protocol (NETCONF)";
  }

  /*** collection of types related to date and time***/

  typedef date-and-time {
    type string {
      pattern '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?'
            + '(Z|[\\+\\-]\\d{2}:\\d{2})';
    }
    description
     "The date-and-time type is a profile of the ISO 8601
      standard for representation of dates and times using the
      Gregorian calendar.  The profile is defined by the
      date-time production in Section 5.6 of RFC 3339.

      The date-and-time type is compatible with the dateTime XML
      schema type with the following notable exceptions:

      (a) The date-and-time type does not allow negative years.

      (b) The date-and-time time-offset -00:00 indicates an unknown
          time zone (see RFC 3339) while -00:00 and +00:00 and Z
          all represent the same time zone in dateTime.

      (c) The canonical format (see below) of data-and-time values
          differs from the canonical format used by the dateTime XML
          schema type, which requires all times to be in UTC using
          the time-offset 'Z'.

      This type is not equivalent to the DateAndTime textual
      convention of the SMIv2 since RFC 3339 uses a different
      separator between full-date and full-time and provides
      higher resolution of time-secfrac.

      The canonical format for date-and-time values with a known time
      zone uses a numeric time zone offset that is calculated using
      the device's configured known offset to UTC time.  A change of
      the device's offset to UTC time will cause date-and-time values
      to change accordingly.  Such changes might happen periodically
      in case a server follows automatically daylight saving time
      (DST) time zone offset changes.  The canonical format for
      date-and-time values with an unknown time zone (usually
      referring to the notion of local time) uses the time-offset
      -00:00.";
    reference
     "RFC 3339: Date and Time on the Internet: Timestamps
      RFC 2579: Textual Conventions for SMIv2
      XSD-TYPES: XML Schema Part 2: Datatypes Second Edition";
  }

  typedef timeticks {
    type uint32;
    description
     "The timeticks type represents a non-negative integer that
      represents the time, modulo 2^32 (4294967296 decimal), in
      hundredths of a second between two epochs.  When a schema
      node is defined that uses this type, the description of
      the schema node identifies both of the reference epochs.

      In the value set and its semantics, this type is equivalent
      to the TimeTicks type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef timestamp {
    type yang:timeticks;
    description
     "The timestamp type represents the value of an associated
      timeticks schema node at which a specific occurrence
      happened.  The specific occurrence must be defined in the
      description of any schema node defined using this type.  When
      the specific occurrence occurred prior to the last time the
      associated timeticks attribute was zero, then the timestamp
      value is zero.  Note that this requires all timestamp values
      to be reset to zero when the value of the associated timeticks
      attribute reaches 497+ days and wraps around to zero.

      The associated timeticks schema node must be specified
      in the description of any schema node using this type.

      In the value set and its semantics, this type is equivalent
      to the TimeStamp textual convention of the SMIv2.";
    reference
     "RFC 2579: Textual Conventions for SMIv2";
  }

  /*** collection of generic address types ***/

  typedef phys-address {
    type string {
      pattern '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?';
    }

    description
     "Represents media- or physical-level addresses represented
      as a sequence octets, each octet represented by two hexadecimal
      numbers.  Octets are separated by colons.  The canonical
      representation uses lowercase characters.

      In the value set and its semantics, this type is equivalent
      to the PhysAddress textual convention of the SMIv2.";
    reference
     "RFC 2579: Textual Conventions for SMIv2";
  }

  typedef mac-address {
    type string {
      pattern '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}';
    }
    description
     "The mac-address type represents an IEEE 802 MAC address.
      The canonical representation uses lowercase characters.

      In the value set and its semantics, this type is equivalent
      to the MacAddress textual convention of the SMIv2.";
    reference
     "IEEE 802: IEEE Standard for Local and Metropolitan Area
                Networks: Overview and Architecture
      RFC 2579: Textual Conventions for SMIv2";
  }

  /*** collection of XML-specific types ***/

  typedef xpath1.0 {
    type string;
    description
     "This type represents an XPATH 1.0 expression.

      When a schema node is defined that uses this type, the
      description of the schema node MUST specify the XPath
      context in which the XPath expression is evaluated.";
    reference
     "XPATH: XML Path Language (XPath) Version 1.0";
  }

  /*** collection of string types ***/

  typedef hex-string {
    type string {
      pattern '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?';
    }
    description
     "A hexadecimal string with octets represented as hex digits
      separated by colons.  The canonical representation uses
      lowercase characters.";
  }

  typedef uuid {
    type string {
      pattern '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-'
            + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}';
    }
    description
     "A Universally Unique IDentifier in the string representation
      defined in RFC 4122.  The canonical representation uses
      lowercase characters.

      The following is an example of a UUID in string representation:
      f81d4fae-7dec-11d0-a765-00a0c91e6bf6
      ";
    reference
     "RFC 4122: A Universally Unique IDentifier (UUID) URN
                Namespace";
  }

  typedef dotted-quad {
    type string {
      pattern
        '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}'
      + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
    }
    description
      "An unsigned 32-bit number expressed in the dotted-quad
       notation, i.e., four octets written as decimal numbers
       and separated with the '.' (full stop) character.";
  }
}
""")
    res.append(r"""module netinfra {
  yang-version "1.1";
  namespace "http://example.com/netinfra";
  prefix "netinfra";
  description "Network Infrastructure";
  revision 2019-01-01 {
    description "test revision";
    reference "ref1";
  }
  import ietf-inet-types {
    prefix inet;
  }

  container netinfra {
    description "Network infrastructure";
    list router {
      key name;

      orchestron:transform sorespo.cfs.Router;

      leaf name {
        type string;
      }
      leaf id {
        type uint32;
        description "router id";
        mandatory true;
      }
      leaf type {
        type string;
        mandatory true;
      }
      leaf role {
        type string;
      }
      leaf asn {
        type inet:as-number;
        mandatory true;
      }
      leaf mock {
        type enumeration {
          enum cisco-ios-xr;
          enum juniper-junos;
        }
      }
      leaf approval-required {
        type boolean;
        default false;
      }
    }

    list backbone-link {
      key "left-router left-interface right-router right-interface";

      orchestron:transform sorespo.cfs.BBLink;

      leaf left-router {
        type string;
      }
      leaf left-interface {
        type string;
      }
      leaf right-router {
        type string;
      }
      leaf right-interface {
        type string;
      }
      leaf monitor-health {
        type boolean;
        default false;
      }
    }
  }
}
""")
    res.append(r"""module ietf-inet-types {

  namespace "urn:ietf:params:xml:ns:yang:ietf-inet-types";
  prefix "inet";

  organization
   "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
   "WG Web:   <http://tools.ietf.org/wg/netmod/>
    WG List:  <mailto:netmod@ietf.org>

    WG Chair: David Kessens
              <mailto:david.kessens@nsn.com>

    WG Chair: Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>

    Editor:   Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>";

  description
   "This module contains a collection of generally useful derived
    YANG data types for Internet addresses and related things.

    Copyright (c) 2013 IETF Trust and the persons identified as
    authors of the code.  All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, is permitted pursuant to, and subject
    to the license terms contained in, the Simplified BSD License
    set forth in Section 4.c of the IETF Trust's Legal Provisions
    Relating to IETF Documents
    (http://trustee.ietf.org/license-info).

    This version of this YANG module is part of RFC 6991; see
    the RFC itself for full legal notices.";

  revision 2013-07-15 {
    description
     "This revision adds the following new data types:
      - ip-address-no-zone
      - ipv4-address-no-zone
      - ipv6-address-no-zone";
    reference
     "RFC 6991: Common YANG Data Types";
  }

  revision 2010-09-24 {
    description
     "Initial revision.";
    reference
     "RFC 6021: Common YANG Data Types";
  }

  /*** collection of types related to protocol fields ***/

  typedef ip-version {
    type enumeration {
      enum unknown {
        value "0";
        description
         "An unknown or unspecified version of the Internet
          protocol.";
      }
      enum ipv4 {
        value "1";
        description
         "The IPv4 protocol as defined in RFC 791.";
      }
      enum ipv6 {
        value "2";
        description
         "The IPv6 protocol as defined in RFC 2460.";
      }
    }
    description
     "This value represents the version of the IP protocol.

      In the value set and its semantics, this type is equivalent
      to the InetVersion textual convention of the SMIv2.";
    reference
     "RFC  791: Internet Protocol
      RFC 2460: Internet Protocol, Version 6 (IPv6) Specification
      RFC 4001: Textual Conventions for Internet Network Addresses";
  }

  typedef dscp {
    type uint8 {
      range "0..63";
    }
    description
     "The dscp type represents a Differentiated Services Code Point
      that may be used for marking packets in a traffic stream.
      In the value set and its semantics, this type is equivalent
      to the Dscp textual convention of the SMIv2.";
    reference
     "RFC 3289: Management Information Base for the Differentiated
                Services Architecture
      RFC 2474: Definition of the Differentiated Services Field
                (DS Field) in the IPv4 and IPv6 Headers
      RFC 2780: IANA Allocation Guidelines For Values In
                the Internet Protocol and Related Headers";
  }

  typedef ipv6-flow-label {
    type uint32 {
      range "0..1048575";
    }
    description
     "The ipv6-flow-label type represents the flow identifier or Flow
      Label in an IPv6 packet header that may be used to
      discriminate traffic flows.

      In the value set and its semantics, this type is equivalent
      to the IPv6FlowLabel textual convention of the SMIv2.";
    reference
     "RFC 3595: Textual Conventions for IPv6 Flow Label
      RFC 2460: Internet Protocol, Version 6 (IPv6) Specification";
  }

  typedef port-number {
    type uint16 {
      range "0..65535";
    }
    description
     "The port-number type represents a 16-bit port number of an
      Internet transport-layer protocol such as UDP, TCP, DCCP, or
      SCTP.  Port numbers are assigned by IANA.  A current list of
      all assignments is available from <http://www.iana.org/>.

      Note that the port number value zero is reserved by IANA.  In
      situations where the value zero does not make sense, it can
      be excluded by subtyping the port-number type.
      In the value set and its semantics, this type is equivalent
      to the InetPortNumber textual convention of the SMIv2.";
    reference
     "RFC  768: User Datagram Protocol
      RFC  793: Transmission Control Protocol
      RFC 4960: Stream Control Transmission Protocol
      RFC 4340: Datagram Congestion Control Protocol (DCCP)
      RFC 4001: Textual Conventions for Internet Network Addresses";
  }

  /*** collection of types related to autonomous systems ***/

  typedef as-number {
    type uint32;
    description
     "The as-number type represents autonomous system numbers
      which identify an Autonomous System (AS).  An AS is a set
      of routers under a single technical administration, using
      an interior gateway protocol and common metrics to route
      packets within the AS, and using an exterior gateway
      protocol to route packets to other ASes.  IANA maintains
      the AS number space and has delegated large parts to the
      regional registries.

      Autonomous system numbers were originally limited to 16
      bits.  BGP extensions have enlarged the autonomous system
      number space to 32 bits.  This type therefore uses an uint32
      base type without a range restriction in order to support
      a larger autonomous system number space.

      In the value set and its semantics, this type is equivalent
      to the InetAutonomousSystemNumber textual convention of
      the SMIv2.";
    reference
     "RFC 1930: Guidelines for creation, selection, and registration
                of an Autonomous System (AS)
      RFC 4271: A Border Gateway Protocol 4 (BGP-4)
      RFC 4001: Textual Conventions for Internet Network Addresses
      RFC 6793: BGP Support for Four-Octet Autonomous System (AS)
                Number Space";
  }

  /*** collection of types related to IP addresses and hostnames ***/

  typedef ip-address {
    type union {
      type inet:ipv4-address;
      type inet:ipv6-address;
    }
    description
     "The ip-address type represents an IP address and is IP
      version neutral.  The format of the textual representation
      implies the IP version.  This type supports scoped addresses
      by allowing zone identifiers in the address format.";
    reference
     "RFC 4007: IPv6 Scoped Address Architecture";
  }

  typedef ipv4-address {
    type string {
      pattern
        '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}'
      +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
      + '(%[\\p{N}\\p{L}]+)?';
    }
    description
      "The ipv4-address type represents an IPv4 address in
       dotted-quad notation.  The IPv4 address may include a zone
       index, separated by a % sign.

       The zone index is used to disambiguate identical address
       values.  For link-local addresses, the zone index will
       typically be the interface index number or the name of an
       interface.  If the zone index is not present, the default
       zone of the device will be used.

       The canonical format for the zone index is the numerical
       format";
  }

  typedef ipv6-address {
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
            + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
            + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}'
            + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
            + '(%[\\p{N}\\p{L}]+)?';
      pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\\..*)))|'
            + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
            + '(%.+)?';
    }
    description
     "The ipv6-address type represents an IPv6 address in full,
      mixed, shortened, and shortened-mixed notation.  The IPv6
      address may include a zone index, separated by a % sign.

      The zone index is used to disambiguate identical address
      values.  For link-local addresses, the zone index will
      typically be the interface index number or the name of an
      interface.  If the zone index is not present, the default
      zone of the device will be used.

      The canonical format of IPv6 addresses uses the textual
      representation defined in Section 4 of RFC 5952.  The
      canonical format for the zone index is the numerical
      format as described in Section 11.2 of RFC 4007.";
    reference
     "RFC 4291: IP Version 6 Addressing Architecture
      RFC 4007: IPv6 Scoped Address Architecture
      RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
  }

  typedef ip-address-no-zone {
    type union {
      type inet:ipv4-address-no-zone;
      type inet:ipv6-address-no-zone;
    }
    description
     "The ip-address-no-zone type represents an IP address and is
      IP version neutral.  The format of the textual representation
      implies the IP version.  This type does not support scoped
      addresses since it does not allow zone identifiers in the
      address format.";
    reference
     "RFC 4007: IPv6 Scoped Address Architecture";
  }

  typedef ipv4-address-no-zone {
    type inet:ipv4-address {
      pattern '[0-9\\.]*';
    }
    description
      "An IPv4 address without a zone index.  This type, derived from
       ipv4-address, may be used in situations where the zone is
       known from the context and hence no zone index is needed.";
  }

  typedef ipv6-address-no-zone {
    type inet:ipv6-address {
      pattern '[0-9a-fA-F:\\.]*';
    }
    description
      "An IPv6 address without a zone index.  This type, derived from
       ipv6-address, may be used in situations where the zone is
       known from the context and hence no zone index is needed.";
    reference
     "RFC 4291: IP Version 6 Addressing Architecture
      RFC 4007: IPv6 Scoped Address Architecture
      RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
  }

  typedef ip-prefix {
    type union {
      type inet:ipv4-prefix;
      type inet:ipv6-prefix;
    }
    description
     "The ip-prefix type represents an IP prefix and is IP
      version neutral.  The format of the textual representations
      implies the IP version.";
  }

  typedef ipv4-prefix {
    type string {
      pattern
         '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}'
       +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
       + '/(([0-9])|([1-2][0-9])|(3[0-2]))';
    }
    description
     "The ipv4-prefix type represents an IPv4 address prefix.
      The prefix length is given by the number following the
      slash character and must be less than or equal to 32.

      A prefix length value of n corresponds to an IP address
      mask that has n contiguous 1-bits from the most
      significant bit (MSB) and all other bits set to 0.

      The canonical format of an IPv4 prefix has all bits of
      the IPv4 address set to zero that are not part of the
      IPv4 prefix.";
  }

  typedef ipv6-prefix {
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
            + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
            + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}'
            + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
            + '(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))';
      pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\\..*)))|'
            + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
            + '(/.+)';
    }

    description
     "The ipv6-prefix type represents an IPv6 address prefix.
      The prefix length is given by the number following the
      slash character and must be less than or equal to 128.

      A prefix length value of n corresponds to an IP address
      mask that has n contiguous 1-bits from the most
      significant bit (MSB) and all other bits set to 0.

      The IPv6 address should have all bits that do not belong
      to the prefix set to zero.

      The canonical format of an IPv6 prefix has all bits of
      the IPv6 address set to zero that are not part of the
      IPv6 prefix.  Furthermore, the IPv6 address is represented
      as defined in Section 4 of RFC 5952.";
    reference
     "RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
  }

  /*** collection of domain name and URI types ***/

  typedef domain-name {
    type string {
      pattern
        '((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*'
      + '([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)'
      + '|\\.';
      length "1..253";
    }
    description
     "The domain-name type represents a DNS domain name.  The
      name SHOULD be fully qualified whenever possible.

      Internet domain names are only loosely specified.  Section
      3.5 of RFC 1034 recommends a syntax (modified in Section
      2.1 of RFC 1123).  The pattern above is intended to allow
      for current practice in domain name use, and some possible
      future expansion.  It is designed to hold various types of
      domain names, including names used for A or AAAA records
      (host names) and other records, such as SRV records.  Note
      that Internet host names have a stricter syntax (described
      in RFC 952) than the DNS recommendations in RFCs 1034 and
      1123, and that systems that want to store host names in
      schema nodes using the domain-name type are recommended to
      adhere to this stricter standard to ensure interoperability.

      The encoding of DNS names in the DNS protocol is limited
      to 255 characters.  Since the encoding consists of labels
      prefixed by a length bytes and there is a trailing NULL
      byte, only 253 characters can appear in the textual dotted
      notation.

      The description clause of schema nodes using the domain-name
      type MUST describe when and how these names are resolved to
      IP addresses.  Note that the resolution of a domain-name value
      may require to query multiple DNS records (e.g., A for IPv4
      and AAAA for IPv6).  The order of the resolution process and
      which DNS record takes precedence can either be defined
      explicitly or may depend on the configuration of the
      resolver.

      Domain-name values use the US-ASCII encoding.  Their canonical
      format uses lowercase US-ASCII characters.  Internationalized
      domain names MUST be A-labels as per RFC 5890.";
    reference
     "RFC  952: DoD Internet Host Table Specification
      RFC 1034: Domain Names - Concepts and Facilities
      RFC 1123: Requirements for Internet Hosts -- Application
                and Support
      RFC 2782: A DNS RR for specifying the location of services
                (DNS SRV)
      RFC 5890: Internationalized Domain Names in Applications
                (IDNA): Definitions and Document Framework";
  }

  typedef host {
    type union {
      type inet:ip-address;
      type inet:domain-name;
    }
    description
     "The host type represents either an IP address or a DNS
      domain name.";
  }

  typedef uri {
    type string;
    description
     "The uri type represents a Uniform Resource Identifier
      (URI) as defined by STD 66.

      Objects using the uri type MUST be in US-ASCII encoding,
      and MUST be normalized as described by RFC 3986 Sections
      6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary
      percent-encoding is removed, and all case-insensitive
      characters are set to lowercase except for hexadecimal
      digits, which are normalized to uppercase as described in
      Section 6.2.2.1.

      The purpose of this normalization is to help provide
      unique URIs.  Note that this normalization is not
      sufficient to provide uniqueness.  Two URIs that are
      textually distinct after this normalization may still be
      equivalent.

      Objects using the uri type may restrict the schemes that
      they permit.  For example, 'data:' and 'urn:' schemes
      might not be appropriate.

      A zero-length URI is not a valid URI.  This can be used to
      express 'URI absent' where required.

      In the value set and its semantics, this type is equivalent
      to the Uri SMIv2 textual convention defined in RFC 5017.";
    reference
     "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax
      RFC 3305: Report from the Joint W3C/IETF URI Planning Interest
                Group: Uniform Resource Identifiers (URIs), URLs,
                and Uniform Resource Names (URNs): Clarifications
                and Recommendations
      RFC 5017: MIB Textual Conventions for Uniform Resource
                Identifiers (URIs)";
  }

}
""")
    return res


mut def from_json_netinfra__netinfra__router__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra__netinfra__router__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__router__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_netinfra__netinfra__router__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_netinfra__netinfra__router__type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra__netinfra__router__type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__router__role(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra__netinfra__router__role(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__router__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_netinfra__netinfra__router__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_netinfra__netinfra__router__mock(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_netinfra__netinfra__router__mock(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_netinfra__netinfra__router__approval_required(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_netinfra__netinfra__router__approval_required(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class netinfra__netinfra__router_entry(yang.adata.MNode):
    name: str
    id: int
    type: str
    role: ?str
    asn: int
    mock: ?str
    approval_required: bool

    mut def __init__(self, name: str, id: int, type: str, asn: int, role: ?str, mock: ?str, approval_required: ?bool=None):
        self._ns = 'http://example.com/netinfra'
        self.name = name
        self.id = id
        self.type = type
        self.role = role
        self.asn = asn
        self.mock = mock
        self.approval_required = approval_required if approval_required is not None else False

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint32', _id)
        _type = self.type
        if _type is not None:
            children['type'] = yang.gdata.Leaf('string', _type)
        _role = self.role
        if _role is not None:
            children['role'] = yang.gdata.Leaf('string', _role)
        _asn = self.asn
        if _asn is not None:
            children['asn'] = yang.gdata.Leaf('uint32', _asn)
        _mock = self.mock
        if _mock is not None:
            children['mock'] = yang.gdata.Leaf('enumeration', _mock)
        _approval_required = self.approval_required
        if _approval_required is not None:
            children['approval-required'] = yang.gdata.Leaf('boolean', _approval_required)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra__netinfra__router_entry:
        return netinfra__netinfra__router_entry(name=n.get_str('name'), id=n.get_int('id'), type=n.get_str('type'), role=n.get_opt_str('role'), asn=n.get_int('asn'), mock=n.get_opt_str('mock'), approval_required=n.get_opt_bool('approval-required'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return netinfra__netinfra__router_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /netinfra/router')
            res.append('{self_name} = netinfra__netinfra__router({repr(self.name)}, {repr(self.id)}, {repr(self.type)}, {repr(self.asn)})')
        leaves = []
        _role = self.role
        if _role is not None:
            leaves.append('{self_name}.role = {repr(_role)}')
        _mock = self.mock
        if _mock is not None:
            leaves.append('{self_name}.mock = {repr(_mock)}')
        _approval_required = self.approval_required
        if _approval_required is not None:
            leaves.append('{self_name}.approval_required = {repr(_approval_required)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /netinfra/router'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['netinfra:netinfra', 'router'])

class netinfra__netinfra__router(yang.adata.MNode):
    elements: list[netinfra__netinfra__router_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/netinfra'
        self._name = 'router'
        self.elements = elements

    mut def create(self, name, id, type, asn):
        for e in self:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = netinfra__netinfra__router_entry(name, id, type, asn)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra__netinfra__router_entry]:
        if n is not None:
            return [netinfra__netinfra__router_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return netinfra__netinfra__router(elements=copied_elements)

extension netinfra__netinfra__router(Iterable[netinfra__netinfra__router_entry]):
    def __iter__(self) -> Iterator[netinfra__netinfra__router_entry]:
        return self.elements.__iter__()

mut def from_xml_netinfra__netinfra__router_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_netinfra__netinfra__router__name, child_name)
    child_id = yang.gdata.from_xml_int(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_netinfra__netinfra__router__id, child_id)
    child_type = yang.gdata.from_xml_str(node, 'type')
    yang.gdata.maybe_add(children, 'type', from_xml_netinfra__netinfra__router__type, child_type)
    child_role = yang.gdata.from_xml_opt_str(node, 'role')
    yang.gdata.maybe_add(children, 'role', from_xml_netinfra__netinfra__router__role, child_role)
    child_asn = yang.gdata.from_xml_int(node, 'asn')
    yang.gdata.maybe_add(children, 'asn', from_xml_netinfra__netinfra__router__asn, child_asn)
    child_mock = yang.gdata.from_xml_opt_str(node, 'mock')
    yang.gdata.maybe_add(children, 'mock', from_xml_netinfra__netinfra__router__mock, child_mock)
    child_approval_required = yang.gdata.from_xml_opt_bool(node, 'approval-required')
    yang.gdata.maybe_add(children, 'approval-required', from_xml_netinfra__netinfra__router__approval_required, child_approval_required)
    return yang.gdata.Container(children)

mut def from_xml_netinfra__netinfra__router(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_netinfra__netinfra__router_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_json_path_netinfra__netinfra__router_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra__netinfra__router_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['name']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_netinfra__netinfra__router__name(keys[0])
        if point == 'id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'role':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'asn':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'mock':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'approval-required':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra__netinfra__router(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra__netinfra__router_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['name'])))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_netinfra__netinfra__router_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra__netinfra__router_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_netinfra__netinfra__router__name, child_name)
    child_id = yang.gdata.take_json_int(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_netinfra__netinfra__router__id, child_id)
    child_type = yang.gdata.take_json_str(jd, 'type')
    yang.gdata.maybe_add(children, 'type', from_json_netinfra__netinfra__router__type, child_type)
    child_role = yang.gdata.take_json_opt_str(jd, 'role')
    yang.gdata.maybe_add(children, 'role', from_json_netinfra__netinfra__router__role, child_role)
    child_asn = yang.gdata.take_json_int(jd, 'asn')
    yang.gdata.maybe_add(children, 'asn', from_json_netinfra__netinfra__router__asn, child_asn)
    child_mock = yang.gdata.take_json_opt_str(jd, 'mock')
    yang.gdata.maybe_add(children, 'mock', from_json_netinfra__netinfra__router__mock, child_mock)
    child_approval_required = yang.gdata.take_json_opt_bool(jd, 'approval-required')
    yang.gdata.maybe_add(children, 'approval-required', from_json_netinfra__netinfra__router__approval_required, child_approval_required)
    return yang.gdata.Container(children)

mut def from_json_netinfra__netinfra__router(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_netinfra__netinfra__router_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_json_netinfra__netinfra__backbone_link__left_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra__netinfra__backbone_link__left_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__backbone_link__left_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra__netinfra__backbone_link__left_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__backbone_link__right_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra__netinfra__backbone_link__right_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__backbone_link__right_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra__netinfra__backbone_link__right_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__backbone_link__monitor_health(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_netinfra__netinfra__backbone_link__monitor_health(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class netinfra__netinfra__backbone_link_entry(yang.adata.MNode):
    left_router: str
    left_interface: str
    right_router: str
    right_interface: str
    monitor_health: bool

    mut def __init__(self, left_router: str, left_interface: str, right_router: str, right_interface: str, monitor_health: ?bool=None):
        self._ns = 'http://example.com/netinfra'
        self.left_router = left_router
        self.left_interface = left_interface
        self.right_router = right_router
        self.right_interface = right_interface
        self.monitor_health = monitor_health if monitor_health is not None else False

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _left_router = self.left_router
        if _left_router is not None:
            children['left-router'] = yang.gdata.Leaf('string', _left_router)
        _left_interface = self.left_interface
        if _left_interface is not None:
            children['left-interface'] = yang.gdata.Leaf('string', _left_interface)
        _right_router = self.right_router
        if _right_router is not None:
            children['right-router'] = yang.gdata.Leaf('string', _right_router)
        _right_interface = self.right_interface
        if _right_interface is not None:
            children['right-interface'] = yang.gdata.Leaf('string', _right_interface)
        _monitor_health = self.monitor_health
        if _monitor_health is not None:
            children['monitor-health'] = yang.gdata.Leaf('boolean', _monitor_health)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra__netinfra__backbone_link_entry:
        return netinfra__netinfra__backbone_link_entry(left_router=n.get_str('left-router'), left_interface=n.get_str('left-interface'), right_router=n.get_str('right-router'), right_interface=n.get_str('right-interface'), monitor_health=n.get_opt_bool('monitor-health'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return netinfra__netinfra__backbone_link_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /netinfra/backbone-link')
            res.append('{self_name} = netinfra__netinfra__backbone_link({repr(self.left_router)}, {repr(self.left_interface)}, {repr(self.right_router)}, {repr(self.right_interface)})')
        leaves = []
        _monitor_health = self.monitor_health
        if _monitor_health is not None:
            leaves.append('{self_name}.monitor_health = {repr(_monitor_health)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /netinfra/backbone-link'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['netinfra:netinfra', 'backbone-link'])

class netinfra__netinfra__backbone_link(yang.adata.MNode):
    elements: list[netinfra__netinfra__backbone_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/netinfra'
        self._name = 'backbone-link'
        self.elements = elements

    mut def create(self, left_router, left_interface, right_router, right_interface):
        for e in self:
            match = True
            if e.left_router != left_router:
                match = False
                continue
            if e.left_interface != left_interface:
                match = False
                continue
            if e.right_router != right_router:
                match = False
                continue
            if e.right_interface != right_interface:
                match = False
                continue
            if match:
                return e

        res = netinfra__netinfra__backbone_link_entry(left_router, left_interface, right_router, right_interface)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra__netinfra__backbone_link_entry]:
        if n is not None:
            return [netinfra__netinfra__backbone_link_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return netinfra__netinfra__backbone_link(elements=copied_elements)

extension netinfra__netinfra__backbone_link(Iterable[netinfra__netinfra__backbone_link_entry]):
    def __iter__(self) -> Iterator[netinfra__netinfra__backbone_link_entry]:
        return self.elements.__iter__()

mut def from_xml_netinfra__netinfra__backbone_link_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_left_router = yang.gdata.from_xml_str(node, 'left-router')
    yang.gdata.maybe_add(children, 'left-router', from_xml_netinfra__netinfra__backbone_link__left_router, child_left_router)
    child_left_interface = yang.gdata.from_xml_str(node, 'left-interface')
    yang.gdata.maybe_add(children, 'left-interface', from_xml_netinfra__netinfra__backbone_link__left_interface, child_left_interface)
    child_right_router = yang.gdata.from_xml_str(node, 'right-router')
    yang.gdata.maybe_add(children, 'right-router', from_xml_netinfra__netinfra__backbone_link__right_router, child_right_router)
    child_right_interface = yang.gdata.from_xml_str(node, 'right-interface')
    yang.gdata.maybe_add(children, 'right-interface', from_xml_netinfra__netinfra__backbone_link__right_interface, child_right_interface)
    child_monitor_health = yang.gdata.from_xml_opt_bool(node, 'monitor-health')
    yang.gdata.maybe_add(children, 'monitor-health', from_xml_netinfra__netinfra__backbone_link__monitor_health, child_monitor_health)
    return yang.gdata.Container(children)

mut def from_xml_netinfra__netinfra__backbone_link(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_netinfra__netinfra__backbone_link_element(e) for e in nodes]
    return yang.gdata.List(keys=['left-router', 'left-interface', 'right-router', 'right-interface'], elements=elements)

mut def from_json_path_netinfra__netinfra__backbone_link_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra__netinfra__backbone_link_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['left-router', 'left-interface', 'right-router', 'right-interface']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['left-router'] = from_json_netinfra__netinfra__backbone_link__left_router(keys[0])
        children['left-interface'] = from_json_netinfra__netinfra__backbone_link__left_interface(keys[1])
        children['right-router'] = from_json_netinfra__netinfra__backbone_link__right_router(keys[2])
        children['right-interface'] = from_json_netinfra__netinfra__backbone_link__right_interface(keys[3])
        if point == 'monitor-health':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra__netinfra__backbone_link(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['left-router', 'left-interface', 'right-router', 'right-interface']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra__netinfra__backbone_link_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['left-router', 'left-interface', 'right-router', 'right-interface'])))
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], [from_json_path_netinfra__netinfra__backbone_link_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra__netinfra__backbone_link_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_left_router = yang.gdata.take_json_str(jd, 'left-router')
    yang.gdata.maybe_add(children, 'left-router', from_json_netinfra__netinfra__backbone_link__left_router, child_left_router)
    child_left_interface = yang.gdata.take_json_str(jd, 'left-interface')
    yang.gdata.maybe_add(children, 'left-interface', from_json_netinfra__netinfra__backbone_link__left_interface, child_left_interface)
    child_right_router = yang.gdata.take_json_str(jd, 'right-router')
    yang.gdata.maybe_add(children, 'right-router', from_json_netinfra__netinfra__backbone_link__right_router, child_right_router)
    child_right_interface = yang.gdata.take_json_str(jd, 'right-interface')
    yang.gdata.maybe_add(children, 'right-interface', from_json_netinfra__netinfra__backbone_link__right_interface, child_right_interface)
    child_monitor_health = yang.gdata.take_json_opt_bool(jd, 'monitor-health')
    yang.gdata.maybe_add(children, 'monitor-health', from_json_netinfra__netinfra__backbone_link__monitor_health, child_monitor_health)
    return yang.gdata.Container(children)

mut def from_json_netinfra__netinfra__backbone_link(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_netinfra__netinfra__backbone_link_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['left-router', 'left-interface', 'right-router', 'right-interface'], elements=elements)

class netinfra__netinfra(yang.adata.MNode):
    router: netinfra__netinfra__router
    backbone_link: netinfra__netinfra__backbone_link

    mut def __init__(self, router: list[netinfra__netinfra__router_entry]=[], backbone_link: list[netinfra__netinfra__backbone_link_entry]=[]):
        self._ns = 'http://example.com/netinfra'
        self.router = netinfra__netinfra__router(elements=router)
        self.backbone_link = netinfra__netinfra__backbone_link(elements=backbone_link)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _router = self.router
        if _router is not None:
            children['router'] = _router.to_gdata()
        _backbone_link = self.backbone_link
        if _backbone_link is not None:
            children['backbone-link'] = _backbone_link.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/netinfra', module='netinfra')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> netinfra__netinfra:
        if n is not None:
            return netinfra__netinfra(router=netinfra__netinfra__router.from_gdata(n.get_opt_list('router')), backbone_link=netinfra__netinfra__backbone_link.from_gdata(n.get_opt_list('backbone-link')))
        return netinfra__netinfra()

    def copy(self):
        """Create a deep copy of this adata object"""
        return netinfra__netinfra.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /netinfra')
            res.append('{self_name} = netinfra__netinfra()')
        leaves = []
        _router = self.router
        for _element in _router:
            res.append('')
            res.append("# List /netinfra/router element: {_element.to_gdata().key_str(['name'])}")
            list_elem = 'router_element = {self_name}.router.create({repr(_element.name)}, {repr(_element.id)}, {repr(_element.type)}, {repr(_element.asn)})'
            res.append(list_elem)
            res.extend(_element.prsrc('router_element', False, list_element=True).splitlines())
        _backbone_link = self.backbone_link
        for _element in _backbone_link:
            res.append('')
            res.append("# List /netinfra/backbone-link element: {_element.to_gdata().key_str(['left-router', 'left-interface', 'right-router', 'right-interface'])}")
            list_elem = 'backbone_link_element = {self_name}.backbone_link.create({repr(_element.left_router)}, {repr(_element.left_interface)}, {repr(_element.right_router)}, {repr(_element.right_interface)})'
            res.append(list_elem)
            res.extend(_element.prsrc('backbone_link_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /netinfra'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['netinfra:netinfra'])


mut def from_xml_netinfra__netinfra(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_router = yang.gdata.from_xml_opt_list(node, 'router')
    yang.gdata.maybe_add(children, 'router', from_xml_netinfra__netinfra__router, child_router)
    child_backbone_link = yang.gdata.from_xml_opt_list(node, 'backbone-link')
    yang.gdata.maybe_add(children, 'backbone-link', from_xml_netinfra__netinfra__backbone_link, child_backbone_link)
    return yang.gdata.Container(children, ns='http://example.com/netinfra', module='netinfra')

mut def from_json_path_netinfra__netinfra(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'router':
            child = {'router': from_json_path_netinfra__netinfra__router(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/netinfra', module='netinfra')
        if point == 'backbone-link':
            child = {'backbone-link': from_json_path_netinfra__netinfra__backbone_link(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/netinfra', module='netinfra')
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_netinfra__netinfra(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_netinfra__netinfra(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_router = yang.gdata.take_json_opt_list(jd, 'router')
    yang.gdata.maybe_add(children, 'router', from_json_netinfra__netinfra__router, child_router)
    child_backbone_link = yang.gdata.take_json_opt_list(jd, 'backbone-link')
    yang.gdata.maybe_add(children, 'backbone-link', from_json_netinfra__netinfra__backbone_link, child_backbone_link)
    return yang.gdata.Container(children, ns='http://example.com/netinfra', module='netinfra')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(id=n.get_str('id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/cloud-identifier')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier({repr(self.id)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/cloud-identifier'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-profiles', 'valid-provider-identifiers', 'cloud-identifier'])

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'cloud-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_str(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier__id(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(id=n.get_str('id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/encryption-profile-identifier')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier({repr(self.id)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/encryption-profile-identifier'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-profiles', 'valid-provider-identifiers', 'encryption-profile-identifier'])

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'encryption-profile-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_str(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier__id(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(id=n.get_str('id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/qos-profile-identifier')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier({repr(self.id)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/qos-profile-identifier'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-profiles', 'valid-provider-identifiers', 'qos-profile-identifier'])

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'qos-profile-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_str(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier__id(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(id=n.get_str('id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/bfd-profile-identifier')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier({repr(self.id)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/bfd-profile-identifier'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-profiles', 'valid-provider-identifiers', 'bfd-profile-identifier'])

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'bfd-profile-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_str(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier__id(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(yang.adata.MNode):
    cloud_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier
    encryption_profile_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier
    qos_profile_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier
    bfd_profile_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier

    mut def __init__(self, cloud_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]=[], encryption_profile_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]=[], qos_profile_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]=[], bfd_profile_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cloud_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(elements=cloud_identifier)
        self.encryption_profile_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(elements=encryption_profile_identifier)
        self.qos_profile_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(elements=qos_profile_identifier)
        self.bfd_profile_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(elements=bfd_profile_identifier)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cloud_identifier = self.cloud_identifier
        if _cloud_identifier is not None:
            children['cloud-identifier'] = _cloud_identifier.to_gdata()
        _encryption_profile_identifier = self.encryption_profile_identifier
        if _encryption_profile_identifier is not None:
            children['encryption-profile-identifier'] = _encryption_profile_identifier.to_gdata()
        _qos_profile_identifier = self.qos_profile_identifier
        if _qos_profile_identifier is not None:
            children['qos-profile-identifier'] = _qos_profile_identifier.to_gdata()
        _bfd_profile_identifier = self.bfd_profile_identifier
        if _bfd_profile_identifier is not None:
            children['bfd-profile-identifier'] = _bfd_profile_identifier.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(cloud_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier.from_gdata(n.get_opt_list('cloud-identifier')), encryption_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier.from_gdata(n.get_opt_list('encryption-profile-identifier')), qos_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier.from_gdata(n.get_opt_list('qos-profile-identifier')), bfd_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier.from_gdata(n.get_opt_list('bfd-profile-identifier')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-profiles/valid-provider-identifiers')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers()')
        leaves = []
        _cloud_identifier = self.cloud_identifier
        for _element in _cloud_identifier:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-profiles/valid-provider-identifiers/cloud-identifier element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'cloud_identifier_element = {self_name}.cloud_identifier.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('cloud_identifier_element', False, list_element=True).splitlines())
        _encryption_profile_identifier = self.encryption_profile_identifier
        for _element in _encryption_profile_identifier:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-profiles/valid-provider-identifiers/encryption-profile-identifier element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'encryption_profile_identifier_element = {self_name}.encryption_profile_identifier.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('encryption_profile_identifier_element', False, list_element=True).splitlines())
        _qos_profile_identifier = self.qos_profile_identifier
        for _element in _qos_profile_identifier:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-profiles/valid-provider-identifiers/qos-profile-identifier element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'qos_profile_identifier_element = {self_name}.qos_profile_identifier.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('qos_profile_identifier_element', False, list_element=True).splitlines())
        _bfd_profile_identifier = self.bfd_profile_identifier
        for _element in _bfd_profile_identifier:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-profiles/valid-provider-identifiers/bfd-profile-identifier element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'bfd_profile_identifier_element = {self_name}.bfd_profile_identifier.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('bfd_profile_identifier_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-profiles/valid-provider-identifiers'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-profiles', 'valid-provider-identifiers'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_cloud_identifier = yang.gdata.from_xml_opt_list(node, 'cloud-identifier')
    yang.gdata.maybe_add(children, 'cloud-identifier', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier, child_cloud_identifier)
    child_encryption_profile_identifier = yang.gdata.from_xml_opt_list(node, 'encryption-profile-identifier')
    yang.gdata.maybe_add(children, 'encryption-profile-identifier', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier, child_encryption_profile_identifier)
    child_qos_profile_identifier = yang.gdata.from_xml_opt_list(node, 'qos-profile-identifier')
    yang.gdata.maybe_add(children, 'qos-profile-identifier', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier, child_qos_profile_identifier)
    child_bfd_profile_identifier = yang.gdata.from_xml_opt_list(node, 'bfd-profile-identifier')
    yang.gdata.maybe_add(children, 'bfd-profile-identifier', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier, child_bfd_profile_identifier)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'cloud-identifier':
            child = {'cloud-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'encryption-profile-identifier':
            child = {'encryption-profile-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'qos-profile-identifier':
            child = {'qos-profile-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'bfd-profile-identifier':
            child = {'bfd-profile-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cloud_identifier = yang.gdata.take_json_opt_list(jd, 'cloud-identifier')
    yang.gdata.maybe_add(children, 'cloud-identifier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier, child_cloud_identifier)
    child_encryption_profile_identifier = yang.gdata.take_json_opt_list(jd, 'encryption-profile-identifier')
    yang.gdata.maybe_add(children, 'encryption-profile-identifier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier, child_encryption_profile_identifier)
    child_qos_profile_identifier = yang.gdata.take_json_opt_list(jd, 'qos-profile-identifier')
    yang.gdata.maybe_add(children, 'qos-profile-identifier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier, child_qos_profile_identifier)
    child_bfd_profile_identifier = yang.gdata.take_json_opt_list(jd, 'bfd-profile-identifier')
    yang.gdata.maybe_add(children, 'bfd-profile-identifier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier, child_bfd_profile_identifier)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(yang.adata.MNode):
    valid_provider_identifiers: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers

    mut def __init__(self, valid_provider_identifiers: ?ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.valid_provider_identifiers = valid_provider_identifiers if valid_provider_identifiers is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _valid_provider_identifiers = self.valid_provider_identifiers
        if _valid_provider_identifiers is not None:
            children['valid-provider-identifiers'] = _valid_provider_identifiers.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(valid_provider_identifiers=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers.from_gdata(n.get_opt_cnt('valid-provider-identifiers')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-profiles')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles()')
        leaves = []
        _valid_provider_identifiers = self.valid_provider_identifiers
        if _valid_provider_identifiers is not None:
            res.extend(_valid_provider_identifiers.prsrc('{self_name}.valid_provider_identifiers', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-profiles'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-profiles'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_valid_provider_identifiers = yang.gdata.from_xml_opt_cnt(node, 'valid-provider-identifiers')
    yang.gdata.maybe_add(children, 'valid-provider-identifiers', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers, child_valid_provider_identifiers)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'valid-provider-identifiers':
            child = {'valid-provider-identifiers': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_valid_provider_identifiers = yang.gdata.take_json_opt_cnt(jd, 'valid-provider-identifiers')
    yang.gdata.maybe_add(children, 'valid-provider-identifiers', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers, child_valid_provider_identifiers)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__customer_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__customer_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_service_topology(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:vpn-topology'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf vpn-service-topology: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_service_topology(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:vpn-topology'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf vpn-service-topology: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__cloud_identifier(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__cloud_identifier(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_any(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_any(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_site(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_site(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__deny_site(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__deny_site(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__nat44_customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__nat44_customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(yang.adata.MNode):
    enabled: bool
    nat44_customer_address: ?str

    mut def __init__(self, enabled: ?bool=None, nat44_customer_address: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.nat44_customer_address = nat44_customer_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _nat44_customer_address = self.nat44_customer_address
        if _nat44_customer_address is not None:
            children['nat44-customer-address'] = yang.gdata.Leaf('string', _nat44_customer_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(enabled=n.get_opt_bool('enabled'), nat44_customer_address=n.get_opt_str('nat44-customer-address'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses/cloud-access/address-translation/nat44')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44()')
        leaves = []
        _enabled = self.enabled
        if _enabled is not None:
            leaves.append('{self_name}.enabled = {repr(_enabled)}')
        _nat44_customer_address = self.nat44_customer_address
        if _nat44_customer_address is not None:
            leaves.append('{self_name}.nat44_customer_address = {repr(_nat44_customer_address)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses/cloud-access/address-translation/nat44'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'cloud-accesses', 'cloud-access', 'address-translation', 'nat44'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.from_xml_opt_bool(node, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__enabled, child_enabled)
    child_nat44_customer_address = yang.gdata.from_xml_opt_str(node, 'nat44-customer-address')
    yang.gdata.maybe_add(children, 'nat44-customer-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__nat44_customer_address, child_nat44_customer_address)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'nat44-customer-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__enabled, child_enabled)
    child_nat44_customer_address = yang.gdata.take_json_opt_str(jd, 'nat44-customer-address')
    yang.gdata.maybe_add(children, 'nat44-customer-address', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__nat44_customer_address, child_nat44_customer_address)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(yang.adata.MNode):
    nat44: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44

    mut def __init__(self, nat44: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.nat44 = nat44 if nat44 is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _nat44 = self.nat44
        if _nat44 is not None:
            children['nat44'] = _nat44.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(nat44=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44.from_gdata(n.get_opt_cnt('nat44')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses/cloud-access/address-translation')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation()')
        leaves = []
        _nat44 = self.nat44
        if _nat44 is not None:
            res.extend(_nat44.prsrc('{self_name}.nat44', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses/cloud-access/address-translation'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'cloud-accesses', 'cloud-access', 'address-translation'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_nat44 = yang.gdata.from_xml_opt_cnt(node, 'nat44')
    yang.gdata.maybe_add(children, 'nat44', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44, child_nat44)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'nat44':
            child = {'nat44': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_nat44 = yang.gdata.take_json_opt_cnt(jd, 'nat44')
    yang.gdata.maybe_add(children, 'nat44', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44, child_nat44)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(yang.adata.MNode):
    cloud_identifier: str
    permit_any: ?bool
    permit_site: list[str]
    deny_site: list[str]
    address_translation: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation

    mut def __init__(self, cloud_identifier: str, permit_any: ?bool, permit_site: ?list[str]=None, deny_site: ?list[str]=None, address_translation: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cloud_identifier = cloud_identifier
        self.permit_any = permit_any
        self.permit_site = permit_site if permit_site is not None else []
        self.deny_site = deny_site if deny_site is not None else []
        self.address_translation = address_translation if address_translation is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cloud_identifier = self.cloud_identifier
        if _cloud_identifier is not None:
            children['cloud-identifier'] = yang.gdata.Leaf('leafref', _cloud_identifier)
        _permit_any = self.permit_any
        if _permit_any is not None:
            children['permit-any'] = yang.gdata.Leaf('empty', _permit_any)
        _permit_site = self.permit_site
        if _permit_site is not None:
            children['permit-site'] = yang.gdata.LeafList('leafref', _permit_site)
        _deny_site = self.deny_site
        if _deny_site is not None:
            children['deny-site'] = yang.gdata.LeafList('leafref', _deny_site)
        _address_translation = self.address_translation
        if _address_translation is not None:
            children['address-translation'] = _address_translation.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(cloud_identifier=n.get_str('cloud-identifier'), permit_any=n.get_opt_empty('permit-any'), permit_site=n.get_opt_strs('permit-site'), deny_site=n.get_opt_strs('deny-site'), address_translation=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation.from_gdata(n.get_opt_cnt('address-translation')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses/cloud-access')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access({repr(self.cloud_identifier)})')
        leaves = []
        _permit_any = self.permit_any
        if _permit_any is not None:
            leaves.append('{self_name}.permit_any = {repr(_permit_any)}')
        _permit_site = self.permit_site
        if len(_permit_site) != 0:
            leaves.append('{self_name}.permit_site = {repr(_permit_site)}')
        _deny_site = self.deny_site
        if len(_deny_site) != 0:
            leaves.append('{self_name}.deny_site = {repr(_deny_site)}')
        _address_translation = self.address_translation
        if _address_translation is not None:
            res.extend(_address_translation.prsrc('{self_name}.address_translation', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses/cloud-access'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'cloud-accesses', 'cloud-access'])

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'cloud-access'
        self.elements = elements

    mut def create(self, cloud_identifier):
        for e in self:
            match = True
            if e.cloud_identifier != cloud_identifier:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(cloud_identifier)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['cloud-identifier'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_cloud_identifier = yang.gdata.from_xml_str(node, 'cloud-identifier')
    yang.gdata.maybe_add(children, 'cloud-identifier', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__cloud_identifier, child_cloud_identifier)
    child_permit_any = yang.gdata.from_xml_opt_empty(node, 'permit-any')
    yang.gdata.maybe_add(children, 'permit-any', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_any, child_permit_any)
    child_permit_site = yang.gdata.from_xml_opt_strs(node, 'permit-site')
    yang.gdata.maybe_add(children, 'permit-site', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_site, child_permit_site)
    child_deny_site = yang.gdata.from_xml_opt_strs(node, 'deny-site')
    yang.gdata.maybe_add(children, 'deny-site', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__deny_site, child_deny_site)
    child_address_translation = yang.gdata.from_xml_opt_cnt(node, 'address-translation')
    yang.gdata.maybe_add(children, 'address-translation', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation, child_address_translation)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(e) for e in nodes]
    return yang.gdata.List(keys=['cloud-identifier'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['cloud-identifier']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['cloud-identifier'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__cloud_identifier(keys[0])
        if point == 'permit-any':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'permit-site':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'deny-site':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'address-translation':
            children['address-translation'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['cloud-identifier']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['cloud-identifier'])))
        return yang.gdata.List(['cloud-identifier'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['cloud-identifier'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_cloud_identifier = yang.gdata.take_json_str(jd, 'cloud-identifier')
    yang.gdata.maybe_add(children, 'cloud-identifier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__cloud_identifier, child_cloud_identifier)
    child_permit_any = yang.gdata.take_json_opt_empty(jd, 'permit-any')
    yang.gdata.maybe_add(children, 'permit-any', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_any, child_permit_any)
    child_permit_site = yang.gdata.take_json_opt_strs(jd, 'permit-site')
    yang.gdata.maybe_add(children, 'permit-site', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_site, child_permit_site)
    child_deny_site = yang.gdata.take_json_opt_strs(jd, 'deny-site')
    yang.gdata.maybe_add(children, 'deny-site', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__deny_site, child_deny_site)
    child_address_translation = yang.gdata.take_json_opt_cnt(jd, 'address-translation')
    yang.gdata.maybe_add(children, 'address-translation', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation, child_address_translation)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['cloud-identifier'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(yang.adata.MNode):
    cloud_access: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access

    mut def __init__(self, cloud_access: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cloud_access = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(elements=cloud_access)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cloud_access = self.cloud_access
        if _cloud_access is not None:
            children['cloud-access'] = _cloud_access.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(cloud_access=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access.from_gdata(n.get_opt_list('cloud-access')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses()')
        leaves = []
        _cloud_access = self.cloud_access
        for _element in _cloud_access:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-services/vpn-service/cloud-accesses/cloud-access element: {_element.to_gdata().key_str(['cloud-identifier'])}")
            list_elem = 'cloud_access_element = {self_name}.cloud_access.create({repr(_element.cloud_identifier)})'
            res.append(list_elem)
            res.extend(_element.prsrc('cloud_access_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'cloud-accesses'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_cloud_access = yang.gdata.from_xml_opt_list(node, 'cloud-access')
    yang.gdata.maybe_add(children, 'cloud-access', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access, child_cloud_access)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'cloud-access':
            child = {'cloud-access': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cloud_access = yang.gdata.take_json_opt_list(jd, 'cloud-access')
    yang.gdata.maybe_add(children, 'cloud-access', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access, child_cloud_access)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors__tree_flavor(val: list[PartialIdentityref]) -> yang.gdata.LeafList:
    new_val = []
    for v in val:
        nv, error = complete_and_validate_identityref(v, _identities, ['l3vpn-svc:multicast-tree-type'], 'ietf-l3vpn-svc')
        if nv is not None:
            new_val.append(nv)
        else:
            raise ValueError('Invalid value for identityref leaf-list tree-flavor: {error}')
    return yang.gdata.LeafList('identityref', new_val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors__tree_flavor(val: list[PartialIdentityref]) -> yang.gdata.LeafList:
    new_val = []
    for v in val:
        nv, error = complete_and_validate_identityref(v, _identities, ['l3vpn-svc:multicast-tree-type'], 'ietf-l3vpn-svc')
        if nv is not None:
            new_val.append(nv)
        else:
            raise ValueError('Invalid value for identityref leaf-list tree-flavor: {error}')
    return yang.gdata.LeafList('identityref', new_val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(yang.adata.MNode):
    tree_flavor: list[Identityref]

    mut def __init__(self, tree_flavor: ?list[Identityref]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.tree_flavor = tree_flavor if tree_flavor is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _tree_flavor = self.tree_flavor
        if _tree_flavor is not None:
            _identityref_tree_flavor = []
            for v in _tree_flavor:
                nv, error = complete_and_validate_identityref(v, _identities, ['l3vpn-svc:multicast-tree-type'], 'ietf-l3vpn-svc')
                if nv is not None:
                    _identityref_tree_flavor.append(nv)
                else:
                    raise ValueError('Invalid value for identityref leaf-list tree-flavor: {error}')
            _tree_flavor = _identityref_tree_flavor
            children['tree-flavor'] = yang.gdata.LeafList('identityref', _tree_flavor)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(tree_flavor=n.get_opt_Identityrefs('tree-flavor'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/customer-tree-flavors')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors()')
        leaves = []
        _tree_flavor = self.tree_flavor
        if len(_tree_flavor) != 0:
            leaves.append('{self_name}.tree_flavor = {repr(_tree_flavor)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/customer-tree-flavors'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'customer-tree-flavors'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_tree_flavor = yang.gdata.from_xml_opt_Identityrefs(node, 'tree-flavor')
    yang.gdata.maybe_add(children, 'tree-flavor', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors__tree_flavor, child_tree_flavor)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'tree-flavor':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_tree_flavor = yang.gdata.take_json_opt_Identityrefs(jd, 'tree-flavor')
    yang.gdata.maybe_add(children, 'tree-flavor', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors__tree_flavor, child_tree_flavor)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__rp_redundancy(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__rp_redundancy(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__optimal_traffic_delivery(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__optimal_traffic_delivery(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(yang.adata.MNode):
    enabled: bool
    rp_redundancy: bool
    optimal_traffic_delivery: bool

    mut def __init__(self, enabled: ?bool=None, rp_redundancy: ?bool=None, optimal_traffic_delivery: ?bool=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.rp_redundancy = rp_redundancy if rp_redundancy is not None else False
        self.optimal_traffic_delivery = optimal_traffic_delivery if optimal_traffic_delivery is not None else False

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _rp_redundancy = self.rp_redundancy
        if _rp_redundancy is not None:
            children['rp-redundancy'] = yang.gdata.Leaf('boolean', _rp_redundancy)
        _optimal_traffic_delivery = self.optimal_traffic_delivery
        if _optimal_traffic_delivery is not None:
            children['optimal-traffic-delivery'] = yang.gdata.Leaf('boolean', _optimal_traffic_delivery)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(enabled=n.get_opt_bool('enabled'), rp_redundancy=n.get_opt_bool('rp-redundancy'), optimal_traffic_delivery=n.get_opt_bool('optimal-traffic-delivery'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping/provider-managed')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed()')
        leaves = []
        _enabled = self.enabled
        if _enabled is not None:
            leaves.append('{self_name}.enabled = {repr(_enabled)}')
        _rp_redundancy = self.rp_redundancy
        if _rp_redundancy is not None:
            leaves.append('{self_name}.rp_redundancy = {repr(_rp_redundancy)}')
        _optimal_traffic_delivery = self.optimal_traffic_delivery
        if _optimal_traffic_delivery is not None:
            leaves.append('{self_name}.optimal_traffic_delivery = {repr(_optimal_traffic_delivery)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping/provider-managed'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp', 'rp-group-mappings', 'rp-group-mapping', 'provider-managed'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.from_xml_opt_bool(node, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__enabled, child_enabled)
    child_rp_redundancy = yang.gdata.from_xml_opt_bool(node, 'rp-redundancy')
    yang.gdata.maybe_add(children, 'rp-redundancy', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__rp_redundancy, child_rp_redundancy)
    child_optimal_traffic_delivery = yang.gdata.from_xml_opt_bool(node, 'optimal-traffic-delivery')
    yang.gdata.maybe_add(children, 'optimal-traffic-delivery', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__optimal_traffic_delivery, child_optimal_traffic_delivery)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'rp-redundancy':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'optimal-traffic-delivery':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__enabled, child_enabled)
    child_rp_redundancy = yang.gdata.take_json_opt_bool(jd, 'rp-redundancy')
    yang.gdata.maybe_add(children, 'rp-redundancy', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__rp_redundancy, child_rp_redundancy)
    child_optimal_traffic_delivery = yang.gdata.take_json_opt_bool(jd, 'optimal-traffic-delivery')
    yang.gdata.maybe_add(children, 'optimal-traffic-delivery', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__optimal_traffic_delivery, child_optimal_traffic_delivery)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__rp_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__rp_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_start(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_start(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(yang.adata.MNode):
    id: int
    group_address: ?str
    group_start: ?str
    group_end: ?str

    mut def __init__(self, id: int, group_address: ?str, group_start: ?str, group_end: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.group_address = group_address
        self.group_start = group_start
        self.group_end = group_end

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint16', _id)
        _group_address = self.group_address
        if _group_address is not None:
            children['group-address'] = yang.gdata.Leaf('union', _group_address)
        _group_start = self.group_start
        if _group_start is not None:
            children['group-start'] = yang.gdata.Leaf('union', _group_start)
        _group_end = self.group_end
        if _group_end is not None:
            children['group-end'] = yang.gdata.Leaf('union', _group_end)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(id=n.get_int('id'), group_address=n.get_opt_str('group-address'), group_start=n.get_opt_str('group-start'), group_end=n.get_opt_str('group-end'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping/groups/group')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group({repr(self.id)})')
        leaves = []
        _group_address = self.group_address
        if _group_address is not None:
            leaves.append('{self_name}.group_address = {repr(_group_address)}')
        _group_start = self.group_start
        if _group_start is not None:
            leaves.append('{self_name}.group_start = {repr(_group_start)}')
        _group_end = self.group_end
        if _group_end is not None:
            leaves.append('{self_name}.group_end = {repr(_group_end)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping/groups/group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp', 'rp-group-mappings', 'rp-group-mapping', 'groups', 'group'])

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_int(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__id, child_id)
    child_group_address = yang.gdata.from_xml_opt_str(node, 'group-address')
    yang.gdata.maybe_add(children, 'group-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_address, child_group_address)
    child_group_start = yang.gdata.from_xml_opt_str(node, 'group-start')
    yang.gdata.maybe_add(children, 'group-start', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_start, child_group_start)
    child_group_end = yang.gdata.from_xml_opt_str(node, 'group-end')
    yang.gdata.maybe_add(children, 'group-end', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_end, child_group_end)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__id(keys[0])
        if point == 'group-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'group-start':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'group-end':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_int(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__id, child_id)
    child_group_address = yang.gdata.take_json_opt_str(jd, 'group-address')
    yang.gdata.maybe_add(children, 'group-address', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_address, child_group_address)
    child_group_start = yang.gdata.take_json_opt_str(jd, 'group-start')
    yang.gdata.maybe_add(children, 'group-start', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_start, child_group_start)
    child_group_end = yang.gdata.take_json_opt_str(jd, 'group-end')
    yang.gdata.maybe_add(children, 'group-end', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_end, child_group_end)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(elements=group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(group=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group.from_gdata(n.get_opt_list('group')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping/groups')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups()')
        leaves = []
        _group = self.group
        for _element in _group:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping/groups/group element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'group_element = {self_name}.group.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('group_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping/groups'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp', 'rp-group-mappings', 'rp-group-mapping', 'groups'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.from_xml_opt_list(node, 'group')
    yang.gdata.maybe_add(children, 'group', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group, child_group)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.take_json_opt_list(jd, 'group')
    yang.gdata.maybe_add(children, 'group', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group, child_group)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(yang.adata.MNode):
    id: int
    provider_managed: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed
    rp_address: str
    groups: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups

    mut def __init__(self, id: int, rp_address: str, provider_managed: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed=None, groups: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.provider_managed = provider_managed if provider_managed is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed()
        self.rp_address = rp_address
        self.groups = groups if groups is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint16', _id)
        _provider_managed = self.provider_managed
        if _provider_managed is not None:
            children['provider-managed'] = _provider_managed.to_gdata()
        _rp_address = self.rp_address
        if _rp_address is not None:
            children['rp-address'] = yang.gdata.Leaf('union', _rp_address)
        _groups = self.groups
        if _groups is not None:
            children['groups'] = _groups.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(id=n.get_int('id'), provider_managed=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed.from_gdata(n.get_opt_cnt('provider-managed')), rp_address=n.get_str('rp-address'), groups=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups.from_gdata(n.get_opt_cnt('groups')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping({repr(self.id)}, {repr(self.rp_address)})')
        leaves = []
        _provider_managed = self.provider_managed
        if _provider_managed is not None:
            res.extend(_provider_managed.prsrc('{self_name}.provider_managed', False).splitlines())
        _groups = self.groups
        if _groups is not None:
            res.extend(_groups.prsrc('{self_name}.groups', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp', 'rp-group-mappings', 'rp-group-mapping'])

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'rp-group-mapping'
        self.elements = elements

    mut def create(self, id, rp_address):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(id, rp_address)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_int(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__id, child_id)
    child_provider_managed = yang.gdata.from_xml_opt_cnt(node, 'provider-managed')
    yang.gdata.maybe_add(children, 'provider-managed', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed, child_provider_managed)
    child_rp_address = yang.gdata.from_xml_str(node, 'rp-address')
    yang.gdata.maybe_add(children, 'rp-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__rp_address, child_rp_address)
    child_groups = yang.gdata.from_xml_opt_cnt(node, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups, child_groups)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__id(keys[0])
        if point == 'provider-managed':
            children['provider-managed'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(jd, rest_path, op)
        if point == 'rp-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'groups':
            children['groups'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_int(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__id, child_id)
    child_provider_managed = yang.gdata.take_json_opt_cnt(jd, 'provider-managed')
    yang.gdata.maybe_add(children, 'provider-managed', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed, child_provider_managed)
    child_rp_address = yang.gdata.take_json_str(jd, 'rp-address')
    yang.gdata.maybe_add(children, 'rp-address', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__rp_address, child_rp_address)
    child_groups = yang.gdata.take_json_opt_cnt(jd, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups, child_groups)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(yang.adata.MNode):
    rp_group_mapping: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping

    mut def __init__(self, rp_group_mapping: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rp_group_mapping = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(elements=rp_group_mapping)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rp_group_mapping = self.rp_group_mapping
        if _rp_group_mapping is not None:
            children['rp-group-mapping'] = _rp_group_mapping.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(rp_group_mapping=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping.from_gdata(n.get_opt_list('rp-group-mapping')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings()')
        leaves = []
        _rp_group_mapping = self.rp_group_mapping
        for _element in _rp_group_mapping:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'rp_group_mapping_element = {self_name}.rp_group_mapping.create({repr(_element.id)}, {repr(_element.rp_address)})'
            res.append(list_elem)
            res.extend(_element.prsrc('rp_group_mapping_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp', 'rp-group-mappings'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_rp_group_mapping = yang.gdata.from_xml_opt_list(node, 'rp-group-mapping')
    yang.gdata.maybe_add(children, 'rp-group-mapping', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping, child_rp_group_mapping)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'rp-group-mapping':
            child = {'rp-group-mapping': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rp_group_mapping = yang.gdata.take_json_opt_list(jd, 'rp-group-mapping')
    yang.gdata.maybe_add(children, 'rp-group-mapping', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping, child_rp_group_mapping)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__rp_discovery_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:multicast-rp-discovery-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf rp-discovery-type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__rp_discovery_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:multicast-rp-discovery-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf rp-discovery-type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates__bsr_candidate_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates__bsr_candidate_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('union', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(yang.adata.MNode):
    bsr_candidate_address: list[str]

    mut def __init__(self, bsr_candidate_address: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.bsr_candidate_address = bsr_candidate_address if bsr_candidate_address is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _bsr_candidate_address = self.bsr_candidate_address
        if _bsr_candidate_address is not None:
            children['bsr-candidate-address'] = yang.gdata.LeafList('union', _bsr_candidate_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(bsr_candidate_address=n.get_opt_strs('bsr-candidate-address'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-discovery/bsr-candidates')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates()')
        leaves = []
        _bsr_candidate_address = self.bsr_candidate_address
        if len(_bsr_candidate_address) != 0:
            leaves.append('{self_name}.bsr_candidate_address = {repr(_bsr_candidate_address)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-discovery/bsr-candidates'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp', 'rp-discovery', 'bsr-candidates'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_bsr_candidate_address = yang.gdata.from_xml_opt_strs(node, 'bsr-candidate-address')
    yang.gdata.maybe_add(children, 'bsr-candidate-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates__bsr_candidate_address, child_bsr_candidate_address)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'bsr-candidate-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_bsr_candidate_address = yang.gdata.take_json_opt_strs(jd, 'bsr-candidate-address')
    yang.gdata.maybe_add(children, 'bsr-candidate-address', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates__bsr_candidate_address, child_bsr_candidate_address)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(yang.adata.MNode):
    rp_discovery_type: Identityref
    bsr_candidates: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates

    mut def __init__(self, rp_discovery_type: ?Identityref=None, bsr_candidates: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        _default_rp_discovery_type, error = complete_and_validate_identityref(Identityref.from_adata('static-rp'), _identities, ['l3vpn-svc:multicast-rp-discovery-type'], 'ietf-l3vpn-svc')
        if _default_rp_discovery_type is not None:
            self.rp_discovery_type = rp_discovery_type if rp_discovery_type is not None else _default_rp_discovery_type
        else:
            raise ValueError('Invalid default value for identityref leaf rp-discovery: {error}')
        self.bsr_candidates = bsr_candidates if bsr_candidates is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rp_discovery_type = self.rp_discovery_type
        if _rp_discovery_type is not None:
            _identityref_rp_discovery_type, error = complete_and_validate_identityref(_rp_discovery_type, _identities, ['l3vpn-svc:multicast-rp-discovery-type'], 'ietf-l3vpn-svc')
            if _identityref_rp_discovery_type is not None:
                _rp_discovery_type = _identityref_rp_discovery_type
            else:
                raise ValueError('Invalid value for identityref leaf rp-discovery-type: {error}')
            children['rp-discovery-type'] = yang.gdata.Leaf('identityref', _rp_discovery_type)
        _bsr_candidates = self.bsr_candidates
        if _bsr_candidates is not None:
            children['bsr-candidates'] = _bsr_candidates.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(rp_discovery_type=n.get_opt_Identityref('rp-discovery-type'), bsr_candidates=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates.from_gdata(n.get_opt_cnt('bsr-candidates')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-discovery')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery()')
        leaves = []
        _rp_discovery_type = self.rp_discovery_type
        if _rp_discovery_type is not None:
            leaves.append('{self_name}.rp_discovery_type = {repr(_rp_discovery_type)}')
        _bsr_candidates = self.bsr_candidates
        if _bsr_candidates is not None:
            res.extend(_bsr_candidates.prsrc('{self_name}.bsr_candidates', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-discovery'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp', 'rp-discovery'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_rp_discovery_type = yang.gdata.from_xml_opt_Identityref(node, 'rp-discovery-type')
    yang.gdata.maybe_add(children, 'rp-discovery-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__rp_discovery_type, child_rp_discovery_type)
    child_bsr_candidates = yang.gdata.from_xml_opt_cnt(node, 'bsr-candidates')
    yang.gdata.maybe_add(children, 'bsr-candidates', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates, child_bsr_candidates)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'rp-discovery-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bsr-candidates':
            child = {'bsr-candidates': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rp_discovery_type = yang.gdata.take_json_opt_Identityref(jd, 'rp-discovery-type')
    yang.gdata.maybe_add(children, 'rp-discovery-type', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__rp_discovery_type, child_rp_discovery_type)
    child_bsr_candidates = yang.gdata.take_json_opt_cnt(jd, 'bsr-candidates')
    yang.gdata.maybe_add(children, 'bsr-candidates', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates, child_bsr_candidates)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(yang.adata.MNode):
    rp_group_mappings: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings
    rp_discovery: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery

    mut def __init__(self, rp_group_mappings: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings=None, rp_discovery: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rp_group_mappings = rp_group_mappings if rp_group_mappings is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings()
        self.rp_discovery = rp_discovery if rp_discovery is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rp_group_mappings = self.rp_group_mappings
        if _rp_group_mappings is not None:
            children['rp-group-mappings'] = _rp_group_mappings.to_gdata()
        _rp_discovery = self.rp_discovery
        if _rp_discovery is not None:
            children['rp-discovery'] = _rp_discovery.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(rp_group_mappings=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings.from_gdata(n.get_opt_cnt('rp-group-mappings')), rp_discovery=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery.from_gdata(n.get_opt_cnt('rp-discovery')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp()')
        leaves = []
        _rp_group_mappings = self.rp_group_mappings
        if _rp_group_mappings is not None:
            res.extend(_rp_group_mappings.prsrc('{self_name}.rp_group_mappings', False).splitlines())
        _rp_discovery = self.rp_discovery
        if _rp_discovery is not None:
            res.extend(_rp_discovery.prsrc('{self_name}.rp_discovery', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_rp_group_mappings = yang.gdata.from_xml_opt_cnt(node, 'rp-group-mappings')
    yang.gdata.maybe_add(children, 'rp-group-mappings', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings, child_rp_group_mappings)
    child_rp_discovery = yang.gdata.from_xml_opt_cnt(node, 'rp-discovery')
    yang.gdata.maybe_add(children, 'rp-discovery', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery, child_rp_discovery)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'rp-group-mappings':
            child = {'rp-group-mappings': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'rp-discovery':
            child = {'rp-discovery': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rp_group_mappings = yang.gdata.take_json_opt_cnt(jd, 'rp-group-mappings')
    yang.gdata.maybe_add(children, 'rp-group-mappings', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings, child_rp_group_mappings)
    child_rp_discovery = yang.gdata.take_json_opt_cnt(jd, 'rp-discovery')
    yang.gdata.maybe_add(children, 'rp-discovery', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery, child_rp_discovery)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(yang.adata.MNode):
    enabled: bool
    customer_tree_flavors: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors
    rp: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp

    mut def __init__(self, enabled: ?bool=None, customer_tree_flavors: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors=None, rp: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.customer_tree_flavors = customer_tree_flavors if customer_tree_flavors is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors()
        self.rp = rp if rp is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _customer_tree_flavors = self.customer_tree_flavors
        if _customer_tree_flavors is not None:
            children['customer-tree-flavors'] = _customer_tree_flavors.to_gdata()
        _rp = self.rp
        if _rp is not None:
            children['rp'] = _rp.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(enabled=n.get_opt_bool('enabled'), customer_tree_flavors=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors.from_gdata(n.get_opt_cnt('customer-tree-flavors')), rp=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp.from_gdata(n.get_opt_cnt('rp')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast()')
        leaves = []
        _enabled = self.enabled
        if _enabled is not None:
            leaves.append('{self_name}.enabled = {repr(_enabled)}')
        _customer_tree_flavors = self.customer_tree_flavors
        if _customer_tree_flavors is not None:
            res.extend(_customer_tree_flavors.prsrc('{self_name}.customer_tree_flavors', False).splitlines())
        _rp = self.rp
        if _rp is not None:
            res.extend(_rp.prsrc('{self_name}.rp', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.from_xml_opt_bool(node, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__enabled, child_enabled)
    child_customer_tree_flavors = yang.gdata.from_xml_opt_cnt(node, 'customer-tree-flavors')
    yang.gdata.maybe_add(children, 'customer-tree-flavors', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors, child_customer_tree_flavors)
    child_rp = yang.gdata.from_xml_opt_cnt(node, 'rp')
    yang.gdata.maybe_add(children, 'rp', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp, child_rp)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-tree-flavors':
            child = {'customer-tree-flavors': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'rp':
            child = {'rp': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__enabled, child_enabled)
    child_customer_tree_flavors = yang.gdata.take_json_opt_cnt(jd, 'customer-tree-flavors')
    yang.gdata.maybe_add(children, 'customer-tree-flavors', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors, child_customer_tree_flavors)
    child_rp = yang.gdata.take_json_opt_cnt(jd, 'rp')
    yang.gdata.maybe_add(children, 'rp', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp, child_rp)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__carrierscarrier(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__carrierscarrier(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__local_sites_role(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf local-sites-role: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__local_sites_role(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf local-sites-role: {error}')

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(yang.adata.MNode):
    vpn_id: str
    local_sites_role: Identityref

    mut def __init__(self, vpn_id: str, local_sites_role: ?Identityref=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_id = vpn_id
        _default_local_sites_role, error = complete_and_validate_identityref(Identityref.from_adata('any-to-any-role'), _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
        if _default_local_sites_role is not None:
            self.local_sites_role = local_sites_role if local_sites_role is not None else _default_local_sites_role
        else:
            raise ValueError('Invalid default value for identityref leaf extranet-vpn: {error}')

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('string', _vpn_id)
        _local_sites_role = self.local_sites_role
        if _local_sites_role is not None:
            _identityref_local_sites_role, error = complete_and_validate_identityref(_local_sites_role, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
            if _identityref_local_sites_role is not None:
                _local_sites_role = _identityref_local_sites_role
            else:
                raise ValueError('Invalid value for identityref leaf local-sites-role: {error}')
            children['local-sites-role'] = yang.gdata.Leaf('identityref', _local_sites_role)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(vpn_id=n.get_str('vpn-id'), local_sites_role=n.get_opt_Identityref('local-sites-role'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/extranet-vpns/extranet-vpn')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn({repr(self.vpn_id)})')
        leaves = []
        _local_sites_role = self.local_sites_role
        if _local_sites_role is not None:
            leaves.append('{self_name}.local_sites_role = {repr(_local_sites_role)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/extranet-vpns/extranet-vpn'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'extranet-vpns', 'extranet-vpn'])

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'extranet-vpn'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(vpn_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.from_xml_str(node, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__vpn_id, child_vpn_id)
    child_local_sites_role = yang.gdata.from_xml_opt_Identityref(node, 'local-sites-role')
    yang.gdata.maybe_add(children, 'local-sites-role', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__local_sites_role, child_local_sites_role)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(e) for e in nodes]
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['vpn-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['vpn-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__vpn_id(keys[0])
        if point == 'local-sites-role':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['vpn-id'])))
        return yang.gdata.List(['vpn-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.take_json_str(jd, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__vpn_id, child_vpn_id)
    child_local_sites_role = yang.gdata.take_json_opt_Identityref(jd, 'local-sites-role')
    yang.gdata.maybe_add(children, 'local-sites-role', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__local_sites_role, child_local_sites_role)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(yang.adata.MNode):
    extranet_vpn: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn

    mut def __init__(self, extranet_vpn: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.extranet_vpn = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(elements=extranet_vpn)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _extranet_vpn = self.extranet_vpn
        if _extranet_vpn is not None:
            children['extranet-vpn'] = _extranet_vpn.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(extranet_vpn=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn.from_gdata(n.get_opt_list('extranet-vpn')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/extranet-vpns')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns()')
        leaves = []
        _extranet_vpn = self.extranet_vpn
        for _element in _extranet_vpn:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-services/vpn-service/extranet-vpns/extranet-vpn element: {_element.to_gdata().key_str(['vpn-id'])}")
            list_elem = 'extranet_vpn_element = {self_name}.extranet_vpn.create({repr(_element.vpn_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('extranet_vpn_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/extranet-vpns'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'extranet-vpns'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_extranet_vpn = yang.gdata.from_xml_opt_list(node, 'extranet-vpn')
    yang.gdata.maybe_add(children, 'extranet-vpn', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn, child_extranet_vpn)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'extranet-vpn':
            child = {'extranet-vpn': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_extranet_vpn = yang.gdata.take_json_opt_list(jd, 'extranet-vpn')
    yang.gdata.maybe_add(children, 'extranet-vpn', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn, child_extranet_vpn)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(yang.adata.MNode):
    vpn_id: str
    customer_name: ?str
    vpn_service_topology: Identityref
    cloud_accesses: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses
    multicast: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast
    carrierscarrier: bool
    extranet_vpns: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns

    mut def __init__(self, vpn_id: str, customer_name: ?str, vpn_service_topology: ?Identityref=None, cloud_accesses: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses=None, multicast: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast=None, carrierscarrier: ?bool=None, extranet_vpns: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_id = vpn_id
        self.customer_name = customer_name
        _default_vpn_service_topology, error = complete_and_validate_identityref(Identityref.from_adata('any-to-any'), _identities, ['l3vpn-svc:vpn-topology'], 'ietf-l3vpn-svc')
        if _default_vpn_service_topology is not None:
            self.vpn_service_topology = vpn_service_topology if vpn_service_topology is not None else _default_vpn_service_topology
        else:
            raise ValueError('Invalid default value for identityref leaf vpn-service: {error}')
        self.cloud_accesses = cloud_accesses if cloud_accesses is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses()
        self.multicast = multicast if multicast is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast()
        self.carrierscarrier = carrierscarrier if carrierscarrier is not None else False
        self.extranet_vpns = extranet_vpns if extranet_vpns is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('string', _vpn_id)
        _customer_name = self.customer_name
        if _customer_name is not None:
            children['customer-name'] = yang.gdata.Leaf('string', _customer_name)
        _vpn_service_topology = self.vpn_service_topology
        if _vpn_service_topology is not None:
            _identityref_vpn_service_topology, error = complete_and_validate_identityref(_vpn_service_topology, _identities, ['l3vpn-svc:vpn-topology'], 'ietf-l3vpn-svc')
            if _identityref_vpn_service_topology is not None:
                _vpn_service_topology = _identityref_vpn_service_topology
            else:
                raise ValueError('Invalid value for identityref leaf vpn-service-topology: {error}')
            children['vpn-service-topology'] = yang.gdata.Leaf('identityref', _vpn_service_topology)
        _cloud_accesses = self.cloud_accesses
        if _cloud_accesses is not None:
            children['cloud-accesses'] = _cloud_accesses.to_gdata()
        _multicast = self.multicast
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        _carrierscarrier = self.carrierscarrier
        if _carrierscarrier is not None:
            children['carrierscarrier'] = yang.gdata.Leaf('boolean', _carrierscarrier)
        _extranet_vpns = self.extranet_vpns
        if _extranet_vpns is not None:
            children['extranet-vpns'] = _extranet_vpns.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(vpn_id=n.get_str('vpn-id'), customer_name=n.get_opt_str('customer-name'), vpn_service_topology=n.get_opt_Identityref('vpn-service-topology'), cloud_accesses=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses.from_gdata(n.get_opt_cnt('cloud-accesses')), multicast=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast.from_gdata(n.get_opt_cnt('multicast')), carrierscarrier=n.get_opt_bool('carrierscarrier'), extranet_vpns=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns.from_gdata(n.get_opt_cnt('extranet-vpns')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service({repr(self.vpn_id)})')
        leaves = []
        _customer_name = self.customer_name
        if _customer_name is not None:
            leaves.append('{self_name}.customer_name = {repr(_customer_name)}')
        _vpn_service_topology = self.vpn_service_topology
        if _vpn_service_topology is not None:
            leaves.append('{self_name}.vpn_service_topology = {repr(_vpn_service_topology)}')
        _cloud_accesses = self.cloud_accesses
        if _cloud_accesses is not None:
            res.extend(_cloud_accesses.prsrc('{self_name}.cloud_accesses', False).splitlines())
        _multicast = self.multicast
        if _multicast is not None:
            res.extend(_multicast.prsrc('{self_name}.multicast', False).splitlines())
        _carrierscarrier = self.carrierscarrier
        if _carrierscarrier is not None:
            leaves.append('{self_name}.carrierscarrier = {repr(_carrierscarrier)}')
        _extranet_vpns = self.extranet_vpns
        if _extranet_vpns is not None:
            res.extend(_extranet_vpns.prsrc('{self_name}.extranet_vpns', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service'])

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'vpn-service'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(vpn_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.from_xml_str(node, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_id, child_vpn_id)
    child_customer_name = yang.gdata.from_xml_opt_str(node, 'customer-name')
    yang.gdata.maybe_add(children, 'customer-name', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__customer_name, child_customer_name)
    child_vpn_service_topology = yang.gdata.from_xml_opt_Identityref(node, 'vpn-service-topology')
    yang.gdata.maybe_add(children, 'vpn-service-topology', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_service_topology, child_vpn_service_topology)
    child_cloud_accesses = yang.gdata.from_xml_opt_cnt(node, 'cloud-accesses')
    yang.gdata.maybe_add(children, 'cloud-accesses', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses, child_cloud_accesses)
    child_multicast = yang.gdata.from_xml_opt_cnt(node, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast, child_multicast)
    child_carrierscarrier = yang.gdata.from_xml_opt_bool(node, 'carrierscarrier')
    yang.gdata.maybe_add(children, 'carrierscarrier', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__carrierscarrier, child_carrierscarrier)
    child_extranet_vpns = yang.gdata.from_xml_opt_cnt(node, 'extranet-vpns')
    yang.gdata.maybe_add(children, 'extranet-vpns', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns, child_extranet_vpns)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(e) for e in nodes]
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['vpn-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['vpn-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_id(keys[0])
        if point == 'customer-name':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'vpn-service-topology':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'cloud-accesses':
            children['cloud-accesses'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(jd, rest_path, op)
        if point == 'multicast':
            children['multicast'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(jd, rest_path, op)
        if point == 'carrierscarrier':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'extranet-vpns':
            children['extranet-vpns'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['vpn-id'])))
        return yang.gdata.List(['vpn-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.take_json_str(jd, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_id, child_vpn_id)
    child_customer_name = yang.gdata.take_json_opt_str(jd, 'customer-name')
    yang.gdata.maybe_add(children, 'customer-name', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__customer_name, child_customer_name)
    child_vpn_service_topology = yang.gdata.take_json_opt_Identityref(jd, 'vpn-service-topology')
    yang.gdata.maybe_add(children, 'vpn-service-topology', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_service_topology, child_vpn_service_topology)
    child_cloud_accesses = yang.gdata.take_json_opt_cnt(jd, 'cloud-accesses')
    yang.gdata.maybe_add(children, 'cloud-accesses', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses, child_cloud_accesses)
    child_multicast = yang.gdata.take_json_opt_cnt(jd, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast, child_multicast)
    child_carrierscarrier = yang.gdata.take_json_opt_bool(jd, 'carrierscarrier')
    yang.gdata.maybe_add(children, 'carrierscarrier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__carrierscarrier, child_carrierscarrier)
    child_extranet_vpns = yang.gdata.take_json_opt_cnt(jd, 'extranet-vpns')
    yang.gdata.maybe_add(children, 'extranet-vpns', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns, child_extranet_vpns)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services(yang.adata.MNode):
    vpn_service: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service

    mut def __init__(self, vpn_service: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_service = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(elements=vpn_service)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_service = self.vpn_service
        if _vpn_service is not None:
            children['vpn-service'] = _vpn_service.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services(vpn_service=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service.from_gdata(n.get_opt_list('vpn-service')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services()')
        leaves = []
        _vpn_service = self.vpn_service
        for _element in _vpn_service:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-services/vpn-service element: {_element.to_gdata().key_str(['vpn-id'])}")
            list_elem = 'vpn_service_element = {self_name}.vpn_service.create({repr(_element.vpn_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('vpn_service_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_vpn_service = yang.gdata.from_xml_opt_list(node, 'vpn-service')
    yang.gdata.maybe_add(children, 'vpn-service', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service, child_vpn_service)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'vpn-service':
            child = {'vpn-service': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_service = yang.gdata.take_json_opt_list(jd, 'vpn-service')
    yang.gdata.maybe_add(children, 'vpn-service', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service, child_vpn_service)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_start(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_start(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_stop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_stop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__location_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__location_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__postal_code(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__postal_code(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__city(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__city(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__country_code(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__country_code(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(yang.adata.MNode):
    location_id: str
    address: ?str
    postal_code: ?str
    state: ?str
    city: ?str
    country_code: ?str

    mut def __init__(self, location_id: str, address: ?str, postal_code: ?str, state: ?str, city: ?str, country_code: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.location_id = location_id
        self.address = address
        self.postal_code = postal_code
        self.state = state
        self.city = city
        self.country_code = country_code

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _location_id = self.location_id
        if _location_id is not None:
            children['location-id'] = yang.gdata.Leaf('string', _location_id)
        _address = self.address
        if _address is not None:
            children['address'] = yang.gdata.Leaf('string', _address)
        _postal_code = self.postal_code
        if _postal_code is not None:
            children['postal-code'] = yang.gdata.Leaf('string', _postal_code)
        _state = self.state
        if _state is not None:
            children['state'] = yang.gdata.Leaf('string', _state)
        _city = self.city
        if _city is not None:
            children['city'] = yang.gdata.Leaf('string', _city)
        _country_code = self.country_code
        if _country_code is not None:
            children['country-code'] = yang.gdata.Leaf('string', _country_code)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(location_id=n.get_str('location-id'), address=n.get_opt_str('address'), postal_code=n.get_opt_str('postal-code'), state=n.get_opt_str('state'), city=n.get_opt_str('city'), country_code=n.get_opt_str('country-code'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/locations/location')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location({repr(self.location_id)})')
        leaves = []
        _address = self.address
        if _address is not None:
            leaves.append('{self_name}.address = {repr(_address)}')
        _postal_code = self.postal_code
        if _postal_code is not None:
            leaves.append('{self_name}.postal_code = {repr(_postal_code)}')
        _state = self.state
        if _state is not None:
            leaves.append('{self_name}.state = {repr(_state)}')
        _city = self.city
        if _city is not None:
            leaves.append('{self_name}.city = {repr(_city)}')
        _country_code = self.country_code
        if _country_code is not None:
            leaves.append('{self_name}.country_code = {repr(_country_code)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/locations/location'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'locations', 'location'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'location'
        self.elements = elements

    mut def create(self, location_id):
        for e in self:
            match = True
            if e.location_id != location_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(location_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['location-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_location_id = yang.gdata.from_xml_str(node, 'location-id')
    yang.gdata.maybe_add(children, 'location-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__location_id, child_location_id)
    child_address = yang.gdata.from_xml_opt_str(node, 'address')
    yang.gdata.maybe_add(children, 'address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__address, child_address)
    child_postal_code = yang.gdata.from_xml_opt_str(node, 'postal-code')
    yang.gdata.maybe_add(children, 'postal-code', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__postal_code, child_postal_code)
    child_state = yang.gdata.from_xml_opt_str(node, 'state')
    yang.gdata.maybe_add(children, 'state', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__state, child_state)
    child_city = yang.gdata.from_xml_opt_str(node, 'city')
    yang.gdata.maybe_add(children, 'city', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__city, child_city)
    child_country_code = yang.gdata.from_xml_opt_str(node, 'country-code')
    yang.gdata.maybe_add(children, 'country-code', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__country_code, child_country_code)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(e) for e in nodes]
    return yang.gdata.List(keys=['location-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['location-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['location-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__location_id(keys[0])
        if point == 'address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'postal-code':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'state':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'city':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'country-code':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['location-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['location-id'])))
        return yang.gdata.List(['location-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['location-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_location_id = yang.gdata.take_json_str(jd, 'location-id')
    yang.gdata.maybe_add(children, 'location-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__location_id, child_location_id)
    child_address = yang.gdata.take_json_opt_str(jd, 'address')
    yang.gdata.maybe_add(children, 'address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__address, child_address)
    child_postal_code = yang.gdata.take_json_opt_str(jd, 'postal-code')
    yang.gdata.maybe_add(children, 'postal-code', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__postal_code, child_postal_code)
    child_state = yang.gdata.take_json_opt_str(jd, 'state')
    yang.gdata.maybe_add(children, 'state', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__state, child_state)
    child_city = yang.gdata.take_json_opt_str(jd, 'city')
    yang.gdata.maybe_add(children, 'city', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__city, child_city)
    child_country_code = yang.gdata.take_json_opt_str(jd, 'country-code')
    yang.gdata.maybe_add(children, 'country-code', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__country_code, child_country_code)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['location-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(yang.adata.MNode):
    location: ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location

    mut def __init__(self, location: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.location = ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(elements=location)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _location = self.location
        if _location is not None:
            children['location'] = _location.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__locations:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(location=ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location.from_gdata(n.get_opt_list('location')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/locations')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__locations()')
        leaves = []
        _location = self.location
        for _element in _location:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/locations/location element: {_element.to_gdata().key_str(['location-id'])}")
            list_elem = 'location_element = {self_name}.location.create({repr(_element.location_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('location_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/locations'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'locations'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_location = yang.gdata.from_xml_opt_list(node, 'location')
    yang.gdata.maybe_add(children, 'location', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location, child_location)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'location':
            child = {'location': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_location = yang.gdata.take_json_opt_list(jd, 'location')
    yang.gdata.maybe_add(children, 'location', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location, child_location)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__device_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__device_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__location(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__location(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address_family(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address_family(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(yang.adata.MNode):
    address_family: ?str
    address: str

    mut def __init__(self, address: str, address_family: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family
        self.address = address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.Leaf('enumeration', _address_family)
        _address = self.address
        if _address is not None:
            children['address'] = yang.gdata.Leaf('union', _address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(address_family=n.get_opt_str('address-family'), address=n.get_str('address'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management')

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/devices/device/management')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management({repr(self.address)})')
        leaves = []
        _address_family = self.address_family
        if _address_family is not None:
            leaves.append('{self_name}.address_family = {repr(_address_family)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/devices/device/management'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'devices', 'device', 'management'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_opt_str(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address_family, child_address_family)
    child_address = yang.gdata.from_xml_str(node, 'address')
    yang.gdata.maybe_add(children, 'address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address, child_address)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_opt_str(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address_family, child_address_family)
    child_address = yang.gdata.take_json_str(jd, 'address')
    yang.gdata.maybe_add(children, 'address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address, child_address)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(yang.adata.MNode):
    device_id: str
    location: str
    management: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management

    mut def __init__(self, device_id: str, location: str, management: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.device_id = device_id
        self.location = location
        self.management = management

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _device_id = self.device_id
        if _device_id is not None:
            children['device-id'] = yang.gdata.Leaf('string', _device_id)
        _location = self.location
        if _location is not None:
            children['location'] = yang.gdata.Leaf('leafref', _location)
        _management = self.management
        if _management is not None:
            children['management'] = _management.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(device_id=n.get_str('device-id'), location=n.get_str('location'), management=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management.from_gdata(n.get_cnt('management')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/devices/device')
            res.append('self_management = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management({repr(self.management.address)})')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device({repr(self.device_id)}, {repr(self.location)}, self_management)')
        leaves = []
        _management = self.management
        if _management is not None:
            res.extend(_management.prsrc('{self_name}.management', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/devices/device'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'devices', 'device'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'device'
        self.elements = elements

    mut def create(self, device_id, location, management):
        for e in self:
            match = True
            if e.device_id != device_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(device_id, location, management)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['device-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_device_id = yang.gdata.from_xml_str(node, 'device-id')
    yang.gdata.maybe_add(children, 'device-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__device_id, child_device_id)
    child_location = yang.gdata.from_xml_str(node, 'location')
    yang.gdata.maybe_add(children, 'location', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__location, child_location)
    child_management = yang.gdata.from_xml_cnt(node, 'management')
    yang.gdata.maybe_add(children, 'management', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management, child_management)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(e) for e in nodes]
    return yang.gdata.List(keys=['device-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['device-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['device-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__device_id(keys[0])
        if point == 'location':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'management':
            children['management'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['device-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['device-id'])))
        return yang.gdata.List(['device-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['device-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_device_id = yang.gdata.take_json_str(jd, 'device-id')
    yang.gdata.maybe_add(children, 'device-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__device_id, child_device_id)
    child_location = yang.gdata.take_json_str(jd, 'location')
    yang.gdata.maybe_add(children, 'location', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__location, child_location)
    child_management = yang.gdata.take_json_cnt(jd, 'management')
    yang.gdata.maybe_add(children, 'management', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management, child_management)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['device-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(yang.adata.MNode):
    device: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device

    mut def __init__(self, device: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.device = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(elements=device)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _device = self.device
        if _device is not None:
            children['device'] = _device.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(device=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device.from_gdata(n.get_opt_list('device')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/devices')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices()')
        leaves = []
        _device = self.device
        for _element in _device:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/devices/device element: {_element.to_gdata().key_str(['device-id'])}")
            res.append('element_management = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management({repr(_element.management.address)})')
            list_elem = 'device_element = {self_name}.device.create({repr(_element.device_id)}, {repr(_element.location)}, element_management)'
            res.append(list_elem)
            res.extend(_element.prsrc('device_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/devices'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'devices'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_device = yang.gdata.from_xml_opt_list(node, 'device')
    yang.gdata.maybe_add(children, 'device', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device, child_device)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'device':
            child = {'device': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_device = yang.gdata.take_json_opt_list(jd, 'device')
    yang.gdata.maybe_add(children, 'device', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device, child_device)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(yang.adata.MNode):
    group_id: str

    mut def __init__(self, group_id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(group_id=n.get_str('group-id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-diversity/groups/group')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group({repr(self.group_id)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-diversity/groups/group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-diversity', 'groups', 'group'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.from_xml_str(node, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group__group_id, child_group_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(e) for e in nodes]
    return yang.gdata.List(keys=['group-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['group-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group__group_id(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['group-id'])))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.take_json_str(jd, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group__group_id, child_group_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['group-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(elements=group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group.from_gdata(n.get_opt_list('group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-diversity/groups')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups()')
        leaves = []
        _group = self.group
        for _element in _group:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-diversity/groups/group element: {_element.to_gdata().key_str(['group-id'])}")
            list_elem = 'group_element = {self_name}.group.create({repr(_element.group_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('group_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-diversity/groups'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-diversity', 'groups'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.from_xml_opt_list(node, 'group')
    yang.gdata.maybe_add(children, 'group', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group, child_group)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.take_json_opt_list(jd, 'group')
    yang.gdata.maybe_add(children, 'group', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group, child_group)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(yang.adata.MNode):
    groups: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups

    mut def __init__(self, groups: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.groups = groups if groups is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _groups = self.groups
        if _groups is not None:
            children['groups'] = _groups.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(groups=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups.from_gdata(n.get_opt_cnt('groups')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-diversity')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity()')
        leaves = []
        _groups = self.groups
        if _groups is not None:
            res.extend(_groups.prsrc('{self_name}.groups', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-diversity'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-diversity'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_groups = yang.gdata.from_xml_opt_cnt(node, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups, child_groups)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'groups':
            child = {'groups': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_groups = yang.gdata.take_json_opt_cnt(jd, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups, child_groups)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:management'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__management__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:management'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

class ietf_l3vpn_svc__l3vpn_svc__sites__site__management(yang.adata.MNode):
    type: Identityref

    mut def __init__(self, type: Identityref):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        if _type is not None:
            _identityref_type, error = complete_and_validate_identityref(_type, _identities, ['l3vpn-svc:management'], 'ietf-l3vpn-svc')
            if _identityref_type is not None:
                _type = _identityref_type
            else:
                raise ValueError('Invalid value for identityref leaf type: {error}')
            children['type'] = yang.gdata.Leaf('identityref', _type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__management:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__management(type=n.get_Identityref('type'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__management')

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__management.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/management')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__management({repr(self.type)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/management'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'management'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_type = yang.gdata.from_xml_Identityref(node, 'type')
    yang.gdata.maybe_add(children, 'type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__management__type, child_type)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_type = yang.gdata.take_json_Identityref(jd, 'type')
    yang.gdata.maybe_add(children, 'type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management__type, child_type)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__vpn_policy_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__vpn_policy_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:vpn-policy-filter-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:vpn-policy-filter-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__lan_tag(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__lan_tag(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv4_lan_prefix(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv4_lan_prefix(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv6_lan_prefix(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv6_lan_prefix(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(yang.adata.MNode):
    type: Identityref
    lan_tag: list[str]
    ipv4_lan_prefix: list[str]
    ipv6_lan_prefix: list[str]

    mut def __init__(self, type: Identityref, lan_tag: ?list[str]=None, ipv4_lan_prefix: ?list[str]=None, ipv6_lan_prefix: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type
        self.lan_tag = lan_tag if lan_tag is not None else []
        self.ipv4_lan_prefix = ipv4_lan_prefix if ipv4_lan_prefix is not None else []
        self.ipv6_lan_prefix = ipv6_lan_prefix if ipv6_lan_prefix is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        if _type is not None:
            _identityref_type, error = complete_and_validate_identityref(_type, _identities, ['l3vpn-svc:vpn-policy-filter-type'], 'ietf-l3vpn-svc')
            if _identityref_type is not None:
                _type = _identityref_type
            else:
                raise ValueError('Invalid value for identityref leaf type: {error}')
            children['type'] = yang.gdata.Leaf('identityref', _type)
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.LeafList('string', _lan_tag)
        _ipv4_lan_prefix = self.ipv4_lan_prefix
        if _ipv4_lan_prefix is not None:
            children['ipv4-lan-prefix'] = yang.gdata.LeafList('string', _ipv4_lan_prefix)
        _ipv6_lan_prefix = self.ipv6_lan_prefix
        if _ipv6_lan_prefix is not None:
            children['ipv6-lan-prefix'] = yang.gdata.LeafList('string', _ipv6_lan_prefix)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(type=n.get_Identityref('type'), lan_tag=n.get_opt_strs('lan-tag'), ipv4_lan_prefix=n.get_opt_strs('ipv4-lan-prefix'), ipv6_lan_prefix=n.get_opt_strs('ipv6-lan-prefix'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/filters/filter')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter({repr(self.type)})')
        leaves = []
        _lan_tag = self.lan_tag
        if len(_lan_tag) != 0:
            leaves.append('{self_name}.lan_tag = {repr(_lan_tag)}')
        _ipv4_lan_prefix = self.ipv4_lan_prefix
        if len(_ipv4_lan_prefix) != 0:
            leaves.append('{self_name}.ipv4_lan_prefix = {repr(_ipv4_lan_prefix)}')
        _ipv6_lan_prefix = self.ipv6_lan_prefix
        if len(_ipv6_lan_prefix) != 0:
            leaves.append('{self_name}.ipv6_lan_prefix = {repr(_ipv6_lan_prefix)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/filters/filter'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'vpn-policies', 'vpn-policy', 'entries', 'filters', 'filter'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'filter'
        self.elements = elements

    mut def create(self, type):
        for e in self:
            match = True
            if e.type != type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['type'], elements, user_order=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_type = yang.gdata.from_xml_Identityref(node, 'type')
    yang.gdata.maybe_add(children, 'type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__type, child_type)
    child_lan_tag = yang.gdata.from_xml_opt_strs(node, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__lan_tag, child_lan_tag)
    child_ipv4_lan_prefix = yang.gdata.from_xml_opt_strs(node, 'ipv4-lan-prefix')
    yang.gdata.maybe_add(children, 'ipv4-lan-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv4_lan_prefix, child_ipv4_lan_prefix)
    child_ipv6_lan_prefix = yang.gdata.from_xml_opt_strs(node, 'ipv6-lan-prefix')
    yang.gdata.maybe_add(children, 'ipv6-lan-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv6_lan_prefix, child_ipv6_lan_prefix)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(e) for e in nodes]
    return yang.gdata.List(keys=['type'], elements=elements, user_order=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['type']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__type(Identityref.from_json(keys[0]))
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-lan-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-lan-prefix':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['type'])))
        return yang.gdata.List(['type'], elements, user_order=True)
    elif len(path) > 1:
        return yang.gdata.List(['type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd, path, op)], user_order=True)
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_type = yang.gdata.take_json_Identityref(jd, 'type')
    yang.gdata.maybe_add(children, 'type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__type, child_type)
    child_lan_tag = yang.gdata.take_json_opt_strs(jd, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__lan_tag, child_lan_tag)
    child_ipv4_lan_prefix = yang.gdata.take_json_opt_strs(jd, 'ipv4-lan-prefix')
    yang.gdata.maybe_add(children, 'ipv4-lan-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv4_lan_prefix, child_ipv4_lan_prefix)
    child_ipv6_lan_prefix = yang.gdata.take_json_opt_strs(jd, 'ipv6-lan-prefix')
    yang.gdata.maybe_add(children, 'ipv6-lan-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv6_lan_prefix, child_ipv6_lan_prefix)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['type'], elements=elements, user_order=True)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(yang.adata.MNode):
    filter: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter

    mut def __init__(self, filter: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.filter = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(elements=filter)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _filter = self.filter
        if _filter is not None:
            children['filter'] = _filter.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(filter=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter.from_gdata(n.get_opt_list('filter')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/filters')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters()')
        leaves = []
        _filter = self.filter
        for _element in _filter:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/filters/filter element: {_element.to_gdata().key_str(['type'])}")
            list_elem = 'filter_element = {self_name}.filter.create({repr(_element.type)})'
            res.append(list_elem)
            res.extend(_element.prsrc('filter_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/filters'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'vpn-policies', 'vpn-policy', 'entries', 'filters'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_filter = yang.gdata.from_xml_opt_list(node, 'filter')
    yang.gdata.maybe_add(children, 'filter', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter, child_filter)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'filter':
            child = {'filter': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_filter = yang.gdata.take_json_opt_list(jd, 'filter')
    yang.gdata.maybe_add(children, 'filter', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter, child_filter)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__site_role(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-role: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__site_role(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-role: {error}')

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(yang.adata.MNode):
    vpn_id: str
    site_role: Identityref

    mut def __init__(self, vpn_id: str, site_role: ?Identityref=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_id = vpn_id
        _default_site_role, error = complete_and_validate_identityref(Identityref.from_adata('any-to-any-role'), _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
        if _default_site_role is not None:
            self.site_role = site_role if site_role is not None else _default_site_role
        else:
            raise ValueError('Invalid default value for identityref leaf vpn: {error}')

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('leafref', _vpn_id)
        _site_role = self.site_role
        if _site_role is not None:
            _identityref_site_role, error = complete_and_validate_identityref(_site_role, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
            if _identityref_site_role is not None:
                _site_role = _identityref_site_role
            else:
                raise ValueError('Invalid value for identityref leaf site-role: {error}')
            children['site-role'] = yang.gdata.Leaf('identityref', _site_role)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(vpn_id=n.get_str('vpn-id'), site_role=n.get_opt_Identityref('site-role'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/vpn')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn({repr(self.vpn_id)})')
        leaves = []
        _site_role = self.site_role
        if _site_role is not None:
            leaves.append('{self_name}.site_role = {repr(_site_role)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/vpn'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'vpn-policies', 'vpn-policy', 'entries', 'vpn'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'vpn'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(vpn_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.from_xml_str(node, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__vpn_id, child_vpn_id)
    child_site_role = yang.gdata.from_xml_opt_Identityref(node, 'site-role')
    yang.gdata.maybe_add(children, 'site-role', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__site_role, child_site_role)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(e) for e in nodes]
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['vpn-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['vpn-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__vpn_id(keys[0])
        if point == 'site-role':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['vpn-id'])))
        return yang.gdata.List(['vpn-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.take_json_str(jd, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__vpn_id, child_vpn_id)
    child_site_role = yang.gdata.take_json_opt_Identityref(jd, 'site-role')
    yang.gdata.maybe_add(children, 'site-role', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__site_role, child_site_role)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(yang.adata.MNode):
    id: str
    filters: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters
    vpn: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn

    mut def __init__(self, id: str, filters: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters=None, vpn: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.filters = filters if filters is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters()
        self.vpn = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(elements=vpn)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        _filters = self.filters
        if _filters is not None:
            children['filters'] = _filters.to_gdata()
        _vpn = self.vpn
        if _vpn is not None:
            children['vpn'] = _vpn.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(id=n.get_str('id'), filters=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters.from_gdata(n.get_opt_cnt('filters')), vpn=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn.from_gdata(n.get_opt_list('vpn')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries({repr(self.id)})')
        leaves = []
        _filters = self.filters
        if _filters is not None:
            res.extend(_filters.prsrc('{self_name}.filters', False).splitlines())
        _vpn = self.vpn
        for _element in _vpn:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/vpn element: {_element.to_gdata().key_str(['vpn-id'])}")
            list_elem = 'vpn_element = {self_name}.vpn.create({repr(_element.vpn_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('vpn_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'vpn-policies', 'vpn-policy', 'entries'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'entries'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_str(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__id, child_id)
    child_filters = yang.gdata.from_xml_opt_cnt(node, 'filters')
    yang.gdata.maybe_add(children, 'filters', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters, child_filters)
    child_vpn = yang.gdata.from_xml_opt_list(node, 'vpn')
    yang.gdata.maybe_add(children, 'vpn', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn, child_vpn)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__id(keys[0])
        if point == 'filters':
            children['filters'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(jd, rest_path, op)
        if point == 'vpn':
            children['vpn'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__id, child_id)
    child_filters = yang.gdata.take_json_opt_cnt(jd, 'filters')
    yang.gdata.maybe_add(children, 'filters', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters, child_filters)
    child_vpn = yang.gdata.take_json_opt_list(jd, 'vpn')
    yang.gdata.maybe_add(children, 'vpn', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn, child_vpn)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(yang.adata.MNode):
    vpn_policy_id: str
    entries: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries

    mut def __init__(self, vpn_policy_id: str, entries: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_policy_id = vpn_policy_id
        self.entries = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(elements=entries)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_policy_id = self.vpn_policy_id
        if _vpn_policy_id is not None:
            children['vpn-policy-id'] = yang.gdata.Leaf('string', _vpn_policy_id)
        _entries = self.entries
        if _entries is not None:
            children['entries'] = _entries.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(vpn_policy_id=n.get_str('vpn-policy-id'), entries=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries.from_gdata(n.get_opt_list('entries')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/vpn-policies/vpn-policy')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy({repr(self.vpn_policy_id)})')
        leaves = []
        _entries = self.entries
        for _element in _entries:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'entries_element = {self_name}.entries.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('entries_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/vpn-policies/vpn-policy'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'vpn-policies', 'vpn-policy'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'vpn-policy'
        self.elements = elements

    mut def create(self, vpn_policy_id):
        for e in self:
            match = True
            if e.vpn_policy_id != vpn_policy_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(vpn_policy_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-policy-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_vpn_policy_id = yang.gdata.from_xml_str(node, 'vpn-policy-id')
    yang.gdata.maybe_add(children, 'vpn-policy-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__vpn_policy_id, child_vpn_policy_id)
    child_entries = yang.gdata.from_xml_opt_list(node, 'entries')
    yang.gdata.maybe_add(children, 'entries', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries, child_entries)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(e) for e in nodes]
    return yang.gdata.List(keys=['vpn-policy-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['vpn-policy-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['vpn-policy-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__vpn_policy_id(keys[0])
        if point == 'entries':
            children['entries'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-policy-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['vpn-policy-id'])))
        return yang.gdata.List(['vpn-policy-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-policy-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_vpn_policy_id = yang.gdata.take_json_str(jd, 'vpn-policy-id')
    yang.gdata.maybe_add(children, 'vpn-policy-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__vpn_policy_id, child_vpn_policy_id)
    child_entries = yang.gdata.take_json_opt_list(jd, 'entries')
    yang.gdata.maybe_add(children, 'entries', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries, child_entries)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['vpn-policy-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(yang.adata.MNode):
    vpn_policy: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy

    mut def __init__(self, vpn_policy: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_policy = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(elements=vpn_policy)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_policy = self.vpn_policy
        if _vpn_policy is not None:
            children['vpn-policy'] = _vpn_policy.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(vpn_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy.from_gdata(n.get_opt_list('vpn-policy')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/vpn-policies')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies()')
        leaves = []
        _vpn_policy = self.vpn_policy
        for _element in _vpn_policy:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/vpn-policies/vpn-policy element: {_element.to_gdata().key_str(['vpn-policy-id'])}")
            list_elem = 'vpn_policy_element = {self_name}.vpn_policy.create({repr(_element.vpn_policy_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('vpn_policy_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/vpn-policies'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'vpn-policies'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_vpn_policy = yang.gdata.from_xml_opt_list(node, 'vpn-policy')
    yang.gdata.maybe_add(children, 'vpn-policy', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy, child_vpn_policy)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'vpn-policy':
            child = {'vpn-policy': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_policy = yang.gdata.take_json_opt_list(jd, 'vpn-policy')
    yang.gdata.maybe_add(children, 'vpn-policy', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy, child_vpn_policy)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_vpn_flavor(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-vpn-flavor'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-vpn-flavor: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_vpn_flavor(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-vpn-flavor'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-vpn-flavor: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__af(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__af(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__maximum_routes(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__maximum_routes(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(yang.adata.MNode):
    af: str
    maximum_routes: ?int

    mut def __init__(self, af: str, maximum_routes: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.af = af
        self.maximum_routes = maximum_routes

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _af = self.af
        if _af is not None:
            children['af'] = yang.gdata.Leaf('enumeration', _af)
        _maximum_routes = self.maximum_routes
        if _maximum_routes is not None:
            children['maximum-routes'] = yang.gdata.Leaf('uint32', _maximum_routes)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(af=n.get_str('af'), maximum_routes=n.get_opt_int('maximum-routes'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/maximum-routes/address-family')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family({repr(self.af)})')
        leaves = []
        _maximum_routes = self.maximum_routes
        if _maximum_routes is not None:
            leaves.append('{self_name}.maximum_routes = {repr(_maximum_routes)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/maximum-routes/address-family'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'maximum-routes', 'address-family'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af):
        for e in self:
            match = True
            if e.af != af:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(af)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['af'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_af = yang.gdata.from_xml_str(node, 'af')
    yang.gdata.maybe_add(children, 'af', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__af, child_af)
    child_maximum_routes = yang.gdata.from_xml_opt_int(node, 'maximum-routes')
    yang.gdata.maybe_add(children, 'maximum-routes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__maximum_routes, child_maximum_routes)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(e) for e in nodes]
    return yang.gdata.List(keys=['af'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['af']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['af'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__af(keys[0])
        if point == 'maximum-routes':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['af']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['af'])))
        return yang.gdata.List(['af'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['af'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_af = yang.gdata.take_json_str(jd, 'af')
    yang.gdata.maybe_add(children, 'af', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__af, child_af)
    child_maximum_routes = yang.gdata.take_json_opt_int(jd, 'maximum-routes')
    yang.gdata.maybe_add(children, 'maximum-routes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__maximum_routes, child_maximum_routes)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['af'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(yang.adata.MNode):
    address_family: ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family

    mut def __init__(self, address_family: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(elements=address_family)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = _address_family.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family.from_gdata(n.get_opt_list('address-family')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/maximum-routes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes()')
        leaves = []
        _address_family = self.address_family
        for _element in _address_family:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/maximum-routes/address-family element: {_element.to_gdata().key_str(['af'])}")
            list_elem = 'address_family_element = {self_name}.address_family.create({repr(_element.af)})'
            res.append(list_elem)
            res.extend(_element.prsrc('address_family_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/maximum-routes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'maximum-routes'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_opt_list(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family, child_address_family)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            child = {'address-family': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_opt_list(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family, child_address_family)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/security/authentication')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/security/authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'security', 'authentication'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__layer(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__layer(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__preshared_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__preshared_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(yang.adata.MNode):
    profile_name: ?str
    algorithm: ?str
    preshared_key: ?str

    mut def __init__(self, profile_name: ?str, algorithm: ?str, preshared_key: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile_name = profile_name
        self.algorithm = algorithm
        self.preshared_key = preshared_key

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile_name = self.profile_name
        if _profile_name is not None:
            children['profile-name'] = yang.gdata.Leaf('leafref', _profile_name)
        _algorithm = self.algorithm
        if _algorithm is not None:
            children['algorithm'] = yang.gdata.Leaf('string', _algorithm)
        _preshared_key = self.preshared_key
        if _preshared_key is not None:
            children['preshared-key'] = yang.gdata.Leaf('string', _preshared_key)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(profile_name=n.get_opt_str('profile-name'), algorithm=n.get_opt_str('algorithm'), preshared_key=n.get_opt_str('preshared-key'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/security/encryption/encryption-profile')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile()')
        leaves = []
        _profile_name = self.profile_name
        if _profile_name is not None:
            leaves.append('{self_name}.profile_name = {repr(_profile_name)}')
        _algorithm = self.algorithm
        if _algorithm is not None:
            leaves.append('{self_name}.algorithm = {repr(_algorithm)}')
        _preshared_key = self.preshared_key
        if _preshared_key is not None:
            leaves.append('{self_name}.preshared_key = {repr(_preshared_key)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/security/encryption/encryption-profile'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'security', 'encryption', 'encryption-profile'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_profile_name = yang.gdata.from_xml_opt_str(node, 'profile-name')
    yang.gdata.maybe_add(children, 'profile-name', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__profile_name, child_profile_name)
    child_algorithm = yang.gdata.from_xml_opt_str(node, 'algorithm')
    yang.gdata.maybe_add(children, 'algorithm', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__algorithm, child_algorithm)
    child_preshared_key = yang.gdata.from_xml_opt_str(node, 'preshared-key')
    yang.gdata.maybe_add(children, 'preshared-key', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__preshared_key, child_preshared_key)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'profile-name':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'algorithm':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'preshared-key':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile_name = yang.gdata.take_json_opt_str(jd, 'profile-name')
    yang.gdata.maybe_add(children, 'profile-name', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__profile_name, child_profile_name)
    child_algorithm = yang.gdata.take_json_opt_str(jd, 'algorithm')
    yang.gdata.maybe_add(children, 'algorithm', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__algorithm, child_algorithm)
    child_preshared_key = yang.gdata.take_json_opt_str(jd, 'preshared-key')
    yang.gdata.maybe_add(children, 'preshared-key', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__preshared_key, child_preshared_key)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(yang.adata.MNode):
    enabled: bool
    layer: ?str
    encryption_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile

    mut def __init__(self, enabled: ?bool=None, layer: ?str, encryption_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.layer = layer
        self.encryption_profile = encryption_profile if encryption_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _layer = self.layer
        if _layer is not None:
            children['layer'] = yang.gdata.Leaf('enumeration', _layer)
        _encryption_profile = self.encryption_profile
        if _encryption_profile is not None:
            children['encryption-profile'] = _encryption_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(enabled=n.get_opt_bool('enabled'), layer=n.get_opt_str('layer'), encryption_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile.from_gdata(n.get_opt_cnt('encryption-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/security/encryption')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption()')
        leaves = []
        _enabled = self.enabled
        if _enabled is not None:
            leaves.append('{self_name}.enabled = {repr(_enabled)}')
        _layer = self.layer
        if _layer is not None:
            leaves.append('{self_name}.layer = {repr(_layer)}')
        _encryption_profile = self.encryption_profile
        if _encryption_profile is not None:
            res.extend(_encryption_profile.prsrc('{self_name}.encryption_profile', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/security/encryption'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'security', 'encryption'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.from_xml_opt_bool(node, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__enabled, child_enabled)
    child_layer = yang.gdata.from_xml_opt_str(node, 'layer')
    yang.gdata.maybe_add(children, 'layer', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__layer, child_layer)
    child_encryption_profile = yang.gdata.from_xml_opt_cnt(node, 'encryption-profile')
    yang.gdata.maybe_add(children, 'encryption-profile', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile, child_encryption_profile)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'layer':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'encryption-profile':
            child = {'encryption-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__enabled, child_enabled)
    child_layer = yang.gdata.take_json_opt_str(jd, 'layer')
    yang.gdata.maybe_add(children, 'layer', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__layer, child_layer)
    child_encryption_profile = yang.gdata.take_json_opt_cnt(jd, 'encryption-profile')
    yang.gdata.maybe_add(children, 'encryption-profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile, child_encryption_profile)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security(yang.adata.MNode):
    authentication: ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication
    encryption: ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption

    mut def __init__(self, authentication: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication=None, encryption: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.authentication = authentication if authentication is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()
        self.encryption = encryption if encryption is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _authentication = self.authentication
        if _authentication is not None:
            children['authentication'] = _authentication.to_gdata()
        _encryption = self.encryption
        if _encryption is not None:
            children['encryption'] = _encryption.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security(authentication=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication.from_gdata(n.get_opt_cnt('authentication')), encryption=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption.from_gdata(n.get_opt_cnt('encryption')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/security')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__security()')
        leaves = []
        _authentication = self.authentication
        if _authentication is not None:
            res.extend(_authentication.prsrc('{self_name}.authentication', False).splitlines())
        _encryption = self.encryption
        if _encryption is not None:
            res.extend(_encryption.prsrc('{self_name}.encryption', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/security'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'security'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_authentication = yang.gdata.from_xml_opt_cnt(node, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication, child_authentication)
    child_encryption = yang.gdata.from_xml_opt_cnt(node, 'encryption')
    yang.gdata.maybe_add(children, 'encryption', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption, child_encryption)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'authentication':
            child = {'authentication': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'encryption':
            child = {'encryption': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_authentication = yang.gdata.take_json_opt_cnt(jd, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication, child_authentication)
    child_encryption = yang.gdata.take_json_opt_cnt(jd, 'encryption')
    yang.gdata.maybe_add(children, 'encryption', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption, child_encryption)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dscp(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dscp(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dot1p(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dot1p(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__target_sites(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__target_sites(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        _upper_port = self.upper_port
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(lower_port=n.get_opt_int('lower-port'), upper_port=n.get_opt_int('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule/match-flow/l4-src-port-range')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()')
        leaves = []
        _lower_port = self.lower_port
        if _lower_port is not None:
            leaves.append('{self_name}.lower_port = {repr(_lower_port)}')
        _upper_port = self.upper_port
        if _upper_port is not None:
            leaves.append('{self_name}.upper_port = {repr(_upper_port)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule/match-flow/l4-src-port-range'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-classification-policy', 'rule', 'match-flow', 'l4-src-port-range'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.from_xml_opt_int(node, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.from_xml_opt_int(node, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.take_json_opt_int(jd, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.take_json_opt_int(jd, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        _upper_port = self.upper_port
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(lower_port=n.get_opt_int('lower-port'), upper_port=n.get_opt_int('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule/match-flow/l4-dst-port-range')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()')
        leaves = []
        _lower_port = self.lower_port
        if _lower_port is not None:
            leaves.append('{self_name}.lower_port = {repr(_lower_port)}')
        _upper_port = self.upper_port
        if _upper_port is not None:
            leaves.append('{self_name}.upper_port = {repr(_upper_port)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule/match-flow/l4-dst-port-range'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-classification-policy', 'rule', 'match-flow', 'l4-dst-port-range'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.from_xml_opt_int(node, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.from_xml_opt_int(node, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.take_json_opt_int(jd, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.take_json_opt_int(jd, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__protocol_field(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__protocol_field(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(yang.adata.MNode):
    dscp: ?int
    dot1p: ?int
    ipv4_src_prefix: ?str
    ipv6_src_prefix: ?str
    ipv4_dst_prefix: ?str
    ipv6_dst_prefix: ?str
    l4_src_port: ?int
    target_sites: list[str]
    l4_src_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range
    l4_dst_port: ?int
    l4_dst_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range
    protocol_field: ?value

    mut def __init__(self, dscp: ?int, dot1p: ?int, ipv4_src_prefix: ?str, ipv6_src_prefix: ?str, ipv4_dst_prefix: ?str, ipv6_dst_prefix: ?str, l4_src_port: ?int, target_sites: ?list[str]=None, l4_src_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range=None, l4_dst_port: ?int, l4_dst_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range=None, protocol_field: ?value):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.dscp = dscp
        self.dot1p = dot1p
        self.ipv4_src_prefix = ipv4_src_prefix
        self.ipv6_src_prefix = ipv6_src_prefix
        self.ipv4_dst_prefix = ipv4_dst_prefix
        self.ipv6_dst_prefix = ipv6_dst_prefix
        self.l4_src_port = l4_src_port
        self.target_sites = target_sites if target_sites is not None else []
        self.l4_src_port_range = l4_src_port_range if l4_src_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()
        self.l4_dst_port = l4_dst_port
        self.l4_dst_port_range = l4_dst_port_range if l4_dst_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()
        self.protocol_field = protocol_field

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _dscp = self.dscp
        if _dscp is not None:
            children['dscp'] = yang.gdata.Leaf('uint8', _dscp)
        _dot1p = self.dot1p
        if _dot1p is not None:
            children['dot1p'] = yang.gdata.Leaf('uint8', _dot1p)
        _ipv4_src_prefix = self.ipv4_src_prefix
        if _ipv4_src_prefix is not None:
            children['ipv4-src-prefix'] = yang.gdata.Leaf('string', _ipv4_src_prefix)
        _ipv6_src_prefix = self.ipv6_src_prefix
        if _ipv6_src_prefix is not None:
            children['ipv6-src-prefix'] = yang.gdata.Leaf('string', _ipv6_src_prefix)
        _ipv4_dst_prefix = self.ipv4_dst_prefix
        if _ipv4_dst_prefix is not None:
            children['ipv4-dst-prefix'] = yang.gdata.Leaf('string', _ipv4_dst_prefix)
        _ipv6_dst_prefix = self.ipv6_dst_prefix
        if _ipv6_dst_prefix is not None:
            children['ipv6-dst-prefix'] = yang.gdata.Leaf('string', _ipv6_dst_prefix)
        _l4_src_port = self.l4_src_port
        if _l4_src_port is not None:
            children['l4-src-port'] = yang.gdata.Leaf('uint16', _l4_src_port)
        _target_sites = self.target_sites
        if _target_sites is not None:
            children['target-sites'] = yang.gdata.LeafList('string', _target_sites)
        _l4_src_port_range = self.l4_src_port_range
        if _l4_src_port_range is not None:
            children['l4-src-port-range'] = _l4_src_port_range.to_gdata()
        _l4_dst_port = self.l4_dst_port
        if _l4_dst_port is not None:
            children['l4-dst-port'] = yang.gdata.Leaf('uint16', _l4_dst_port)
        _l4_dst_port_range = self.l4_dst_port_range
        if _l4_dst_port_range is not None:
            children['l4-dst-port-range'] = _l4_dst_port_range.to_gdata()
        _protocol_field = self.protocol_field
        if _protocol_field is not None:
            children['protocol-field'] = yang.gdata.Leaf('union', _protocol_field)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(dscp=n.get_opt_int('dscp'), dot1p=n.get_opt_int('dot1p'), ipv4_src_prefix=n.get_opt_str('ipv4-src-prefix'), ipv6_src_prefix=n.get_opt_str('ipv6-src-prefix'), ipv4_dst_prefix=n.get_opt_str('ipv4-dst-prefix'), ipv6_dst_prefix=n.get_opt_str('ipv6-dst-prefix'), l4_src_port=n.get_opt_int('l4-src-port'), target_sites=n.get_opt_strs('target-sites'), l4_src_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_gdata(n.get_opt_cnt('l4-src-port-range')), l4_dst_port=n.get_opt_int('l4-dst-port'), l4_dst_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_gdata(n.get_opt_cnt('l4-dst-port-range')), protocol_field=n.get_opt_value('protocol-field'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule/match-flow')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow()')
        leaves = []
        _dscp = self.dscp
        if _dscp is not None:
            leaves.append('{self_name}.dscp = {repr(_dscp)}')
        _dot1p = self.dot1p
        if _dot1p is not None:
            leaves.append('{self_name}.dot1p = {repr(_dot1p)}')
        _ipv4_src_prefix = self.ipv4_src_prefix
        if _ipv4_src_prefix is not None:
            leaves.append('{self_name}.ipv4_src_prefix = {repr(_ipv4_src_prefix)}')
        _ipv6_src_prefix = self.ipv6_src_prefix
        if _ipv6_src_prefix is not None:
            leaves.append('{self_name}.ipv6_src_prefix = {repr(_ipv6_src_prefix)}')
        _ipv4_dst_prefix = self.ipv4_dst_prefix
        if _ipv4_dst_prefix is not None:
            leaves.append('{self_name}.ipv4_dst_prefix = {repr(_ipv4_dst_prefix)}')
        _ipv6_dst_prefix = self.ipv6_dst_prefix
        if _ipv6_dst_prefix is not None:
            leaves.append('{self_name}.ipv6_dst_prefix = {repr(_ipv6_dst_prefix)}')
        _l4_src_port = self.l4_src_port
        if _l4_src_port is not None:
            leaves.append('{self_name}.l4_src_port = {repr(_l4_src_port)}')
        _target_sites = self.target_sites
        if len(_target_sites) != 0:
            leaves.append('{self_name}.target_sites = {repr(_target_sites)}')
        _l4_src_port_range = self.l4_src_port_range
        if _l4_src_port_range is not None:
            res.extend(_l4_src_port_range.prsrc('{self_name}.l4_src_port_range', False).splitlines())
        _l4_dst_port = self.l4_dst_port
        if _l4_dst_port is not None:
            leaves.append('{self_name}.l4_dst_port = {repr(_l4_dst_port)}')
        _l4_dst_port_range = self.l4_dst_port_range
        if _l4_dst_port_range is not None:
            res.extend(_l4_dst_port_range.prsrc('{self_name}.l4_dst_port_range', False).splitlines())
        _protocol_field = self.protocol_field
        if _protocol_field is not None:
            leaves.append('{self_name}.protocol_field = {repr(_protocol_field)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule/match-flow'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-classification-policy', 'rule', 'match-flow'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_dscp = yang.gdata.from_xml_opt_int(node, 'dscp')
    yang.gdata.maybe_add(children, 'dscp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dscp, child_dscp)
    child_dot1p = yang.gdata.from_xml_opt_int(node, 'dot1p')
    yang.gdata.maybe_add(children, 'dot1p', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dot1p, child_dot1p)
    child_ipv4_src_prefix = yang.gdata.from_xml_opt_str(node, 'ipv4-src-prefix')
    yang.gdata.maybe_add(children, 'ipv4-src-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix, child_ipv4_src_prefix)
    child_ipv6_src_prefix = yang.gdata.from_xml_opt_str(node, 'ipv6-src-prefix')
    yang.gdata.maybe_add(children, 'ipv6-src-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix, child_ipv6_src_prefix)
    child_ipv4_dst_prefix = yang.gdata.from_xml_opt_str(node, 'ipv4-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv4-dst-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix, child_ipv4_dst_prefix)
    child_ipv6_dst_prefix = yang.gdata.from_xml_opt_str(node, 'ipv6-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv6-dst-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix, child_ipv6_dst_prefix)
    child_l4_src_port = yang.gdata.from_xml_opt_int(node, 'l4-src-port')
    yang.gdata.maybe_add(children, 'l4-src-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port, child_l4_src_port)
    child_target_sites = yang.gdata.from_xml_opt_strs(node, 'target-sites')
    yang.gdata.maybe_add(children, 'target-sites', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__target_sites, child_target_sites)
    child_l4_src_port_range = yang.gdata.from_xml_opt_cnt(node, 'l4-src-port-range')
    yang.gdata.maybe_add(children, 'l4-src-port-range', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range, child_l4_src_port_range)
    child_l4_dst_port = yang.gdata.from_xml_opt_int(node, 'l4-dst-port')
    yang.gdata.maybe_add(children, 'l4-dst-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port, child_l4_dst_port)
    child_l4_dst_port_range = yang.gdata.from_xml_opt_cnt(node, 'l4-dst-port-range')
    yang.gdata.maybe_add(children, 'l4-dst-port-range', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range, child_l4_dst_port_range)
    child_protocol_field = yang.gdata.from_xml_opt_value(node, 'protocol-field')
    yang.gdata.maybe_add(children, 'protocol-field', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__protocol_field, child_protocol_field)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'dscp':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'dot1p':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-src-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'target-sites':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-src-port-range':
            child = {'l4-src-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l4-dst-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-dst-port-range':
            child = {'l4-dst-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'protocol-field':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_dscp = yang.gdata.take_json_opt_int(jd, 'dscp')
    yang.gdata.maybe_add(children, 'dscp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dscp, child_dscp)
    child_dot1p = yang.gdata.take_json_opt_int(jd, 'dot1p')
    yang.gdata.maybe_add(children, 'dot1p', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dot1p, child_dot1p)
    child_ipv4_src_prefix = yang.gdata.take_json_opt_str(jd, 'ipv4-src-prefix')
    yang.gdata.maybe_add(children, 'ipv4-src-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix, child_ipv4_src_prefix)
    child_ipv6_src_prefix = yang.gdata.take_json_opt_str(jd, 'ipv6-src-prefix')
    yang.gdata.maybe_add(children, 'ipv6-src-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix, child_ipv6_src_prefix)
    child_ipv4_dst_prefix = yang.gdata.take_json_opt_str(jd, 'ipv4-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv4-dst-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix, child_ipv4_dst_prefix)
    child_ipv6_dst_prefix = yang.gdata.take_json_opt_str(jd, 'ipv6-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv6-dst-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix, child_ipv6_dst_prefix)
    child_l4_src_port = yang.gdata.take_json_opt_int(jd, 'l4-src-port')
    yang.gdata.maybe_add(children, 'l4-src-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port, child_l4_src_port)
    child_target_sites = yang.gdata.take_json_opt_strs(jd, 'target-sites')
    yang.gdata.maybe_add(children, 'target-sites', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__target_sites, child_target_sites)
    child_l4_src_port_range = yang.gdata.take_json_opt_cnt(jd, 'l4-src-port-range')
    yang.gdata.maybe_add(children, 'l4-src-port-range', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range, child_l4_src_port_range)
    child_l4_dst_port = yang.gdata.take_json_opt_int(jd, 'l4-dst-port')
    yang.gdata.maybe_add(children, 'l4-dst-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port, child_l4_dst_port)
    child_l4_dst_port_range = yang.gdata.take_json_opt_cnt(jd, 'l4-dst-port-range')
    yang.gdata.maybe_add(children, 'l4-dst-port-range', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range, child_l4_dst_port_range)
    child_protocol_field = yang.gdata.take_json_opt_value(jd, 'protocol-field')
    yang.gdata.maybe_add(children, 'protocol-field', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__protocol_field, child_protocol_field)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_application(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:customer-application'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf match-application: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_application(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:customer-application'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf match-application: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__target_class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__target_class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(yang.adata.MNode):
    id: str
    match_flow: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow
    match_application: ?Identityref
    target_class_id: ?str

    mut def __init__(self, id: str, match_flow: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow=None, match_application: ?Identityref, target_class_id: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.match_flow = match_flow if match_flow is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow()
        self.match_application = match_application
        self.target_class_id = target_class_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        _match_flow = self.match_flow
        if _match_flow is not None:
            children['match-flow'] = _match_flow.to_gdata()
        _match_application = self.match_application
        if _match_application is not None:
            _identityref_match_application, error = complete_and_validate_identityref(_match_application, _identities, ['l3vpn-svc:customer-application'], 'ietf-l3vpn-svc')
            if _identityref_match_application is not None:
                _match_application = _identityref_match_application
            else:
                raise ValueError('Invalid value for identityref leaf match-application: {error}')
            children['match-application'] = yang.gdata.Leaf('identityref', _match_application)
        _target_class_id = self.target_class_id
        if _target_class_id is not None:
            children['target-class-id'] = yang.gdata.Leaf('string', _target_class_id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(id=n.get_str('id'), match_flow=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow.from_gdata(n.get_opt_cnt('match-flow')), match_application=n.get_opt_Identityref('match-application'), target_class_id=n.get_opt_str('target-class-id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule({repr(self.id)})')
        leaves = []
        _match_flow = self.match_flow
        if _match_flow is not None:
            res.extend(_match_flow.prsrc('{self_name}.match_flow', False).splitlines())
        _match_application = self.match_application
        if _match_application is not None:
            leaves.append('{self_name}.match_application = {repr(_match_application)}')
        _target_class_id = self.target_class_id
        if _target_class_id is not None:
            leaves.append('{self_name}.target_class_id = {repr(_target_class_id)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-classification-policy', 'rule'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'rule'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements, user_order=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_str(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__id, child_id)
    child_match_flow = yang.gdata.from_xml_opt_cnt(node, 'match-flow')
    yang.gdata.maybe_add(children, 'match-flow', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow, child_match_flow)
    child_match_application = yang.gdata.from_xml_opt_Identityref(node, 'match-application')
    yang.gdata.maybe_add(children, 'match-application', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_application, child_match_application)
    child_target_class_id = yang.gdata.from_xml_opt_str(node, 'target-class-id')
    yang.gdata.maybe_add(children, 'target-class-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__target_class_id, child_target_class_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements, user_order=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__id(keys[0])
        if point == 'match-flow':
            children['match-flow'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(jd, rest_path, op)
        if point == 'match-application':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'target-class-id':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements, user_order=True)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd, path, op)], user_order=True)
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__id, child_id)
    child_match_flow = yang.gdata.take_json_opt_cnt(jd, 'match-flow')
    yang.gdata.maybe_add(children, 'match-flow', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow, child_match_flow)
    child_match_application = yang.gdata.take_json_opt_Identityref(jd, 'match-application')
    yang.gdata.maybe_add(children, 'match-application', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_application, child_match_application)
    child_target_class_id = yang.gdata.take_json_opt_str(jd, 'target-class-id')
    yang.gdata.maybe_add(children, 'target-class-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__target_class_id, child_target_class_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements, user_order=True)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(yang.adata.MNode):
    rule: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule

    mut def __init__(self, rule: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rule = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(elements=rule)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rule = self.rule
        if _rule is not None:
            children['rule'] = _rule.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(rule=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule.from_gdata(n.get_opt_list('rule')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-classification-policy')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy()')
        leaves = []
        _rule = self.rule
        for _element in _rule:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'rule_element = {self_name}.rule.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('rule_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-classification-policy'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-classification-policy'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_rule = yang.gdata.from_xml_opt_list(node, 'rule')
    yang.gdata.maybe_add(children, 'rule', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule, child_rule)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'rule':
            child = {'rule': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rule = yang.gdata.take_json_opt_list(jd, 'rule')
    yang.gdata.maybe_add(children, 'rule', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule, child_rule)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__profile(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__profile(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__direction(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf direction: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__direction(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf direction: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__rate_limit(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__rate_limit(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__use_lowest_latency(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__use_lowest_latency(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(yang.adata.MNode):
    use_lowest_latency: ?bool
    latency_boundary: int

    mut def __init__(self, use_lowest_latency: ?bool, latency_boundary: ?int=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_latency = use_lowest_latency
        self.latency_boundary = latency_boundary if latency_boundary is not None else 400

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_latency = self.use_lowest_latency
        if _use_lowest_latency is not None:
            children['use-lowest-latency'] = yang.gdata.Leaf('empty', _use_lowest_latency)
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint16', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(use_lowest_latency=n.get_opt_empty('use-lowest-latency'), latency_boundary=n.get_opt_int('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class/latency')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency()')
        leaves = []
        _use_lowest_latency = self.use_lowest_latency
        if _use_lowest_latency is not None:
            leaves.append('{self_name}.use_lowest_latency = {repr(_use_lowest_latency)}')
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            leaves.append('{self_name}.latency_boundary = {repr(_latency_boundary)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class/latency'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-profile', 'classes', 'class', 'latency'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_use_lowest_latency = yang.gdata.from_xml_opt_empty(node, 'use-lowest-latency')
    yang.gdata.maybe_add(children, 'use-lowest-latency', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__use_lowest_latency, child_use_lowest_latency)
    child_latency_boundary = yang.gdata.from_xml_opt_int(node, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'use-lowest-latency':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_latency = yang.gdata.take_json_opt_empty(jd, 'use-lowest-latency')
    yang.gdata.maybe_add(children, 'use-lowest-latency', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__use_lowest_latency, child_use_lowest_latency)
    child_latency_boundary = yang.gdata.take_json_opt_int(jd, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(yang.adata.MNode):
    use_lowest_jitter: ?bool
    latency_boundary: int

    mut def __init__(self, use_lowest_jitter: ?bool, latency_boundary: ?int=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_jitter = use_lowest_jitter
        self.latency_boundary = latency_boundary if latency_boundary is not None else 40000

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_jitter = self.use_lowest_jitter
        if _use_lowest_jitter is not None:
            children['use-lowest-jitter'] = yang.gdata.Leaf('empty', _use_lowest_jitter)
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint32', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(use_lowest_jitter=n.get_opt_empty('use-lowest-jitter'), latency_boundary=n.get_opt_int('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class/jitter')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter()')
        leaves = []
        _use_lowest_jitter = self.use_lowest_jitter
        if _use_lowest_jitter is not None:
            leaves.append('{self_name}.use_lowest_jitter = {repr(_use_lowest_jitter)}')
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            leaves.append('{self_name}.latency_boundary = {repr(_latency_boundary)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class/jitter'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-profile', 'classes', 'class', 'jitter'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_use_lowest_jitter = yang.gdata.from_xml_opt_empty(node, 'use-lowest-jitter')
    yang.gdata.maybe_add(children, 'use-lowest-jitter', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter, child_use_lowest_jitter)
    child_latency_boundary = yang.gdata.from_xml_opt_int(node, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'use-lowest-jitter':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_jitter = yang.gdata.take_json_opt_empty(jd, 'use-lowest-jitter')
    yang.gdata.maybe_add(children, 'use-lowest-jitter', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter, child_use_lowest_jitter)
    child_latency_boundary = yang.gdata.take_json_opt_int(jd, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__end_to_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__end_to_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(yang.adata.MNode):
    guaranteed_bw_percent: float
    end_to_end: ?bool

    mut def __init__(self, guaranteed_bw_percent: float, end_to_end: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.guaranteed_bw_percent = guaranteed_bw_percent
        self.end_to_end = end_to_end

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _guaranteed_bw_percent = self.guaranteed_bw_percent
        if _guaranteed_bw_percent is not None:
            children['guaranteed-bw-percent'] = yang.gdata.Leaf('decimal64', _guaranteed_bw_percent)
        _end_to_end = self.end_to_end
        if _end_to_end is not None:
            children['end-to-end'] = yang.gdata.Leaf('empty', _end_to_end)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(guaranteed_bw_percent=n.get_float('guaranteed-bw-percent'), end_to_end=n.get_opt_empty('end-to-end'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth')

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class/bandwidth')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth({repr(self.guaranteed_bw_percent)})')
        leaves = []
        _end_to_end = self.end_to_end
        if _end_to_end is not None:
            leaves.append('{self_name}.end_to_end = {repr(_end_to_end)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class/bandwidth'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-profile', 'classes', 'class', 'bandwidth'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_guaranteed_bw_percent = yang.gdata.from_xml_float(node, 'guaranteed-bw-percent')
    yang.gdata.maybe_add(children, 'guaranteed-bw-percent', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent, child_guaranteed_bw_percent)
    child_end_to_end = yang.gdata.from_xml_opt_empty(node, 'end-to-end')
    yang.gdata.maybe_add(children, 'end-to-end', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__end_to_end, child_end_to_end)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'guaranteed-bw-percent':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'end-to-end':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_guaranteed_bw_percent = yang.gdata.take_json_float(jd, 'guaranteed-bw-percent')
    yang.gdata.maybe_add(children, 'guaranteed-bw-percent', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent, child_guaranteed_bw_percent)
    child_end_to_end = yang.gdata.take_json_opt_empty(jd, 'end-to-end')
    yang.gdata.maybe_add(children, 'end-to-end', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__end_to_end, child_end_to_end)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(yang.adata.MNode):
    class_id: str
    direction: Identityref
    rate_limit: ?float
    latency: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency
    jitter: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter
    bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth

    mut def __init__(self, class_id: str, bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth, direction: ?Identityref=None, rate_limit: ?float, latency: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency=None, jitter: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_id = class_id
        _default_direction, error = complete_and_validate_identityref(Identityref.from_adata('both'), _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
        if _default_direction is not None:
            self.direction = direction if direction is not None else _default_direction
        else:
            raise ValueError('Invalid default value for identityref leaf class: {error}')
        self.rate_limit = rate_limit
        self.latency = latency if latency is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency()
        self.jitter = jitter if jitter is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter()
        self.bandwidth = bandwidth

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_id = self.class_id
        if _class_id is not None:
            children['class-id'] = yang.gdata.Leaf('string', _class_id)
        _direction = self.direction
        if _direction is not None:
            _identityref_direction, error = complete_and_validate_identityref(_direction, _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
            if _identityref_direction is not None:
                _direction = _identityref_direction
            else:
                raise ValueError('Invalid value for identityref leaf direction: {error}')
            children['direction'] = yang.gdata.Leaf('identityref', _direction)
        _rate_limit = self.rate_limit
        if _rate_limit is not None:
            children['rate-limit'] = yang.gdata.Leaf('decimal64', _rate_limit)
        _latency = self.latency
        if _latency is not None:
            children['latency'] = _latency.to_gdata()
        _jitter = self.jitter
        if _jitter is not None:
            children['jitter'] = _jitter.to_gdata()
        _bandwidth = self.bandwidth
        if _bandwidth is not None:
            children['bandwidth'] = _bandwidth.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(class_id=n.get_str('class-id'), direction=n.get_opt_Identityref('direction'), rate_limit=n.get_opt_float('rate-limit'), latency=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency.from_gdata(n.get_opt_cnt('latency')), jitter=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter.from_gdata(n.get_opt_cnt('jitter')), bandwidth=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth.from_gdata(n.get_cnt('bandwidth')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class')
            res.append('self_bandwidth = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth({repr(self.bandwidth.guaranteed_bw_percent)})')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class({repr(self.class_id)}, self_bandwidth)')
        leaves = []
        _direction = self.direction
        if _direction is not None:
            leaves.append('{self_name}.direction = {repr(_direction)}')
        _rate_limit = self.rate_limit
        if _rate_limit is not None:
            leaves.append('{self_name}.rate_limit = {repr(_rate_limit)}')
        _latency = self.latency
        if _latency is not None:
            res.extend(_latency.prsrc('{self_name}.latency', False).splitlines())
        _jitter = self.jitter
        if _jitter is not None:
            res.extend(_jitter.prsrc('{self_name}.jitter', False).splitlines())
        _bandwidth = self.bandwidth
        if _bandwidth is not None:
            res.extend(_bandwidth.prsrc('{self_name}.bandwidth', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-profile', 'classes', 'class'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'class'
        self.elements = elements

    mut def create(self, class_id, bandwidth):
        for e in self:
            match = True
            if e.class_id != class_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(class_id, bandwidth)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['class-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_class_id = yang.gdata.from_xml_str(node, 'class-id')
    yang.gdata.maybe_add(children, 'class-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__class_id, child_class_id)
    child_direction = yang.gdata.from_xml_opt_Identityref(node, 'direction')
    yang.gdata.maybe_add(children, 'direction', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__direction, child_direction)
    child_rate_limit = yang.gdata.from_xml_opt_float(node, 'rate-limit')
    yang.gdata.maybe_add(children, 'rate-limit', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__rate_limit, child_rate_limit)
    child_latency = yang.gdata.from_xml_opt_cnt(node, 'latency')
    yang.gdata.maybe_add(children, 'latency', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency, child_latency)
    child_jitter = yang.gdata.from_xml_opt_cnt(node, 'jitter')
    yang.gdata.maybe_add(children, 'jitter', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter, child_jitter)
    child_bandwidth = yang.gdata.from_xml_cnt(node, 'bandwidth')
    yang.gdata.maybe_add(children, 'bandwidth', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth, child_bandwidth)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(e) for e in nodes]
    return yang.gdata.List(keys=['class-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['class-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['class-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__class_id(keys[0])
        if point == 'direction':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'rate-limit':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency':
            children['latency'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(jd, rest_path, op)
        if point == 'jitter':
            children['jitter'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(jd, rest_path, op)
        if point == 'bandwidth':
            children['bandwidth'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['class-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['class-id'])))
        return yang.gdata.List(['class-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['class-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_class_id = yang.gdata.take_json_str(jd, 'class-id')
    yang.gdata.maybe_add(children, 'class-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__class_id, child_class_id)
    child_direction = yang.gdata.take_json_opt_Identityref(jd, 'direction')
    yang.gdata.maybe_add(children, 'direction', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__direction, child_direction)
    child_rate_limit = yang.gdata.take_json_opt_float(jd, 'rate-limit')
    yang.gdata.maybe_add(children, 'rate-limit', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__rate_limit, child_rate_limit)
    child_latency = yang.gdata.take_json_opt_cnt(jd, 'latency')
    yang.gdata.maybe_add(children, 'latency', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency, child_latency)
    child_jitter = yang.gdata.take_json_opt_cnt(jd, 'jitter')
    yang.gdata.maybe_add(children, 'jitter', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter, child_jitter)
    child_bandwidth = yang.gdata.take_json_cnt(jd, 'bandwidth')
    yang.gdata.maybe_add(children, 'bandwidth', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth, child_bandwidth)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['class-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(yang.adata.MNode):
    class_: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class

    mut def __init__(self, class_: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_ = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(elements=class_)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_ = self.class_
        if _class_ is not None:
            children['class'] = _class_.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(class_=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class.from_gdata(n.get_opt_list('class')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-profile/classes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes()')
        leaves = []
        _class_ = self.class_
        for _element in _class_:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class element: {_element.to_gdata().key_str(['class-id'])}")
            res.append('element_bandwidth = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth({repr(_element.bandwidth.guaranteed_bw_percent)})')
            list_elem = 'class__element = {self_name}.class_.create({repr(_element.class_id)}, element_bandwidth)'
            res.append(list_elem)
            res.extend(_element.prsrc('class__element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-profile/classes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-profile', 'classes'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_class_ = yang.gdata.from_xml_opt_list(node, 'class')
    yang.gdata.maybe_add(children, 'class', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class, child_class_)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'class':
            child = {'class': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_class_ = yang.gdata.take_json_opt_list(jd, 'class')
    yang.gdata.maybe_add(children, 'class', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class, child_class_)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(yang.adata.MNode):
    profile: ?str
    classes: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes

    mut def __init__(self, profile: ?str, classes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile = profile
        self.classes = classes if classes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile = self.profile
        if _profile is not None:
            children['profile'] = yang.gdata.Leaf('leafref', _profile)
        _classes = self.classes
        if _classes is not None:
            children['classes'] = _classes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(profile=n.get_opt_str('profile'), classes=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes.from_gdata(n.get_opt_cnt('classes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-profile')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile()')
        leaves = []
        _profile = self.profile
        if _profile is not None:
            leaves.append('{self_name}.profile = {repr(_profile)}')
        _classes = self.classes
        if _classes is not None:
            res.extend(_classes.prsrc('{self_name}.classes', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-profile'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-profile'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_profile = yang.gdata.from_xml_opt_str(node, 'profile')
    yang.gdata.maybe_add(children, 'profile', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__profile, child_profile)
    child_classes = yang.gdata.from_xml_opt_cnt(node, 'classes')
    yang.gdata.maybe_add(children, 'classes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes, child_classes)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'profile':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'classes':
            child = {'classes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile = yang.gdata.take_json_opt_str(jd, 'profile')
    yang.gdata.maybe_add(children, 'profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__profile, child_profile)
    child_classes = yang.gdata.take_json_opt_cnt(jd, 'classes')
    yang.gdata.maybe_add(children, 'classes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes, child_classes)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(yang.adata.MNode):
    qos_classification_policy: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy
    qos_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile

    mut def __init__(self, qos_classification_policy: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy=None, qos_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.qos_classification_policy = qos_classification_policy if qos_classification_policy is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy()
        self.qos_profile = qos_profile if qos_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _qos_classification_policy = self.qos_classification_policy
        if _qos_classification_policy is not None:
            children['qos-classification-policy'] = _qos_classification_policy.to_gdata()
        _qos_profile = self.qos_profile
        if _qos_profile is not None:
            children['qos-profile'] = _qos_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(qos_classification_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy.from_gdata(n.get_opt_cnt('qos-classification-policy')), qos_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile.from_gdata(n.get_opt_cnt('qos-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos()')
        leaves = []
        _qos_classification_policy = self.qos_classification_policy
        if _qos_classification_policy is not None:
            res.extend(_qos_classification_policy.prsrc('{self_name}.qos_classification_policy', False).splitlines())
        _qos_profile = self.qos_profile
        if _qos_profile is not None:
            res.extend(_qos_profile.prsrc('{self_name}.qos_profile', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_qos_classification_policy = yang.gdata.from_xml_opt_cnt(node, 'qos-classification-policy')
    yang.gdata.maybe_add(children, 'qos-classification-policy', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy, child_qos_classification_policy)
    child_qos_profile = yang.gdata.from_xml_opt_cnt(node, 'qos-profile')
    yang.gdata.maybe_add(children, 'qos-profile', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile, child_qos_profile)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'qos-classification-policy':
            child = {'qos-classification-policy': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'qos-profile':
            child = {'qos-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_qos_classification_policy = yang.gdata.take_json_opt_cnt(jd, 'qos-classification-policy')
    yang.gdata.maybe_add(children, 'qos-classification-policy', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy, child_qos_classification_policy)
    child_qos_profile = yang.gdata.take_json_opt_cnt(jd, 'qos-profile')
    yang.gdata.maybe_add(children, 'qos-profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile, child_qos_profile)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier__signalling_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier__signalling_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(yang.adata.MNode):
    signalling_type: str

    mut def __init__(self, signalling_type: ?str=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.signalling_type = signalling_type if signalling_type is not None else "bgp"

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _signalling_type = self.signalling_type
        if _signalling_type is not None:
            children['signalling-type'] = yang.gdata.Leaf('enumeration', _signalling_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(signalling_type=n.get_opt_str('signalling-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/carrierscarrier')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier()')
        leaves = []
        _signalling_type = self.signalling_type
        if _signalling_type is not None:
            leaves.append('{self_name}.signalling_type = {repr(_signalling_type)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/carrierscarrier'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'carrierscarrier'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_signalling_type = yang.gdata.from_xml_opt_str(node, 'signalling-type')
    yang.gdata.maybe_add(children, 'signalling-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier__signalling_type, child_signalling_type)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'signalling-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_signalling_type = yang.gdata.take_json_opt_str(jd, 'signalling-type')
    yang.gdata.maybe_add(children, 'signalling-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier__signalling_type, child_signalling_type)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_site_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_site_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv4(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv4(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv6(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv6(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(yang.adata.MNode):
    ipv4: bool
    ipv6: bool

    mut def __init__(self, ipv4: ?bool=None, ipv6: ?bool=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4 = ipv4 if ipv4 is not None else False
        self.ipv6 = ipv6 if ipv6 is not None else False

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            children['ipv4'] = yang.gdata.Leaf('boolean', _ipv4)
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            children['ipv6'] = yang.gdata.Leaf('boolean', _ipv6)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(ipv4=n.get_opt_bool('ipv4'), ipv6=n.get_opt_bool('ipv6'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/multicast/multicast-address-family')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family()')
        leaves = []
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            leaves.append('{self_name}.ipv4 = {repr(_ipv4)}')
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            leaves.append('{self_name}.ipv6 = {repr(_ipv6)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/multicast/multicast-address-family'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'multicast', 'multicast-address-family'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.from_xml_opt_bool(node, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.from_xml_opt_bool(node, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv6, child_ipv6)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'ipv4':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.take_json_opt_bool(jd, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.take_json_opt_bool(jd, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv6, child_ipv6)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__protocol_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__protocol_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(yang.adata.MNode):
    multicast_site_type: str
    multicast_address_family: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family
    protocol_type: str

    mut def __init__(self, multicast_site_type: ?str=None, multicast_address_family: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family=None, protocol_type: ?str=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.multicast_site_type = multicast_site_type if multicast_site_type is not None else "source-receiver"
        self.multicast_address_family = multicast_address_family if multicast_address_family is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family()
        self.protocol_type = protocol_type if protocol_type is not None else "both"

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _multicast_site_type = self.multicast_site_type
        if _multicast_site_type is not None:
            children['multicast-site-type'] = yang.gdata.Leaf('enumeration', _multicast_site_type)
        _multicast_address_family = self.multicast_address_family
        if _multicast_address_family is not None:
            children['multicast-address-family'] = _multicast_address_family.to_gdata()
        _protocol_type = self.protocol_type
        if _protocol_type is not None:
            children['protocol-type'] = yang.gdata.Leaf('enumeration', _protocol_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(multicast_site_type=n.get_opt_str('multicast-site-type'), multicast_address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family.from_gdata(n.get_opt_cnt('multicast-address-family')), protocol_type=n.get_opt_str('protocol-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/multicast')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast()')
        leaves = []
        _multicast_site_type = self.multicast_site_type
        if _multicast_site_type is not None:
            leaves.append('{self_name}.multicast_site_type = {repr(_multicast_site_type)}')
        _multicast_address_family = self.multicast_address_family
        if _multicast_address_family is not None:
            res.extend(_multicast_address_family.prsrc('{self_name}.multicast_address_family', False).splitlines())
        _protocol_type = self.protocol_type
        if _protocol_type is not None:
            leaves.append('{self_name}.protocol_type = {repr(_protocol_type)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/multicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'multicast'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_multicast_site_type = yang.gdata.from_xml_opt_str(node, 'multicast-site-type')
    yang.gdata.maybe_add(children, 'multicast-site-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_site_type, child_multicast_site_type)
    child_multicast_address_family = yang.gdata.from_xml_opt_cnt(node, 'multicast-address-family')
    yang.gdata.maybe_add(children, 'multicast-address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family, child_multicast_address_family)
    child_protocol_type = yang.gdata.from_xml_opt_str(node, 'protocol-type')
    yang.gdata.maybe_add(children, 'protocol-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__protocol_type, child_protocol_type)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'multicast-site-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'multicast-address-family':
            child = {'multicast-address-family': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'protocol-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_multicast_site_type = yang.gdata.take_json_opt_str(jd, 'multicast-site-type')
    yang.gdata.maybe_add(children, 'multicast-site-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_site_type, child_multicast_site_type)
    child_multicast_address_family = yang.gdata.take_json_opt_cnt(jd, 'multicast-address-family')
    yang.gdata.maybe_add(children, 'multicast-address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family, child_multicast_address_family)
    child_protocol_type = yang.gdata.take_json_opt_str(jd, 'protocol-type')
    yang.gdata.maybe_add(children, 'protocol-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__protocol_type, child_protocol_type)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service(yang.adata.MNode):
    qos: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos
    carrierscarrier: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier
    multicast: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast

    mut def __init__(self, qos: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos=None, carrierscarrier: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier=None, multicast: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.qos = qos if qos is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos()
        self.carrierscarrier = carrierscarrier if carrierscarrier is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier()
        self.multicast = multicast if multicast is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _qos = self.qos
        if _qos is not None:
            children['qos'] = _qos.to_gdata()
        _carrierscarrier = self.carrierscarrier
        if _carrierscarrier is not None:
            children['carrierscarrier'] = _carrierscarrier.to_gdata()
        _multicast = self.multicast
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service(qos=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos.from_gdata(n.get_opt_cnt('qos')), carrierscarrier=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier.from_gdata(n.get_opt_cnt('carrierscarrier')), multicast=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast.from_gdata(n.get_opt_cnt('multicast')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service()')
        leaves = []
        _qos = self.qos
        if _qos is not None:
            res.extend(_qos.prsrc('{self_name}.qos', False).splitlines())
        _carrierscarrier = self.carrierscarrier
        if _carrierscarrier is not None:
            res.extend(_carrierscarrier.prsrc('{self_name}.carrierscarrier', False).splitlines())
        _multicast = self.multicast
        if _multicast is not None:
            res.extend(_multicast.prsrc('{self_name}.multicast', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_qos = yang.gdata.from_xml_opt_cnt(node, 'qos')
    yang.gdata.maybe_add(children, 'qos', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos, child_qos)
    child_carrierscarrier = yang.gdata.from_xml_opt_cnt(node, 'carrierscarrier')
    yang.gdata.maybe_add(children, 'carrierscarrier', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier, child_carrierscarrier)
    child_multicast = yang.gdata.from_xml_opt_cnt(node, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast, child_multicast)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'qos':
            child = {'qos': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'carrierscarrier':
            child = {'carrierscarrier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'multicast':
            child = {'multicast': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_qos = yang.gdata.take_json_opt_cnt(jd, 'qos')
    yang.gdata.maybe_add(children, 'qos', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos, child_qos)
    child_carrierscarrier = yang.gdata.take_json_opt_cnt(jd, 'carrierscarrier')
    yang.gdata.maybe_add(children, 'carrierscarrier', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier, child_carrierscarrier)
    child_multicast = yang.gdata.take_json_opt_cnt(jd, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast, child_multicast)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(yang.adata.MNode):
    enabled: bool

    mut def __init__(self, enabled: ?bool=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(enabled=n.get_opt_bool('enabled'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/traffic-protection')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection()')
        leaves = []
        _enabled = self.enabled
        if _enabled is not None:
            leaves.append('{self_name}.enabled = {repr(_enabled)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/traffic-protection'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'traffic-protection'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.from_xml_opt_bool(node, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection__enabled, child_enabled)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection__enabled, child_enabled)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:routing-protocol-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:routing-protocol-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__area_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__area_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(yang.adata.MNode):
    target_site: str
    metric: int

    mut def __init__(self, target_site: str, metric: ?int=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.target_site = target_site
        self.metric = metric if metric is not None else 1

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _target_site = self.target_site
        if _target_site is not None:
            children['target-site'] = yang.gdata.Leaf('string', _target_site)
        _metric = self.metric
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site=n.get_str('target-site'), metric=n.get_opt_int('metric'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf/sham-links/sham-link')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link({repr(self.target_site)})')
        leaves = []
        _metric = self.metric
        if _metric is not None:
            leaves.append('{self_name}.metric = {repr(_metric)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf/sham-links/sham-link'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'ospf', 'sham-links', 'sham-link'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'sham-link'
        self.elements = elements

    mut def create(self, target_site):
        for e in self:
            match = True
            if e.target_site != target_site:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['target-site'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_target_site = yang.gdata.from_xml_str(node, 'target-site')
    yang.gdata.maybe_add(children, 'target-site', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site, child_target_site)
    child_metric = yang.gdata.from_xml_opt_int(node, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric, child_metric)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(e) for e in nodes]
    return yang.gdata.List(keys=['target-site'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['target-site']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['target-site'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(keys[0])
        if point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['target-site']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['target-site'])))
        return yang.gdata.List(['target-site'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['target-site'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_target_site = yang.gdata.take_json_str(jd, 'target-site')
    yang.gdata.maybe_add(children, 'target-site', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site, child_target_site)
    child_metric = yang.gdata.take_json_opt_int(jd, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric, child_metric)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['target-site'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(yang.adata.MNode):
    sham_link: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link

    mut def __init__(self, sham_link: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.sham_link = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(elements=sham_link)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _sham_link = self.sham_link
        if _sham_link is not None:
            children['sham-link'] = _sham_link.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(sham_link=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link.from_gdata(n.get_opt_list('sham-link')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf/sham-links')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links()')
        leaves = []
        _sham_link = self.sham_link
        for _element in _sham_link:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf/sham-links/sham-link element: {_element.to_gdata().key_str(['target-site'])}")
            list_elem = 'sham_link_element = {self_name}.sham_link.create({repr(_element.target_site)})'
            res.append(list_elem)
            res.extend(_element.prsrc('sham_link_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf/sham-links'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'ospf', 'sham-links'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_sham_link = yang.gdata.from_xml_opt_list(node, 'sham-link')
    yang.gdata.maybe_add(children, 'sham-link', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link, child_sham_link)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'sham-link':
            child = {'sham-link': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_sham_link = yang.gdata.take_json_opt_list(jd, 'sham-link')
    yang.gdata.maybe_add(children, 'sham-link', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link, child_sham_link)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(yang.adata.MNode):
    address_family: list[str]
    area_address: str
    metric: int
    sham_links: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links

    mut def __init__(self, area_address: str, address_family: ?list[str]=None, metric: ?int=None, sham_links: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []
        self.area_address = area_address
        self.metric = metric if metric is not None else 1
        self.sham_links = sham_links if sham_links is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        _area_address = self.area_address
        if _area_address is not None:
            children['area-address'] = yang.gdata.Leaf('string', _area_address)
        _metric = self.metric
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        _sham_links = self.sham_links
        if _sham_links is not None:
            children['sham-links'] = _sham_links.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(address_family=n.get_strs('address-family'), area_address=n.get_str('area-address'), metric=n.get_opt_int('metric'), sham_links=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links.from_gdata(n.get_opt_cnt('sham-links')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf({repr(self.area_address)})')
        leaves = []
        _metric = self.metric
        if _metric is not None:
            leaves.append('{self_name}.metric = {repr(_metric)}')
        _sham_links = self.sham_links
        if _sham_links is not None:
            res.extend(_sham_links.prsrc('{self_name}.sham_links', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'ospf'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__address_family, child_address_family)
    child_area_address = yang.gdata.from_xml_str(node, 'area-address')
    yang.gdata.maybe_add(children, 'area-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__area_address, child_area_address)
    child_metric = yang.gdata.from_xml_opt_int(node, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__metric, child_metric)
    child_sham_links = yang.gdata.from_xml_opt_cnt(node, 'sham-links')
    yang.gdata.maybe_add(children, 'sham-links', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links, child_sham_links)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'area-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'sham-links':
            child = {'sham-links': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__address_family, child_address_family)
    child_area_address = yang.gdata.take_json_str(jd, 'area-address')
    yang.gdata.maybe_add(children, 'area-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__area_address, child_area_address)
    child_metric = yang.gdata.take_json_opt_int(jd, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__metric, child_metric)
    child_sham_links = yang.gdata.take_json_opt_cnt(jd, 'sham-links')
    yang.gdata.maybe_add(children, 'sham-links', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links, child_sham_links)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__autonomous_system(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__autonomous_system(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(yang.adata.MNode):
    autonomous_system: int
    address_family: list[str]

    mut def __init__(self, autonomous_system: int, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.autonomous_system = autonomous_system
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _autonomous_system = self.autonomous_system
        if _autonomous_system is not None:
            children['autonomous-system'] = yang.gdata.Leaf('uint32', _autonomous_system)
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(autonomous_system=n.get_int('autonomous-system'), address_family=n.get_strs('address-family'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/bgp')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp({repr(self.autonomous_system)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/bgp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'bgp'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_autonomous_system = yang.gdata.from_xml_int(node, 'autonomous-system')
    yang.gdata.maybe_add(children, 'autonomous-system', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__autonomous_system, child_autonomous_system)
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'autonomous-system':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_autonomous_system = yang.gdata.take_json_int(jd, 'autonomous-system')
    yang.gdata.maybe_add(children, 'autonomous-system', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__autonomous_system, child_autonomous_system)
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        _next_hop = self.next_hop
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv4-lan-prefixes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes({repr(self.lan)}, {repr(self.next_hop)})')
        leaves = []
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            leaves.append('{self_name}.lan_tag = {repr(_lan_tag)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv4-lan-prefixes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'static', 'cascaded-lan-prefixes', 'ipv4-lan-prefixes'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv4-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.from_xml_str(node, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.from_xml_str(node, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.from_xml_opt_str(node, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(e) for e in nodes]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['lan', 'next-hop']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(keys[0])
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(keys[1])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['lan', 'next-hop'])))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.take_json_str(jd, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.take_json_str(jd, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.take_json_opt_str(jd, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        _next_hop = self.next_hop
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv6-lan-prefixes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes({repr(self.lan)}, {repr(self.next_hop)})')
        leaves = []
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            leaves.append('{self_name}.lan_tag = {repr(_lan_tag)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv6-lan-prefixes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'static', 'cascaded-lan-prefixes', 'ipv6-lan-prefixes'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv6-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.from_xml_str(node, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.from_xml_str(node, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.from_xml_opt_str(node, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(e) for e in nodes]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['lan', 'next-hop']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(keys[0])
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(keys[1])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['lan', 'next-hop'])))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.take_json_str(jd, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.take_json_str(jd, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.take_json_opt_str(jd, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.adata.MNode):
    ipv4_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes
    ipv6_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes

    mut def __init__(self, ipv4_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]=[], ipv6_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(elements=ipv4_lan_prefixes)
        self.ipv6_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(elements=ipv6_lan_prefixes)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4_lan_prefixes = self.ipv4_lan_prefixes
        if _ipv4_lan_prefixes is not None:
            children['ipv4-lan-prefixes'] = _ipv4_lan_prefixes.to_gdata()
        _ipv6_lan_prefixes = self.ipv6_lan_prefixes
        if _ipv6_lan_prefixes is not None:
            children['ipv6-lan-prefixes'] = _ipv6_lan_prefixes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(ipv4_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes.from_gdata(n.get_opt_list('ipv4-lan-prefixes')), ipv6_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes.from_gdata(n.get_opt_list('ipv6-lan-prefixes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()')
        leaves = []
        _ipv4_lan_prefixes = self.ipv4_lan_prefixes
        for _element in _ipv4_lan_prefixes:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv4-lan-prefixes element: {_element.to_gdata().key_str(['lan', 'next-hop'])}")
            list_elem = 'ipv4_lan_prefixes_element = {self_name}.ipv4_lan_prefixes.create({repr(_element.lan)}, {repr(_element.next_hop)})'
            res.append(list_elem)
            res.extend(_element.prsrc('ipv4_lan_prefixes_element', False, list_element=True).splitlines())
        _ipv6_lan_prefixes = self.ipv6_lan_prefixes
        for _element in _ipv6_lan_prefixes:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv6-lan-prefixes element: {_element.to_gdata().key_str(['lan', 'next-hop'])}")
            list_elem = 'ipv6_lan_prefixes_element = {self_name}.ipv6_lan_prefixes.create({repr(_element.lan)}, {repr(_element.next_hop)})'
            res.append(list_elem)
            res.extend(_element.prsrc('ipv6_lan_prefixes_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'static', 'cascaded-lan-prefixes'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4_lan_prefixes = yang.gdata.from_xml_opt_list(node, 'ipv4-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv4-lan-prefixes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes, child_ipv4_lan_prefixes)
    child_ipv6_lan_prefixes = yang.gdata.from_xml_opt_list(node, 'ipv6-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv6-lan-prefixes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes, child_ipv6_lan_prefixes)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'ipv4-lan-prefixes':
            child = {'ipv4-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'ipv6-lan-prefixes':
            child = {'ipv6-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4_lan_prefixes = yang.gdata.take_json_opt_list(jd, 'ipv4-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv4-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes, child_ipv4_lan_prefixes)
    child_ipv6_lan_prefixes = yang.gdata.take_json_opt_list(jd, 'ipv6-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv6-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes, child_ipv6_lan_prefixes)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(yang.adata.MNode):
    cascaded_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes

    mut def __init__(self, cascaded_lan_prefixes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cascaded_lan_prefixes = cascaded_lan_prefixes if cascaded_lan_prefixes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cascaded_lan_prefixes = self.cascaded_lan_prefixes
        if _cascaded_lan_prefixes is not None:
            children['cascaded-lan-prefixes'] = _cascaded_lan_prefixes.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(cascaded_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_gdata(n.get_opt_cnt('cascaded-lan-prefixes')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static()')
        leaves = []
        _cascaded_lan_prefixes = self.cascaded_lan_prefixes
        if _cascaded_lan_prefixes is not None:
            res.extend(_cascaded_lan_prefixes.prsrc('{self_name}.cascaded_lan_prefixes', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'static'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_cascaded_lan_prefixes = yang.gdata.from_xml_opt_cnt(node, 'cascaded-lan-prefixes')
    yang.gdata.maybe_add(children, 'cascaded-lan-prefixes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes, child_cascaded_lan_prefixes)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'cascaded-lan-prefixes':
            child = {'cascaded-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cascaded_lan_prefixes = yang.gdata.take_json_opt_cnt(jd, 'cascaded-lan-prefixes')
    yang.gdata.maybe_add(children, 'cascaded-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes, child_cascaded_lan_prefixes)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(address_family=n.get_strs('address-family'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/rip')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/rip'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'rip'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(address_family=n.get_strs('address-family'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/vrrp')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/vrrp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'vrrp'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(yang.adata.MNode):
    type: Identityref
    ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf
    bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp
    static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static
    rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip
    vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp

    mut def __init__(self, type: Identityref, ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf=None, bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp=None, static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static=None, rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip=None, vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type
        self.ospf = ospf
        self.bgp = bgp
        self.static = static
        self.rip = rip
        self.vrrp = vrrp

    mut def create_ospf(self, area_address):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(area_address)
        self.ospf = res
        return res

    mut def create_bgp(self, autonomous_system):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(autonomous_system)
        self.bgp = res
        return res

    mut def create_static(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static()
        self.static = res
        return res

    mut def create_rip(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip()
        self.rip = res
        return res

    mut def create_vrrp(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp()
        self.vrrp = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        if _type is not None:
            _identityref_type, error = complete_and_validate_identityref(_type, _identities, ['l3vpn-svc:routing-protocol-type'], 'ietf-l3vpn-svc')
            if _identityref_type is not None:
                _type = _identityref_type
            else:
                raise ValueError('Invalid value for identityref leaf type: {error}')
            children['type'] = yang.gdata.Leaf('identityref', _type)
        _ospf = self.ospf
        if _ospf is not None:
            children['ospf'] = _ospf.to_gdata()
        _bgp = self.bgp
        if _bgp is not None:
            children['bgp'] = _bgp.to_gdata()
        _static = self.static
        if _static is not None:
            children['static'] = _static.to_gdata()
        _rip = self.rip
        if _rip is not None:
            children['rip'] = _rip.to_gdata()
        _vrrp = self.vrrp
        if _vrrp is not None:
            children['vrrp'] = _vrrp.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(type=n.get_Identityref('type'), ospf=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf.from_gdata(n.get_opt_cnt('ospf')), bgp=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp.from_gdata(n.get_opt_cnt('bgp')), static=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static.from_gdata(n.get_opt_cnt('static')), rip=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip.from_gdata(n.get_opt_cnt('rip')), vrrp=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp.from_gdata(n.get_opt_cnt('vrrp')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol({repr(self.type)})')
        leaves = []
        _ospf = self.ospf
        if _ospf is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf')
            res.append('ospf = {self_name}.create_ospf({repr(_ospf.area_address)})')
            res.extend(_ospf.prsrc('ospf', False).splitlines())
        _bgp = self.bgp
        if _bgp is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/bgp')
            res.append('bgp = {self_name}.create_bgp({repr(_bgp.autonomous_system)})')
            res.extend(_bgp.prsrc('bgp', False).splitlines())
        _static = self.static
        if _static is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static')
            res.append('static = {self_name}.create_static()')
            res.extend(_static.prsrc('static', False).splitlines())
        _rip = self.rip
        if _rip is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/rip')
            res.append('rip = {self_name}.create_rip()')
            res.extend(_rip.prsrc('rip', False).splitlines())
        _vrrp = self.vrrp
        if _vrrp is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/vrrp')
            res.append('vrrp = {self_name}.create_vrrp()')
            res.extend(_vrrp.prsrc('vrrp', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'routing-protocol'
        self.elements = elements

    mut def create(self, type):
        for e in self:
            match = True
            if e.type != type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['type'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_type = yang.gdata.from_xml_Identityref(node, 'type')
    yang.gdata.maybe_add(children, 'type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__type, child_type)
    child_ospf = yang.gdata.from_xml_opt_cnt(node, 'ospf')
    yang.gdata.maybe_add(children, 'ospf', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf, child_ospf)
    child_bgp = yang.gdata.from_xml_opt_cnt(node, 'bgp')
    yang.gdata.maybe_add(children, 'bgp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp, child_bgp)
    child_static = yang.gdata.from_xml_opt_cnt(node, 'static')
    yang.gdata.maybe_add(children, 'static', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static, child_static)
    child_rip = yang.gdata.from_xml_opt_cnt(node, 'rip')
    yang.gdata.maybe_add(children, 'rip', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip, child_rip)
    child_vrrp = yang.gdata.from_xml_opt_cnt(node, 'vrrp')
    yang.gdata.maybe_add(children, 'vrrp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp, child_vrrp)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(e) for e in nodes]
    return yang.gdata.List(keys=['type'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['type']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__type(Identityref.from_json(keys[0]))
        if point == 'ospf':
            children['ospf'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(jd, rest_path, op)
        if point == 'bgp':
            children['bgp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(jd, rest_path, op)
        if point == 'static':
            children['static'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(jd, rest_path, op)
        if point == 'rip':
            children['rip'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(jd, rest_path, op)
        if point == 'vrrp':
            children['vrrp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['type'])))
        return yang.gdata.List(['type'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_type = yang.gdata.take_json_Identityref(jd, 'type')
    yang.gdata.maybe_add(children, 'type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__type, child_type)
    child_ospf = yang.gdata.take_json_opt_cnt(jd, 'ospf')
    yang.gdata.maybe_add(children, 'ospf', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf, child_ospf)
    child_bgp = yang.gdata.take_json_opt_cnt(jd, 'bgp')
    yang.gdata.maybe_add(children, 'bgp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp, child_bgp)
    child_static = yang.gdata.take_json_opt_cnt(jd, 'static')
    yang.gdata.maybe_add(children, 'static', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static, child_static)
    child_rip = yang.gdata.take_json_opt_cnt(jd, 'rip')
    yang.gdata.maybe_add(children, 'rip', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip, child_rip)
    child_vrrp = yang.gdata.take_json_opt_cnt(jd, 'vrrp')
    yang.gdata.maybe_add(children, 'vrrp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp, child_vrrp)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['type'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(yang.adata.MNode):
    routing_protocol: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol

    mut def __init__(self, routing_protocol: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.routing_protocol = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(elements=routing_protocol)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _routing_protocol = self.routing_protocol
        if _routing_protocol is not None:
            children['routing-protocol'] = _routing_protocol.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(routing_protocol=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol.from_gdata(n.get_opt_list('routing-protocol')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols()')
        leaves = []
        _routing_protocol = self.routing_protocol
        for _element in _routing_protocol:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/routing-protocols/routing-protocol element: {_element.to_gdata().key_str(['type'])}")
            list_elem = 'routing_protocol_element = {self_name}.routing_protocol.create({repr(_element.type)})'
            res.append(list_elem)
            res.extend(_element.prsrc('routing_protocol_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_routing_protocol = yang.gdata.from_xml_opt_list(node, 'routing-protocol')
    yang.gdata.maybe_add(children, 'routing-protocol', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol, child_routing_protocol)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'routing-protocol':
            child = {'routing-protocol': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_routing_protocol = yang.gdata.take_json_opt_list(jd, 'routing-protocol')
    yang.gdata.maybe_add(children, 'routing-protocol', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol, child_routing_protocol)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-network-access-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-network-access-type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-network-access-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-network-access-type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__location_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__location_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__device_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__device_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(yang.adata.MNode):
    group_id: str

    mut def __init__(self, group_id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(group_id=n.get_str('group-id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/groups/group')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group({repr(self.group_id)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/groups/group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'access-diversity', 'groups', 'group'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.from_xml_str(node, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group__group_id, child_group_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(e) for e in nodes]
    return yang.gdata.List(keys=['group-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['group-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group__group_id(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['group-id'])))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.take_json_str(jd, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group__group_id, child_group_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['group-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(elements=group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group.from_gdata(n.get_opt_list('group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/groups')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups()')
        leaves = []
        _group = self.group
        for _element in _group:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/groups/group element: {_element.to_gdata().key_str(['group-id'])}")
            list_elem = 'group_element = {self_name}.group.create({repr(_element.group_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('group_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/groups'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'access-diversity', 'groups'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.from_xml_opt_list(node, 'group')
    yang.gdata.maybe_add(children, 'group', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group, child_group)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.take_json_opt_list(jd, 'group')
    yang.gdata.maybe_add(children, 'group', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group, child_group)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__constraint_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:placement-diversity'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf constraint-type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__constraint_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:placement-diversity'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf constraint-type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(yang.adata.MNode):
    group_id: str

    mut def __init__(self, group_id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(group_id=n.get_str('group-id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint/target/group')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group({repr(self.group_id)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint/target/group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'access-diversity', 'constraints', 'constraint', 'target', 'group'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.from_xml_str(node, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group__group_id, child_group_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(e) for e in nodes]
    return yang.gdata.List(keys=['group-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['group-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group__group_id(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['group-id'])))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.take_json_str(jd, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group__group_id, child_group_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['group-id'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_accesses(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_accesses(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_groups(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_groups(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group
    all_other_accesses: ?bool
    all_other_groups: ?bool

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]=[], all_other_accesses: ?bool, all_other_groups: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(elements=group)
        self.all_other_accesses = all_other_accesses
        self.all_other_groups = all_other_groups

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        _all_other_accesses = self.all_other_accesses
        if _all_other_accesses is not None:
            children['all-other-accesses'] = yang.gdata.Leaf('empty', _all_other_accesses)
        _all_other_groups = self.all_other_groups
        if _all_other_groups is not None:
            children['all-other-groups'] = yang.gdata.Leaf('empty', _all_other_groups)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group.from_gdata(n.get_opt_list('group')), all_other_accesses=n.get_opt_empty('all-other-accesses'), all_other_groups=n.get_opt_empty('all-other-groups'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint/target')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target()')
        leaves = []
        _group = self.group
        for _element in _group:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint/target/group element: {_element.to_gdata().key_str(['group-id'])}")
            list_elem = 'group_element = {self_name}.group.create({repr(_element.group_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('group_element', False, list_element=True).splitlines())
        _all_other_accesses = self.all_other_accesses
        if _all_other_accesses is not None:
            leaves.append('{self_name}.all_other_accesses = {repr(_all_other_accesses)}')
        _all_other_groups = self.all_other_groups
        if _all_other_groups is not None:
            leaves.append('{self_name}.all_other_groups = {repr(_all_other_groups)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint/target'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'access-diversity', 'constraints', 'constraint', 'target'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.from_xml_opt_list(node, 'group')
    yang.gdata.maybe_add(children, 'group', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group, child_group)
    child_all_other_accesses = yang.gdata.from_xml_opt_empty(node, 'all-other-accesses')
    yang.gdata.maybe_add(children, 'all-other-accesses', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_accesses, child_all_other_accesses)
    child_all_other_groups = yang.gdata.from_xml_opt_empty(node, 'all-other-groups')
    yang.gdata.maybe_add(children, 'all-other-groups', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_groups, child_all_other_groups)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'all-other-accesses':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'all-other-groups':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.take_json_opt_list(jd, 'group')
    yang.gdata.maybe_add(children, 'group', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group, child_group)
    child_all_other_accesses = yang.gdata.take_json_opt_empty(jd, 'all-other-accesses')
    yang.gdata.maybe_add(children, 'all-other-accesses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_accesses, child_all_other_accesses)
    child_all_other_groups = yang.gdata.take_json_opt_empty(jd, 'all-other-groups')
    yang.gdata.maybe_add(children, 'all-other-groups', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_groups, child_all_other_groups)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(yang.adata.MNode):
    constraint_type: Identityref
    target: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target

    mut def __init__(self, constraint_type: Identityref, target: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.constraint_type = constraint_type
        self.target = target if target is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _constraint_type = self.constraint_type
        if _constraint_type is not None:
            _identityref_constraint_type, error = complete_and_validate_identityref(_constraint_type, _identities, ['l3vpn-svc:placement-diversity'], 'ietf-l3vpn-svc')
            if _identityref_constraint_type is not None:
                _constraint_type = _identityref_constraint_type
            else:
                raise ValueError('Invalid value for identityref leaf constraint-type: {error}')
            children['constraint-type'] = yang.gdata.Leaf('identityref', _constraint_type)
        _target = self.target
        if _target is not None:
            children['target'] = _target.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(constraint_type=n.get_Identityref('constraint-type'), target=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target.from_gdata(n.get_opt_cnt('target')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint({repr(self.constraint_type)})')
        leaves = []
        _target = self.target
        if _target is not None:
            res.extend(_target.prsrc('{self_name}.target', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'access-diversity', 'constraints', 'constraint'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'constraint'
        self.elements = elements

    mut def create(self, constraint_type):
        for e in self:
            match = True
            if e.constraint_type != constraint_type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(constraint_type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['constraint-type'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_constraint_type = yang.gdata.from_xml_Identityref(node, 'constraint-type')
    yang.gdata.maybe_add(children, 'constraint-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__constraint_type, child_constraint_type)
    child_target = yang.gdata.from_xml_opt_cnt(node, 'target')
    yang.gdata.maybe_add(children, 'target', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target, child_target)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(e) for e in nodes]
    return yang.gdata.List(keys=['constraint-type'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['constraint-type']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['constraint-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__constraint_type(Identityref.from_json(keys[0]))
        if point == 'target':
            children['target'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['constraint-type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['constraint-type'])))
        return yang.gdata.List(['constraint-type'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['constraint-type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_constraint_type = yang.gdata.take_json_Identityref(jd, 'constraint-type')
    yang.gdata.maybe_add(children, 'constraint-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__constraint_type, child_constraint_type)
    child_target = yang.gdata.take_json_opt_cnt(jd, 'target')
    yang.gdata.maybe_add(children, 'target', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target, child_target)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['constraint-type'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(yang.adata.MNode):
    constraint: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint

    mut def __init__(self, constraint: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.constraint = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(elements=constraint)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _constraint = self.constraint
        if _constraint is not None:
            children['constraint'] = _constraint.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(constraint=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint.from_gdata(n.get_opt_list('constraint')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints()')
        leaves = []
        _constraint = self.constraint
        for _element in _constraint:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint element: {_element.to_gdata().key_str(['constraint-type'])}")
            list_elem = 'constraint_element = {self_name}.constraint.create({repr(_element.constraint_type)})'
            res.append(list_elem)
            res.extend(_element.prsrc('constraint_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'access-diversity', 'constraints'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_constraint = yang.gdata.from_xml_opt_list(node, 'constraint')
    yang.gdata.maybe_add(children, 'constraint', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint, child_constraint)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'constraint':
            child = {'constraint': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_constraint = yang.gdata.take_json_opt_list(jd, 'constraint')
    yang.gdata.maybe_add(children, 'constraint', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint, child_constraint)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(yang.adata.MNode):
    groups: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups
    constraints: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints

    mut def __init__(self, groups: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups=None, constraints: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.groups = groups if groups is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups()
        self.constraints = constraints if constraints is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _groups = self.groups
        if _groups is not None:
            children['groups'] = _groups.to_gdata()
        _constraints = self.constraints
        if _constraints is not None:
            children['constraints'] = _constraints.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(groups=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups.from_gdata(n.get_opt_cnt('groups')), constraints=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints.from_gdata(n.get_opt_cnt('constraints')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity()')
        leaves = []
        _groups = self.groups
        if _groups is not None:
            res.extend(_groups.prsrc('{self_name}.groups', False).splitlines())
        _constraints = self.constraints
        if _constraints is not None:
            res.extend(_constraints.prsrc('{self_name}.constraints', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'access-diversity'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_groups = yang.gdata.from_xml_opt_cnt(node, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups, child_groups)
    child_constraints = yang.gdata.from_xml_opt_cnt(node, 'constraints')
    yang.gdata.maybe_add(children, 'constraints', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints, child_constraints)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'groups':
            child = {'groups': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'constraints':
            child = {'constraints': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_groups = yang.gdata.take_json_opt_cnt(jd, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups, child_groups)
    child_constraints = yang.gdata.take_json_opt_cnt(jd, 'constraints')
    yang.gdata.maybe_add(children, 'constraints', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints, child_constraints)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__requested_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__requested_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__strict(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__strict(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(yang.adata.MNode):
    requested_type: ?str
    strict: bool

    mut def __init__(self, requested_type: ?str, strict: ?bool=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.requested_type = requested_type
        self.strict = strict if strict is not None else False

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _requested_type = self.requested_type
        if _requested_type is not None:
            children['requested-type'] = yang.gdata.Leaf('string', _requested_type)
        _strict = self.strict
        if _strict is not None:
            children['strict'] = yang.gdata.Leaf('boolean', _strict)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(requested_type=n.get_opt_str('requested-type'), strict=n.get_opt_bool('strict'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/bearer/requested-type')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type()')
        leaves = []
        _requested_type = self.requested_type
        if _requested_type is not None:
            leaves.append('{self_name}.requested_type = {repr(_requested_type)}')
        _strict = self.strict
        if _strict is not None:
            leaves.append('{self_name}.strict = {repr(_strict)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/bearer/requested-type'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'bearer', 'requested-type'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_requested_type = yang.gdata.from_xml_opt_str(node, 'requested-type')
    yang.gdata.maybe_add(children, 'requested-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__requested_type, child_requested_type)
    child_strict = yang.gdata.from_xml_opt_bool(node, 'strict')
    yang.gdata.maybe_add(children, 'strict', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__strict, child_strict)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'requested-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'strict':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_requested_type = yang.gdata.take_json_opt_str(jd, 'requested-type')
    yang.gdata.maybe_add(children, 'requested-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__requested_type, child_requested_type)
    child_strict = yang.gdata.take_json_opt_bool(jd, 'strict')
    yang.gdata.maybe_add(children, 'strict', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__strict, child_strict)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__always_on(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__always_on(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__bearer_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__bearer_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(yang.adata.MNode):
    requested_type: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type
    always_on: bool
    bearer_reference: ?str

    mut def __init__(self, requested_type: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type=None, always_on: ?bool=None, bearer_reference: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.requested_type = requested_type if requested_type is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type()
        self.always_on = always_on if always_on is not None else True
        self.bearer_reference = bearer_reference

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _requested_type = self.requested_type
        if _requested_type is not None:
            children['requested-type'] = _requested_type.to_gdata()
        _always_on = self.always_on
        if _always_on is not None:
            children['always-on'] = yang.gdata.Leaf('boolean', _always_on)
        _bearer_reference = self.bearer_reference
        if _bearer_reference is not None:
            children['bearer-reference'] = yang.gdata.Leaf('string', _bearer_reference)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(requested_type=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type.from_gdata(n.get_opt_cnt('requested-type')), always_on=n.get_opt_bool('always-on'), bearer_reference=n.get_opt_str('bearer-reference'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/bearer')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer()')
        leaves = []
        _requested_type = self.requested_type
        if _requested_type is not None:
            res.extend(_requested_type.prsrc('{self_name}.requested_type', False).splitlines())
        _always_on = self.always_on
        if _always_on is not None:
            leaves.append('{self_name}.always_on = {repr(_always_on)}')
        _bearer_reference = self.bearer_reference
        if _bearer_reference is not None:
            leaves.append('{self_name}.bearer_reference = {repr(_bearer_reference)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/bearer'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'bearer'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_requested_type = yang.gdata.from_xml_opt_cnt(node, 'requested-type')
    yang.gdata.maybe_add(children, 'requested-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type, child_requested_type)
    child_always_on = yang.gdata.from_xml_opt_bool(node, 'always-on')
    yang.gdata.maybe_add(children, 'always-on', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__always_on, child_always_on)
    child_bearer_reference = yang.gdata.from_xml_opt_str(node, 'bearer-reference')
    yang.gdata.maybe_add(children, 'bearer-reference', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__bearer_reference, child_bearer_reference)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'requested-type':
            child = {'requested-type': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'always-on':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bearer-reference':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_requested_type = yang.gdata.take_json_opt_cnt(jd, 'requested-type')
    yang.gdata.maybe_add(children, 'requested-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type, child_requested_type)
    child_always_on = yang.gdata.take_json_opt_bool(jd, 'always-on')
    yang.gdata.maybe_add(children, 'always-on', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__always_on, child_always_on)
    child_bearer_reference = yang.gdata.take_json_opt_str(jd, 'bearer-reference')
    yang.gdata.maybe_add(children, 'bearer-reference', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__bearer_reference, child_bearer_reference)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__address_allocation_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:address-allocation-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf address-allocation-type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__address_allocation_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:address-allocation-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf address-allocation-type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__number_of_dynamic_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__number_of_dynamic_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__start_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__start_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__end_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__end_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(yang.adata.MNode):
    group_id: str
    start_address: ?str
    end_address: ?str

    mut def __init__(self, group_id: str, start_address: ?str, end_address: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id
        self.start_address = start_address
        self.end_address = end_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        _start_address = self.start_address
        if _start_address is not None:
            children['start-address'] = yang.gdata.Leaf('string', _start_address)
        _end_address = self.end_address
        if _end_address is not None:
            children['end-address'] = yang.gdata.Leaf('string', _end_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(group_id=n.get_str('group-id'), start_address=n.get_opt_str('start-address'), end_address=n.get_opt_str('end-address'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/provider-dhcp/customer-addresses/address-group')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group({repr(self.group_id)})')
        leaves = []
        _start_address = self.start_address
        if _start_address is not None:
            leaves.append('{self_name}.start_address = {repr(_start_address)}')
        _end_address = self.end_address
        if _end_address is not None:
            leaves.append('{self_name}.end_address = {repr(_end_address)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/provider-dhcp/customer-addresses/address-group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv4', 'provider-dhcp', 'customer-addresses', 'address-group'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'address-group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.from_xml_str(node, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__group_id, child_group_id)
    child_start_address = yang.gdata.from_xml_opt_str(node, 'start-address')
    yang.gdata.maybe_add(children, 'start-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__start_address, child_start_address)
    child_end_address = yang.gdata.from_xml_opt_str(node, 'end-address')
    yang.gdata.maybe_add(children, 'end-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__end_address, child_end_address)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(e) for e in nodes]
    return yang.gdata.List(keys=['group-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['group-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__group_id(keys[0])
        if point == 'start-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'end-address':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['group-id'])))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.take_json_str(jd, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__group_id, child_group_id)
    child_start_address = yang.gdata.take_json_opt_str(jd, 'start-address')
    yang.gdata.maybe_add(children, 'start-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__start_address, child_start_address)
    child_end_address = yang.gdata.take_json_opt_str(jd, 'end-address')
    yang.gdata.maybe_add(children, 'end-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__end_address, child_end_address)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['group-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(yang.adata.MNode):
    address_group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group

    mut def __init__(self, address_group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(elements=address_group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_group = self.address_group
        if _address_group is not None:
            children['address-group'] = _address_group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(address_group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group.from_gdata(n.get_opt_list('address-group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/provider-dhcp/customer-addresses')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses()')
        leaves = []
        _address_group = self.address_group
        for _element in _address_group:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/provider-dhcp/customer-addresses/address-group element: {_element.to_gdata().key_str(['group-id'])}")
            list_elem = 'address_group_element = {self_name}.address_group.create({repr(_element.group_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('address_group_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/provider-dhcp/customer-addresses'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv4', 'provider-dhcp', 'customer-addresses'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_group = yang.gdata.from_xml_opt_list(node, 'address-group')
    yang.gdata.maybe_add(children, 'address-group', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group, child_address_group)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-group':
            child = {'address-group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_group = yang.gdata.take_json_opt_list(jd, 'address-group')
    yang.gdata.maybe_add(children, 'address-group', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group, child_address_group)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    number_of_dynamic_address: int
    customer_addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, number_of_dynamic_address: ?int=None, customer_addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.number_of_dynamic_address = number_of_dynamic_address if number_of_dynamic_address is not None else 1
        self.customer_addresses = customer_addresses if customer_addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        _number_of_dynamic_address = self.number_of_dynamic_address
        if _number_of_dynamic_address is not None:
            children['number-of-dynamic-address'] = yang.gdata.Leaf('uint16', _number_of_dynamic_address)
        _customer_addresses = self.customer_addresses
        if _customer_addresses is not None:
            children['customer-addresses'] = _customer_addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_int('prefix-length'), number_of_dynamic_address=n.get_opt_int('number-of-dynamic-address'), customer_addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses.from_gdata(n.get_opt_cnt('customer-addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/provider-dhcp')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp()')
        leaves = []
        _provider_address = self.provider_address
        if _provider_address is not None:
            leaves.append('{self_name}.provider_address = {repr(_provider_address)}')
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            leaves.append('{self_name}.prefix_length = {repr(_prefix_length)}')
        _number_of_dynamic_address = self.number_of_dynamic_address
        if _number_of_dynamic_address is not None:
            leaves.append('{self_name}.number_of_dynamic_address = {repr(_number_of_dynamic_address)}')
        _customer_addresses = self.customer_addresses
        if _customer_addresses is not None:
            res.extend(_customer_addresses.prsrc('{self_name}.customer_addresses', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/provider-dhcp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv4', 'provider-dhcp'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.from_xml_opt_str(node, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.from_xml_opt_int(node, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__prefix_length, child_prefix_length)
    child_number_of_dynamic_address = yang.gdata.from_xml_opt_int(node, 'number-of-dynamic-address')
    yang.gdata.maybe_add(children, 'number-of-dynamic-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__number_of_dynamic_address, child_number_of_dynamic_address)
    child_customer_addresses = yang.gdata.from_xml_opt_cnt(node, 'customer-addresses')
    yang.gdata.maybe_add(children, 'customer-addresses', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses, child_customer_addresses)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'number-of-dynamic-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-addresses':
            child = {'customer-addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__prefix_length, child_prefix_length)
    child_number_of_dynamic_address = yang.gdata.take_json_opt_int(jd, 'number-of-dynamic-address')
    yang.gdata.maybe_add(children, 'number-of-dynamic-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__number_of_dynamic_address, child_number_of_dynamic_address)
    child_customer_addresses = yang.gdata.take_json_opt_cnt(jd, 'customer-addresses')
    yang.gdata.maybe_add(children, 'customer-addresses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses, child_customer_addresses)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers__server_ip_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers__server_ip_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(yang.adata.MNode):
    server_ip_address: list[str]

    mut def __init__(self, server_ip_address: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.server_ip_address = server_ip_address if server_ip_address is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _server_ip_address = self.server_ip_address
        if _server_ip_address is not None:
            children['server-ip-address'] = yang.gdata.LeafList('string', _server_ip_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(server_ip_address=n.get_opt_strs('server-ip-address'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/dhcp-relay/customer-dhcp-servers')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers()')
        leaves = []
        _server_ip_address = self.server_ip_address
        if len(_server_ip_address) != 0:
            leaves.append('{self_name}.server_ip_address = {repr(_server_ip_address)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/dhcp-relay/customer-dhcp-servers'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv4', 'dhcp-relay', 'customer-dhcp-servers'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_server_ip_address = yang.gdata.from_xml_opt_strs(node, 'server-ip-address')
    yang.gdata.maybe_add(children, 'server-ip-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers__server_ip_address, child_server_ip_address)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'server-ip-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_server_ip_address = yang.gdata.take_json_opt_strs(jd, 'server-ip-address')
    yang.gdata.maybe_add(children, 'server-ip-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers__server_ip_address, child_server_ip_address)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    customer_dhcp_servers: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, customer_dhcp_servers: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.customer_dhcp_servers = customer_dhcp_servers if customer_dhcp_servers is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        _customer_dhcp_servers = self.customer_dhcp_servers
        if _customer_dhcp_servers is not None:
            children['customer-dhcp-servers'] = _customer_dhcp_servers.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_int('prefix-length'), customer_dhcp_servers=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers.from_gdata(n.get_opt_cnt('customer-dhcp-servers')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/dhcp-relay')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay()')
        leaves = []
        _provider_address = self.provider_address
        if _provider_address is not None:
            leaves.append('{self_name}.provider_address = {repr(_provider_address)}')
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            leaves.append('{self_name}.prefix_length = {repr(_prefix_length)}')
        _customer_dhcp_servers = self.customer_dhcp_servers
        if _customer_dhcp_servers is not None:
            res.extend(_customer_dhcp_servers.prsrc('{self_name}.customer_dhcp_servers', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/dhcp-relay'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv4', 'dhcp-relay'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.from_xml_opt_str(node, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.from_xml_opt_int(node, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__prefix_length, child_prefix_length)
    child_customer_dhcp_servers = yang.gdata.from_xml_opt_cnt(node, 'customer-dhcp-servers')
    yang.gdata.maybe_add(children, 'customer-dhcp-servers', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers, child_customer_dhcp_servers)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-dhcp-servers':
            child = {'customer-dhcp-servers': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__prefix_length, child_prefix_length)
    child_customer_dhcp_servers = yang.gdata.take_json_opt_cnt(jd, 'customer-dhcp-servers')
    yang.gdata.maybe_add(children, 'customer-dhcp-servers', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers, child_customer_dhcp_servers)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(yang.adata.MNode):
    provider_address: ?str
    customer_address: ?str
    prefix_length: ?int

    mut def __init__(self, provider_address: ?str, customer_address: ?str, prefix_length: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.customer_address = customer_address
        self.prefix_length = prefix_length

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _customer_address = self.customer_address
        if _customer_address is not None:
            children['customer-address'] = yang.gdata.Leaf('string', _customer_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(provider_address=n.get_opt_str('provider-address'), customer_address=n.get_opt_str('customer-address'), prefix_length=n.get_opt_int('prefix-length'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/addresses')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses()')
        leaves = []
        _provider_address = self.provider_address
        if _provider_address is not None:
            leaves.append('{self_name}.provider_address = {repr(_provider_address)}')
        _customer_address = self.customer_address
        if _customer_address is not None:
            leaves.append('{self_name}.customer_address = {repr(_customer_address)}')
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            leaves.append('{self_name}.prefix_length = {repr(_prefix_length)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/addresses'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv4', 'addresses'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.from_xml_opt_str(node, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__provider_address, child_provider_address)
    child_customer_address = yang.gdata.from_xml_opt_str(node, 'customer-address')
    yang.gdata.maybe_add(children, 'customer-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__customer_address, child_customer_address)
    child_prefix_length = yang.gdata.from_xml_opt_int(node, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__prefix_length, child_prefix_length)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__provider_address, child_provider_address)
    child_customer_address = yang.gdata.take_json_opt_str(jd, 'customer-address')
    yang.gdata.maybe_add(children, 'customer-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__customer_address, child_customer_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__prefix_length, child_prefix_length)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(yang.adata.MNode):
    address_allocation_type: ?Identityref
    provider_dhcp: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp
    dhcp_relay: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay
    addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses

    mut def __init__(self, address_allocation_type: ?Identityref, provider_dhcp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp=None, dhcp_relay: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay=None, addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_allocation_type = address_allocation_type
        self.provider_dhcp = provider_dhcp if provider_dhcp is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp()
        self.dhcp_relay = dhcp_relay if dhcp_relay is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay()
        self.addresses = addresses if addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_allocation_type = self.address_allocation_type
        if _address_allocation_type is not None:
            _identityref_address_allocation_type, error = complete_and_validate_identityref(_address_allocation_type, _identities, ['l3vpn-svc:address-allocation-type'], 'ietf-l3vpn-svc')
            if _identityref_address_allocation_type is not None:
                _address_allocation_type = _identityref_address_allocation_type
            else:
                raise ValueError('Invalid value for identityref leaf address-allocation-type: {error}')
            children['address-allocation-type'] = yang.gdata.Leaf('identityref', _address_allocation_type)
        _provider_dhcp = self.provider_dhcp
        if _provider_dhcp is not None:
            children['provider-dhcp'] = _provider_dhcp.to_gdata()
        _dhcp_relay = self.dhcp_relay
        if _dhcp_relay is not None:
            children['dhcp-relay'] = _dhcp_relay.to_gdata()
        _addresses = self.addresses
        if _addresses is not None:
            children['addresses'] = _addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(address_allocation_type=n.get_opt_Identityref('address-allocation-type'), provider_dhcp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp.from_gdata(n.get_opt_cnt('provider-dhcp')), dhcp_relay=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay.from_gdata(n.get_opt_cnt('dhcp-relay')), addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses.from_gdata(n.get_opt_cnt('addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4()')
        leaves = []
        _address_allocation_type = self.address_allocation_type
        if _address_allocation_type is not None:
            leaves.append('{self_name}.address_allocation_type = {repr(_address_allocation_type)}')
        _provider_dhcp = self.provider_dhcp
        if _provider_dhcp is not None:
            res.extend(_provider_dhcp.prsrc('{self_name}.provider_dhcp', False).splitlines())
        _dhcp_relay = self.dhcp_relay
        if _dhcp_relay is not None:
            res.extend(_dhcp_relay.prsrc('{self_name}.dhcp_relay', False).splitlines())
        _addresses = self.addresses
        if _addresses is not None:
            res.extend(_addresses.prsrc('{self_name}.addresses', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv4'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_allocation_type = yang.gdata.from_xml_opt_Identityref(node, 'address-allocation-type')
    yang.gdata.maybe_add(children, 'address-allocation-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__address_allocation_type, child_address_allocation_type)
    child_provider_dhcp = yang.gdata.from_xml_opt_cnt(node, 'provider-dhcp')
    yang.gdata.maybe_add(children, 'provider-dhcp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp, child_provider_dhcp)
    child_dhcp_relay = yang.gdata.from_xml_opt_cnt(node, 'dhcp-relay')
    yang.gdata.maybe_add(children, 'dhcp-relay', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay, child_dhcp_relay)
    child_addresses = yang.gdata.from_xml_opt_cnt(node, 'addresses')
    yang.gdata.maybe_add(children, 'addresses', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses, child_addresses)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-allocation-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'provider-dhcp':
            child = {'provider-dhcp': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'dhcp-relay':
            child = {'dhcp-relay': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'addresses':
            child = {'addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_allocation_type = yang.gdata.take_json_opt_Identityref(jd, 'address-allocation-type')
    yang.gdata.maybe_add(children, 'address-allocation-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__address_allocation_type, child_address_allocation_type)
    child_provider_dhcp = yang.gdata.take_json_opt_cnt(jd, 'provider-dhcp')
    yang.gdata.maybe_add(children, 'provider-dhcp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp, child_provider_dhcp)
    child_dhcp_relay = yang.gdata.take_json_opt_cnt(jd, 'dhcp-relay')
    yang.gdata.maybe_add(children, 'dhcp-relay', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay, child_dhcp_relay)
    child_addresses = yang.gdata.take_json_opt_cnt(jd, 'addresses')
    yang.gdata.maybe_add(children, 'addresses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses, child_addresses)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__address_allocation_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:address-allocation-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf address-allocation-type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__address_allocation_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:address-allocation-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf address-allocation-type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__number_of_dynamic_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__number_of_dynamic_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__start_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__start_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__end_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__end_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(yang.adata.MNode):
    group_id: str
    start_address: ?str
    end_address: ?str

    mut def __init__(self, group_id: str, start_address: ?str, end_address: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id
        self.start_address = start_address
        self.end_address = end_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        _start_address = self.start_address
        if _start_address is not None:
            children['start-address'] = yang.gdata.Leaf('string', _start_address)
        _end_address = self.end_address
        if _end_address is not None:
            children['end-address'] = yang.gdata.Leaf('string', _end_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(group_id=n.get_str('group-id'), start_address=n.get_opt_str('start-address'), end_address=n.get_opt_str('end-address'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/provider-dhcp/customer-addresses/address-group')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group({repr(self.group_id)})')
        leaves = []
        _start_address = self.start_address
        if _start_address is not None:
            leaves.append('{self_name}.start_address = {repr(_start_address)}')
        _end_address = self.end_address
        if _end_address is not None:
            leaves.append('{self_name}.end_address = {repr(_end_address)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/provider-dhcp/customer-addresses/address-group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv6', 'provider-dhcp', 'customer-addresses', 'address-group'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'address-group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.from_xml_str(node, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__group_id, child_group_id)
    child_start_address = yang.gdata.from_xml_opt_str(node, 'start-address')
    yang.gdata.maybe_add(children, 'start-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__start_address, child_start_address)
    child_end_address = yang.gdata.from_xml_opt_str(node, 'end-address')
    yang.gdata.maybe_add(children, 'end-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__end_address, child_end_address)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(e) for e in nodes]
    return yang.gdata.List(keys=['group-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['group-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__group_id(keys[0])
        if point == 'start-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'end-address':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['group-id'])))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.take_json_str(jd, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__group_id, child_group_id)
    child_start_address = yang.gdata.take_json_opt_str(jd, 'start-address')
    yang.gdata.maybe_add(children, 'start-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__start_address, child_start_address)
    child_end_address = yang.gdata.take_json_opt_str(jd, 'end-address')
    yang.gdata.maybe_add(children, 'end-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__end_address, child_end_address)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['group-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(yang.adata.MNode):
    address_group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group

    mut def __init__(self, address_group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(elements=address_group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_group = self.address_group
        if _address_group is not None:
            children['address-group'] = _address_group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(address_group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group.from_gdata(n.get_opt_list('address-group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/provider-dhcp/customer-addresses')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses()')
        leaves = []
        _address_group = self.address_group
        for _element in _address_group:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/provider-dhcp/customer-addresses/address-group element: {_element.to_gdata().key_str(['group-id'])}")
            list_elem = 'address_group_element = {self_name}.address_group.create({repr(_element.group_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('address_group_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/provider-dhcp/customer-addresses'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv6', 'provider-dhcp', 'customer-addresses'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_group = yang.gdata.from_xml_opt_list(node, 'address-group')
    yang.gdata.maybe_add(children, 'address-group', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group, child_address_group)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-group':
            child = {'address-group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_group = yang.gdata.take_json_opt_list(jd, 'address-group')
    yang.gdata.maybe_add(children, 'address-group', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group, child_address_group)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    number_of_dynamic_address: int
    customer_addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, number_of_dynamic_address: ?int=None, customer_addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.number_of_dynamic_address = number_of_dynamic_address if number_of_dynamic_address is not None else 1
        self.customer_addresses = customer_addresses if customer_addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        _number_of_dynamic_address = self.number_of_dynamic_address
        if _number_of_dynamic_address is not None:
            children['number-of-dynamic-address'] = yang.gdata.Leaf('uint16', _number_of_dynamic_address)
        _customer_addresses = self.customer_addresses
        if _customer_addresses is not None:
            children['customer-addresses'] = _customer_addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_int('prefix-length'), number_of_dynamic_address=n.get_opt_int('number-of-dynamic-address'), customer_addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses.from_gdata(n.get_opt_cnt('customer-addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/provider-dhcp')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp()')
        leaves = []
        _provider_address = self.provider_address
        if _provider_address is not None:
            leaves.append('{self_name}.provider_address = {repr(_provider_address)}')
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            leaves.append('{self_name}.prefix_length = {repr(_prefix_length)}')
        _number_of_dynamic_address = self.number_of_dynamic_address
        if _number_of_dynamic_address is not None:
            leaves.append('{self_name}.number_of_dynamic_address = {repr(_number_of_dynamic_address)}')
        _customer_addresses = self.customer_addresses
        if _customer_addresses is not None:
            res.extend(_customer_addresses.prsrc('{self_name}.customer_addresses', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/provider-dhcp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv6', 'provider-dhcp'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.from_xml_opt_str(node, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.from_xml_opt_int(node, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__prefix_length, child_prefix_length)
    child_number_of_dynamic_address = yang.gdata.from_xml_opt_int(node, 'number-of-dynamic-address')
    yang.gdata.maybe_add(children, 'number-of-dynamic-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__number_of_dynamic_address, child_number_of_dynamic_address)
    child_customer_addresses = yang.gdata.from_xml_opt_cnt(node, 'customer-addresses')
    yang.gdata.maybe_add(children, 'customer-addresses', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses, child_customer_addresses)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'number-of-dynamic-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-addresses':
            child = {'customer-addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__prefix_length, child_prefix_length)
    child_number_of_dynamic_address = yang.gdata.take_json_opt_int(jd, 'number-of-dynamic-address')
    yang.gdata.maybe_add(children, 'number-of-dynamic-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__number_of_dynamic_address, child_number_of_dynamic_address)
    child_customer_addresses = yang.gdata.take_json_opt_cnt(jd, 'customer-addresses')
    yang.gdata.maybe_add(children, 'customer-addresses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses, child_customer_addresses)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers__server_ip_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers__server_ip_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(yang.adata.MNode):
    server_ip_address: list[str]

    mut def __init__(self, server_ip_address: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.server_ip_address = server_ip_address if server_ip_address is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _server_ip_address = self.server_ip_address
        if _server_ip_address is not None:
            children['server-ip-address'] = yang.gdata.LeafList('string', _server_ip_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(server_ip_address=n.get_opt_strs('server-ip-address'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/dhcp-relay/customer-dhcp-servers')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers()')
        leaves = []
        _server_ip_address = self.server_ip_address
        if len(_server_ip_address) != 0:
            leaves.append('{self_name}.server_ip_address = {repr(_server_ip_address)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/dhcp-relay/customer-dhcp-servers'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv6', 'dhcp-relay', 'customer-dhcp-servers'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_server_ip_address = yang.gdata.from_xml_opt_strs(node, 'server-ip-address')
    yang.gdata.maybe_add(children, 'server-ip-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers__server_ip_address, child_server_ip_address)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'server-ip-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_server_ip_address = yang.gdata.take_json_opt_strs(jd, 'server-ip-address')
    yang.gdata.maybe_add(children, 'server-ip-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers__server_ip_address, child_server_ip_address)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    customer_dhcp_servers: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, customer_dhcp_servers: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.customer_dhcp_servers = customer_dhcp_servers if customer_dhcp_servers is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        _customer_dhcp_servers = self.customer_dhcp_servers
        if _customer_dhcp_servers is not None:
            children['customer-dhcp-servers'] = _customer_dhcp_servers.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_int('prefix-length'), customer_dhcp_servers=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers.from_gdata(n.get_opt_cnt('customer-dhcp-servers')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/dhcp-relay')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay()')
        leaves = []
        _provider_address = self.provider_address
        if _provider_address is not None:
            leaves.append('{self_name}.provider_address = {repr(_provider_address)}')
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            leaves.append('{self_name}.prefix_length = {repr(_prefix_length)}')
        _customer_dhcp_servers = self.customer_dhcp_servers
        if _customer_dhcp_servers is not None:
            res.extend(_customer_dhcp_servers.prsrc('{self_name}.customer_dhcp_servers', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/dhcp-relay'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv6', 'dhcp-relay'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.from_xml_opt_str(node, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.from_xml_opt_int(node, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__prefix_length, child_prefix_length)
    child_customer_dhcp_servers = yang.gdata.from_xml_opt_cnt(node, 'customer-dhcp-servers')
    yang.gdata.maybe_add(children, 'customer-dhcp-servers', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers, child_customer_dhcp_servers)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-dhcp-servers':
            child = {'customer-dhcp-servers': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__prefix_length, child_prefix_length)
    child_customer_dhcp_servers = yang.gdata.take_json_opt_cnt(jd, 'customer-dhcp-servers')
    yang.gdata.maybe_add(children, 'customer-dhcp-servers', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers, child_customer_dhcp_servers)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(yang.adata.MNode):
    provider_address: ?str
    customer_address: ?str
    prefix_length: ?int

    mut def __init__(self, provider_address: ?str, customer_address: ?str, prefix_length: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.customer_address = customer_address
        self.prefix_length = prefix_length

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _customer_address = self.customer_address
        if _customer_address is not None:
            children['customer-address'] = yang.gdata.Leaf('string', _customer_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(provider_address=n.get_opt_str('provider-address'), customer_address=n.get_opt_str('customer-address'), prefix_length=n.get_opt_int('prefix-length'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/addresses')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses()')
        leaves = []
        _provider_address = self.provider_address
        if _provider_address is not None:
            leaves.append('{self_name}.provider_address = {repr(_provider_address)}')
        _customer_address = self.customer_address
        if _customer_address is not None:
            leaves.append('{self_name}.customer_address = {repr(_customer_address)}')
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            leaves.append('{self_name}.prefix_length = {repr(_prefix_length)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/addresses'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv6', 'addresses'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.from_xml_opt_str(node, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__provider_address, child_provider_address)
    child_customer_address = yang.gdata.from_xml_opt_str(node, 'customer-address')
    yang.gdata.maybe_add(children, 'customer-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__customer_address, child_customer_address)
    child_prefix_length = yang.gdata.from_xml_opt_int(node, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__prefix_length, child_prefix_length)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__provider_address, child_provider_address)
    child_customer_address = yang.gdata.take_json_opt_str(jd, 'customer-address')
    yang.gdata.maybe_add(children, 'customer-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__customer_address, child_customer_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__prefix_length, child_prefix_length)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(yang.adata.MNode):
    address_allocation_type: ?Identityref
    provider_dhcp: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp
    dhcp_relay: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay
    addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses

    mut def __init__(self, address_allocation_type: ?Identityref, provider_dhcp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp=None, dhcp_relay: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay=None, addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_allocation_type = address_allocation_type
        self.provider_dhcp = provider_dhcp if provider_dhcp is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp()
        self.dhcp_relay = dhcp_relay if dhcp_relay is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay()
        self.addresses = addresses if addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_allocation_type = self.address_allocation_type
        if _address_allocation_type is not None:
            _identityref_address_allocation_type, error = complete_and_validate_identityref(_address_allocation_type, _identities, ['l3vpn-svc:address-allocation-type'], 'ietf-l3vpn-svc')
            if _identityref_address_allocation_type is not None:
                _address_allocation_type = _identityref_address_allocation_type
            else:
                raise ValueError('Invalid value for identityref leaf address-allocation-type: {error}')
            children['address-allocation-type'] = yang.gdata.Leaf('identityref', _address_allocation_type)
        _provider_dhcp = self.provider_dhcp
        if _provider_dhcp is not None:
            children['provider-dhcp'] = _provider_dhcp.to_gdata()
        _dhcp_relay = self.dhcp_relay
        if _dhcp_relay is not None:
            children['dhcp-relay'] = _dhcp_relay.to_gdata()
        _addresses = self.addresses
        if _addresses is not None:
            children['addresses'] = _addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(address_allocation_type=n.get_opt_Identityref('address-allocation-type'), provider_dhcp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp.from_gdata(n.get_opt_cnt('provider-dhcp')), dhcp_relay=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay.from_gdata(n.get_opt_cnt('dhcp-relay')), addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses.from_gdata(n.get_opt_cnt('addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6()')
        leaves = []
        _address_allocation_type = self.address_allocation_type
        if _address_allocation_type is not None:
            leaves.append('{self_name}.address_allocation_type = {repr(_address_allocation_type)}')
        _provider_dhcp = self.provider_dhcp
        if _provider_dhcp is not None:
            res.extend(_provider_dhcp.prsrc('{self_name}.provider_dhcp', False).splitlines())
        _dhcp_relay = self.dhcp_relay
        if _dhcp_relay is not None:
            res.extend(_dhcp_relay.prsrc('{self_name}.dhcp_relay', False).splitlines())
        _addresses = self.addresses
        if _addresses is not None:
            res.extend(_addresses.prsrc('{self_name}.addresses', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv6'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_allocation_type = yang.gdata.from_xml_opt_Identityref(node, 'address-allocation-type')
    yang.gdata.maybe_add(children, 'address-allocation-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__address_allocation_type, child_address_allocation_type)
    child_provider_dhcp = yang.gdata.from_xml_opt_cnt(node, 'provider-dhcp')
    yang.gdata.maybe_add(children, 'provider-dhcp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp, child_provider_dhcp)
    child_dhcp_relay = yang.gdata.from_xml_opt_cnt(node, 'dhcp-relay')
    yang.gdata.maybe_add(children, 'dhcp-relay', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay, child_dhcp_relay)
    child_addresses = yang.gdata.from_xml_opt_cnt(node, 'addresses')
    yang.gdata.maybe_add(children, 'addresses', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses, child_addresses)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-allocation-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'provider-dhcp':
            child = {'provider-dhcp': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'dhcp-relay':
            child = {'dhcp-relay': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'addresses':
            child = {'addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_allocation_type = yang.gdata.take_json_opt_Identityref(jd, 'address-allocation-type')
    yang.gdata.maybe_add(children, 'address-allocation-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__address_allocation_type, child_address_allocation_type)
    child_provider_dhcp = yang.gdata.take_json_opt_cnt(jd, 'provider-dhcp')
    yang.gdata.maybe_add(children, 'provider-dhcp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp, child_provider_dhcp)
    child_dhcp_relay = yang.gdata.take_json_opt_cnt(jd, 'dhcp-relay')
    yang.gdata.maybe_add(children, 'dhcp-relay', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay, child_dhcp_relay)
    child_addresses = yang.gdata.take_json_opt_cnt(jd, 'addresses')
    yang.gdata.maybe_add(children, 'addresses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses, child_addresses)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__fixed_value(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__fixed_value(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(yang.adata.MNode):
    enabled: bool
    fixed_value: ?int
    profile_name: ?str

    mut def __init__(self, enabled: ?bool=None, fixed_value: ?int, profile_name: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.fixed_value = fixed_value
        self.profile_name = profile_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _fixed_value = self.fixed_value
        if _fixed_value is not None:
            children['fixed-value'] = yang.gdata.Leaf('uint32', _fixed_value)
        _profile_name = self.profile_name
        if _profile_name is not None:
            children['profile-name'] = yang.gdata.Leaf('leafref', _profile_name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(enabled=n.get_opt_bool('enabled'), fixed_value=n.get_opt_int('fixed-value'), profile_name=n.get_opt_str('profile-name'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/oam/bfd')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd()')
        leaves = []
        _enabled = self.enabled
        if _enabled is not None:
            leaves.append('{self_name}.enabled = {repr(_enabled)}')
        _fixed_value = self.fixed_value
        if _fixed_value is not None:
            leaves.append('{self_name}.fixed_value = {repr(_fixed_value)}')
        _profile_name = self.profile_name
        if _profile_name is not None:
            leaves.append('{self_name}.profile_name = {repr(_profile_name)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/oam/bfd'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'oam', 'bfd'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.from_xml_opt_bool(node, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__enabled, child_enabled)
    child_fixed_value = yang.gdata.from_xml_opt_int(node, 'fixed-value')
    yang.gdata.maybe_add(children, 'fixed-value', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__fixed_value, child_fixed_value)
    child_profile_name = yang.gdata.from_xml_opt_str(node, 'profile-name')
    yang.gdata.maybe_add(children, 'profile-name', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__profile_name, child_profile_name)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'fixed-value':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'profile-name':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__enabled, child_enabled)
    child_fixed_value = yang.gdata.take_json_opt_int(jd, 'fixed-value')
    yang.gdata.maybe_add(children, 'fixed-value', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__fixed_value, child_fixed_value)
    child_profile_name = yang.gdata.take_json_opt_str(jd, 'profile-name')
    yang.gdata.maybe_add(children, 'profile-name', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__profile_name, child_profile_name)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(yang.adata.MNode):
    bfd: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd

    mut def __init__(self, bfd: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.bfd = bfd if bfd is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _bfd = self.bfd
        if _bfd is not None:
            children['bfd'] = _bfd.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(bfd=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd.from_gdata(n.get_opt_cnt('bfd')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/oam')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam()')
        leaves = []
        _bfd = self.bfd
        if _bfd is not None:
            res.extend(_bfd.prsrc('{self_name}.bfd', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/oam'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'oam'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_bfd = yang.gdata.from_xml_opt_cnt(node, 'bfd')
    yang.gdata.maybe_add(children, 'bfd', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd, child_bfd)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'bfd':
            child = {'bfd': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_bfd = yang.gdata.take_json_opt_cnt(jd, 'bfd')
    yang.gdata.maybe_add(children, 'bfd', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd, child_bfd)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(yang.adata.MNode):
    ipv4: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4
    ipv6: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6
    oam: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam

    mut def __init__(self, ipv4: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4=None, ipv6: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6=None, oam: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4 = ipv4 if ipv4 is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4()
        self.ipv6 = ipv6 if ipv6 is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6()
        self.oam = oam if oam is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            children['ipv4'] = _ipv4.to_gdata()
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            children['ipv6'] = _ipv6.to_gdata()
        _oam = self.oam
        if _oam is not None:
            children['oam'] = _oam.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(ipv4=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4.from_gdata(n.get_opt_cnt('ipv4')), ipv6=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6.from_gdata(n.get_opt_cnt('ipv6')), oam=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam.from_gdata(n.get_opt_cnt('oam')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection()')
        leaves = []
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            res.extend(_ipv4.prsrc('{self_name}.ipv4', False).splitlines())
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            res.extend(_ipv6.prsrc('{self_name}.ipv6', False).splitlines())
        _oam = self.oam
        if _oam is not None:
            res.extend(_oam.prsrc('{self_name}.oam', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.from_xml_opt_cnt(node, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.from_xml_opt_cnt(node, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6, child_ipv6)
    child_oam = yang.gdata.from_xml_opt_cnt(node, 'oam')
    yang.gdata.maybe_add(children, 'oam', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam, child_oam)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'ipv4':
            child = {'ipv4': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'ipv6':
            child = {'ipv6': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'oam':
            child = {'oam': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.take_json_opt_cnt(jd, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.take_json_opt_cnt(jd, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6, child_ipv6)
    child_oam = yang.gdata.take_json_opt_cnt(jd, 'oam')
    yang.gdata.maybe_add(children, 'oam', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam, child_oam)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security/authentication')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security/authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'security', 'authentication'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__layer(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__layer(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__preshared_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__preshared_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(yang.adata.MNode):
    profile_name: ?str
    algorithm: ?str
    preshared_key: ?str

    mut def __init__(self, profile_name: ?str, algorithm: ?str, preshared_key: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile_name = profile_name
        self.algorithm = algorithm
        self.preshared_key = preshared_key

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile_name = self.profile_name
        if _profile_name is not None:
            children['profile-name'] = yang.gdata.Leaf('leafref', _profile_name)
        _algorithm = self.algorithm
        if _algorithm is not None:
            children['algorithm'] = yang.gdata.Leaf('string', _algorithm)
        _preshared_key = self.preshared_key
        if _preshared_key is not None:
            children['preshared-key'] = yang.gdata.Leaf('string', _preshared_key)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(profile_name=n.get_opt_str('profile-name'), algorithm=n.get_opt_str('algorithm'), preshared_key=n.get_opt_str('preshared-key'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security/encryption/encryption-profile')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile()')
        leaves = []
        _profile_name = self.profile_name
        if _profile_name is not None:
            leaves.append('{self_name}.profile_name = {repr(_profile_name)}')
        _algorithm = self.algorithm
        if _algorithm is not None:
            leaves.append('{self_name}.algorithm = {repr(_algorithm)}')
        _preshared_key = self.preshared_key
        if _preshared_key is not None:
            leaves.append('{self_name}.preshared_key = {repr(_preshared_key)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security/encryption/encryption-profile'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'security', 'encryption', 'encryption-profile'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_profile_name = yang.gdata.from_xml_opt_str(node, 'profile-name')
    yang.gdata.maybe_add(children, 'profile-name', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__profile_name, child_profile_name)
    child_algorithm = yang.gdata.from_xml_opt_str(node, 'algorithm')
    yang.gdata.maybe_add(children, 'algorithm', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__algorithm, child_algorithm)
    child_preshared_key = yang.gdata.from_xml_opt_str(node, 'preshared-key')
    yang.gdata.maybe_add(children, 'preshared-key', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__preshared_key, child_preshared_key)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'profile-name':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'algorithm':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'preshared-key':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile_name = yang.gdata.take_json_opt_str(jd, 'profile-name')
    yang.gdata.maybe_add(children, 'profile-name', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__profile_name, child_profile_name)
    child_algorithm = yang.gdata.take_json_opt_str(jd, 'algorithm')
    yang.gdata.maybe_add(children, 'algorithm', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__algorithm, child_algorithm)
    child_preshared_key = yang.gdata.take_json_opt_str(jd, 'preshared-key')
    yang.gdata.maybe_add(children, 'preshared-key', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__preshared_key, child_preshared_key)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(yang.adata.MNode):
    enabled: bool
    layer: ?str
    encryption_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile

    mut def __init__(self, enabled: ?bool=None, layer: ?str, encryption_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.layer = layer
        self.encryption_profile = encryption_profile if encryption_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _layer = self.layer
        if _layer is not None:
            children['layer'] = yang.gdata.Leaf('enumeration', _layer)
        _encryption_profile = self.encryption_profile
        if _encryption_profile is not None:
            children['encryption-profile'] = _encryption_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(enabled=n.get_opt_bool('enabled'), layer=n.get_opt_str('layer'), encryption_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile.from_gdata(n.get_opt_cnt('encryption-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security/encryption')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption()')
        leaves = []
        _enabled = self.enabled
        if _enabled is not None:
            leaves.append('{self_name}.enabled = {repr(_enabled)}')
        _layer = self.layer
        if _layer is not None:
            leaves.append('{self_name}.layer = {repr(_layer)}')
        _encryption_profile = self.encryption_profile
        if _encryption_profile is not None:
            res.extend(_encryption_profile.prsrc('{self_name}.encryption_profile', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security/encryption'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'security', 'encryption'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.from_xml_opt_bool(node, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__enabled, child_enabled)
    child_layer = yang.gdata.from_xml_opt_str(node, 'layer')
    yang.gdata.maybe_add(children, 'layer', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__layer, child_layer)
    child_encryption_profile = yang.gdata.from_xml_opt_cnt(node, 'encryption-profile')
    yang.gdata.maybe_add(children, 'encryption-profile', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile, child_encryption_profile)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'layer':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'encryption-profile':
            child = {'encryption-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__enabled, child_enabled)
    child_layer = yang.gdata.take_json_opt_str(jd, 'layer')
    yang.gdata.maybe_add(children, 'layer', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__layer, child_layer)
    child_encryption_profile = yang.gdata.take_json_opt_cnt(jd, 'encryption-profile')
    yang.gdata.maybe_add(children, 'encryption-profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile, child_encryption_profile)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(yang.adata.MNode):
    authentication: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication
    encryption: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption

    mut def __init__(self, authentication: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication=None, encryption: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.authentication = authentication if authentication is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()
        self.encryption = encryption if encryption is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _authentication = self.authentication
        if _authentication is not None:
            children['authentication'] = _authentication.to_gdata()
        _encryption = self.encryption
        if _encryption is not None:
            children['encryption'] = _encryption.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(authentication=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication.from_gdata(n.get_opt_cnt('authentication')), encryption=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption.from_gdata(n.get_opt_cnt('encryption')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security()')
        leaves = []
        _authentication = self.authentication
        if _authentication is not None:
            res.extend(_authentication.prsrc('{self_name}.authentication', False).splitlines())
        _encryption = self.encryption
        if _encryption is not None:
            res.extend(_encryption.prsrc('{self_name}.encryption', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'security'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_authentication = yang.gdata.from_xml_opt_cnt(node, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication, child_authentication)
    child_encryption = yang.gdata.from_xml_opt_cnt(node, 'encryption')
    yang.gdata.maybe_add(children, 'encryption', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption, child_encryption)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'authentication':
            child = {'authentication': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'encryption':
            child = {'encryption': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_authentication = yang.gdata.take_json_opt_cnt(jd, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication, child_authentication)
    child_encryption = yang.gdata.take_json_opt_cnt(jd, 'encryption')
    yang.gdata.maybe_add(children, 'encryption', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption, child_encryption)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_input_bandwidth(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint64', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_input_bandwidth(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_output_bandwidth(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint64', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_output_bandwidth(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_mtu(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_mtu(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dscp(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dscp(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dot1p(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dot1p(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__target_sites(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__target_sites(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        _upper_port = self.upper_port
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(lower_port=n.get_opt_int('lower-port'), upper_port=n.get_opt_int('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule/match-flow/l4-src-port-range')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()')
        leaves = []
        _lower_port = self.lower_port
        if _lower_port is not None:
            leaves.append('{self_name}.lower_port = {repr(_lower_port)}')
        _upper_port = self.upper_port
        if _upper_port is not None:
            leaves.append('{self_name}.upper_port = {repr(_upper_port)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule/match-flow/l4-src-port-range'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-classification-policy', 'rule', 'match-flow', 'l4-src-port-range'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.from_xml_opt_int(node, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.from_xml_opt_int(node, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.take_json_opt_int(jd, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.take_json_opt_int(jd, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        _upper_port = self.upper_port
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(lower_port=n.get_opt_int('lower-port'), upper_port=n.get_opt_int('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule/match-flow/l4-dst-port-range')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()')
        leaves = []
        _lower_port = self.lower_port
        if _lower_port is not None:
            leaves.append('{self_name}.lower_port = {repr(_lower_port)}')
        _upper_port = self.upper_port
        if _upper_port is not None:
            leaves.append('{self_name}.upper_port = {repr(_upper_port)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule/match-flow/l4-dst-port-range'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-classification-policy', 'rule', 'match-flow', 'l4-dst-port-range'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.from_xml_opt_int(node, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.from_xml_opt_int(node, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.take_json_opt_int(jd, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.take_json_opt_int(jd, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__protocol_field(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__protocol_field(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(yang.adata.MNode):
    dscp: ?int
    dot1p: ?int
    ipv4_src_prefix: ?str
    ipv6_src_prefix: ?str
    ipv4_dst_prefix: ?str
    ipv6_dst_prefix: ?str
    l4_src_port: ?int
    target_sites: list[str]
    l4_src_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range
    l4_dst_port: ?int
    l4_dst_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range
    protocol_field: ?value

    mut def __init__(self, dscp: ?int, dot1p: ?int, ipv4_src_prefix: ?str, ipv6_src_prefix: ?str, ipv4_dst_prefix: ?str, ipv6_dst_prefix: ?str, l4_src_port: ?int, target_sites: ?list[str]=None, l4_src_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range=None, l4_dst_port: ?int, l4_dst_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range=None, protocol_field: ?value):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.dscp = dscp
        self.dot1p = dot1p
        self.ipv4_src_prefix = ipv4_src_prefix
        self.ipv6_src_prefix = ipv6_src_prefix
        self.ipv4_dst_prefix = ipv4_dst_prefix
        self.ipv6_dst_prefix = ipv6_dst_prefix
        self.l4_src_port = l4_src_port
        self.target_sites = target_sites if target_sites is not None else []
        self.l4_src_port_range = l4_src_port_range if l4_src_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()
        self.l4_dst_port = l4_dst_port
        self.l4_dst_port_range = l4_dst_port_range if l4_dst_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()
        self.protocol_field = protocol_field

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _dscp = self.dscp
        if _dscp is not None:
            children['dscp'] = yang.gdata.Leaf('uint8', _dscp)
        _dot1p = self.dot1p
        if _dot1p is not None:
            children['dot1p'] = yang.gdata.Leaf('uint8', _dot1p)
        _ipv4_src_prefix = self.ipv4_src_prefix
        if _ipv4_src_prefix is not None:
            children['ipv4-src-prefix'] = yang.gdata.Leaf('string', _ipv4_src_prefix)
        _ipv6_src_prefix = self.ipv6_src_prefix
        if _ipv6_src_prefix is not None:
            children['ipv6-src-prefix'] = yang.gdata.Leaf('string', _ipv6_src_prefix)
        _ipv4_dst_prefix = self.ipv4_dst_prefix
        if _ipv4_dst_prefix is not None:
            children['ipv4-dst-prefix'] = yang.gdata.Leaf('string', _ipv4_dst_prefix)
        _ipv6_dst_prefix = self.ipv6_dst_prefix
        if _ipv6_dst_prefix is not None:
            children['ipv6-dst-prefix'] = yang.gdata.Leaf('string', _ipv6_dst_prefix)
        _l4_src_port = self.l4_src_port
        if _l4_src_port is not None:
            children['l4-src-port'] = yang.gdata.Leaf('uint16', _l4_src_port)
        _target_sites = self.target_sites
        if _target_sites is not None:
            children['target-sites'] = yang.gdata.LeafList('string', _target_sites)
        _l4_src_port_range = self.l4_src_port_range
        if _l4_src_port_range is not None:
            children['l4-src-port-range'] = _l4_src_port_range.to_gdata()
        _l4_dst_port = self.l4_dst_port
        if _l4_dst_port is not None:
            children['l4-dst-port'] = yang.gdata.Leaf('uint16', _l4_dst_port)
        _l4_dst_port_range = self.l4_dst_port_range
        if _l4_dst_port_range is not None:
            children['l4-dst-port-range'] = _l4_dst_port_range.to_gdata()
        _protocol_field = self.protocol_field
        if _protocol_field is not None:
            children['protocol-field'] = yang.gdata.Leaf('union', _protocol_field)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(dscp=n.get_opt_int('dscp'), dot1p=n.get_opt_int('dot1p'), ipv4_src_prefix=n.get_opt_str('ipv4-src-prefix'), ipv6_src_prefix=n.get_opt_str('ipv6-src-prefix'), ipv4_dst_prefix=n.get_opt_str('ipv4-dst-prefix'), ipv6_dst_prefix=n.get_opt_str('ipv6-dst-prefix'), l4_src_port=n.get_opt_int('l4-src-port'), target_sites=n.get_opt_strs('target-sites'), l4_src_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_gdata(n.get_opt_cnt('l4-src-port-range')), l4_dst_port=n.get_opt_int('l4-dst-port'), l4_dst_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_gdata(n.get_opt_cnt('l4-dst-port-range')), protocol_field=n.get_opt_value('protocol-field'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule/match-flow')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow()')
        leaves = []
        _dscp = self.dscp
        if _dscp is not None:
            leaves.append('{self_name}.dscp = {repr(_dscp)}')
        _dot1p = self.dot1p
        if _dot1p is not None:
            leaves.append('{self_name}.dot1p = {repr(_dot1p)}')
        _ipv4_src_prefix = self.ipv4_src_prefix
        if _ipv4_src_prefix is not None:
            leaves.append('{self_name}.ipv4_src_prefix = {repr(_ipv4_src_prefix)}')
        _ipv6_src_prefix = self.ipv6_src_prefix
        if _ipv6_src_prefix is not None:
            leaves.append('{self_name}.ipv6_src_prefix = {repr(_ipv6_src_prefix)}')
        _ipv4_dst_prefix = self.ipv4_dst_prefix
        if _ipv4_dst_prefix is not None:
            leaves.append('{self_name}.ipv4_dst_prefix = {repr(_ipv4_dst_prefix)}')
        _ipv6_dst_prefix = self.ipv6_dst_prefix
        if _ipv6_dst_prefix is not None:
            leaves.append('{self_name}.ipv6_dst_prefix = {repr(_ipv6_dst_prefix)}')
        _l4_src_port = self.l4_src_port
        if _l4_src_port is not None:
            leaves.append('{self_name}.l4_src_port = {repr(_l4_src_port)}')
        _target_sites = self.target_sites
        if len(_target_sites) != 0:
            leaves.append('{self_name}.target_sites = {repr(_target_sites)}')
        _l4_src_port_range = self.l4_src_port_range
        if _l4_src_port_range is not None:
            res.extend(_l4_src_port_range.prsrc('{self_name}.l4_src_port_range', False).splitlines())
        _l4_dst_port = self.l4_dst_port
        if _l4_dst_port is not None:
            leaves.append('{self_name}.l4_dst_port = {repr(_l4_dst_port)}')
        _l4_dst_port_range = self.l4_dst_port_range
        if _l4_dst_port_range is not None:
            res.extend(_l4_dst_port_range.prsrc('{self_name}.l4_dst_port_range', False).splitlines())
        _protocol_field = self.protocol_field
        if _protocol_field is not None:
            leaves.append('{self_name}.protocol_field = {repr(_protocol_field)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule/match-flow'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-classification-policy', 'rule', 'match-flow'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_dscp = yang.gdata.from_xml_opt_int(node, 'dscp')
    yang.gdata.maybe_add(children, 'dscp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dscp, child_dscp)
    child_dot1p = yang.gdata.from_xml_opt_int(node, 'dot1p')
    yang.gdata.maybe_add(children, 'dot1p', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dot1p, child_dot1p)
    child_ipv4_src_prefix = yang.gdata.from_xml_opt_str(node, 'ipv4-src-prefix')
    yang.gdata.maybe_add(children, 'ipv4-src-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix, child_ipv4_src_prefix)
    child_ipv6_src_prefix = yang.gdata.from_xml_opt_str(node, 'ipv6-src-prefix')
    yang.gdata.maybe_add(children, 'ipv6-src-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix, child_ipv6_src_prefix)
    child_ipv4_dst_prefix = yang.gdata.from_xml_opt_str(node, 'ipv4-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv4-dst-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix, child_ipv4_dst_prefix)
    child_ipv6_dst_prefix = yang.gdata.from_xml_opt_str(node, 'ipv6-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv6-dst-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix, child_ipv6_dst_prefix)
    child_l4_src_port = yang.gdata.from_xml_opt_int(node, 'l4-src-port')
    yang.gdata.maybe_add(children, 'l4-src-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port, child_l4_src_port)
    child_target_sites = yang.gdata.from_xml_opt_strs(node, 'target-sites')
    yang.gdata.maybe_add(children, 'target-sites', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__target_sites, child_target_sites)
    child_l4_src_port_range = yang.gdata.from_xml_opt_cnt(node, 'l4-src-port-range')
    yang.gdata.maybe_add(children, 'l4-src-port-range', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range, child_l4_src_port_range)
    child_l4_dst_port = yang.gdata.from_xml_opt_int(node, 'l4-dst-port')
    yang.gdata.maybe_add(children, 'l4-dst-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port, child_l4_dst_port)
    child_l4_dst_port_range = yang.gdata.from_xml_opt_cnt(node, 'l4-dst-port-range')
    yang.gdata.maybe_add(children, 'l4-dst-port-range', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range, child_l4_dst_port_range)
    child_protocol_field = yang.gdata.from_xml_opt_value(node, 'protocol-field')
    yang.gdata.maybe_add(children, 'protocol-field', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__protocol_field, child_protocol_field)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'dscp':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'dot1p':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-src-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'target-sites':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-src-port-range':
            child = {'l4-src-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l4-dst-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-dst-port-range':
            child = {'l4-dst-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'protocol-field':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_dscp = yang.gdata.take_json_opt_int(jd, 'dscp')
    yang.gdata.maybe_add(children, 'dscp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dscp, child_dscp)
    child_dot1p = yang.gdata.take_json_opt_int(jd, 'dot1p')
    yang.gdata.maybe_add(children, 'dot1p', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dot1p, child_dot1p)
    child_ipv4_src_prefix = yang.gdata.take_json_opt_str(jd, 'ipv4-src-prefix')
    yang.gdata.maybe_add(children, 'ipv4-src-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix, child_ipv4_src_prefix)
    child_ipv6_src_prefix = yang.gdata.take_json_opt_str(jd, 'ipv6-src-prefix')
    yang.gdata.maybe_add(children, 'ipv6-src-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix, child_ipv6_src_prefix)
    child_ipv4_dst_prefix = yang.gdata.take_json_opt_str(jd, 'ipv4-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv4-dst-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix, child_ipv4_dst_prefix)
    child_ipv6_dst_prefix = yang.gdata.take_json_opt_str(jd, 'ipv6-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv6-dst-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix, child_ipv6_dst_prefix)
    child_l4_src_port = yang.gdata.take_json_opt_int(jd, 'l4-src-port')
    yang.gdata.maybe_add(children, 'l4-src-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port, child_l4_src_port)
    child_target_sites = yang.gdata.take_json_opt_strs(jd, 'target-sites')
    yang.gdata.maybe_add(children, 'target-sites', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__target_sites, child_target_sites)
    child_l4_src_port_range = yang.gdata.take_json_opt_cnt(jd, 'l4-src-port-range')
    yang.gdata.maybe_add(children, 'l4-src-port-range', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range, child_l4_src_port_range)
    child_l4_dst_port = yang.gdata.take_json_opt_int(jd, 'l4-dst-port')
    yang.gdata.maybe_add(children, 'l4-dst-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port, child_l4_dst_port)
    child_l4_dst_port_range = yang.gdata.take_json_opt_cnt(jd, 'l4-dst-port-range')
    yang.gdata.maybe_add(children, 'l4-dst-port-range', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range, child_l4_dst_port_range)
    child_protocol_field = yang.gdata.take_json_opt_value(jd, 'protocol-field')
    yang.gdata.maybe_add(children, 'protocol-field', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__protocol_field, child_protocol_field)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_application(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:customer-application'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf match-application: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_application(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:customer-application'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf match-application: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__target_class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__target_class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(yang.adata.MNode):
    id: str
    match_flow: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow
    match_application: ?Identityref
    target_class_id: ?str

    mut def __init__(self, id: str, match_flow: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow=None, match_application: ?Identityref, target_class_id: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.match_flow = match_flow if match_flow is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow()
        self.match_application = match_application
        self.target_class_id = target_class_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        _match_flow = self.match_flow
        if _match_flow is not None:
            children['match-flow'] = _match_flow.to_gdata()
        _match_application = self.match_application
        if _match_application is not None:
            _identityref_match_application, error = complete_and_validate_identityref(_match_application, _identities, ['l3vpn-svc:customer-application'], 'ietf-l3vpn-svc')
            if _identityref_match_application is not None:
                _match_application = _identityref_match_application
            else:
                raise ValueError('Invalid value for identityref leaf match-application: {error}')
            children['match-application'] = yang.gdata.Leaf('identityref', _match_application)
        _target_class_id = self.target_class_id
        if _target_class_id is not None:
            children['target-class-id'] = yang.gdata.Leaf('string', _target_class_id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(id=n.get_str('id'), match_flow=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow.from_gdata(n.get_opt_cnt('match-flow')), match_application=n.get_opt_Identityref('match-application'), target_class_id=n.get_opt_str('target-class-id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule({repr(self.id)})')
        leaves = []
        _match_flow = self.match_flow
        if _match_flow is not None:
            res.extend(_match_flow.prsrc('{self_name}.match_flow', False).splitlines())
        _match_application = self.match_application
        if _match_application is not None:
            leaves.append('{self_name}.match_application = {repr(_match_application)}')
        _target_class_id = self.target_class_id
        if _target_class_id is not None:
            leaves.append('{self_name}.target_class_id = {repr(_target_class_id)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-classification-policy', 'rule'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'rule'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements, user_order=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_str(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__id, child_id)
    child_match_flow = yang.gdata.from_xml_opt_cnt(node, 'match-flow')
    yang.gdata.maybe_add(children, 'match-flow', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow, child_match_flow)
    child_match_application = yang.gdata.from_xml_opt_Identityref(node, 'match-application')
    yang.gdata.maybe_add(children, 'match-application', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_application, child_match_application)
    child_target_class_id = yang.gdata.from_xml_opt_str(node, 'target-class-id')
    yang.gdata.maybe_add(children, 'target-class-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__target_class_id, child_target_class_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements, user_order=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__id(keys[0])
        if point == 'match-flow':
            children['match-flow'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(jd, rest_path, op)
        if point == 'match-application':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'target-class-id':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements, user_order=True)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd, path, op)], user_order=True)
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__id, child_id)
    child_match_flow = yang.gdata.take_json_opt_cnt(jd, 'match-flow')
    yang.gdata.maybe_add(children, 'match-flow', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow, child_match_flow)
    child_match_application = yang.gdata.take_json_opt_Identityref(jd, 'match-application')
    yang.gdata.maybe_add(children, 'match-application', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_application, child_match_application)
    child_target_class_id = yang.gdata.take_json_opt_str(jd, 'target-class-id')
    yang.gdata.maybe_add(children, 'target-class-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__target_class_id, child_target_class_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements, user_order=True)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(yang.adata.MNode):
    rule: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule

    mut def __init__(self, rule: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rule = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(elements=rule)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rule = self.rule
        if _rule is not None:
            children['rule'] = _rule.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(rule=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule.from_gdata(n.get_opt_list('rule')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy()')
        leaves = []
        _rule = self.rule
        for _element in _rule:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'rule_element = {self_name}.rule.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('rule_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-classification-policy'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_rule = yang.gdata.from_xml_opt_list(node, 'rule')
    yang.gdata.maybe_add(children, 'rule', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule, child_rule)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'rule':
            child = {'rule': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rule = yang.gdata.take_json_opt_list(jd, 'rule')
    yang.gdata.maybe_add(children, 'rule', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule, child_rule)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__profile(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__profile(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__direction(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf direction: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__direction(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf direction: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__rate_limit(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__rate_limit(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__use_lowest_latency(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__use_lowest_latency(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(yang.adata.MNode):
    use_lowest_latency: ?bool
    latency_boundary: int

    mut def __init__(self, use_lowest_latency: ?bool, latency_boundary: ?int=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_latency = use_lowest_latency
        self.latency_boundary = latency_boundary if latency_boundary is not None else 400

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_latency = self.use_lowest_latency
        if _use_lowest_latency is not None:
            children['use-lowest-latency'] = yang.gdata.Leaf('empty', _use_lowest_latency)
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint16', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(use_lowest_latency=n.get_opt_empty('use-lowest-latency'), latency_boundary=n.get_opt_int('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class/latency')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency()')
        leaves = []
        _use_lowest_latency = self.use_lowest_latency
        if _use_lowest_latency is not None:
            leaves.append('{self_name}.use_lowest_latency = {repr(_use_lowest_latency)}')
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            leaves.append('{self_name}.latency_boundary = {repr(_latency_boundary)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class/latency'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-profile', 'classes', 'class', 'latency'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_use_lowest_latency = yang.gdata.from_xml_opt_empty(node, 'use-lowest-latency')
    yang.gdata.maybe_add(children, 'use-lowest-latency', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__use_lowest_latency, child_use_lowest_latency)
    child_latency_boundary = yang.gdata.from_xml_opt_int(node, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'use-lowest-latency':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_latency = yang.gdata.take_json_opt_empty(jd, 'use-lowest-latency')
    yang.gdata.maybe_add(children, 'use-lowest-latency', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__use_lowest_latency, child_use_lowest_latency)
    child_latency_boundary = yang.gdata.take_json_opt_int(jd, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(yang.adata.MNode):
    use_lowest_jitter: ?bool
    latency_boundary: int

    mut def __init__(self, use_lowest_jitter: ?bool, latency_boundary: ?int=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_jitter = use_lowest_jitter
        self.latency_boundary = latency_boundary if latency_boundary is not None else 40000

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_jitter = self.use_lowest_jitter
        if _use_lowest_jitter is not None:
            children['use-lowest-jitter'] = yang.gdata.Leaf('empty', _use_lowest_jitter)
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint32', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(use_lowest_jitter=n.get_opt_empty('use-lowest-jitter'), latency_boundary=n.get_opt_int('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class/jitter')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter()')
        leaves = []
        _use_lowest_jitter = self.use_lowest_jitter
        if _use_lowest_jitter is not None:
            leaves.append('{self_name}.use_lowest_jitter = {repr(_use_lowest_jitter)}')
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            leaves.append('{self_name}.latency_boundary = {repr(_latency_boundary)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class/jitter'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-profile', 'classes', 'class', 'jitter'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_use_lowest_jitter = yang.gdata.from_xml_opt_empty(node, 'use-lowest-jitter')
    yang.gdata.maybe_add(children, 'use-lowest-jitter', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter, child_use_lowest_jitter)
    child_latency_boundary = yang.gdata.from_xml_opt_int(node, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'use-lowest-jitter':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_jitter = yang.gdata.take_json_opt_empty(jd, 'use-lowest-jitter')
    yang.gdata.maybe_add(children, 'use-lowest-jitter', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter, child_use_lowest_jitter)
    child_latency_boundary = yang.gdata.take_json_opt_int(jd, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__end_to_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__end_to_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(yang.adata.MNode):
    guaranteed_bw_percent: float
    end_to_end: ?bool

    mut def __init__(self, guaranteed_bw_percent: float, end_to_end: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.guaranteed_bw_percent = guaranteed_bw_percent
        self.end_to_end = end_to_end

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _guaranteed_bw_percent = self.guaranteed_bw_percent
        if _guaranteed_bw_percent is not None:
            children['guaranteed-bw-percent'] = yang.gdata.Leaf('decimal64', _guaranteed_bw_percent)
        _end_to_end = self.end_to_end
        if _end_to_end is not None:
            children['end-to-end'] = yang.gdata.Leaf('empty', _end_to_end)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(guaranteed_bw_percent=n.get_float('guaranteed-bw-percent'), end_to_end=n.get_opt_empty('end-to-end'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth')

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class/bandwidth')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth({repr(self.guaranteed_bw_percent)})')
        leaves = []
        _end_to_end = self.end_to_end
        if _end_to_end is not None:
            leaves.append('{self_name}.end_to_end = {repr(_end_to_end)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class/bandwidth'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-profile', 'classes', 'class', 'bandwidth'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_guaranteed_bw_percent = yang.gdata.from_xml_float(node, 'guaranteed-bw-percent')
    yang.gdata.maybe_add(children, 'guaranteed-bw-percent', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent, child_guaranteed_bw_percent)
    child_end_to_end = yang.gdata.from_xml_opt_empty(node, 'end-to-end')
    yang.gdata.maybe_add(children, 'end-to-end', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__end_to_end, child_end_to_end)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'guaranteed-bw-percent':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'end-to-end':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_guaranteed_bw_percent = yang.gdata.take_json_float(jd, 'guaranteed-bw-percent')
    yang.gdata.maybe_add(children, 'guaranteed-bw-percent', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent, child_guaranteed_bw_percent)
    child_end_to_end = yang.gdata.take_json_opt_empty(jd, 'end-to-end')
    yang.gdata.maybe_add(children, 'end-to-end', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__end_to_end, child_end_to_end)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(yang.adata.MNode):
    class_id: str
    direction: Identityref
    rate_limit: ?float
    latency: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency
    jitter: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter
    bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth

    mut def __init__(self, class_id: str, bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth, direction: ?Identityref=None, rate_limit: ?float, latency: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency=None, jitter: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_id = class_id
        _default_direction, error = complete_and_validate_identityref(Identityref.from_adata('both'), _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
        if _default_direction is not None:
            self.direction = direction if direction is not None else _default_direction
        else:
            raise ValueError('Invalid default value for identityref leaf class: {error}')
        self.rate_limit = rate_limit
        self.latency = latency if latency is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency()
        self.jitter = jitter if jitter is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter()
        self.bandwidth = bandwidth

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_id = self.class_id
        if _class_id is not None:
            children['class-id'] = yang.gdata.Leaf('string', _class_id)
        _direction = self.direction
        if _direction is not None:
            _identityref_direction, error = complete_and_validate_identityref(_direction, _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
            if _identityref_direction is not None:
                _direction = _identityref_direction
            else:
                raise ValueError('Invalid value for identityref leaf direction: {error}')
            children['direction'] = yang.gdata.Leaf('identityref', _direction)
        _rate_limit = self.rate_limit
        if _rate_limit is not None:
            children['rate-limit'] = yang.gdata.Leaf('decimal64', _rate_limit)
        _latency = self.latency
        if _latency is not None:
            children['latency'] = _latency.to_gdata()
        _jitter = self.jitter
        if _jitter is not None:
            children['jitter'] = _jitter.to_gdata()
        _bandwidth = self.bandwidth
        if _bandwidth is not None:
            children['bandwidth'] = _bandwidth.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(class_id=n.get_str('class-id'), direction=n.get_opt_Identityref('direction'), rate_limit=n.get_opt_float('rate-limit'), latency=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency.from_gdata(n.get_opt_cnt('latency')), jitter=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter.from_gdata(n.get_opt_cnt('jitter')), bandwidth=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth.from_gdata(n.get_cnt('bandwidth')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class')
            res.append('self_bandwidth = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth({repr(self.bandwidth.guaranteed_bw_percent)})')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class({repr(self.class_id)}, self_bandwidth)')
        leaves = []
        _direction = self.direction
        if _direction is not None:
            leaves.append('{self_name}.direction = {repr(_direction)}')
        _rate_limit = self.rate_limit
        if _rate_limit is not None:
            leaves.append('{self_name}.rate_limit = {repr(_rate_limit)}')
        _latency = self.latency
        if _latency is not None:
            res.extend(_latency.prsrc('{self_name}.latency', False).splitlines())
        _jitter = self.jitter
        if _jitter is not None:
            res.extend(_jitter.prsrc('{self_name}.jitter', False).splitlines())
        _bandwidth = self.bandwidth
        if _bandwidth is not None:
            res.extend(_bandwidth.prsrc('{self_name}.bandwidth', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-profile', 'classes', 'class'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'class'
        self.elements = elements

    mut def create(self, class_id, bandwidth):
        for e in self:
            match = True
            if e.class_id != class_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(class_id, bandwidth)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['class-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_class_id = yang.gdata.from_xml_str(node, 'class-id')
    yang.gdata.maybe_add(children, 'class-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__class_id, child_class_id)
    child_direction = yang.gdata.from_xml_opt_Identityref(node, 'direction')
    yang.gdata.maybe_add(children, 'direction', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__direction, child_direction)
    child_rate_limit = yang.gdata.from_xml_opt_float(node, 'rate-limit')
    yang.gdata.maybe_add(children, 'rate-limit', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__rate_limit, child_rate_limit)
    child_latency = yang.gdata.from_xml_opt_cnt(node, 'latency')
    yang.gdata.maybe_add(children, 'latency', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency, child_latency)
    child_jitter = yang.gdata.from_xml_opt_cnt(node, 'jitter')
    yang.gdata.maybe_add(children, 'jitter', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter, child_jitter)
    child_bandwidth = yang.gdata.from_xml_cnt(node, 'bandwidth')
    yang.gdata.maybe_add(children, 'bandwidth', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth, child_bandwidth)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(e) for e in nodes]
    return yang.gdata.List(keys=['class-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['class-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['class-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__class_id(keys[0])
        if point == 'direction':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'rate-limit':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency':
            children['latency'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(jd, rest_path, op)
        if point == 'jitter':
            children['jitter'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(jd, rest_path, op)
        if point == 'bandwidth':
            children['bandwidth'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['class-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['class-id'])))
        return yang.gdata.List(['class-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['class-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_class_id = yang.gdata.take_json_str(jd, 'class-id')
    yang.gdata.maybe_add(children, 'class-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__class_id, child_class_id)
    child_direction = yang.gdata.take_json_opt_Identityref(jd, 'direction')
    yang.gdata.maybe_add(children, 'direction', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__direction, child_direction)
    child_rate_limit = yang.gdata.take_json_opt_float(jd, 'rate-limit')
    yang.gdata.maybe_add(children, 'rate-limit', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__rate_limit, child_rate_limit)
    child_latency = yang.gdata.take_json_opt_cnt(jd, 'latency')
    yang.gdata.maybe_add(children, 'latency', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency, child_latency)
    child_jitter = yang.gdata.take_json_opt_cnt(jd, 'jitter')
    yang.gdata.maybe_add(children, 'jitter', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter, child_jitter)
    child_bandwidth = yang.gdata.take_json_cnt(jd, 'bandwidth')
    yang.gdata.maybe_add(children, 'bandwidth', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth, child_bandwidth)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['class-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(yang.adata.MNode):
    class_: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class

    mut def __init__(self, class_: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_ = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(elements=class_)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_ = self.class_
        if _class_ is not None:
            children['class'] = _class_.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(class_=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class.from_gdata(n.get_opt_list('class')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes()')
        leaves = []
        _class_ = self.class_
        for _element in _class_:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class element: {_element.to_gdata().key_str(['class-id'])}")
            res.append('element_bandwidth = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth({repr(_element.bandwidth.guaranteed_bw_percent)})')
            list_elem = 'class__element = {self_name}.class_.create({repr(_element.class_id)}, element_bandwidth)'
            res.append(list_elem)
            res.extend(_element.prsrc('class__element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-profile', 'classes'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_class_ = yang.gdata.from_xml_opt_list(node, 'class')
    yang.gdata.maybe_add(children, 'class', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class, child_class_)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'class':
            child = {'class': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_class_ = yang.gdata.take_json_opt_list(jd, 'class')
    yang.gdata.maybe_add(children, 'class', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class, child_class_)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(yang.adata.MNode):
    profile: ?str
    classes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes

    mut def __init__(self, profile: ?str, classes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile = profile
        self.classes = classes if classes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile = self.profile
        if _profile is not None:
            children['profile'] = yang.gdata.Leaf('leafref', _profile)
        _classes = self.classes
        if _classes is not None:
            children['classes'] = _classes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(profile=n.get_opt_str('profile'), classes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes.from_gdata(n.get_opt_cnt('classes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile()')
        leaves = []
        _profile = self.profile
        if _profile is not None:
            leaves.append('{self_name}.profile = {repr(_profile)}')
        _classes = self.classes
        if _classes is not None:
            res.extend(_classes.prsrc('{self_name}.classes', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-profile'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_profile = yang.gdata.from_xml_opt_str(node, 'profile')
    yang.gdata.maybe_add(children, 'profile', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__profile, child_profile)
    child_classes = yang.gdata.from_xml_opt_cnt(node, 'classes')
    yang.gdata.maybe_add(children, 'classes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes, child_classes)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'profile':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'classes':
            child = {'classes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile = yang.gdata.take_json_opt_str(jd, 'profile')
    yang.gdata.maybe_add(children, 'profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__profile, child_profile)
    child_classes = yang.gdata.take_json_opt_cnt(jd, 'classes')
    yang.gdata.maybe_add(children, 'classes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes, child_classes)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(yang.adata.MNode):
    qos_classification_policy: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy
    qos_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile

    mut def __init__(self, qos_classification_policy: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy=None, qos_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.qos_classification_policy = qos_classification_policy if qos_classification_policy is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy()
        self.qos_profile = qos_profile if qos_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _qos_classification_policy = self.qos_classification_policy
        if _qos_classification_policy is not None:
            children['qos-classification-policy'] = _qos_classification_policy.to_gdata()
        _qos_profile = self.qos_profile
        if _qos_profile is not None:
            children['qos-profile'] = _qos_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(qos_classification_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy.from_gdata(n.get_opt_cnt('qos-classification-policy')), qos_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile.from_gdata(n.get_opt_cnt('qos-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos()')
        leaves = []
        _qos_classification_policy = self.qos_classification_policy
        if _qos_classification_policy is not None:
            res.extend(_qos_classification_policy.prsrc('{self_name}.qos_classification_policy', False).splitlines())
        _qos_profile = self.qos_profile
        if _qos_profile is not None:
            res.extend(_qos_profile.prsrc('{self_name}.qos_profile', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_qos_classification_policy = yang.gdata.from_xml_opt_cnt(node, 'qos-classification-policy')
    yang.gdata.maybe_add(children, 'qos-classification-policy', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy, child_qos_classification_policy)
    child_qos_profile = yang.gdata.from_xml_opt_cnt(node, 'qos-profile')
    yang.gdata.maybe_add(children, 'qos-profile', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile, child_qos_profile)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'qos-classification-policy':
            child = {'qos-classification-policy': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'qos-profile':
            child = {'qos-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_qos_classification_policy = yang.gdata.take_json_opt_cnt(jd, 'qos-classification-policy')
    yang.gdata.maybe_add(children, 'qos-classification-policy', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy, child_qos_classification_policy)
    child_qos_profile = yang.gdata.take_json_opt_cnt(jd, 'qos-profile')
    yang.gdata.maybe_add(children, 'qos-profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile, child_qos_profile)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier__signalling_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier__signalling_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(yang.adata.MNode):
    signalling_type: str

    mut def __init__(self, signalling_type: ?str=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.signalling_type = signalling_type if signalling_type is not None else "bgp"

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _signalling_type = self.signalling_type
        if _signalling_type is not None:
            children['signalling-type'] = yang.gdata.Leaf('enumeration', _signalling_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(signalling_type=n.get_opt_str('signalling-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/carrierscarrier')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier()')
        leaves = []
        _signalling_type = self.signalling_type
        if _signalling_type is not None:
            leaves.append('{self_name}.signalling_type = {repr(_signalling_type)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/carrierscarrier'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'carrierscarrier'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_signalling_type = yang.gdata.from_xml_opt_str(node, 'signalling-type')
    yang.gdata.maybe_add(children, 'signalling-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier__signalling_type, child_signalling_type)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'signalling-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_signalling_type = yang.gdata.take_json_opt_str(jd, 'signalling-type')
    yang.gdata.maybe_add(children, 'signalling-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier__signalling_type, child_signalling_type)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_site_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_site_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv4(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv4(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv6(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv6(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(yang.adata.MNode):
    ipv4: bool
    ipv6: bool

    mut def __init__(self, ipv4: ?bool=None, ipv6: ?bool=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4 = ipv4 if ipv4 is not None else False
        self.ipv6 = ipv6 if ipv6 is not None else False

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            children['ipv4'] = yang.gdata.Leaf('boolean', _ipv4)
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            children['ipv6'] = yang.gdata.Leaf('boolean', _ipv6)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(ipv4=n.get_opt_bool('ipv4'), ipv6=n.get_opt_bool('ipv6'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/multicast/multicast-address-family')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family()')
        leaves = []
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            leaves.append('{self_name}.ipv4 = {repr(_ipv4)}')
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            leaves.append('{self_name}.ipv6 = {repr(_ipv6)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/multicast/multicast-address-family'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'multicast', 'multicast-address-family'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.from_xml_opt_bool(node, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.from_xml_opt_bool(node, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv6, child_ipv6)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'ipv4':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.take_json_opt_bool(jd, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.take_json_opt_bool(jd, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv6, child_ipv6)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__protocol_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__protocol_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(yang.adata.MNode):
    multicast_site_type: str
    multicast_address_family: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family
    protocol_type: str

    mut def __init__(self, multicast_site_type: ?str=None, multicast_address_family: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family=None, protocol_type: ?str=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.multicast_site_type = multicast_site_type if multicast_site_type is not None else "source-receiver"
        self.multicast_address_family = multicast_address_family if multicast_address_family is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family()
        self.protocol_type = protocol_type if protocol_type is not None else "both"

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _multicast_site_type = self.multicast_site_type
        if _multicast_site_type is not None:
            children['multicast-site-type'] = yang.gdata.Leaf('enumeration', _multicast_site_type)
        _multicast_address_family = self.multicast_address_family
        if _multicast_address_family is not None:
            children['multicast-address-family'] = _multicast_address_family.to_gdata()
        _protocol_type = self.protocol_type
        if _protocol_type is not None:
            children['protocol-type'] = yang.gdata.Leaf('enumeration', _protocol_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(multicast_site_type=n.get_opt_str('multicast-site-type'), multicast_address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family.from_gdata(n.get_opt_cnt('multicast-address-family')), protocol_type=n.get_opt_str('protocol-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/multicast')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast()')
        leaves = []
        _multicast_site_type = self.multicast_site_type
        if _multicast_site_type is not None:
            leaves.append('{self_name}.multicast_site_type = {repr(_multicast_site_type)}')
        _multicast_address_family = self.multicast_address_family
        if _multicast_address_family is not None:
            res.extend(_multicast_address_family.prsrc('{self_name}.multicast_address_family', False).splitlines())
        _protocol_type = self.protocol_type
        if _protocol_type is not None:
            leaves.append('{self_name}.protocol_type = {repr(_protocol_type)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/multicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'multicast'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_multicast_site_type = yang.gdata.from_xml_opt_str(node, 'multicast-site-type')
    yang.gdata.maybe_add(children, 'multicast-site-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_site_type, child_multicast_site_type)
    child_multicast_address_family = yang.gdata.from_xml_opt_cnt(node, 'multicast-address-family')
    yang.gdata.maybe_add(children, 'multicast-address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family, child_multicast_address_family)
    child_protocol_type = yang.gdata.from_xml_opt_str(node, 'protocol-type')
    yang.gdata.maybe_add(children, 'protocol-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__protocol_type, child_protocol_type)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'multicast-site-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'multicast-address-family':
            child = {'multicast-address-family': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'protocol-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_multicast_site_type = yang.gdata.take_json_opt_str(jd, 'multicast-site-type')
    yang.gdata.maybe_add(children, 'multicast-site-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_site_type, child_multicast_site_type)
    child_multicast_address_family = yang.gdata.take_json_opt_cnt(jd, 'multicast-address-family')
    yang.gdata.maybe_add(children, 'multicast-address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family, child_multicast_address_family)
    child_protocol_type = yang.gdata.take_json_opt_str(jd, 'protocol-type')
    yang.gdata.maybe_add(children, 'protocol-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__protocol_type, child_protocol_type)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(yang.adata.MNode):
    svc_input_bandwidth: int
    svc_output_bandwidth: int
    svc_mtu: int
    qos: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos
    carrierscarrier: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier
    multicast: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast

    mut def __init__(self, svc_input_bandwidth: int, svc_output_bandwidth: int, svc_mtu: int, qos: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos=None, carrierscarrier: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier=None, multicast: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.svc_input_bandwidth = svc_input_bandwidth
        self.svc_output_bandwidth = svc_output_bandwidth
        self.svc_mtu = svc_mtu
        self.qos = qos if qos is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos()
        self.carrierscarrier = carrierscarrier if carrierscarrier is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier()
        self.multicast = multicast if multicast is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _svc_input_bandwidth = self.svc_input_bandwidth
        if _svc_input_bandwidth is not None:
            children['svc-input-bandwidth'] = yang.gdata.Leaf('uint64', _svc_input_bandwidth)
        _svc_output_bandwidth = self.svc_output_bandwidth
        if _svc_output_bandwidth is not None:
            children['svc-output-bandwidth'] = yang.gdata.Leaf('uint64', _svc_output_bandwidth)
        _svc_mtu = self.svc_mtu
        if _svc_mtu is not None:
            children['svc-mtu'] = yang.gdata.Leaf('uint16', _svc_mtu)
        _qos = self.qos
        if _qos is not None:
            children['qos'] = _qos.to_gdata()
        _carrierscarrier = self.carrierscarrier
        if _carrierscarrier is not None:
            children['carrierscarrier'] = _carrierscarrier.to_gdata()
        _multicast = self.multicast
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(svc_input_bandwidth=n.get_int('svc-input-bandwidth'), svc_output_bandwidth=n.get_int('svc-output-bandwidth'), svc_mtu=n.get_int('svc-mtu'), qos=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos.from_gdata(n.get_opt_cnt('qos')), carrierscarrier=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier.from_gdata(n.get_opt_cnt('carrierscarrier')), multicast=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast.from_gdata(n.get_opt_cnt('multicast')))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service')

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service({repr(self.svc_input_bandwidth)}, {repr(self.svc_output_bandwidth)}, {repr(self.svc_mtu)})')
        leaves = []
        _qos = self.qos
        if _qos is not None:
            res.extend(_qos.prsrc('{self_name}.qos', False).splitlines())
        _carrierscarrier = self.carrierscarrier
        if _carrierscarrier is not None:
            res.extend(_carrierscarrier.prsrc('{self_name}.carrierscarrier', False).splitlines())
        _multicast = self.multicast
        if _multicast is not None:
            res.extend(_multicast.prsrc('{self_name}.multicast', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_svc_input_bandwidth = yang.gdata.from_xml_int(node, 'svc-input-bandwidth')
    yang.gdata.maybe_add(children, 'svc-input-bandwidth', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_input_bandwidth, child_svc_input_bandwidth)
    child_svc_output_bandwidth = yang.gdata.from_xml_int(node, 'svc-output-bandwidth')
    yang.gdata.maybe_add(children, 'svc-output-bandwidth', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_output_bandwidth, child_svc_output_bandwidth)
    child_svc_mtu = yang.gdata.from_xml_int(node, 'svc-mtu')
    yang.gdata.maybe_add(children, 'svc-mtu', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_mtu, child_svc_mtu)
    child_qos = yang.gdata.from_xml_opt_cnt(node, 'qos')
    yang.gdata.maybe_add(children, 'qos', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos, child_qos)
    child_carrierscarrier = yang.gdata.from_xml_opt_cnt(node, 'carrierscarrier')
    yang.gdata.maybe_add(children, 'carrierscarrier', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier, child_carrierscarrier)
    child_multicast = yang.gdata.from_xml_opt_cnt(node, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast, child_multicast)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'svc-input-bandwidth':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'svc-output-bandwidth':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'svc-mtu':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'qos':
            child = {'qos': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'carrierscarrier':
            child = {'carrierscarrier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'multicast':
            child = {'multicast': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_svc_input_bandwidth = yang.gdata.take_json_int64(jd, 'svc-input-bandwidth')
    yang.gdata.maybe_add(children, 'svc-input-bandwidth', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_input_bandwidth, child_svc_input_bandwidth)
    child_svc_output_bandwidth = yang.gdata.take_json_int64(jd, 'svc-output-bandwidth')
    yang.gdata.maybe_add(children, 'svc-output-bandwidth', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_output_bandwidth, child_svc_output_bandwidth)
    child_svc_mtu = yang.gdata.take_json_int(jd, 'svc-mtu')
    yang.gdata.maybe_add(children, 'svc-mtu', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_mtu, child_svc_mtu)
    child_qos = yang.gdata.take_json_opt_cnt(jd, 'qos')
    yang.gdata.maybe_add(children, 'qos', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos, child_qos)
    child_carrierscarrier = yang.gdata.take_json_opt_cnt(jd, 'carrierscarrier')
    yang.gdata.maybe_add(children, 'carrierscarrier', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier, child_carrierscarrier)
    child_multicast = yang.gdata.take_json_opt_cnt(jd, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast, child_multicast)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:routing-protocol-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:routing-protocol-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__area_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__area_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(yang.adata.MNode):
    target_site: str
    metric: int

    mut def __init__(self, target_site: str, metric: ?int=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.target_site = target_site
        self.metric = metric if metric is not None else 1

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _target_site = self.target_site
        if _target_site is not None:
            children['target-site'] = yang.gdata.Leaf('string', _target_site)
        _metric = self.metric
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site=n.get_str('target-site'), metric=n.get_opt_int('metric'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf/sham-links/sham-link')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link({repr(self.target_site)})')
        leaves = []
        _metric = self.metric
        if _metric is not None:
            leaves.append('{self_name}.metric = {repr(_metric)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf/sham-links/sham-link'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'ospf', 'sham-links', 'sham-link'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'sham-link'
        self.elements = elements

    mut def create(self, target_site):
        for e in self:
            match = True
            if e.target_site != target_site:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['target-site'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_target_site = yang.gdata.from_xml_str(node, 'target-site')
    yang.gdata.maybe_add(children, 'target-site', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site, child_target_site)
    child_metric = yang.gdata.from_xml_opt_int(node, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric, child_metric)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(e) for e in nodes]
    return yang.gdata.List(keys=['target-site'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['target-site']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['target-site'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(keys[0])
        if point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['target-site']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['target-site'])))
        return yang.gdata.List(['target-site'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['target-site'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_target_site = yang.gdata.take_json_str(jd, 'target-site')
    yang.gdata.maybe_add(children, 'target-site', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site, child_target_site)
    child_metric = yang.gdata.take_json_opt_int(jd, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric, child_metric)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['target-site'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(yang.adata.MNode):
    sham_link: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link

    mut def __init__(self, sham_link: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.sham_link = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(elements=sham_link)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _sham_link = self.sham_link
        if _sham_link is not None:
            children['sham-link'] = _sham_link.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(sham_link=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link.from_gdata(n.get_opt_list('sham-link')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf/sham-links')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links()')
        leaves = []
        _sham_link = self.sham_link
        for _element in _sham_link:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf/sham-links/sham-link element: {_element.to_gdata().key_str(['target-site'])}")
            list_elem = 'sham_link_element = {self_name}.sham_link.create({repr(_element.target_site)})'
            res.append(list_elem)
            res.extend(_element.prsrc('sham_link_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf/sham-links'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'ospf', 'sham-links'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_sham_link = yang.gdata.from_xml_opt_list(node, 'sham-link')
    yang.gdata.maybe_add(children, 'sham-link', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link, child_sham_link)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'sham-link':
            child = {'sham-link': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_sham_link = yang.gdata.take_json_opt_list(jd, 'sham-link')
    yang.gdata.maybe_add(children, 'sham-link', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link, child_sham_link)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(yang.adata.MNode):
    address_family: list[str]
    area_address: str
    metric: int
    sham_links: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links

    mut def __init__(self, area_address: str, address_family: ?list[str]=None, metric: ?int=None, sham_links: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []
        self.area_address = area_address
        self.metric = metric if metric is not None else 1
        self.sham_links = sham_links if sham_links is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        _area_address = self.area_address
        if _area_address is not None:
            children['area-address'] = yang.gdata.Leaf('string', _area_address)
        _metric = self.metric
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        _sham_links = self.sham_links
        if _sham_links is not None:
            children['sham-links'] = _sham_links.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(address_family=n.get_strs('address-family'), area_address=n.get_str('area-address'), metric=n.get_opt_int('metric'), sham_links=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links.from_gdata(n.get_opt_cnt('sham-links')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf({repr(self.area_address)})')
        leaves = []
        _metric = self.metric
        if _metric is not None:
            leaves.append('{self_name}.metric = {repr(_metric)}')
        _sham_links = self.sham_links
        if _sham_links is not None:
            res.extend(_sham_links.prsrc('{self_name}.sham_links', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'ospf'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__address_family, child_address_family)
    child_area_address = yang.gdata.from_xml_str(node, 'area-address')
    yang.gdata.maybe_add(children, 'area-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__area_address, child_area_address)
    child_metric = yang.gdata.from_xml_opt_int(node, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__metric, child_metric)
    child_sham_links = yang.gdata.from_xml_opt_cnt(node, 'sham-links')
    yang.gdata.maybe_add(children, 'sham-links', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links, child_sham_links)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'area-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'sham-links':
            child = {'sham-links': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__address_family, child_address_family)
    child_area_address = yang.gdata.take_json_str(jd, 'area-address')
    yang.gdata.maybe_add(children, 'area-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__area_address, child_area_address)
    child_metric = yang.gdata.take_json_opt_int(jd, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__metric, child_metric)
    child_sham_links = yang.gdata.take_json_opt_cnt(jd, 'sham-links')
    yang.gdata.maybe_add(children, 'sham-links', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links, child_sham_links)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__autonomous_system(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__autonomous_system(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(yang.adata.MNode):
    autonomous_system: int
    address_family: list[str]

    mut def __init__(self, autonomous_system: int, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.autonomous_system = autonomous_system
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _autonomous_system = self.autonomous_system
        if _autonomous_system is not None:
            children['autonomous-system'] = yang.gdata.Leaf('uint32', _autonomous_system)
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(autonomous_system=n.get_int('autonomous-system'), address_family=n.get_strs('address-family'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/bgp')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp({repr(self.autonomous_system)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/bgp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'bgp'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_autonomous_system = yang.gdata.from_xml_int(node, 'autonomous-system')
    yang.gdata.maybe_add(children, 'autonomous-system', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__autonomous_system, child_autonomous_system)
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'autonomous-system':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_autonomous_system = yang.gdata.take_json_int(jd, 'autonomous-system')
    yang.gdata.maybe_add(children, 'autonomous-system', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__autonomous_system, child_autonomous_system)
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        _next_hop = self.next_hop
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv4-lan-prefixes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes({repr(self.lan)}, {repr(self.next_hop)})')
        leaves = []
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            leaves.append('{self_name}.lan_tag = {repr(_lan_tag)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv4-lan-prefixes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'static', 'cascaded-lan-prefixes', 'ipv4-lan-prefixes'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv4-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.from_xml_str(node, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.from_xml_str(node, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.from_xml_opt_str(node, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(e) for e in nodes]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['lan', 'next-hop']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(keys[0])
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(keys[1])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['lan', 'next-hop'])))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.take_json_str(jd, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.take_json_str(jd, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.take_json_opt_str(jd, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        _next_hop = self.next_hop
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv6-lan-prefixes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes({repr(self.lan)}, {repr(self.next_hop)})')
        leaves = []
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            leaves.append('{self_name}.lan_tag = {repr(_lan_tag)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv6-lan-prefixes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'static', 'cascaded-lan-prefixes', 'ipv6-lan-prefixes'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv6-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.from_xml_str(node, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.from_xml_str(node, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.from_xml_opt_str(node, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(e) for e in nodes]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['lan', 'next-hop']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(keys[0])
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(keys[1])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['lan', 'next-hop'])))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.take_json_str(jd, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.take_json_str(jd, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.take_json_opt_str(jd, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.adata.MNode):
    ipv4_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes
    ipv6_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes

    mut def __init__(self, ipv4_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]=[], ipv6_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(elements=ipv4_lan_prefixes)
        self.ipv6_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(elements=ipv6_lan_prefixes)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4_lan_prefixes = self.ipv4_lan_prefixes
        if _ipv4_lan_prefixes is not None:
            children['ipv4-lan-prefixes'] = _ipv4_lan_prefixes.to_gdata()
        _ipv6_lan_prefixes = self.ipv6_lan_prefixes
        if _ipv6_lan_prefixes is not None:
            children['ipv6-lan-prefixes'] = _ipv6_lan_prefixes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(ipv4_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes.from_gdata(n.get_opt_list('ipv4-lan-prefixes')), ipv6_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes.from_gdata(n.get_opt_list('ipv6-lan-prefixes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()')
        leaves = []
        _ipv4_lan_prefixes = self.ipv4_lan_prefixes
        for _element in _ipv4_lan_prefixes:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv4-lan-prefixes element: {_element.to_gdata().key_str(['lan', 'next-hop'])}")
            list_elem = 'ipv4_lan_prefixes_element = {self_name}.ipv4_lan_prefixes.create({repr(_element.lan)}, {repr(_element.next_hop)})'
            res.append(list_elem)
            res.extend(_element.prsrc('ipv4_lan_prefixes_element', False, list_element=True).splitlines())
        _ipv6_lan_prefixes = self.ipv6_lan_prefixes
        for _element in _ipv6_lan_prefixes:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv6-lan-prefixes element: {_element.to_gdata().key_str(['lan', 'next-hop'])}")
            list_elem = 'ipv6_lan_prefixes_element = {self_name}.ipv6_lan_prefixes.create({repr(_element.lan)}, {repr(_element.next_hop)})'
            res.append(list_elem)
            res.extend(_element.prsrc('ipv6_lan_prefixes_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'static', 'cascaded-lan-prefixes'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4_lan_prefixes = yang.gdata.from_xml_opt_list(node, 'ipv4-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv4-lan-prefixes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes, child_ipv4_lan_prefixes)
    child_ipv6_lan_prefixes = yang.gdata.from_xml_opt_list(node, 'ipv6-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv6-lan-prefixes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes, child_ipv6_lan_prefixes)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'ipv4-lan-prefixes':
            child = {'ipv4-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'ipv6-lan-prefixes':
            child = {'ipv6-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4_lan_prefixes = yang.gdata.take_json_opt_list(jd, 'ipv4-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv4-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes, child_ipv4_lan_prefixes)
    child_ipv6_lan_prefixes = yang.gdata.take_json_opt_list(jd, 'ipv6-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv6-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes, child_ipv6_lan_prefixes)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(yang.adata.MNode):
    cascaded_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes

    mut def __init__(self, cascaded_lan_prefixes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cascaded_lan_prefixes = cascaded_lan_prefixes if cascaded_lan_prefixes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cascaded_lan_prefixes = self.cascaded_lan_prefixes
        if _cascaded_lan_prefixes is not None:
            children['cascaded-lan-prefixes'] = _cascaded_lan_prefixes.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(cascaded_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_gdata(n.get_opt_cnt('cascaded-lan-prefixes')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static()')
        leaves = []
        _cascaded_lan_prefixes = self.cascaded_lan_prefixes
        if _cascaded_lan_prefixes is not None:
            res.extend(_cascaded_lan_prefixes.prsrc('{self_name}.cascaded_lan_prefixes', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'static'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_cascaded_lan_prefixes = yang.gdata.from_xml_opt_cnt(node, 'cascaded-lan-prefixes')
    yang.gdata.maybe_add(children, 'cascaded-lan-prefixes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes, child_cascaded_lan_prefixes)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'cascaded-lan-prefixes':
            child = {'cascaded-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cascaded_lan_prefixes = yang.gdata.take_json_opt_cnt(jd, 'cascaded-lan-prefixes')
    yang.gdata.maybe_add(children, 'cascaded-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes, child_cascaded_lan_prefixes)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(address_family=n.get_strs('address-family'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/rip')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/rip'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'rip'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(address_family=n.get_strs('address-family'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/vrrp')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/vrrp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'vrrp'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(yang.adata.MNode):
    type: Identityref
    ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf
    bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp
    static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static
    rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip
    vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp

    mut def __init__(self, type: Identityref, ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf=None, bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp=None, static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static=None, rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip=None, vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type
        self.ospf = ospf
        self.bgp = bgp
        self.static = static
        self.rip = rip
        self.vrrp = vrrp

    mut def create_ospf(self, area_address):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(area_address)
        self.ospf = res
        return res

    mut def create_bgp(self, autonomous_system):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(autonomous_system)
        self.bgp = res
        return res

    mut def create_static(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static()
        self.static = res
        return res

    mut def create_rip(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip()
        self.rip = res
        return res

    mut def create_vrrp(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp()
        self.vrrp = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        if _type is not None:
            _identityref_type, error = complete_and_validate_identityref(_type, _identities, ['l3vpn-svc:routing-protocol-type'], 'ietf-l3vpn-svc')
            if _identityref_type is not None:
                _type = _identityref_type
            else:
                raise ValueError('Invalid value for identityref leaf type: {error}')
            children['type'] = yang.gdata.Leaf('identityref', _type)
        _ospf = self.ospf
        if _ospf is not None:
            children['ospf'] = _ospf.to_gdata()
        _bgp = self.bgp
        if _bgp is not None:
            children['bgp'] = _bgp.to_gdata()
        _static = self.static
        if _static is not None:
            children['static'] = _static.to_gdata()
        _rip = self.rip
        if _rip is not None:
            children['rip'] = _rip.to_gdata()
        _vrrp = self.vrrp
        if _vrrp is not None:
            children['vrrp'] = _vrrp.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(type=n.get_Identityref('type'), ospf=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf.from_gdata(n.get_opt_cnt('ospf')), bgp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp.from_gdata(n.get_opt_cnt('bgp')), static=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static.from_gdata(n.get_opt_cnt('static')), rip=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip.from_gdata(n.get_opt_cnt('rip')), vrrp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp.from_gdata(n.get_opt_cnt('vrrp')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol({repr(self.type)})')
        leaves = []
        _ospf = self.ospf
        if _ospf is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf')
            res.append('ospf = {self_name}.create_ospf({repr(_ospf.area_address)})')
            res.extend(_ospf.prsrc('ospf', False).splitlines())
        _bgp = self.bgp
        if _bgp is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/bgp')
            res.append('bgp = {self_name}.create_bgp({repr(_bgp.autonomous_system)})')
            res.extend(_bgp.prsrc('bgp', False).splitlines())
        _static = self.static
        if _static is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static')
            res.append('static = {self_name}.create_static()')
            res.extend(_static.prsrc('static', False).splitlines())
        _rip = self.rip
        if _rip is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/rip')
            res.append('rip = {self_name}.create_rip()')
            res.extend(_rip.prsrc('rip', False).splitlines())
        _vrrp = self.vrrp
        if _vrrp is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/vrrp')
            res.append('vrrp = {self_name}.create_vrrp()')
            res.extend(_vrrp.prsrc('vrrp', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'routing-protocol'
        self.elements = elements

    mut def create(self, type):
        for e in self:
            match = True
            if e.type != type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['type'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_type = yang.gdata.from_xml_Identityref(node, 'type')
    yang.gdata.maybe_add(children, 'type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__type, child_type)
    child_ospf = yang.gdata.from_xml_opt_cnt(node, 'ospf')
    yang.gdata.maybe_add(children, 'ospf', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf, child_ospf)
    child_bgp = yang.gdata.from_xml_opt_cnt(node, 'bgp')
    yang.gdata.maybe_add(children, 'bgp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp, child_bgp)
    child_static = yang.gdata.from_xml_opt_cnt(node, 'static')
    yang.gdata.maybe_add(children, 'static', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static, child_static)
    child_rip = yang.gdata.from_xml_opt_cnt(node, 'rip')
    yang.gdata.maybe_add(children, 'rip', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip, child_rip)
    child_vrrp = yang.gdata.from_xml_opt_cnt(node, 'vrrp')
    yang.gdata.maybe_add(children, 'vrrp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp, child_vrrp)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(e) for e in nodes]
    return yang.gdata.List(keys=['type'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['type']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__type(Identityref.from_json(keys[0]))
        if point == 'ospf':
            children['ospf'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(jd, rest_path, op)
        if point == 'bgp':
            children['bgp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(jd, rest_path, op)
        if point == 'static':
            children['static'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(jd, rest_path, op)
        if point == 'rip':
            children['rip'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(jd, rest_path, op)
        if point == 'vrrp':
            children['vrrp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['type'])))
        return yang.gdata.List(['type'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_type = yang.gdata.take_json_Identityref(jd, 'type')
    yang.gdata.maybe_add(children, 'type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__type, child_type)
    child_ospf = yang.gdata.take_json_opt_cnt(jd, 'ospf')
    yang.gdata.maybe_add(children, 'ospf', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf, child_ospf)
    child_bgp = yang.gdata.take_json_opt_cnt(jd, 'bgp')
    yang.gdata.maybe_add(children, 'bgp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp, child_bgp)
    child_static = yang.gdata.take_json_opt_cnt(jd, 'static')
    yang.gdata.maybe_add(children, 'static', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static, child_static)
    child_rip = yang.gdata.take_json_opt_cnt(jd, 'rip')
    yang.gdata.maybe_add(children, 'rip', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip, child_rip)
    child_vrrp = yang.gdata.take_json_opt_cnt(jd, 'vrrp')
    yang.gdata.maybe_add(children, 'vrrp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp, child_vrrp)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['type'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(yang.adata.MNode):
    routing_protocol: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol

    mut def __init__(self, routing_protocol: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.routing_protocol = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(elements=routing_protocol)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _routing_protocol = self.routing_protocol
        if _routing_protocol is not None:
            children['routing-protocol'] = _routing_protocol.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(routing_protocol=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol.from_gdata(n.get_opt_list('routing-protocol')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols()')
        leaves = []
        _routing_protocol = self.routing_protocol
        for _element in _routing_protocol:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol element: {_element.to_gdata().key_str(['type'])}")
            list_elem = 'routing_protocol_element = {self_name}.routing_protocol.create({repr(_element.type)})'
            res.append(list_elem)
            res.extend(_element.prsrc('routing_protocol_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_routing_protocol = yang.gdata.from_xml_opt_list(node, 'routing-protocol')
    yang.gdata.maybe_add(children, 'routing-protocol', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol, child_routing_protocol)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'routing-protocol':
            child = {'routing-protocol': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_routing_protocol = yang.gdata.take_json_opt_list(jd, 'routing-protocol')
    yang.gdata.maybe_add(children, 'routing-protocol', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol, child_routing_protocol)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability__access_priority(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability__access_priority(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(yang.adata.MNode):
    access_priority: int

    mut def __init__(self, access_priority: ?int=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.access_priority = access_priority if access_priority is not None else 100

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _access_priority = self.access_priority
        if _access_priority is not None:
            children['access-priority'] = yang.gdata.Leaf('uint32', _access_priority)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(access_priority=n.get_opt_int('access-priority'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/availability')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability()')
        leaves = []
        _access_priority = self.access_priority
        if _access_priority is not None:
            leaves.append('{self_name}.access_priority = {repr(_access_priority)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/availability'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'availability'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_access_priority = yang.gdata.from_xml_opt_int(node, 'access-priority')
    yang.gdata.maybe_add(children, 'access-priority', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability__access_priority, child_access_priority)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'access-priority':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_access_priority = yang.gdata.take_json_opt_int(jd, 'access-priority')
    yang.gdata.maybe_add(children, 'access-priority', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability__access_priority, child_access_priority)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_policy_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_policy_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__site_role(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-role: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__site_role(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-role: {error}')

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(yang.adata.MNode):
    vpn_policy_id: ?str
    vpn_id: ?str
    site_role: Identityref

    mut def __init__(self, vpn_policy_id: ?str, vpn_id: ?str, site_role: ?Identityref=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_policy_id = vpn_policy_id
        self.vpn_id = vpn_id
        _default_site_role, error = complete_and_validate_identityref(Identityref.from_adata('any-to-any-role'), _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
        if _default_site_role is not None:
            self.site_role = site_role if site_role is not None else _default_site_role
        else:
            raise ValueError('Invalid default value for identityref leaf vpn-attachment: {error}')

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_policy_id = self.vpn_policy_id
        if _vpn_policy_id is not None:
            children['vpn-policy-id'] = yang.gdata.Leaf('leafref', _vpn_policy_id)
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('leafref', _vpn_id)
        _site_role = self.site_role
        if _site_role is not None:
            _identityref_site_role, error = complete_and_validate_identityref(_site_role, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
            if _identityref_site_role is not None:
                _site_role = _identityref_site_role
            else:
                raise ValueError('Invalid value for identityref leaf site-role: {error}')
            children['site-role'] = yang.gdata.Leaf('identityref', _site_role)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(vpn_policy_id=n.get_opt_str('vpn-policy-id'), vpn_id=n.get_opt_str('vpn-id'), site_role=n.get_opt_Identityref('site-role'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/vpn-attachment')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment()')
        leaves = []
        _vpn_policy_id = self.vpn_policy_id
        if _vpn_policy_id is not None:
            leaves.append('{self_name}.vpn_policy_id = {repr(_vpn_policy_id)}')
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            leaves.append('{self_name}.vpn_id = {repr(_vpn_id)}')
        _site_role = self.site_role
        if _site_role is not None:
            leaves.append('{self_name}.site_role = {repr(_site_role)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/vpn-attachment'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'vpn-attachment'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_vpn_policy_id = yang.gdata.from_xml_opt_str(node, 'vpn-policy-id')
    yang.gdata.maybe_add(children, 'vpn-policy-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_policy_id, child_vpn_policy_id)
    child_vpn_id = yang.gdata.from_xml_opt_str(node, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_id, child_vpn_id)
    child_site_role = yang.gdata.from_xml_opt_Identityref(node, 'site-role')
    yang.gdata.maybe_add(children, 'site-role', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__site_role, child_site_role)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'vpn-policy-id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'vpn-id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'site-role':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_policy_id = yang.gdata.take_json_opt_str(jd, 'vpn-policy-id')
    yang.gdata.maybe_add(children, 'vpn-policy-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_policy_id, child_vpn_policy_id)
    child_vpn_id = yang.gdata.take_json_opt_str(jd, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_id, child_vpn_id)
    child_site_role = yang.gdata.take_json_opt_Identityref(jd, 'site-role')
    yang.gdata.maybe_add(children, 'site-role', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__site_role, child_site_role)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(yang.adata.MNode):
    site_network_access_id: str
    site_network_access_type: Identityref
    location_reference: ?str
    device_reference: ?str
    access_diversity: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity
    bearer: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer
    ip_connection: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection
    security: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security
    service: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service
    routing_protocols: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols
    availability: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability
    vpn_attachment: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment

    mut def __init__(self, site_network_access_id: str, service: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service, site_network_access_type: ?Identityref=None, location_reference: ?str, device_reference: ?str, access_diversity: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity=None, bearer: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer=None, ip_connection: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection=None, security: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security=None, routing_protocols: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols=None, availability: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability=None, vpn_attachment: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site_network_access_id = site_network_access_id
        _default_site_network_access_type, error = complete_and_validate_identityref(Identityref.from_adata('point-to-point'), _identities, ['l3vpn-svc:site-network-access-type'], 'ietf-l3vpn-svc')
        if _default_site_network_access_type is not None:
            self.site_network_access_type = site_network_access_type if site_network_access_type is not None else _default_site_network_access_type
        else:
            raise ValueError('Invalid default value for identityref leaf site-network-access: {error}')
        self.location_reference = location_reference
        self.device_reference = device_reference
        self.access_diversity = access_diversity if access_diversity is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity()
        self.bearer = bearer if bearer is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer()
        self.ip_connection = ip_connection if ip_connection is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection()
        self.security = security if security is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security()
        self.service = service
        self.routing_protocols = routing_protocols if routing_protocols is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols()
        self.availability = availability if availability is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability()
        self.vpn_attachment = vpn_attachment if vpn_attachment is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site_network_access_id = self.site_network_access_id
        if _site_network_access_id is not None:
            children['site-network-access-id'] = yang.gdata.Leaf('string', _site_network_access_id)
        _site_network_access_type = self.site_network_access_type
        if _site_network_access_type is not None:
            _identityref_site_network_access_type, error = complete_and_validate_identityref(_site_network_access_type, _identities, ['l3vpn-svc:site-network-access-type'], 'ietf-l3vpn-svc')
            if _identityref_site_network_access_type is not None:
                _site_network_access_type = _identityref_site_network_access_type
            else:
                raise ValueError('Invalid value for identityref leaf site-network-access-type: {error}')
            children['site-network-access-type'] = yang.gdata.Leaf('identityref', _site_network_access_type)
        _location_reference = self.location_reference
        if _location_reference is not None:
            children['location-reference'] = yang.gdata.Leaf('leafref', _location_reference)
        _device_reference = self.device_reference
        if _device_reference is not None:
            children['device-reference'] = yang.gdata.Leaf('leafref', _device_reference)
        _access_diversity = self.access_diversity
        if _access_diversity is not None:
            children['access-diversity'] = _access_diversity.to_gdata()
        _bearer = self.bearer
        if _bearer is not None:
            children['bearer'] = _bearer.to_gdata()
        _ip_connection = self.ip_connection
        if _ip_connection is not None:
            children['ip-connection'] = _ip_connection.to_gdata()
        _security = self.security
        if _security is not None:
            children['security'] = _security.to_gdata()
        _service = self.service
        if _service is not None:
            children['service'] = _service.to_gdata()
        _routing_protocols = self.routing_protocols
        if _routing_protocols is not None:
            children['routing-protocols'] = _routing_protocols.to_gdata()
        _availability = self.availability
        if _availability is not None:
            children['availability'] = _availability.to_gdata()
        _vpn_attachment = self.vpn_attachment
        if _vpn_attachment is not None:
            children['vpn-attachment'] = _vpn_attachment.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(site_network_access_id=n.get_str('site-network-access-id'), site_network_access_type=n.get_opt_Identityref('site-network-access-type'), location_reference=n.get_opt_str('location-reference'), device_reference=n.get_opt_str('device-reference'), access_diversity=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity.from_gdata(n.get_opt_cnt('access-diversity')), bearer=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer.from_gdata(n.get_opt_cnt('bearer')), ip_connection=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection.from_gdata(n.get_opt_cnt('ip-connection')), security=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security.from_gdata(n.get_opt_cnt('security')), service=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service.from_gdata(n.get_cnt('service')), routing_protocols=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols.from_gdata(n.get_opt_cnt('routing-protocols')), availability=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability.from_gdata(n.get_opt_cnt('availability')), vpn_attachment=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment.from_gdata(n.get_opt_cnt('vpn-attachment')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access')
            res.append('self_service = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service({repr(self.service.svc_input_bandwidth)}, {repr(self.service.svc_output_bandwidth)}, {repr(self.service.svc_mtu)})')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access({repr(self.site_network_access_id)}, self_service)')
        leaves = []
        _site_network_access_type = self.site_network_access_type
        if _site_network_access_type is not None:
            leaves.append('{self_name}.site_network_access_type = {repr(_site_network_access_type)}')
        _location_reference = self.location_reference
        if _location_reference is not None:
            leaves.append('{self_name}.location_reference = {repr(_location_reference)}')
        _device_reference = self.device_reference
        if _device_reference is not None:
            leaves.append('{self_name}.device_reference = {repr(_device_reference)}')
        _access_diversity = self.access_diversity
        if _access_diversity is not None:
            res.extend(_access_diversity.prsrc('{self_name}.access_diversity', False).splitlines())
        _bearer = self.bearer
        if _bearer is not None:
            res.extend(_bearer.prsrc('{self_name}.bearer', False).splitlines())
        _ip_connection = self.ip_connection
        if _ip_connection is not None:
            res.extend(_ip_connection.prsrc('{self_name}.ip_connection', False).splitlines())
        _security = self.security
        if _security is not None:
            res.extend(_security.prsrc('{self_name}.security', False).splitlines())
        _service = self.service
        if _service is not None:
            res.extend(_service.prsrc('{self_name}.service', False).splitlines())
        _routing_protocols = self.routing_protocols
        if _routing_protocols is not None:
            res.extend(_routing_protocols.prsrc('{self_name}.routing_protocols', False).splitlines())
        _availability = self.availability
        if _availability is not None:
            res.extend(_availability.prsrc('{self_name}.availability', False).splitlines())
        _vpn_attachment = self.vpn_attachment
        if _vpn_attachment is not None:
            res.extend(_vpn_attachment.prsrc('{self_name}.vpn_attachment', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'site-network-access'
        self.elements = elements

    mut def create(self, site_network_access_id, service):
        for e in self:
            match = True
            if e.site_network_access_id != site_network_access_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(site_network_access_id, service)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['site-network-access-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_site_network_access_id = yang.gdata.from_xml_str(node, 'site-network-access-id')
    yang.gdata.maybe_add(children, 'site-network-access-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_id, child_site_network_access_id)
    child_site_network_access_type = yang.gdata.from_xml_opt_Identityref(node, 'site-network-access-type')
    yang.gdata.maybe_add(children, 'site-network-access-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_type, child_site_network_access_type)
    child_location_reference = yang.gdata.from_xml_opt_str(node, 'location-reference')
    yang.gdata.maybe_add(children, 'location-reference', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__location_reference, child_location_reference)
    child_device_reference = yang.gdata.from_xml_opt_str(node, 'device-reference')
    yang.gdata.maybe_add(children, 'device-reference', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__device_reference, child_device_reference)
    child_access_diversity = yang.gdata.from_xml_opt_cnt(node, 'access-diversity')
    yang.gdata.maybe_add(children, 'access-diversity', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity, child_access_diversity)
    child_bearer = yang.gdata.from_xml_opt_cnt(node, 'bearer')
    yang.gdata.maybe_add(children, 'bearer', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer, child_bearer)
    child_ip_connection = yang.gdata.from_xml_opt_cnt(node, 'ip-connection')
    yang.gdata.maybe_add(children, 'ip-connection', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection, child_ip_connection)
    child_security = yang.gdata.from_xml_opt_cnt(node, 'security')
    yang.gdata.maybe_add(children, 'security', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security, child_security)
    child_service = yang.gdata.from_xml_cnt(node, 'service')
    yang.gdata.maybe_add(children, 'service', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service, child_service)
    child_routing_protocols = yang.gdata.from_xml_opt_cnt(node, 'routing-protocols')
    yang.gdata.maybe_add(children, 'routing-protocols', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols, child_routing_protocols)
    child_availability = yang.gdata.from_xml_opt_cnt(node, 'availability')
    yang.gdata.maybe_add(children, 'availability', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability, child_availability)
    child_vpn_attachment = yang.gdata.from_xml_opt_cnt(node, 'vpn-attachment')
    yang.gdata.maybe_add(children, 'vpn-attachment', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment, child_vpn_attachment)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(e) for e in nodes]
    return yang.gdata.List(keys=['site-network-access-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['site-network-access-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['site-network-access-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_id(keys[0])
        if point == 'site-network-access-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'location-reference':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'device-reference':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'access-diversity':
            children['access-diversity'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(jd, rest_path, op)
        if point == 'bearer':
            children['bearer'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(jd, rest_path, op)
        if point == 'ip-connection':
            children['ip-connection'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(jd, rest_path, op)
        if point == 'security':
            children['security'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(jd, rest_path, op)
        if point == 'service':
            children['service'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(jd, rest_path, op)
        if point == 'routing-protocols':
            children['routing-protocols'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(jd, rest_path, op)
        if point == 'availability':
            children['availability'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(jd, rest_path, op)
        if point == 'vpn-attachment':
            children['vpn-attachment'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['site-network-access-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['site-network-access-id'])))
        return yang.gdata.List(['site-network-access-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['site-network-access-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_site_network_access_id = yang.gdata.take_json_str(jd, 'site-network-access-id')
    yang.gdata.maybe_add(children, 'site-network-access-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_id, child_site_network_access_id)
    child_site_network_access_type = yang.gdata.take_json_opt_Identityref(jd, 'site-network-access-type')
    yang.gdata.maybe_add(children, 'site-network-access-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_type, child_site_network_access_type)
    child_location_reference = yang.gdata.take_json_opt_str(jd, 'location-reference')
    yang.gdata.maybe_add(children, 'location-reference', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__location_reference, child_location_reference)
    child_device_reference = yang.gdata.take_json_opt_str(jd, 'device-reference')
    yang.gdata.maybe_add(children, 'device-reference', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__device_reference, child_device_reference)
    child_access_diversity = yang.gdata.take_json_opt_cnt(jd, 'access-diversity')
    yang.gdata.maybe_add(children, 'access-diversity', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity, child_access_diversity)
    child_bearer = yang.gdata.take_json_opt_cnt(jd, 'bearer')
    yang.gdata.maybe_add(children, 'bearer', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer, child_bearer)
    child_ip_connection = yang.gdata.take_json_opt_cnt(jd, 'ip-connection')
    yang.gdata.maybe_add(children, 'ip-connection', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection, child_ip_connection)
    child_security = yang.gdata.take_json_opt_cnt(jd, 'security')
    yang.gdata.maybe_add(children, 'security', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security, child_security)
    child_service = yang.gdata.take_json_cnt(jd, 'service')
    yang.gdata.maybe_add(children, 'service', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service, child_service)
    child_routing_protocols = yang.gdata.take_json_opt_cnt(jd, 'routing-protocols')
    yang.gdata.maybe_add(children, 'routing-protocols', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols, child_routing_protocols)
    child_availability = yang.gdata.take_json_opt_cnt(jd, 'availability')
    yang.gdata.maybe_add(children, 'availability', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability, child_availability)
    child_vpn_attachment = yang.gdata.take_json_opt_cnt(jd, 'vpn-attachment')
    yang.gdata.maybe_add(children, 'vpn-attachment', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment, child_vpn_attachment)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['site-network-access-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(yang.adata.MNode):
    site_network_access: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access

    mut def __init__(self, site_network_access: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site_network_access = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(elements=site_network_access)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site_network_access = self.site_network_access
        if _site_network_access is not None:
            children['site-network-access'] = _site_network_access.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(site_network_access=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access.from_gdata(n.get_opt_list('site-network-access')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses()')
        leaves = []
        _site_network_access = self.site_network_access
        for _element in _site_network_access:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access element: {_element.to_gdata().key_str(['site-network-access-id'])}")
            res.append('element_service = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service({repr(_element.service.svc_input_bandwidth)}, {repr(_element.service.svc_output_bandwidth)}, {repr(_element.service.svc_mtu)})')
            list_elem = 'site_network_access_element = {self_name}.site_network_access.create({repr(_element.site_network_access_id)}, element_service)'
            res.append(list_elem)
            res.extend(_element.prsrc('site_network_access_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_site_network_access = yang.gdata.from_xml_opt_list(node, 'site-network-access')
    yang.gdata.maybe_add(children, 'site-network-access', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access, child_site_network_access)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'site-network-access':
            child = {'site-network-access': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_site_network_access = yang.gdata.take_json_opt_list(jd, 'site-network-access')
    yang.gdata.maybe_add(children, 'site-network-access', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access, child_site_network_access)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(yang.adata.MNode):
    site_id: str
    requested_site_start: ?str
    requested_site_stop: ?str
    locations: ietf_l3vpn_svc__l3vpn_svc__sites__site__locations
    devices: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices
    site_diversity: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity
    management: ietf_l3vpn_svc__l3vpn_svc__sites__site__management
    vpn_policies: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies
    site_vpn_flavor: Identityref
    maximum_routes: ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes
    security: ietf_l3vpn_svc__l3vpn_svc__sites__site__security
    service: ietf_l3vpn_svc__l3vpn_svc__sites__site__service
    traffic_protection: ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection
    routing_protocols: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols
    site_network_accesses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses

    mut def __init__(self, site_id: str, management: ietf_l3vpn_svc__l3vpn_svc__sites__site__management, requested_site_start: ?str, requested_site_stop: ?str, locations: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__locations=None, devices: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__devices=None, site_diversity: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity=None, vpn_policies: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies=None, site_vpn_flavor: ?Identityref=None, maximum_routes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes=None, security: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security=None, service: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service=None, traffic_protection: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection=None, routing_protocols: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols=None, site_network_accesses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site_id = site_id
        self.requested_site_start = requested_site_start
        self.requested_site_stop = requested_site_stop
        self.locations = locations if locations is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__locations()
        self.devices = devices if devices is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__devices()
        self.site_diversity = site_diversity if site_diversity is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity()
        self.management = management
        self.vpn_policies = vpn_policies if vpn_policies is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies()
        _default_site_vpn_flavor, error = complete_and_validate_identityref(Identityref.from_adata('site-vpn-flavor-single'), _identities, ['l3vpn-svc:site-vpn-flavor'], 'ietf-l3vpn-svc')
        if _default_site_vpn_flavor is not None:
            self.site_vpn_flavor = site_vpn_flavor if site_vpn_flavor is not None else _default_site_vpn_flavor
        else:
            raise ValueError('Invalid default value for identityref leaf site: {error}')
        self.maximum_routes = maximum_routes if maximum_routes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes()
        self.security = security if security is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security()
        self.service = service if service is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service()
        self.traffic_protection = traffic_protection if traffic_protection is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection()
        self.routing_protocols = routing_protocols if routing_protocols is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols()
        self.site_network_accesses = site_network_accesses if site_network_accesses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site_id = self.site_id
        if _site_id is not None:
            children['site-id'] = yang.gdata.Leaf('string', _site_id)
        _requested_site_start = self.requested_site_start
        if _requested_site_start is not None:
            children['requested-site-start'] = yang.gdata.Leaf('string', _requested_site_start)
        _requested_site_stop = self.requested_site_stop
        if _requested_site_stop is not None:
            children['requested-site-stop'] = yang.gdata.Leaf('string', _requested_site_stop)
        _locations = self.locations
        if _locations is not None:
            children['locations'] = _locations.to_gdata()
        _devices = self.devices
        if _devices is not None:
            children['devices'] = _devices.to_gdata()
        _site_diversity = self.site_diversity
        if _site_diversity is not None:
            children['site-diversity'] = _site_diversity.to_gdata()
        _management = self.management
        if _management is not None:
            children['management'] = _management.to_gdata()
        _vpn_policies = self.vpn_policies
        if _vpn_policies is not None:
            children['vpn-policies'] = _vpn_policies.to_gdata()
        _site_vpn_flavor = self.site_vpn_flavor
        if _site_vpn_flavor is not None:
            _identityref_site_vpn_flavor, error = complete_and_validate_identityref(_site_vpn_flavor, _identities, ['l3vpn-svc:site-vpn-flavor'], 'ietf-l3vpn-svc')
            if _identityref_site_vpn_flavor is not None:
                _site_vpn_flavor = _identityref_site_vpn_flavor
            else:
                raise ValueError('Invalid value for identityref leaf site-vpn-flavor: {error}')
            children['site-vpn-flavor'] = yang.gdata.Leaf('identityref', _site_vpn_flavor)
        _maximum_routes = self.maximum_routes
        if _maximum_routes is not None:
            children['maximum-routes'] = _maximum_routes.to_gdata()
        _security = self.security
        if _security is not None:
            children['security'] = _security.to_gdata()
        _service = self.service
        if _service is not None:
            children['service'] = _service.to_gdata()
        _traffic_protection = self.traffic_protection
        if _traffic_protection is not None:
            children['traffic-protection'] = _traffic_protection.to_gdata()
        _routing_protocols = self.routing_protocols
        if _routing_protocols is not None:
            children['routing-protocols'] = _routing_protocols.to_gdata()
        _site_network_accesses = self.site_network_accesses
        if _site_network_accesses is not None:
            children['site-network-accesses'] = _site_network_accesses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(site_id=n.get_str('site-id'), requested_site_start=n.get_opt_str('requested-site-start'), requested_site_stop=n.get_opt_str('requested-site-stop'), locations=ietf_l3vpn_svc__l3vpn_svc__sites__site__locations.from_gdata(n.get_opt_cnt('locations')), devices=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices.from_gdata(n.get_opt_cnt('devices')), site_diversity=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity.from_gdata(n.get_opt_cnt('site-diversity')), management=ietf_l3vpn_svc__l3vpn_svc__sites__site__management.from_gdata(n.get_cnt('management')), vpn_policies=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies.from_gdata(n.get_opt_cnt('vpn-policies')), site_vpn_flavor=n.get_opt_Identityref('site-vpn-flavor'), maximum_routes=ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes.from_gdata(n.get_opt_cnt('maximum-routes')), security=ietf_l3vpn_svc__l3vpn_svc__sites__site__security.from_gdata(n.get_opt_cnt('security')), service=ietf_l3vpn_svc__l3vpn_svc__sites__site__service.from_gdata(n.get_opt_cnt('service')), traffic_protection=ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection.from_gdata(n.get_opt_cnt('traffic-protection')), routing_protocols=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols.from_gdata(n.get_opt_cnt('routing-protocols')), site_network_accesses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses.from_gdata(n.get_opt_cnt('site-network-accesses')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site')
            res.append('self_management = ietf_l3vpn_svc__l3vpn_svc__sites__site__management({repr(self.management.type)})')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site({repr(self.site_id)}, self_management)')
        leaves = []
        _requested_site_start = self.requested_site_start
        if _requested_site_start is not None:
            leaves.append('{self_name}.requested_site_start = {repr(_requested_site_start)}')
        _requested_site_stop = self.requested_site_stop
        if _requested_site_stop is not None:
            leaves.append('{self_name}.requested_site_stop = {repr(_requested_site_stop)}')
        _locations = self.locations
        if _locations is not None:
            res.extend(_locations.prsrc('{self_name}.locations', False).splitlines())
        _devices = self.devices
        if _devices is not None:
            res.extend(_devices.prsrc('{self_name}.devices', False).splitlines())
        _site_diversity = self.site_diversity
        if _site_diversity is not None:
            res.extend(_site_diversity.prsrc('{self_name}.site_diversity', False).splitlines())
        _management = self.management
        if _management is not None:
            res.extend(_management.prsrc('{self_name}.management', False).splitlines())
        _vpn_policies = self.vpn_policies
        if _vpn_policies is not None:
            res.extend(_vpn_policies.prsrc('{self_name}.vpn_policies', False).splitlines())
        _site_vpn_flavor = self.site_vpn_flavor
        if _site_vpn_flavor is not None:
            leaves.append('{self_name}.site_vpn_flavor = {repr(_site_vpn_flavor)}')
        _maximum_routes = self.maximum_routes
        if _maximum_routes is not None:
            res.extend(_maximum_routes.prsrc('{self_name}.maximum_routes', False).splitlines())
        _security = self.security
        if _security is not None:
            res.extend(_security.prsrc('{self_name}.security', False).splitlines())
        _service = self.service
        if _service is not None:
            res.extend(_service.prsrc('{self_name}.service', False).splitlines())
        _traffic_protection = self.traffic_protection
        if _traffic_protection is not None:
            res.extend(_traffic_protection.prsrc('{self_name}.traffic_protection', False).splitlines())
        _routing_protocols = self.routing_protocols
        if _routing_protocols is not None:
            res.extend(_routing_protocols.prsrc('{self_name}.routing_protocols', False).splitlines())
        _site_network_accesses = self.site_network_accesses
        if _site_network_accesses is not None:
            res.extend(_site_network_accesses.prsrc('{self_name}.site_network_accesses', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site'])

class ietf_l3vpn_svc__l3vpn_svc__sites__site(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'site'
        self.elements = elements

    mut def create(self, site_id, management):
        for e in self:
            match = True
            if e.site_id != site_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(site_id, management)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['site-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]:
        return self.elements.__iter__()

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_site_id = yang.gdata.from_xml_str(node, 'site-id')
    yang.gdata.maybe_add(children, 'site-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_id, child_site_id)
    child_requested_site_start = yang.gdata.from_xml_opt_str(node, 'requested-site-start')
    yang.gdata.maybe_add(children, 'requested-site-start', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_start, child_requested_site_start)
    child_requested_site_stop = yang.gdata.from_xml_opt_str(node, 'requested-site-stop')
    yang.gdata.maybe_add(children, 'requested-site-stop', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_stop, child_requested_site_stop)
    child_locations = yang.gdata.from_xml_opt_cnt(node, 'locations')
    yang.gdata.maybe_add(children, 'locations', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations, child_locations)
    child_devices = yang.gdata.from_xml_opt_cnt(node, 'devices')
    yang.gdata.maybe_add(children, 'devices', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices, child_devices)
    child_site_diversity = yang.gdata.from_xml_opt_cnt(node, 'site-diversity')
    yang.gdata.maybe_add(children, 'site-diversity', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity, child_site_diversity)
    child_management = yang.gdata.from_xml_cnt(node, 'management')
    yang.gdata.maybe_add(children, 'management', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__management, child_management)
    child_vpn_policies = yang.gdata.from_xml_opt_cnt(node, 'vpn-policies')
    yang.gdata.maybe_add(children, 'vpn-policies', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies, child_vpn_policies)
    child_site_vpn_flavor = yang.gdata.from_xml_opt_Identityref(node, 'site-vpn-flavor')
    yang.gdata.maybe_add(children, 'site-vpn-flavor', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_vpn_flavor, child_site_vpn_flavor)
    child_maximum_routes = yang.gdata.from_xml_opt_cnt(node, 'maximum-routes')
    yang.gdata.maybe_add(children, 'maximum-routes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes, child_maximum_routes)
    child_security = yang.gdata.from_xml_opt_cnt(node, 'security')
    yang.gdata.maybe_add(children, 'security', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security, child_security)
    child_service = yang.gdata.from_xml_opt_cnt(node, 'service')
    yang.gdata.maybe_add(children, 'service', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service, child_service)
    child_traffic_protection = yang.gdata.from_xml_opt_cnt(node, 'traffic-protection')
    yang.gdata.maybe_add(children, 'traffic-protection', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection, child_traffic_protection)
    child_routing_protocols = yang.gdata.from_xml_opt_cnt(node, 'routing-protocols')
    yang.gdata.maybe_add(children, 'routing-protocols', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols, child_routing_protocols)
    child_site_network_accesses = yang.gdata.from_xml_opt_cnt(node, 'site-network-accesses')
    yang.gdata.maybe_add(children, 'site-network-accesses', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses, child_site_network_accesses)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(e) for e in nodes]
    return yang.gdata.List(keys=['site-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['site-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['site-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_id(keys[0])
        if point == 'requested-site-start':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'requested-site-stop':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'locations':
            children['locations'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(jd, rest_path, op)
        if point == 'devices':
            children['devices'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(jd, rest_path, op)
        if point == 'site-diversity':
            children['site-diversity'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(jd, rest_path, op)
        if point == 'management':
            children['management'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(jd, rest_path, op)
        if point == 'vpn-policies':
            children['vpn-policies'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(jd, rest_path, op)
        if point == 'site-vpn-flavor':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'maximum-routes':
            children['maximum-routes'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(jd, rest_path, op)
        if point == 'security':
            children['security'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(jd, rest_path, op)
        if point == 'service':
            children['service'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(jd, rest_path, op)
        if point == 'traffic-protection':
            children['traffic-protection'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(jd, rest_path, op)
        if point == 'routing-protocols':
            children['routing-protocols'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(jd, rest_path, op)
        if point == 'site-network-accesses':
            children['site-network-accesses'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['site-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['site-id'])))
        return yang.gdata.List(['site-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['site-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_site_id = yang.gdata.take_json_str(jd, 'site-id')
    yang.gdata.maybe_add(children, 'site-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_id, child_site_id)
    child_requested_site_start = yang.gdata.take_json_opt_str(jd, 'requested-site-start')
    yang.gdata.maybe_add(children, 'requested-site-start', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_start, child_requested_site_start)
    child_requested_site_stop = yang.gdata.take_json_opt_str(jd, 'requested-site-stop')
    yang.gdata.maybe_add(children, 'requested-site-stop', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_stop, child_requested_site_stop)
    child_locations = yang.gdata.take_json_opt_cnt(jd, 'locations')
    yang.gdata.maybe_add(children, 'locations', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations, child_locations)
    child_devices = yang.gdata.take_json_opt_cnt(jd, 'devices')
    yang.gdata.maybe_add(children, 'devices', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices, child_devices)
    child_site_diversity = yang.gdata.take_json_opt_cnt(jd, 'site-diversity')
    yang.gdata.maybe_add(children, 'site-diversity', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity, child_site_diversity)
    child_management = yang.gdata.take_json_cnt(jd, 'management')
    yang.gdata.maybe_add(children, 'management', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management, child_management)
    child_vpn_policies = yang.gdata.take_json_opt_cnt(jd, 'vpn-policies')
    yang.gdata.maybe_add(children, 'vpn-policies', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies, child_vpn_policies)
    child_site_vpn_flavor = yang.gdata.take_json_opt_Identityref(jd, 'site-vpn-flavor')
    yang.gdata.maybe_add(children, 'site-vpn-flavor', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_vpn_flavor, child_site_vpn_flavor)
    child_maximum_routes = yang.gdata.take_json_opt_cnt(jd, 'maximum-routes')
    yang.gdata.maybe_add(children, 'maximum-routes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes, child_maximum_routes)
    child_security = yang.gdata.take_json_opt_cnt(jd, 'security')
    yang.gdata.maybe_add(children, 'security', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security, child_security)
    child_service = yang.gdata.take_json_opt_cnt(jd, 'service')
    yang.gdata.maybe_add(children, 'service', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service, child_service)
    child_traffic_protection = yang.gdata.take_json_opt_cnt(jd, 'traffic-protection')
    yang.gdata.maybe_add(children, 'traffic-protection', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection, child_traffic_protection)
    child_routing_protocols = yang.gdata.take_json_opt_cnt(jd, 'routing-protocols')
    yang.gdata.maybe_add(children, 'routing-protocols', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols, child_routing_protocols)
    child_site_network_accesses = yang.gdata.take_json_opt_cnt(jd, 'site-network-accesses')
    yang.gdata.maybe_add(children, 'site-network-accesses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses, child_site_network_accesses)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['site-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites(yang.adata.MNode):
    site: ietf_l3vpn_svc__l3vpn_svc__sites__site

    mut def __init__(self, site: list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site = ietf_l3vpn_svc__l3vpn_svc__sites__site(elements=site)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site = self.site
        if _site is not None:
            children['site'] = _site.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites(site=ietf_l3vpn_svc__l3vpn_svc__sites__site.from_gdata(n.get_opt_list('site')))
        return ietf_l3vpn_svc__l3vpn_svc__sites()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites()')
        leaves = []
        _site = self.site
        for _element in _site:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site element: {_element.to_gdata().key_str(['site-id'])}")
            res.append('element_management = ietf_l3vpn_svc__l3vpn_svc__sites__site__management({repr(_element.management.type)})')
            list_elem = 'site_element = {self_name}.site.create({repr(_element.site_id)}, element_management)'
            res.append(list_elem)
            res.extend(_element.prsrc('site_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_site = yang.gdata.from_xml_opt_list(node, 'site')
    yang.gdata.maybe_add(children, 'site', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site, child_site)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'site':
            child = {'site': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_site = yang.gdata.take_json_opt_list(jd, 'site')
    yang.gdata.maybe_add(children, 'site', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site, child_site)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc(yang.adata.MNode):
    vpn_profiles: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles
    vpn_services: ietf_l3vpn_svc__l3vpn_svc__vpn_services
    sites: ietf_l3vpn_svc__l3vpn_svc__sites

    mut def __init__(self, vpn_profiles: ?ietf_l3vpn_svc__l3vpn_svc__vpn_profiles=None, vpn_services: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services=None, sites: ?ietf_l3vpn_svc__l3vpn_svc__sites=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_profiles = vpn_profiles if vpn_profiles is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_profiles()
        self.vpn_services = vpn_services if vpn_services is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services()
        self.sites = sites if sites is not None else ietf_l3vpn_svc__l3vpn_svc__sites()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_profiles = self.vpn_profiles
        if _vpn_profiles is not None:
            children['vpn-profiles'] = _vpn_profiles.to_gdata()
        _vpn_services = self.vpn_services
        if _vpn_services is not None:
            children['vpn-services'] = _vpn_services.to_gdata()
        _sites = self.sites
        if _sites is not None:
            children['sites'] = _sites.to_gdata()
        return yang.gdata.Container(children, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc(vpn_profiles=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles.from_gdata(n.get_opt_cnt('vpn-profiles')), vpn_services=ietf_l3vpn_svc__l3vpn_svc__vpn_services.from_gdata(n.get_opt_cnt('vpn-services')), sites=ietf_l3vpn_svc__l3vpn_svc__sites.from_gdata(n.get_opt_cnt('sites')))
        return ietf_l3vpn_svc__l3vpn_svc()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc()')
        leaves = []
        _vpn_profiles = self.vpn_profiles
        if _vpn_profiles is not None:
            res.extend(_vpn_profiles.prsrc('{self_name}.vpn_profiles', False).splitlines())
        _vpn_services = self.vpn_services
        if _vpn_services is not None:
            res.extend(_vpn_services.prsrc('{self_name}.vpn_services', False).splitlines())
        _sites = self.sites
        if _sites is not None:
            res.extend(_sites.prsrc('{self_name}.sites', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc'])


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_vpn_profiles = yang.gdata.from_xml_opt_cnt(node, 'vpn-profiles')
    yang.gdata.maybe_add(children, 'vpn-profiles', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles, child_vpn_profiles)
    child_vpn_services = yang.gdata.from_xml_opt_cnt(node, 'vpn-services')
    yang.gdata.maybe_add(children, 'vpn-services', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services, child_vpn_services)
    child_sites = yang.gdata.from_xml_opt_cnt(node, 'sites')
    yang.gdata.maybe_add(children, 'sites', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites, child_sites)
    return yang.gdata.Container(children, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'vpn-profiles':
            child = {'vpn-profiles': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')
        if point == 'vpn-services':
            child = {'vpn-services': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')
        if point == 'sites':
            child = {'sites': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_profiles = yang.gdata.take_json_opt_cnt(jd, 'vpn-profiles')
    yang.gdata.maybe_add(children, 'vpn-profiles', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles, child_vpn_profiles)
    child_vpn_services = yang.gdata.take_json_opt_cnt(jd, 'vpn-services')
    yang.gdata.maybe_add(children, 'vpn-services', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services, child_vpn_services)
    child_sites = yang.gdata.take_json_opt_cnt(jd, 'sites')
    yang.gdata.maybe_add(children, 'sites', from_json_ietf_l3vpn_svc__l3vpn_svc__sites, child_sites)
    return yang.gdata.Container(children, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')

class root(yang.adata.MNode):
    netinfra: netinfra__netinfra
    l3vpn_svc: ietf_l3vpn_svc__l3vpn_svc

    mut def __init__(self, netinfra: ?netinfra__netinfra=None, l3vpn_svc: ?ietf_l3vpn_svc__l3vpn_svc=None):
        self._ns = ''
        self.netinfra = netinfra if netinfra is not None else netinfra__netinfra()
        self.l3vpn_svc = l3vpn_svc if l3vpn_svc is not None else ietf_l3vpn_svc__l3vpn_svc()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _netinfra = self.netinfra
        if _netinfra is not None:
            children['netinfra'] = _netinfra.to_gdata()
        _l3vpn_svc = self.l3vpn_svc
        if _l3vpn_svc is not None:
            children['l3vpn-svc'] = _l3vpn_svc.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> root:
        if n is not None:
            return root(netinfra=netinfra__netinfra.from_gdata(n.get_opt_cnt('netinfra')), l3vpn_svc=ietf_l3vpn_svc__l3vpn_svc.from_gdata(n.get_opt_cnt('l3vpn-svc')))
        return root()

    def copy(self):
        """Create a deep copy of this adata object"""
        return root.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /root')
            res.append('{self_name} = root()')
        leaves = []
        _netinfra = self.netinfra
        if _netinfra is not None:
            res.extend(_netinfra.prsrc('{self_name}.netinfra', False).splitlines())
        _l3vpn_svc = self.l3vpn_svc
        if _l3vpn_svc is not None:
            res.extend(_l3vpn_svc.prsrc('{self_name}.l3vpn_svc', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /root'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=False)


mut def from_xml(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_netinfra = yang.gdata.from_xml_opt_cnt(node, 'netinfra', 'http://example.com/netinfra')
    yang.gdata.maybe_add(children, 'netinfra', from_xml_netinfra__netinfra, child_netinfra)
    child_l3vpn_svc = yang.gdata.from_xml_opt_cnt(node, 'l3vpn-svc', 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc')
    yang.gdata.maybe_add(children, 'l3vpn-svc', from_xml_ietf_l3vpn_svc__l3vpn_svc, child_l3vpn_svc)
    return yang.gdata.Container(children)

def from_xml_gen3(node: xml.Node, root_path: list[str]=[]) -> yang.gdata.Container:
    # WARNING: this wrapper for the gen3.from_xml schema-driven parser compiles the schema on every call!
    s = yang.compile(src_yang())
    return yang.gen3.from_xml(s, node, loose=False, root_path=root_path)

mut def from_json_path(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'netinfra:netinfra':
            child = {'netinfra': from_json_path_netinfra__netinfra(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'ietf-l3vpn-svc:l3vpn-svc':
            child = {'l3vpn-svc': from_json_path_ietf_l3vpn_svc__l3vpn_svc(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_netinfra = yang.gdata.take_json_opt_cnt(jd, 'netinfra', 'netinfra')
    yang.gdata.maybe_add(children, 'netinfra', from_json_netinfra__netinfra, child_netinfra)
    child_l3vpn_svc = yang.gdata.take_json_opt_cnt(jd, 'l3vpn-svc', 'ietf-l3vpn-svc')
    yang.gdata.maybe_add(children, 'l3vpn-svc', from_json_ietf_l3vpn_svc__l3vpn_svc, child_l3vpn_svc)
    return yang.gdata.Container(children)

def from_json_gen3(jd: dict[str, ?value], root_path: list[str]=[]) -> yang.gdata.Container:
    # WARNING: this wrapper for the gen3.from_json schema-driven parser compiles the schema on every call!
    s = yang.compile(src_yang())
    return yang.gen3.from_json(s, jd, loose=False, root_path=root_path)

def from_json_path_gen3(jd: dict[str, ?value], path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    s = yang.compile(src_yang())
    return yang.gen3.from_json_path(s, jd, path, op, loose=False)

schema_namespaces: set[str] = {
    'http://example.com/netinfra',
    'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc',
}

def prsrc_gen3(data, self_name='ad'):
    # WARNING: this wrapper for the gen3.prsrc schema-driven parser compiles the schema on every call!
    s = yang.compile(src_yang())
    return yang.gen3.pradata(s, data, self_name, loose=False)
