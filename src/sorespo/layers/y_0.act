import base64
import json
import xml
import yang
import yang.adata
import yang.gdata
import yang.gen3
from yang.gdata import repr_yang
from yang.identityref import Identityref, PartialIdentityref
from yang.pattern import YangPattern
from yang.schema import *
from yang.type import Decimal, Ranges

# == This file is generated ==




_base_ietf_l3vpn_svc_site_network_access_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-network-access-type', base=[])
_base_ietf_l3vpn_svc_placement_diversity = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='placement-diversity', base=[])
_base_ietf_l3vpn_svc_customer_application = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application', base=[])
_base_ietf_l3vpn_svc_site_vpn_flavor = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor', base=[])
_base_ietf_l3vpn_svc_management = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='management', base=[])
_base_ietf_l3vpn_svc_address_allocation_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-allocation-type', base=[])
_base_ietf_l3vpn_svc_site_role = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-role', base=[])
_base_ietf_l3vpn_svc_vpn_topology = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-topology', base=[])
_base_ietf_l3vpn_svc_multicast_tree_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-tree-type', base=[])
_base_ietf_l3vpn_svc_multicast_rp_discovery_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-rp-discovery-type', base=[])
_base_ietf_l3vpn_svc_routing_protocol_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing-protocol-type', base=[])
_base_ietf_l3vpn_svc_protocol_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type', base=[])
_base_ietf_l3vpn_svc_vpn_policy_filter_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-policy-filter-type', base=[])
_base_ietf_l3vpn_svc_qos_profile_direction = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='qos-profile-direction', base=[])
_identities = [
    _base_ietf_l3vpn_svc_site_network_access_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='point-to-point', base=[_base_ietf_l3vpn_svc_site_network_access_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multipoint', base=[_base_ietf_l3vpn_svc_site_network_access_type]),
    _base_ietf_l3vpn_svc_placement_diversity,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bearer-diverse', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='pe-diverse', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='pop-diverse', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='linecard-diverse', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='same-pe', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='same-bearer', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    _base_ietf_l3vpn_svc_customer_application,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='web', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='mail', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='file-transfer', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='database', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='social', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='games', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='p2p', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='network-management', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='voice', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='video', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='embb', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='urllc', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='mmtc', base=[_base_ietf_l3vpn_svc_customer_application]),
    _base_ietf_l3vpn_svc_site_vpn_flavor,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-single', base=[_base_ietf_l3vpn_svc_site_vpn_flavor]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-multi', base=[_base_ietf_l3vpn_svc_site_vpn_flavor]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-sub', base=[_base_ietf_l3vpn_svc_site_vpn_flavor]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-nni', base=[_base_ietf_l3vpn_svc_site_vpn_flavor]),
    _base_ietf_l3vpn_svc_management,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='co-managed', base=[_base_ietf_l3vpn_svc_management]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-managed', base=[_base_ietf_l3vpn_svc_management]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-managed', base=[_base_ietf_l3vpn_svc_management]),
    _base_ietf_l3vpn_svc_address_allocation_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-dhcp', base=[_base_ietf_l3vpn_svc_address_allocation_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-dhcp-relay', base=[_base_ietf_l3vpn_svc_address_allocation_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-dhcp-slaac', base=[_base_ietf_l3vpn_svc_address_allocation_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='static-address', base=[_base_ietf_l3vpn_svc_address_allocation_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='slaac', base=[_base_ietf_l3vpn_svc_address_allocation_type]),
    _base_ietf_l3vpn_svc_site_role,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='any-to-any-role', base=[_base_ietf_l3vpn_svc_site_role]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='spoke-role', base=[_base_ietf_l3vpn_svc_site_role]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hub-role', base=[_base_ietf_l3vpn_svc_site_role]),
    _base_ietf_l3vpn_svc_vpn_topology,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='any-to-any', base=[_base_ietf_l3vpn_svc_vpn_topology]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hub-spoke', base=[_base_ietf_l3vpn_svc_vpn_topology]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hub-spoke-disjoint', base=[_base_ietf_l3vpn_svc_vpn_topology]),
    _base_ietf_l3vpn_svc_multicast_tree_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ssm-tree-type', base=[_base_ietf_l3vpn_svc_multicast_tree_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='asm-tree-type', base=[_base_ietf_l3vpn_svc_multicast_tree_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bidir-tree-type', base=[_base_ietf_l3vpn_svc_multicast_tree_type]),
    _base_ietf_l3vpn_svc_multicast_rp_discovery_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='auto-rp', base=[_base_ietf_l3vpn_svc_multicast_rp_discovery_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='static-rp', base=[_base_ietf_l3vpn_svc_multicast_rp_discovery_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bsr-rp', base=[_base_ietf_l3vpn_svc_multicast_rp_discovery_type]),
    _base_ietf_l3vpn_svc_routing_protocol_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ospf', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bgp', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='static', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rip', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vrrp', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='direct', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    _base_ietf_l3vpn_svc_protocol_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='tcp', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='udp', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='icmp', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='icmp6', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='gre', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipip', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hop-by-hop', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='esp', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ah', base=[_base_ietf_l3vpn_svc_protocol_type]),
    _base_ietf_l3vpn_svc_vpn_policy_filter_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv4', base=[_base_ietf_l3vpn_svc_vpn_policy_filter_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv6', base=[_base_ietf_l3vpn_svc_vpn_policy_filter_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lan', base=[_base_ietf_l3vpn_svc_vpn_policy_filter_type]),
    _base_ietf_l3vpn_svc_qos_profile_direction,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-to-wan', base=[_base_ietf_l3vpn_svc_qos_profile_direction]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='wan-to-site', base=[_base_ietf_l3vpn_svc_qos_profile_direction]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='both', base=[_base_ietf_l3vpn_svc_qos_profile_direction]),
]


# Identityref constants
ietf_l3vpn_svc_site_network_access_type = Identityref('site-network-access-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_point_to_point = Identityref('point-to-point', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_multipoint = Identityref('multipoint', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_placement_diversity = Identityref('placement-diversity', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_bearer_diverse = Identityref('bearer-diverse', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_pe_diverse = Identityref('pe-diverse', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_pop_diverse = Identityref('pop-diverse', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_linecard_diverse = Identityref('linecard-diverse', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_same_pe = Identityref('same-pe', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_same_bearer = Identityref('same-bearer', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_customer_application = Identityref('customer-application', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_web = Identityref('web', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_mail = Identityref('mail', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_file_transfer = Identityref('file-transfer', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_database = Identityref('database', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_social = Identityref('social', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_games = Identityref('games', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_p2p = Identityref('p2p', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_network_management = Identityref('network-management', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_voice = Identityref('voice', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_video = Identityref('video', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_embb = Identityref('embb', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_urllc = Identityref('urllc', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_mmtc = Identityref('mmtc', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_vpn_flavor = Identityref('site-vpn-flavor', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_vpn_flavor_single = Identityref('site-vpn-flavor-single', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_vpn_flavor_multi = Identityref('site-vpn-flavor-multi', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_vpn_flavor_sub = Identityref('site-vpn-flavor-sub', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_vpn_flavor_nni = Identityref('site-vpn-flavor-nni', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_management = Identityref('management', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_co_managed = Identityref('co-managed', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_customer_managed = Identityref('customer-managed', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_provider_managed = Identityref('provider-managed', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_address_allocation_type = Identityref('address-allocation-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_provider_dhcp = Identityref('provider-dhcp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_provider_dhcp_relay = Identityref('provider-dhcp-relay', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_provider_dhcp_slaac = Identityref('provider-dhcp-slaac', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_static_address = Identityref('static-address', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_slaac = Identityref('slaac', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_role = Identityref('site-role', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_any_to_any_role = Identityref('any-to-any-role', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_spoke_role = Identityref('spoke-role', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_hub_role = Identityref('hub-role', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_vpn_topology = Identityref('vpn-topology', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_any_to_any = Identityref('any-to-any', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_hub_spoke = Identityref('hub-spoke', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_hub_spoke_disjoint = Identityref('hub-spoke-disjoint', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_multicast_tree_type = Identityref('multicast-tree-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ssm_tree_type = Identityref('ssm-tree-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_asm_tree_type = Identityref('asm-tree-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_bidir_tree_type = Identityref('bidir-tree-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_multicast_rp_discovery_type = Identityref('multicast-rp-discovery-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_auto_rp = Identityref('auto-rp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_static_rp = Identityref('static-rp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_bsr_rp = Identityref('bsr-rp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_routing_protocol_type = Identityref('routing-protocol-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ospf = Identityref('ospf', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_bgp = Identityref('bgp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_static = Identityref('static', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_rip = Identityref('rip', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_vrrp = Identityref('vrrp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_direct = Identityref('direct', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_protocol_type = Identityref('protocol-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_tcp = Identityref('tcp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_udp = Identityref('udp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_icmp = Identityref('icmp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_icmp6 = Identityref('icmp6', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_gre = Identityref('gre', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ipip = Identityref('ipip', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_hop_by_hop = Identityref('hop-by-hop', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_routing = Identityref('routing', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_esp = Identityref('esp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ah = Identityref('ah', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_vpn_policy_filter_type = Identityref('vpn-policy-filter-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ipv4 = Identityref('ipv4', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ipv6 = Identityref('ipv6', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_lan = Identityref('lan', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_qos_profile_direction = Identityref('qos-profile-direction', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_to_wan = Identityref('site-to-wan', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_wan_to_site = Identityref('wan-to-site', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_both = Identityref('both', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')


def src_yang():
    res = []
    res.append(r"""module ietf-l3vpn-svc {
 yang-version 1.1;
 namespace "urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc";
 prefix l3vpn-svc;
 import ietf-inet-types {
  prefix inet;
 }
 import ietf-yang-types {
  prefix yang;
 }
 organization
  "IETF L3SM Working Group";
 contact
  "WG List: <mailto:l3sm@ietf.org>
   Editor:
    L3SM WG
   Chairs:
    Adrian Farrel, Qin Wu
  ";
 description
 "This YANG module defines a generic service configuration
 model for Layer 3 VPNs. This model is common across all
 vendor implementations.

 Copyright (c) 2018 IETF Trust and the persons
 identified as authors of the code.  All rights reserved.

 Redistribution and use in source and binary forms, with or
 without modification, is permitted pursuant to, and subject
 to the license terms contained in, the Simplified BSD License
 set forth in Section 4.c of the IETF Trust's Legal Provisions
 Relating to IETF Documents
 (https://trustee.ietf.org/license-info).

 This version of this YANG module is part of RFC 8299; see
 the RFC itself for full legal notices.";

 revision 2018-01-19 {
  description
   "Revision of RFC 8049 to fix implementation issues.";
  reference
   "RFC 8299";
  }
 revision 2017-01-27 {
  description
  "Initial document.";
  reference
    "RFC 8049.";
  }
 /* Features */
 feature cloud-access {
  description
  "Allows the VPN to connect to a CSP.";
 }
 feature multicast {
  description
  "Enables multicast capabilities in a VPN.";
 }
 feature ipv4 {
  description
  "Enables IPv4 support in a VPN.";
 }
 feature ipv6 {
  description
  "Enables IPv6 support in a VPN.";
 }
 feature lan-tag {
  description
  "Enables LAN Tag support in a VPN Policy filter.";
 }
 feature carrierscarrier {
  description
  "Enables support of CsC.";
 }
 feature extranet-vpn {
  description
  "Enables support of extranet VPNs.";
 }
 feature site-diversity {
  description
  "Enables support of site diversity constraints.";
 }
 feature encryption {
  description
  "Enables support of encryption.";
 }
 feature qos {
  description
  "Enables support of classes of services.";
 }
 feature qos-custom {
  description
  "Enables support of the custom QoS profile.";
 }
 feature rtg-bgp {
  description
  "Enables support of the BGP routing protocol.";
 }
 feature rtg-rip {
  description
  "Enables support of the RIP routing protocol.";
 }
 feature rtg-ospf {
  description
  "Enables support of the OSPF routing protocol.";
 }
 feature rtg-ospf-sham-link {
  description
  "Enables support of OSPF sham links.";
 }
 feature rtg-vrrp {
  description
  "Enables support of the VRRP routing protocol.";
 }
 feature fast-reroute {
  description
  "Enables support of Fast Reroute.";
 }
 feature bfd {
  description
  "Enables support of BFD.";
 }
 feature always-on {
  description
  "Enables support of the 'always-on' access constraint.";
 }
 feature requested-type {
  description
  "Enables support of the 'requested-type' access constraint.";
 }
 feature bearer-reference {
  description
  "Enables support of the 'bearer-reference' access constraint.";
 }
 feature target-sites {
  description
  "Enables support of the 'target-sites' match flow parameter.";
 }
 /* Typedefs */
 typedef svc-id {
  type string;
  description
  "Defines a type of service component identifier.";
 }
 typedef template-id {
  type string;
  description
  "Defines a type of service template identifier.";
 }
 typedef address-family {
  type enumeration {
   enum ipv4 {
    description
    "IPv4 address family.";
   }
   enum ipv6 {
    description
    "IPv6 address family.";
   }
  }
  description
  "Defines a type for the address family.";
 }
 /* Identities */
 identity site-network-access-type {
  description
  "Base identity for site-network-access type.";
 }
 identity point-to-point {
  base site-network-access-type;
  description
  "Identity for point-to-point connection.";
 }
 identity multipoint {
  base site-network-access-type;
  description
  "Identity for multipoint connection.
  Example: Ethernet broadcast segment.";
 }
 identity placement-diversity {
  description
  "Base identity for site placement constraints.";
 }
 identity bearer-diverse {
  base placement-diversity;
  description
  "Identity for bearer diversity.
  The bearers should not use common elements.";
 }
 identity pe-diverse {
  base placement-diversity;
  description
  "Identity for PE diversity.";
 }
 identity pop-diverse {
  base placement-diversity;
  description
  "Identity for POP diversity.";
 }
 identity linecard-diverse {
  base placement-diversity;
  description
  "Identity for linecard diversity.";
 }
 identity same-pe {
  base placement-diversity;
  description
  "Identity for having sites connected on the same PE.";
 }
 identity same-bearer {
  base placement-diversity;
  description
  "Identity for having sites connected using the same bearer.";
 }
 identity customer-application {
  description
  "Base identity for customer application.";
 }
 identity web {
  base customer-application;
  description
  "Identity for Web application (e.g., HTTP, HTTPS).";
 }
 identity mail {
  base customer-application;
  description
  "Identity for mail application.";
 }
 identity file-transfer {
  base customer-application;
  description
  "Identity for file transfer application (e.g., FTP, SFTP).";
 }
 identity database {
  base customer-application;
  description
  "Identity for database application.";
 }
 identity social {
  base customer-application;
  description
  "Identity for social-network application.";
 }
 identity games {
  base customer-application;
  description
  "Identity for gaming application.";
 }
 identity p2p {
  base customer-application;
  description
  "Identity for peer-to-peer application.";
 }
 identity network-management {
  base customer-application;
  description
  "Identity for management application
  (e.g., Telnet, syslog, SNMP).";
 }
 identity voice {
  base customer-application;
  description
  "Identity for voice application.";
 }
 identity video {
  base customer-application;
  description
  "Identity for video conference application.";
 }
 identity embb {
  base customer-application;
  description
  "Identity for an enhanced Mobile Broadband (eMBB)
  application.  Note that an eMBB application demands
  network performance with a wide variety of
  characteristics, such as data rate, latency,
  loss rate, reliability, and many other parameters.";
}
identity urllc {
  base customer-application;
  description
  "Identity for an Ultra-Reliable and Low Latency
  Communications (URLLC) application.  Note that a
  URLLC application demands network performance
  with a wide variety of characteristics, such as latency,
  reliability, and many other parameters.";
 }
 identity mmtc {
   base customer-application;
   description
   "Identity for a massive Machine Type
   Communications (mMTC) application.  Note that an
   mMTC application demands network performance
   with a wide variety of characteristics, such as data
   rate, latency, loss rate, reliability, and many
   other parameters.";
 }
 identity site-vpn-flavor {
  description
  "Base identity for the site VPN service flavor.";
 }
 identity site-vpn-flavor-single {
  base site-vpn-flavor;
  description
  "Base identity for the site VPN service flavor.
  Used when the site belongs to only one VPN.";
 }
 identity site-vpn-flavor-multi {
  base site-vpn-flavor;
  description
  "Base identity for the site VPN service flavor.
  Used when a logical connection of a site
  belongs to multiple VPNs.";
 }
 identity site-vpn-flavor-sub {
  base site-vpn-flavor;
  description
  "Base identity for the site VPN service flavor.
  Used when a site has multiple logical connections.
  Each connection may belong to different multiple VPNs.";
 }
 identity site-vpn-flavor-nni {
  base site-vpn-flavor;
  description
  "Base identity for the site VPN service flavor.
  Used to describe an NNI option A connection.";
 }
 identity management {
  description
  "Base identity for site management scheme.";
 }
 identity co-managed {
  base management;
  description
  "Base identity for co-managed site.";
 }
 identity customer-managed {
  base management;
  description
  "Base identity for customer-managed site.";
 }
 identity provider-managed {
  base management;
  description
  "Base identity for provider-managed site.";
 }
 identity address-allocation-type {
  description
  "Base identity for address-allocation-type for PE-CE link.";
 }
 identity provider-dhcp {
  base address-allocation-type;
  description
  "Provider network provides DHCP service to customer.";
 }
 identity provider-dhcp-relay {
  base address-allocation-type;
  description
  "Provider network provides DHCP relay service to customer.";
 }
 identity provider-dhcp-slaac {
  base address-allocation-type;
  description
  "Provider network provides DHCP service to customer,
  as well as SLAAC.";
 }
 identity static-address {
  base address-allocation-type;
  description
  "Provider-to-customer addressing is static.";
 }
 identity slaac {
  base address-allocation-type;
  description
  "Use IPv6 SLAAC.";
 }
 identity site-role {
  description
  "Base identity for site type.";
 }
 identity any-to-any-role {
  base site-role;
  description
  "Site in an any-to-any IP VPN.";
 }
 identity spoke-role {
  base site-role;
  description
  "Spoke site in a Hub-and-Spoke IP VPN.";
 }
 identity hub-role {
  base site-role;
  description
  "Hub site in a Hub-and-Spoke IP VPN.";
 }
 identity vpn-topology {
  description
  "Base identity for VPN topology.";
 }
 identity any-to-any {
  base vpn-topology;
  description
  "Identity for any-to-any VPN topology.";
 }
 identity hub-spoke {
  base vpn-topology;
  description
  "Identity for Hub-and-Spoke VPN topology.";
 }
 identity hub-spoke-disjoint {
  base vpn-topology;
  description
  "Identity for Hub-and-Spoke VPN topology
  where Hubs cannot communicate with each other.";
 }
 identity multicast-tree-type {
  description
  "Base identity for multicast tree type.";
 }
 identity ssm-tree-type {
  base multicast-tree-type;
  description
  "Identity for SSM tree type.";
 }
 identity asm-tree-type {
  base multicast-tree-type;
  description
  "Identity for ASM tree type.";
 }
 identity bidir-tree-type {
  base multicast-tree-type;
  description
  "Identity for bidirectional tree type.";
 }
 identity multicast-rp-discovery-type {
  description
  "Base identity for RP discovery type.";
 }
 identity auto-rp {
  base multicast-rp-discovery-type;
  description
  "Base identity for Auto-RP discovery type.";
 }
 identity static-rp {
  base multicast-rp-discovery-type;
  description
  "Base identity for static type.";
 }
 identity bsr-rp {
  base multicast-rp-discovery-type;
  description
  "Base identity for BSR discovery type.";
 }
 identity routing-protocol-type {
  description
  "Base identity for routing protocol type.";
 }
 identity ospf {
  base routing-protocol-type;
  description
  "Identity for OSPF protocol type.";
 }
 identity bgp {
  base routing-protocol-type;
  description
  "Identity for BGP protocol type.";
 }
 identity static {
  base routing-protocol-type;
  description
  "Identity for static routing protocol type.";
 }
 identity rip {
  base routing-protocol-type;
  description
  "Identity for RIP protocol type.";
 }
 identity vrrp {
  base routing-protocol-type;
  description
  "Identity for VRRP protocol type.
  This is to be used when LANs are directly connected
  to PE routers.";
 }
 identity direct {
  base routing-protocol-type;
  description
  "Identity for direct protocol type.";
 }
 identity protocol-type {
  description
  "Base identity for protocol field type.";
 }
 identity tcp {
  base protocol-type;
  description
  "TCP protocol type.";
 }
 identity udp {
  base protocol-type;
  description
  "UDP protocol type.";
 }

 identity icmp {
  base protocol-type;
  description
  "ICMP protocol type.";
 }
 identity icmp6 {
  base protocol-type;
  description
  "ICMPv6 protocol type.";
 }
 identity gre {
  base protocol-type;
  description
  "GRE protocol type.";
 }
 identity ipip {
  base protocol-type;
  description
  "IP-in-IP protocol type.";
 }
 identity hop-by-hop {
  base protocol-type;
  description
  "Hop-by-Hop IPv6 header type.";
 }
 identity routing {
  base protocol-type;
  description
  "Routing IPv6 header type.";
 }
 identity esp {
  base protocol-type;
  description
  "ESP header type.";
 }
 identity ah {
  base protocol-type;
  description
  "AH header type.";
 }
 identity vpn-policy-filter-type {
  description
  "Base identity for VPN Policy filter type.";
 }
 identity ipv4 {
   base vpn-policy-filter-type;
   description
   "Identity for IPv4 Prefix filter type.";
 }
 identity ipv6 {
   base vpn-policy-filter-type;
   description
   "Identity for IPv6 Prefix filter type.";
}
 identity lan {
   base vpn-policy-filter-type;
   description
   "Identity for LAN Tag filter type.";
}

 identity qos-profile-direction {
  description
  "Base identity for QoS profile direction.";
 }

 identity site-to-wan {
   base qos-profile-direction;
   description
   "Identity for Site-to-WAN direction.";
 }
 identity wan-to-site {
   base qos-profile-direction;
   description
   "Identity for WAN-to-Site direction.";
 }
 identity both {
   base qos-profile-direction;
   description
   "Identity for both WAN-to-Site direction
   and Site-to-WAN direction.";
 }
 /* Groupings */
 grouping vpn-service-cloud-access {
  container cloud-accesses {
   if-feature cloud-access;
   list cloud-access {
    key cloud-identifier;
    leaf cloud-identifier {
     type leafref {
      path "/l3vpn-svc/vpn-profiles/"+
      "valid-provider-identifiers/cloud-identifier/id";
     }
     description
     "Identification of cloud service.
     Local administration meaning.";
    }
    choice list-flavor {
     case permit-any {
      leaf permit-any {
       type empty;
       description
       "Allows all sites.";
      }
     }
     case deny-any-except {
      leaf-list permit-site {
       type leafref {
        path "/l3vpn-svc/sites/site/site-id";
       }
       description
       "Site ID to be authorized.";
      }
     }
     case permit-any-except {
      leaf-list deny-site {
       type leafref {
       path "/l3vpn-svc/sites/site/site-id";
      }
      description
      "Site ID to be denied.";
      }
     }
     description
     "Choice for cloud access policy.  By
     default, all sites in the IP VPN MUST
     be authorized to access the cloud.";
    }
    container address-translation {
     container nat44 {
      leaf enabled {
       type boolean;
        default false;
        description
        "Controls whether or not Network address
        translation from IPv4 to IPv4 (NAT44)
        [RFC3022] is required.";
      }
      leaf nat44-customer-address {
       type inet:ipv4-address;
        description
        "Address to be used for network address
        translation from IPv4 to IPv4.  This is
        to be used if the customer is providing
        the IPv4 address.  If the customer address
        is not set, the model assumes that the
        provider will allocate the address.";
      }
      description
      "IPv4-to-IPv4 translation.";
     }
     description
     "Container for NAT.";
    }
    description
    "Cloud access configuration.";
   }
   description
   "Container for cloud access configurations.";
  }
  description
  "Grouping for VPN cloud definition.";
 }
 grouping multicast-rp-group-cfg {
  choice group-format {
   mandatory true;
   case singleaddress {
    leaf group-address {
     type inet:ip-address;
     description
     "A single multicast group address.";
    }
   }
   case startend {
    leaf group-start {
     type inet:ip-address;
     description
     "The first multicast group address in
     the multicast group address range.";
    }
    leaf group-end {
     type inet:ip-address;
     description
     "The last multicast group address in
     the multicast group address range.";
    }
   }
   description
   "Choice for multicast group format.";
  }
  description
  "This grouping defines multicast group or
  multicast groups for RP-to-group mapping.";
 }
 grouping vpn-service-multicast {
  container multicast {
   if-feature multicast;
   leaf enabled {
    type boolean;
    default false;
    description
    "Enables multicast.";
   }
   container customer-tree-flavors {
    leaf-list tree-flavor {
     type identityref {
      base multicast-tree-type;
     }
     description
      "Type of tree to be used.";
    }
    description
    "Type of trees used by customer.";
   }
   container rp {
    container rp-group-mappings {
     list rp-group-mapping {
      key id;
      leaf id {
       type uint16;
       description
       "Unique identifier for the mapping.";
      }
      container provider-managed {
       leaf enabled {
        type boolean;
        default false;
        description
        "Set to true if the Rendezvous Point (RP)
        must be a provider-managed node.  Set to false
        if it is a customer-managed node.";
       }
       leaf rp-redundancy {
        type boolean;
        default false;
        description
        "If true, a redundancy mechanism for the RP
        is required.";
       }
       leaf optimal-traffic-delivery {
        type boolean;
        default false;
        description
        "If true, the SP must ensure that
        traffic uses an optimal path.  An SP may use
        Anycast RP or RP-tree-to-SPT switchover
        architectures.";
       }
       description
       "Parameters for a provider-managed RP.";
      }
      leaf rp-address {
       when "../provider-managed/enabled = 'false'" {
        description
        "Relevant when the RP is not provider-managed.";
       }
       type inet:ip-address;
         mandatory true;
       description
       "Defines the address of the RP.
       Used if the RP is customer-managed.";
      }
      container groups {
       list group {
        key id;
        leaf id {
         type uint16;
         description
         "Identifier for the group.";
        }
        uses multicast-rp-group-cfg;
        description
        "List of multicast groups.";
       }
       description
       "Multicast groups associated with the RP.";
      }
      description
      "List of RP-to-group mappings.";
     }
     description
     "RP-to-group mappings parameters.";
    }
    container rp-discovery {
     leaf rp-discovery-type {
      type identityref {
       base multicast-rp-discovery-type;
       }
      default static-rp;
      description
      "Type of RP discovery used.";
     }
     container bsr-candidates {
       when "derived-from-or-self(../rp-discovery-type, "+
           "'l3vpn-svc:bsr-rp')" {
       description
       "Only applicable if discovery type
       is BSR-RP.";
      }
      leaf-list bsr-candidate-address {
       type inet:ip-address;
        description
        "Address of BSR candidate.";
      }
      description
      "Container for List of Customer
      BSR candidate's addresses.";
     }
     description
     "RP discovery parameters.";
    }
    description
    "RP parameters.";
   }
   description
   "Multicast global parameters for the VPN service.";
  }
  description
  "Grouping for multicast VPN definition.";
 }
 grouping vpn-service-mpls {
  leaf carrierscarrier {
   if-feature carrierscarrier;
    type boolean;
    default false;
    description
    "The VPN is using CsC, and so MPLS is required.";
  }
  description
  "Grouping for MPLS CsC definition.";
 }
 grouping customer-location-info {
  container locations {
   list location {
    key location-id;
    leaf location-id {
     type svc-id;
     description
     "Identifier for a particular location.";
    }
    leaf address {
     type string;
     description
     "Address (number and street) of the site.";
    }
    leaf postal-code {
     type string;
     description
     "Postal code of the site.";
    }
    leaf state {
     type string;
     description
     "State of the site.  This leaf can also be
     used to describe a region for a country that
     does not have states.";
    }
    leaf city {
     type string;
     description
     "City of the site.";
    }
    leaf country-code {
     type string {
      pattern '[A-Z]{2}';
     }
     description
     "Country of the site.
     Expressed as ISO ALPHA-2 code.";
    }
    description
    "Location of the site.";
   }
   description
   "List of locations for the site.";
  }
  description
  "This grouping defines customer location parameters.";
 }
 grouping site-group {
  container groups {
   list group {
    key group-id;
    leaf group-id {
     type string;
     description
     "Group-id the site belongs to.";
    }
    description
    "List of group-ids.";
   }
   description
   "Groups the site or site-network-access belongs to.";
  }
  description
  "Grouping definition to assign
  group-ids to site or site-network-access.";
 }
 grouping site-diversity {
  container site-diversity {
   if-feature site-diversity;
   uses site-group;
   description
   "Diversity constraint type.  All
   site-network-accesses will inherit
   the group values defined here.";
  }
  description
  "This grouping defines site
  diversity parameters.";
 }
 grouping access-diversity {
  container access-diversity {
   if-feature site-diversity;
   uses site-group;
   container constraints {
    list constraint {
     key constraint-type;
     leaf constraint-type {
      type identityref {
       base placement-diversity;
      }
      description
      "Diversity constraint type.";
     }
     container target {
      choice target-flavor {
       default id;
       case id {
        list group {
         key group-id;
         leaf group-id {
          type string;
          description
          "The constraint will be applied against
          this particular group-id for this site
          network access level.";
         }
         description
         "List of group-ids associated with one specific
         constraint for this site network access level.";
        }
       }
       case all-accesses {
        leaf all-other-accesses {
         type empty;
         description
         "The constraint will be applied against
         all other site network accesses of this site.";
        }
       }
       case all-groups {
        leaf all-other-groups {
         type empty;
         description
         "The constraint will be applied against
         all other groups managed by the customer.";
        }
       }
       description
       "Choice for the target flavor definition.";
      }
      description
      "The constraint will be applied against a
      Specific target, and the target can be a list
      of group-ids,all other site network accesses of
      this site, or all other groups managed by the
      customer.";
     }
     description
     "List of constraints.";
    }
    description
    "Placement constraints for this site network access.";
   }
   description
   "Diversity parameters.";
  }
  description
  "This grouping defines access diversity parameters.";
 }
 grouping operational-requirements {
   leaf requested-site-start {
    type yang:date-and-time;
     description
     "Optional leaf indicating requested date and
     time when the service at a particular site is
     expected to start.";
  }

  leaf requested-site-stop {
    type yang:date-and-time;
     description
     "Optional leaf indicating requested date and
     time when the service at a particular site is
     expected to stop.";
  }
  description
  "This grouping defines some operational
  parameters.";
 }
 grouping operational-requirements-ops {
   leaf actual-site-start {
    type yang:date-and-time;
    config false;
     description
     "Optional leaf indicating actual date and
     time when the service at a particular site
     actually started.";
  }
  leaf actual-site-stop {
   type yang:date-and-time;
   config false;
     description
     "Optional leaf indicating actual date and
     time when the service at a particular site
     actually stopped.";
  }
  description
  "This grouping defines some operational
  parameters.";
 }
 grouping flow-definition {
  container match-flow {
   leaf dscp {
    type inet:dscp;
     description
     "DSCP value.";
   }
   leaf dot1p {
    type uint8 {
     range "0..7";
    }
    description
    "802.1p matching.";
   }
   leaf ipv4-src-prefix {
    type inet:ipv4-prefix;
     description
     "Match on IPv4 src address.";
   }
   leaf ipv6-src-prefix {
    type inet:ipv6-prefix;
     description
     "Match on IPv6 src address.";
   }
   leaf ipv4-dst-prefix {
    type inet:ipv4-prefix;
     description
     "Match on IPv4 dst address.";
   }
   leaf ipv6-dst-prefix {
    type inet:ipv6-prefix;
    description
    "Match on IPv6 dst address.";
   }
   leaf l4-src-port {
    type inet:port-number;
        must "current() < ../l4-src-port-range/lower-port or "+
        "current() > ../l4-src-port-range/upper-port" {
     description
     "If l4-src-port and l4-src-port-range/lower-port and
     upper-port are set at the same time, l4-src-port
     should not overlap with l4-src-port-range.";
     }
     description
     "Match on Layer 4 src port.";
   }
   leaf-list target-sites {
     if-feature target-sites;
     type svc-id;
     description
     "Identify a site as traffic destination.";
   }
   container l4-src-port-range {
     leaf lower-port {
     type inet:port-number;
     description
     "Lower boundary for port.";
    }
    leaf upper-port {
     type inet:port-number;
     must ". >= ../lower-port" {
      description
      "Upper boundary for port.  If it
      exists, the upper boundary must be
      higher than the lower boundary.";
     }
     description
     "Upper boundary for port.";
    }
     description
     "Match on Layer 4 src port range.  When
     only the lower-port is present, it represents
     a single port.  When both the lower-port and
     upper-port are specified, it implies
     a range inclusive of both values.";
   }
   leaf l4-dst-port {
    type inet:port-number;
         must "current() < ../l4-dst-port-range/lower-port or "+
         "current() > ../l4-dst-port-range/upper-port" {
     description
     "If l4-dst-port and l4-dst-port-range/lower-port
     and upper-port are set at the same time,
     l4-dst-port should not overlap with
     l4-src-port-range.";
     }
     description
     "Match on Layer 4 dst port.";
   }
   container l4-dst-port-range {
    leaf lower-port {
     type inet:port-number;
     description
     "Lower boundary for port.";
    }
    leaf upper-port {
     type inet:port-number;
     must ". >= ../lower-port" {
     description
     "Upper boundary must be
     higher than lower boundary.";
     }
     description
     "Upper boundary for port.  If it exists,
     upper boundary must be higher than lower
     boundary.";
    }
    description
    "Match on Layer 4 dst port range.  When only
    lower-port is present, it represents a single
    port.  When both lower-port and upper-port are
    specified, it implies a range inclusive of both
    values.";
   }
   leaf protocol-field {
    type union {
     type uint8;
     type identityref {
      base protocol-type;
     }
    }
    description
    "Match on IPv4 protocol or IPv6 Next Header field.";
   }
   description
   "Describes flow-matching criteria.";
  }
  description
  "Flow definition based on criteria.";
 }
 grouping site-service-basic {
  leaf svc-input-bandwidth {
    type uint64;
    units bps;
    mandatory true;
     description
     "From the customer site's perspective, the service
     input bandwidth of the connection or download
     bandwidth from the SP to the site.";
  }
  leaf svc-output-bandwidth {
   type uint64;
   units bps;
   mandatory true;
     description
     "From the customer site's perspective, the service
     output bandwidth of the connection or upload
     bandwidth from the site to the SP.";
  }
  leaf svc-mtu {
   type uint16;
   units bytes;
   mandatory true;
    description
    "MTU at service level.  If the service is IP,
    it refers to the IP MTU.  If CsC is enabled,
    the requested 'svc-mtu' leaf will refer to the
    MPLS MTU and not to the IP MTU.";
  }
  description
  "Defines basic service parameters for a site.";
 }
 grouping site-protection {
  container traffic-protection {
   if-feature fast-reroute;
   leaf enabled {
    type boolean;
    default false;
     description
     "Enables traffic protection of access link.";
   }
   description
   "Fast Reroute service parameters for the site.";
  }
  description
  "Defines protection service parameters for a site.";
 }
 grouping site-service-mpls {
  container carrierscarrier {
   if-feature carrierscarrier;
   leaf signalling-type {
    type enumeration {
    enum ldp {
     description
     "Use LDP as the signalling protocol
     between the PE and the CE.  In this case,
     an IGP routing protocol must also be activated.";
     }
    enum bgp {
     description
     "Use BGP (as per RFC 8277) as the signalling protocol
     between the PE and the CE.
     In this case, BGP must also be configured as
     the routing protocol.";
     }
    }
    default bgp;
    description
    "MPLS signalling type.";
   }
     description
     "This container is used when the customer provides
     MPLS-based services.  This is only used in the case
     of CsC (i.e., a customer builds an MPLS service using
     an IP VPN to carry its traffic).";
  }
     description
     "Defines MPLS service parameters for a site.";
 }
 grouping site-service-qos-profile {
  container qos {
   if-feature qos;
   container qos-classification-policy {
    list rule {
     key id;
     ordered-by user;
     leaf id {
      type string;
      description
      "A description identifying the
       qos-classification-policy rule.";
     }
     choice match-type {
      default match-flow;
      case match-flow {
      uses flow-definition;
      }
      case match-application {
       leaf match-application {
        type identityref {
         base customer-application;
        }
         description
         "Defines the application to match.";
       }
      }
      description
      "Choice for classification.";
     }
     leaf target-class-id {
      type string;
      description
      "Identification of the class of service.
      This identifier is internal to the administration.";
     }
     description
     "List of marking rules.";
    }
    description
    "Configuration of the traffic classification policy.";
   }
   container qos-profile {
    choice qos-profile {
     description
     "Choice for QoS profile.
     Can be standard profile or customized profile.";
     case standard {
      description
      "Standard QoS profile.";
      leaf profile {
       type leafref {
       path "/l3vpn-svc/vpn-profiles/valid-provider-identifiers"+
           "/qos-profile-identifier/id";
       }
       description
       "QoS profile to be used.";
      }
     }
     case custom {
      description
      "Customized QoS profile.";
       container classes {
        if-feature qos-custom;
        list class {
         key class-id;
         leaf class-id {
         type string;
                  description
                  "Identification of the class of service.
                  This identifier is internal to the
                  administration.";
         }
         leaf direction {
                  type identityref {
                   base qos-profile-direction;
                   }
                  default both;
                   description
                   "The direction to which the QoS profile
                   is applied.";
                }
                 leaf rate-limit {
                  type decimal64 {
                   fraction-digits 5;
                   range "0..100";
          }
                  units percent;
                   description
                   "To be used if the class must be rate-limited.
                   Expressed as percentage of the service
                   bandwidth.";
        }
        container latency {
         choice flavor {
          case lowest {
           leaf use-lowest-latency {
            type empty;
             description
             "The traffic class should use the path with the
             lowest latency.";
           }
          }
          case boundary {
           leaf latency-boundary {
            type uint16;
            units msec;
            default 400;
             description
             "The traffic class should use a path with a
             defined maximum latency.";
           }
          }
          description
          "Latency constraint on the traffic class.";
         }
         description
         "Latency constraint on the traffic class.";
        }
        container jitter {
         choice flavor {
          case lowest {
           leaf use-lowest-jitter {
            type empty;
             description
             "The traffic class should use the path with the
             lowest jitter.";
           }
          }
          case boundary {
           leaf latency-boundary {
            type uint32;
            units usec;
            default 40000;
             description
             "The traffic class should use a path with a
             defined maximum jitter.";
           }
          }
          description
          "Jitter constraint on the traffic class.";
         }
         description
         "Jitter constraint on the traffic class.";
        }
        container bandwidth {
         leaf guaranteed-bw-percent {
          type decimal64 {
                  fraction-digits 5;
                  range "0..100";
          }
          units percent;
          mandatory true;
           description
           "To be used to define the guaranteed bandwidth
           as a percentage of the available service bandwidth.";
         }
         leaf end-to-end {
          type empty;
           description
           "Used if the bandwidth reservation
           must be done on the MPLS network too.";
         }
         description
         "Bandwidth constraint on the traffic class.";
        }
        description
        "List of classes of services.";
       }
       description
       "Container for list of classes of services.";
      }
     }
    }
    description
    "QoS profile configuration.";
   }
   description
   "QoS configuration.";
  }
  description
  "This grouping defines QoS parameters for a site.";
 }
 grouping site-security-authentication {
  container authentication {
     description
     "Authentication parameters.";
  }
  description
  "This grouping defines authentication parameters for a site.";
 }
 grouping site-security-encryption {
  container encryption {
   if-feature encryption;
   leaf enabled {
    type boolean;
    default false;
     description
     "If true, traffic encryption on the connection is required.";
   }
   leaf layer {
      when "../enabled = 'true'" {
         description
         "Require a value for layer when enabled is true.";
       }
    type enumeration {
     enum layer2 {
      description
      "Encryption will occur at Layer 2.";
     }
     enum layer3 {
      description
      "Encryption will occur at Layer 3.
      For example, IPsec may be used when
      a customer requests Layer 3 encryption.";
     }
    }
    description
     "Layer on which encryption is applied.";
   }
   container encryption-profile {
    choice profile {
     case provider-profile {
      leaf profile-name {
       type leafref {
        path "/l3vpn-svc/vpn-profiles/valid-provider-identifiers"+
                "/encryption-profile-identifier/id";
       }
         description
         "Name of the SP profile to be applied.";
      }
     }
     case customer-profile {
      leaf algorithm {
       type string;
         description
         "Encryption algorithm to be used.";
      }
      choice key-type {
       default psk;
       case psk {
        leaf preshared-key {
         type string;
         description
         "Pre-Shared Key (PSK) coming from the customer.";
        }
       }
       description
       "Type of keys to be used.";
      }
     }
     description
     "Choice of encryption profile.  The encryption
     profile can be the provider profile or customer profile.";
    }
    description
    "Profile of encryption to be applied.";
   }
   description
   "Encryption parameters.";
  }
  description
  "This grouping defines encryption parameters for a site.";
 }
 grouping site-attachment-bearer {
  container bearer {
   container requested-type {
    if-feature requested-type;
    leaf requested-type {
     type string;
     description
     "Type of requested bearer: Ethernet, DSL,
     Wireless, etc. Operator specific.";
    }
    leaf strict {
     type boolean;
     default false;
     description
     "Defines whether requested-type is a preference
     or a strict requirement.";
    }
     description
     "Container for requested-type.";
   }
   leaf always-on {
    if-feature always-on;
    type boolean;
    default true;
     description
     "Request for an always-on access type.
     For example, this could mean no dial access type.";
   }
   leaf bearer-reference {
    if-feature bearer-reference;
    type string;
     description
     "This is an internal reference for the SP.";
   }
     description
     "Bearer-specific parameters.
     To be augmented.";
  }
  description
  "Defines physical properties of a site attachment.";
 }
 grouping site-routing {
  container routing-protocols {
   list routing-protocol {
    key type;
    leaf type {
     type identityref {
      base routing-protocol-type;
     }
     description
     "Type of routing protocol.";
    }
    container ospf {
     presence "acton-yang doesn't support when clause";
     when "derived-from-or-self(../type, 'l3vpn-svc:ospf')" {
     description
     "Only applies when protocol is OSPF.";
     }
     if-feature rtg-ospf;
     leaf-list address-family {
      type address-family;
          min-elements "1";
         description
         "If OSPF is used on this site, this node
         contains a configured value.  This node
         contains at least one address family
         to be activated.";
     }
     leaf area-address {
      type yang:dotted-quad;
      mandatory true;
         description
         "Area address.";
     }
     leaf metric {
      type uint16;
      default 1;
         description
         "Metric of the PE-CE link.  It is used
         in the routing state calculation and
         path selection.";
     }
     container sham-links {
      if-feature rtg-ospf-sham-link;
      list sham-link {
       key target-site;
       leaf target-site {
        type svc-id;
         description
         "Target site for the sham link connection.
         The site is referred to by its ID.";
       }
       leaf metric {
        type uint16;
        default 1;
         description
         "Metric of the sham link.  It is used in
         the routing state calculation and path
         selection.  The default value is set
         to 1.";
       }
         description
         "Creates a sham link with another site.";
      }
      description
      "List of sham links.";
     }
     description
     "OSPF-specific configuration.";
    }
    container bgp {
     presence "acton-yang doesn't support when clause";
     when "derived-from-or-self(../type, 'l3vpn-svc:bgp')" {
      description
      "Only applies when protocol is BGP.";
     }
     if-feature rtg-bgp;
     leaf autonomous-system {
      type uint32;
      mandatory true;
         description
         "Customer AS number in case the customer
         requests BGP routing.";
     }
     leaf-list address-family {
      type address-family;
          min-elements "1";
         description
         "If BGP is used on this site, this node
         contains a configured value.  This node
         contains at least one address family
         to be activated.";
     }
     description
     "BGP-specific configuration.";
    }
    container static {
     presence "acton-yang doesn't support when clause";
     when "derived-from-or-self(../type, 'l3vpn-svc:static')" {
       description
       "Only applies when protocol is static.
       BGP activation requires the SP to know
       the address of the customer peer.  When
       BGP is enabled, the 'static-address'
       allocation type for the IP connection
       MUST be used.";
     }
     container cascaded-lan-prefixes {
      list ipv4-lan-prefixes {
       if-feature ipv4;
       key "lan next-hop";
       leaf lan {
        type inet:ipv4-prefix;
        description
        "LAN prefixes.";
       }
       leaf lan-tag {
        type string;
         description
         "Internal tag to be used in VPN policies.";
       }
       leaf next-hop {
        type inet:ipv4-address;
         description
         "Next-hop address to use on the customer side.";
       }
       description
       "List of LAN prefixes for the site.";
      }
      list ipv6-lan-prefixes {
       if-feature ipv6;
       key "lan next-hop";
       leaf lan {
        type inet:ipv6-prefix;
         description
         "LAN prefixes.";
       }
       leaf lan-tag {
        type string;
        description
        "Internal tag to be used in VPN policies.";
       }
       leaf next-hop {
        type inet:ipv6-address;
         description
         "Next-hop address to use on the customer side.";
       }
       description
       "List of LAN prefixes for the site.";
      }
      description
      "LAN prefixes from the customer.";
     }
     description
     "Configuration specific to static routing.";
    }
    container rip {
     presence "acton-yang doesn't support when clause";
     when "derived-from-or-self(../type, 'l3vpn-svc:rip')" {
      description
      "Only applies when the protocol is RIP.  For IPv4,
      the model assumes that RIP version 2 is used.";
     }
     if-feature rtg-rip;
     leaf-list address-family {
      type address-family;
          min-elements "1";
         description
         "If RIP is used on this site, this node
         contains a configured value.  This node
         contains at least one address family
         to be activated.";
     }
     description
     "Configuration specific to RIP routing.";
    }
    container vrrp {
     presence "acton-yang doesn't support when clause";
     when "derived-from-or-self(../type, 'l3vpn-svc:vrrp')" {
      description
      "Only applies when protocol is VRRP.";
     }
     if-feature rtg-vrrp;
     leaf-list address-family {
      type address-family;
          min-elements "1";
         description
         "If VRRP is used on this site, this node
         contains a configured value.  This node contains
         at least one address family to be activated.";
     }
     description
     "Configuration specific to VRRP routing.";
    }
    description
    "List of routing protocols used on
    the site.  This list can be augmented.";
   }
   description
   "Defines routing protocols.";
  }
  description
  "Grouping for routing protocols.";
 }
 grouping site-attachment-ip-connection {
   container ip-connection {
     container ipv4 {
     if-feature ipv4;
      leaf address-allocation-type {
      type identityref {
       base address-allocation-type;
     }
     must "not(derived-from-or-self(current(), 'l3vpn-svc:slaac') or "+
         "derived-from-or-self(current(), "+
         "'l3vpn-svc:provider-dhcp-slaac'))" {
     error-message "SLAAC is only applicable to IPv6";
     }
     description
     "Defines how addresses are allocated.
     If there is no value for the address
     allocation type, then IPv4 is not enabled.";
    }
   container provider-dhcp {
     when "derived-from-or-self(../address-allocation-type, "+
     "'l3vpn-svc:provider-dhcp')" {
     description
     "Only applies when addresses are allocated by DHCP.";
   }
     leaf provider-address {
      type inet:ipv4-address;
         description
         "Address of provider side.  If provider-address is not
         specified, then prefix length should not be specified
         either.  It also implies provider-dhcp allocation is
         not enabled.  If provider-address is specified, then
         the prefix length may or may not be specified.";
     }
     leaf prefix-length {
      type uint8 {
      range "0..32";
      }
         must "(../provider-address)" {
          error-message
          "If the prefix length is specified, provider-address
          must also be specified.";
             description
             "If the prefix length is specified, provider-address
             must also be specified.";
        }
     description
     "Subnet prefix length expressed in bits.
     If not specified, or specified as zero,
     this means the customer leaves the actual
     prefix length value to the provider.";
     }
     choice address-assign {
      default number;
      case number {
       leaf number-of-dynamic-address {
        type uint16;
        default 1;
         description
         "Describes the number of IP addresses
         the customer requires.";
       }
      }
      case explicit {
       container customer-addresses {
        list address-group {
         key "group-id";
         leaf group-id {
         type string;
         description
         "Group-id for the address range from
         start-address to end-address.";
         }
        leaf start-address {
         type inet:ipv4-address;
          description
          "First address.";
         }
        leaf end-address {
         type inet:ipv4-address;
         description
         "Last address.";
         }
         description
         "Describes IP addresses allocated by DHCP.
         When only start-address or only end-address
         is present, it represents a single address.
         When both start-address and end-address are
         specified, it implies a range inclusive of both
         addresses.  If no address is specified, it implies
         customer addresses group is not supported.";
        }
         description
         "Container for customer addresses is allocated by DHCP.";
       }
     }
         description
         "Choice for the way to assign addresses.";
     }
         description
         "DHCP allocated addresses related parameters.";
    }
 container dhcp-relay {
   when "derived-from-or-self(../address-allocation-type, "+
   "'l3vpn-svc:provider-dhcp-relay')" {
     description
     "Only applies when provider is required to implement
     DHCP relay function.";
  }
 leaf provider-address {
  type inet:ipv4-address;
     description
     "Address of provider side.  If provider-address is not
     specified, then prefix length should not be specified
     either.  It also implies provider-dhcp allocation is
     not enabled.  If provider-address is specified, then
     prefix length may or may not be specified.";
 }
 leaf prefix-length {
  type uint8 {
  range "0..32";
  }
 must "(../provider-address)" {
  error-message
     "If prefix length is specified, provider-address
      must also be specified.";
     description
     "If prefix length is specified, provider-address
     must also be specified.";
}
     description
     "Subnet prefix length expressed in bits.  If not
     specified, or specified as zero, this means the
     customer leaves the actual prefix length value
     to the provider.";
 }
 container customer-dhcp-servers {
  leaf-list server-ip-address {
  type inet:ipv4-address;
     description
     "IP address of customer DHCP server.";
 }
 description
 "Container for list of customer DHCP servers.";
 }
 description
 "DHCP relay provided by operator.";
}
 container addresses {
   when "derived-from-or-self(../address-allocation-type, "+
   "'l3vpn-svc:static-address')" {
   description
   "Only applies when protocol allocation type is static.";
    }
     leaf provider-address {
      type inet:ipv4-address;
         description
         "IPv4 Address List of the provider side.
         When the protocol allocation type is static,
         the provider address must be configured.";
     }
     leaf customer-address {
      type inet:ipv4-address;
         description
         "IPv4 Address of customer side.";
     }
     leaf prefix-length {
      type uint8 {
       range "0..32";
      }
     description
     "Subnet prefix length expressed in bits.
     It is applied to both provider-address
     and customer-address.";
     }
     description
     "Describes IPv4 addresses used.";
    }
    description
    "IPv4-specific parameters.";
   }
   container ipv6 {
    if-feature ipv6;
    leaf address-allocation-type {
     type identityref {
      base address-allocation-type;
     }
     description
     "Defines how addresses are allocated.
     If there is no value for the address
     allocation type, then IPv6 is
     not enabled.";
    }

   container provider-dhcp {
      when "derived-from-or-self(../address-allocation-type, "+
      "'l3vpn-svc:provider-dhcp') "+
      "or derived-from-or-self(../address-allocation-type, "+
      "'l3vpn-svc:provider-dhcp-slaac')" {
      description
      "Only applies when addresses are allocated by DHCP.";
       }
          leaf provider-address {
           type inet:ipv6-address;
           description
           "Address of the provider side.  If provider-address
           is not specified, then prefix length should not be
           specified either.  It also implies provider-dhcp
           allocation is not enabled.  If provider-address is
           specified, then prefix length may or may
           not be specified.";
         }
      leaf prefix-length {
       type uint8 {
       range "0..128";
       }
           must "(../provider-address)" {
             error-message
             "If prefix length is specified, provider-address
             must also be specified.";
             description
             "If prefix length is specified, provider-address
             must also be specified.";
            }
       description
       "Subnet prefix length expressed in bits.  If not
       specified, or specified as zero, this means the
       customer leaves the actual prefix length value
       to the provider.";
     }
        choice address-assign {
         default number;
         case number {
          leaf number-of-dynamic-address {
           type uint16;
           default 1;
           description
           "Describes the number of IP addresses the customer
           requires.";
          }
         }
         case explicit {
          container customer-addresses {
           list address-group {
                 key "group-id";
                 leaf group-id {
                 type string;
                 description
                 "Group-id for the address range from
                 start-address to end-address.";
             }
                 leaf start-address {
                  type inet:ipv6-address;
                  description
                  "First address.";
                  }
                 leaf end-address {
                  type inet:ipv6-address;
                  description
                  "Last address.";
                  }
                 description
                 "Describes IP addresses allocated by DHCP.  When only
                 start-address or only end-address is present, it
                 represents a single address.  When both start-address
                 and end-address are specified, it implies a range
                 inclusive of both addresses.  If no address is
                 specified, it implies customer addresses group is
                 not supported.";
          }
           description
           "Container for customer addresses allocated by DHCP.";
         }
        }
         description
         "Choice for the way to assign addresses.";
        }
         description
         "DHCP allocated addresses related parameters.";
        }
   container dhcp-relay {
    when "derived-from-or-self(../address-allocation-type, "+
         "'l3vpn-svc:provider-dhcp-relay')" {
      description
      "Only applies when the provider is required
      to implement DHCP relay function.";
      }
        leaf provider-address {
         type inet:ipv6-address;
          description
          "Address of the provider side.  If provider-address is
          not specified, then prefix length should not be
          specified either.  It also implies provider-dhcp
          allocation is not enabled.  If provider address
          is specified, then prefix length may or may
          not be specified.";
          }
        leaf prefix-length {
         type uint8 {
          range "0..128";
          }
         must "(../provider-address)" {
          error-message
           "If prefix length is specified, provider-address
           must also be specified.";
          description
          "If prefix length is specified, provider-address
          must also be specified.";
           }
         description
         "Subnet prefix length expressed in bits.  If not
         specified, or specified as zero, this means the
         customer leaves the actual prefix length value
         to the provider.";
         }
    container customer-dhcp-servers {
     leaf-list server-ip-address {
      type inet:ipv6-address;
       description
       "This node contains the IP address of
       the customer DHCP server.  If the DHCP relay
       function is implemented by the
       provider, this node contains the
       configured value.";
     }
      description
      "Container for list of customer DHCP servers.";
     }
    description
    "DHCP relay provided by operator.";
    }
   container addresses {
    when "derived-from-or-self(../address-allocation-type, "+
        "'l3vpn-svc:static-address')" {
     description
     "Only applies when protocol allocation type is static.";
     }
    leaf provider-address {
     type inet:ipv6-address;
      description
      "IPv6 Address of the provider side.  When the protocol
      allocation type is static, the provider address
      must be configured.";
     }
    leaf customer-address {
     type inet:ipv6-address;
      description
      "The IPv6 Address of the customer side.";
     }
    leaf prefix-length {
     type uint8 {
      range "0..128";
     }
     description
     "Subnet prefix length expressed in bits.
     It is applied to both provider-address and
     customer-address.";
    }
    description
    "Describes IPv6 addresses used.";
    }
    description
    "IPv6-specific parameters.";
   }
   container oam {
    container bfd {
     if-feature bfd;
     leaf enabled {
      type boolean;
      default false;
      description
      "If true, BFD activation is required.";
     }
     choice holdtime {
      default fixed;
      case fixed {
       leaf fixed-value {
        type uint32;
        units msec;
         description
         "Expected BFD holdtime expressed in msec.  The customer
         may impose some fixed values for the holdtime period
         if the provider allows the customer use this function.
         If the provider doesn't allow the customer to use this
         function, the fixed-value will not be set.";
       }
      }
      case profile {
       leaf profile-name {
        type leafref {
         path "/l3vpn-svc/vpn-profiles/valid-provider-identifiers/"+
                 "bfd-profile-identifier/id";
        }
        description
        "Well-known SP profile name.  The provider can propose
        some profiles to the customer, depending on the service
        level the customer wants to achieve.  Profile names
        must be communicated to the customer.";
       }
       description
       "Well-known SP profile.";
      }
      description
      "Choice for holdtime flavor.";
     }
     description
     "Container for BFD.";
    }
    description
    "Defines the Operations, Administration, and Maintenance (OAM)
    mechanisms used on the connection.  BFD is set as a fault
    detection mechanism, but the 'oam' container can easily
    be augmented by other mechanisms";
   }
   description
   "Defines connection parameters.";
  }
  description
  "This grouping defines IP connection parameters.";
 }
 grouping site-service-multicast {
  container multicast {
   if-feature multicast;
   leaf multicast-site-type {
    type enumeration {
     enum receiver-only {
      description
      "The site only has receivers.";
     }
     enum source-only {
      description
      "The site only has sources.";
     }
     enum source-receiver {
      description
      "The site has both sources and receivers.";
     }
    }
    default source-receiver;
    description
    "Type of multicast site.";
   }
   container multicast-address-family {
    leaf ipv4 {
     if-feature ipv4;
     type boolean;
     default false;
     description
     "Enables IPv4 multicast.";
    }
    leaf ipv6 {
     if-feature ipv6;
     type boolean;
     default false;
     description
     "Enables IPv6 multicast.";
    }
    description
    "Defines protocol to carry multicast.";
    }
   leaf protocol-type {
    type enumeration {
     enum host {
      description
      "Hosts are directly connected to the provider network.
      Host protocols such as IGMP or MLD are required.";
     }
     enum router {
      description
      "Hosts are behind a customer router.
      PIM will be implemented.";
     }
     enum both {
      description
      "Some hosts are behind a customer router, and
      some others are directly connected to the
      provider network.  Both host and routing protocols
      must be used.  Typically, IGMP and PIM will be
      implemented.";
     }
    }
    default "both";
    description
    "Multicast protocol type to be used with the customer site.";
   }
   description
   "Multicast parameters for the site.";
  }
  description
  "Multicast parameters for the site.";
 }
 grouping site-management {
  container management {
   leaf type {
    type identityref {
     base management;
    }
    mandatory true;
    description
    "Management type of the connection.";
   }
   description
   "Management configuration.";
  }
  description
  "Management parameters for the site.";
 }
 grouping site-devices {
  container devices {
   when "derived-from-or-self(../management/type, "+
   "'l3vpn-svc:provider-managed') or "+
   "derived-from-or-self(../management/type, 'l3vpn-svc:co-managed')" {
   description
   "Applicable only for provider-managed or
   co-managed device.";
  }
  list device {
   key device-id;
   leaf device-id {
    type svc-id;
    description
    "Identifier for the device.";
   }
   leaf location {
    type leafref {
     path "../../../locations/"+
     "location/location-id";
    }
    mandatory true;
    description
     "Location of the device.";
    }
   container management {
    when "derived-from-or-self(../../../management/type,"+
      "'l3vpn-svc:co-managed')" {
      description
       "Applicable only for co-managed device.";
     }
    leaf address-family {
     type address-family;
     description
     "Address family used for management.";
    }
    leaf address {
         when "(../address-family)" {
           description
           "If address-family is specified, then address should
           also be specified.  If address-family is not specified,
           then address should also not be specified.";
           }
         type inet:ip-address;
         mandatory true;
     description
     "Management address.";
     }
    description
     "Management configuration.  Applicable only for
      co-managed device.";
    }
    description
    "List of devices requested by customer.";
   }
   description
   "Device configuration.";
  }
  description
  "Grouping for device allocation.";
 }
 grouping site-vpn-flavor {
  leaf site-vpn-flavor {
   type identityref {
    base site-vpn-flavor;
   }
   default site-vpn-flavor-single;
   description
   "Defines the way the VPN multiplexing is done, e.g., whether
   the site belongs to a single VPN site or a multiVPN; or, in the case
   of a multiVPN, whether the logical accesses of the sites belong
   to the same set of VPNs or each logical access maps to
   different VPNs.";
  }
  description
  "Grouping for site VPN flavor.";
 }
 grouping site-vpn-policy {
  container vpn-policies {
   list vpn-policy {
    key vpn-policy-id;
    leaf vpn-policy-id {
     type svc-id;
     description
     "Unique identifier for the VPN policy.";
    }
    list entries {
     key id;
     leaf id {
      type svc-id;
      description
      "Unique identifier for the policy entry.";
     }
     container filters {
      list filter {
       key type;
       ordered-by user;
       leaf type {
        type identityref {
         base vpn-policy-filter-type;
         }
        description
        "Type of VPN Policy filter.";
        }
        leaf-list lan-tag {
        when "derived-from-or-self(../type, 'l3vpn-svc:lan')" {
         description
         "Only applies when the VPN Policy filter is a
         LAN Tag filter.";
        }
         if-feature lan-tag;
         type string;
         description
         "List of 'lan-tag' items to be matched.  LAN Tag
         is an Internal tag to be used in VPN policies ";
        }
        leaf-list ipv4-lan-prefix {
        when "derived-from-or-self(../type, 'l3vpn-svc:ipv4')" {
          description
          "Only applies when VPN Policy filter is IPv4 Prefix filter.";
         }
         if-feature ipv4;
         type inet:ipv4-prefix;
         description
         "List of IPv4 prefixes as LAN Prefixes to be matched.";
        }
        leaf-list ipv6-lan-prefix {
        when "derived-from-or-self(../type, 'l3vpn-svc:ipv6')" {
        description
        "Only applies when VPN Policy filter is IPv6 Prefix filter.";
         }
         if-feature ipv6;
         type inet:ipv6-prefix;
         description
         "List of IPv6 prefixes as LAN prefixes to be matched.";
        }
         description
         "List of filters used on the site.  This list can
         be augmented.";
      }
      description
      "If a more-granular VPN attachment is necessary, filtering can
      be used.  If used, it permits the splitting of site LANs among
      multiple VPNs.  The Site LAN can be split based on either LAN
      Tag or LAN prefix.  If no filter is used, all the LANs will be
      part of the same VPNs with the same role.";
     }
     list vpn {
      key vpn-id;
      leaf vpn-id {
       type leafref {
        path "/l3vpn-svc/vpn-services/"+
         "vpn-service/vpn-id";
       }
       description
       "Reference to an IP VPN.";
      }
      leaf site-role {
       type identityref {
        base site-role;
       }
       default any-to-any-role;
       description
       "Role of the site in the IP VPN.";
      }
      description
      "List of VPNs the LAN is associated with.";
     }
     description
     "List of entries for export policy.";
    }
    description
    "List of VPN policies.";
   }
   description
   "VPN policy.";
  }
  description
  "VPN policy parameters for the site.";
 }
 grouping site-maximum-routes {
  container maximum-routes {
   list address-family {
    key af;
    leaf af {
     type address-family;
     description
     "Address family.";
    }
    leaf maximum-routes {
     type uint32;
     description
     "Maximum prefixes the VRF can accept
     for this address family.";
    }
    description
    "List of address families.";
   }
   description
   "Defines 'maximum-routes' for the VRF.";
  }
  description
  "Defines 'maximum-routes' for the site.";
 }
 grouping site-security {
  container security {
   uses site-security-authentication;
   uses site-security-encryption;
   description
   "Site-specific security parameters.";
  }
  description
  "Grouping for security parameters.";
 }
 grouping site-service {
  container service {
   uses site-service-qos-profile;
   uses site-service-mpls;
   uses site-service-multicast;
   description
   "Service parameters on the attachment.";
  }
  description
  "Grouping for service parameters.";
 }
 grouping site-network-access-service {
  container service {
   uses site-service-basic;
   uses site-service-qos-profile;
   uses site-service-mpls;
   uses site-service-multicast;
   description
   "Service parameters on the attachment.";
  }
  description
  "Grouping for service parameters.";
 }
 grouping vpn-extranet {
  container extranet-vpns {
   if-feature extranet-vpn;
   list extranet-vpn {
    key vpn-id;
    leaf vpn-id {
     type svc-id;
     description
     "Identifies the target VPN the local VPN want to access.";
    }
    leaf local-sites-role {
     type identityref {
      base site-role;
     }
     default any-to-any-role;
     description
     "This describes the role of the
     local sites in the target VPN topology.  In the any-to-any VPN
     service topology, the local sites must have the same role, which
     will be 'any-to-any-role'.  In the Hub-and-Spoke VPN service
     topology or the Hub-and-Spoke disjoint VPN service topology,
     the local sites must have a Hub role or a Spoke role.";
    }
    description
    "List of extranet VPNs or target VPNs the local VPN is
    attached to.";
   }
   description
   "Container for extranet VPN configuration.";
  }
  description
  "Grouping for extranet VPN configuration.
  This provides an easy way to interconnect
  all sites from two VPNs.";
 }
 grouping site-attachment-availability {
  container availability {
   leaf access-priority {
    type uint32;
    default 100;
    description
    "Defines the priority for the access.
    The higher the access-priority value,
    the higher the preference of the
    access will be.";
   }
   description
   "Availability parameters (used for multihoming).";
  }
  description
  "Defines availability parameters for a site.";
 }
 grouping access-vpn-policy {
  container vpn-attachment {
   choice attachment-flavor {
    case vpn-policy-id {
     leaf vpn-policy-id {
      type leafref {
       path "../../../../"+
        "vpn-policies/vpn-policy/"+
        "vpn-policy-id";
      }
      description
      "Reference to a VPN policy.  When referencing VPN
      policy for attachment, the vpn-policy-id must be
      configured.";
     }
    }
    case vpn-id {
     leaf vpn-id {
      type leafref {
       path "/l3vpn-svc/vpn-services"+
        "/vpn-service/vpn-id";
      }
      description
      "Reference to an IP VPN.  Referencing a vpn-id provides
      an easy way to attach a particular logical access to
      a VPN.  In this case, vpn-id must be configured.";
     }
     leaf site-role {
      type identityref {
       base site-role;
      }
      default any-to-any-role;
      description
      "Role of the site in the IP VPN.  When referencing a vpn-id,
      the site-role setting must be added to express the role of
      the site in the target VPN service topology.";
     }
    }
    mandatory true;
    description
    "Choice for VPN attachment flavor.  A choice is implemented
    to allow the user to choose the flavor that provides the
    best fit.";
   }
   description
   "Defines VPN attachment of a site.";
  }
  description
  "Defines the VPN attachment rules for
  a site's logical access.";
 }
 grouping vpn-profile-cfg {
  container valid-provider-identifiers {
   list cloud-identifier {
    if-feature cloud-access;
    key id;
    leaf id {
     type string;
     description
     "Identification of cloud service.
     Local administration meaning.";
    }
    description
    "List for Cloud Identifiers.";
   }
   list encryption-profile-identifier {
    key id;
    leaf id {
     type string;
     description
     "Identification of the SP encryption profile
     to be used.  Local administration meaning.";
    }
    description
    "List for encryption profile identifiers.";
   }
   list qos-profile-identifier {
    key id;
    leaf id {
     type string;
     description
     "Identification of the QoS Profile to be used.
     Local administration meaning.";
    }
    description
    "List for QoS Profile Identifiers.";
   }
   list bfd-profile-identifier {
    key id;
    leaf id {
     type string;
     description
     "Identification of the SP BFD Profile to be used.
     Local administration meaning.";
    }
    description
    "List for BFD Profile identifiers.";
   }
     description
     "Container for Valid Provider Identifies.";
  }
   description
   "Grouping for VPN Profile configuration.";
 }
 grouping vpn-svc-cfg {
  leaf vpn-id {
   type svc-id;
   description
   "VPN identifier.  Local administration meaning.";
  }
  leaf customer-name {
   type string;
   description
   "Name of the customer that actually uses the VPN service.
   In the case that any intermediary (e.g., Tier-2 provider
   or partner) sells the VPN service to their end user
   on behalf of the original service provider (e.g., Tier-1
   provider), the original service provider may require the
   customer name to provide smooth activation/commissioning
   and operation for the service.";
  }
  leaf vpn-service-topology {
   type identityref {
    base vpn-topology;
   }
   default any-to-any;
   description
   "VPN service topology.";
  }
  uses vpn-service-cloud-access;
  uses vpn-service-multicast;
  uses vpn-service-mpls;
  uses vpn-extranet;
  description
  "Grouping for VPN service configuration.";
 }
 grouping site-top-level-cfg {
  uses operational-requirements;
  uses customer-location-info;
  uses site-devices;
  uses site-diversity;
  uses site-management;
  uses site-vpn-policy;
  uses site-vpn-flavor;
  uses site-maximum-routes;
  uses site-security;
  uses site-service;
  uses site-protection;
  uses site-routing;
  description
  "Grouping for site top-level configuration.";
 }
 grouping site-network-access-top-level-cfg {
  leaf site-network-access-type {
   type identityref {
    base site-network-access-type;
   }
   default point-to-point;
   description
   "Describes the type of connection, e.g.,
   point-to-point or multipoint.";
  }
  choice location-flavor {
   case location {
    when "derived-from-or-self(../../management/type, "+
     "'l3vpn-svc:customer-managed')" {
     description
     "Applicable only for customer-managed device.";
    }
    leaf location-reference {
     type leafref {
      path "../../../locations/location/location-id";
     }
     description
     "Location of the site-network-access.";
    }
   }
   case device {
    when "derived-from-or-self(../../management/type, "+
     "'l3vpn-svc:provider-managed') or "+
     "derived-from-or-self(../../management/type, "+
     "'l3vpn-svc:co-managed')" {
     description
     "Applicable only for provider-managed or co-managed device.";
    }
    leaf device-reference {
     type leafref {
      path "../../../devices/device/device-id";
     }
     description
     "Identifier of CE to use.";
    }
   }
   mandatory true;
   description
   "Choice of how to describe the site's location.";
  }
  uses access-diversity;
  uses site-attachment-bearer;
  uses site-attachment-ip-connection;
  uses site-security;
  uses site-network-access-service;
  uses site-routing;
  uses site-attachment-availability;
  uses access-vpn-policy;
  description
  "Grouping for site network access top-level configuration.";
 }
 /* Main blocks */
 container l3vpn-svc {
  container vpn-profiles {
   uses vpn-profile-cfg;
    description
    "Container for VPN Profiles.";
  }
  container vpn-services {
   list vpn-service {
    key vpn-id;
    orchestron:transform sorespo.cfs.L3VpnVpnService;
    uses vpn-svc-cfg;
    description
    "List of VPN services.";
   }
   description
   "Top-level container for the VPN services.";
  }
  container sites {
   list site {
    key site-id;
    orchestron:transform sorespo.cfs.L3VpnSite;
    leaf site-id {
     type svc-id;
     description
     "Identifier of the site.";
    }
    uses site-top-level-cfg;
    uses operational-requirements-ops;
    container site-network-accesses {
     list site-network-access {
      key site-network-access-id;
      leaf site-network-access-id {
       type svc-id;
       description
       "Identifier for the access.";
      }
      uses site-network-access-top-level-cfg;
      description
      "List of accesses for a site.";
     }
     description
     "List of accesses for a site.";
    }
    description
    "List of sites.";
   }
   description
   "Container for sites.";
  }
  description
  "Main container for L3VPN service configuration.";
 }
}
""")
    res.append(r"""module ietf-yang-types {

  namespace "urn:ietf:params:xml:ns:yang:ietf-yang-types";
  prefix "yang";

  organization
   "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
   "WG Web:   <http://tools.ietf.org/wg/netmod/>
    WG List:  <mailto:netmod@ietf.org>

    WG Chair: David Kessens
              <mailto:david.kessens@nsn.com>

    WG Chair: Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>

    Editor:   Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>";

  description
   "This module contains a collection of generally useful derived
    YANG data types.

    Copyright (c) 2013 IETF Trust and the persons identified as
    authors of the code.  All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, is permitted pursuant to, and subject
    to the license terms contained in, the Simplified BSD License
    set forth in Section 4.c of the IETF Trust's Legal Provisions
    Relating to IETF Documents
    (http://trustee.ietf.org/license-info).

    This version of this YANG module is part of RFC 6991; see
    the RFC itself for full legal notices.";

  revision 2013-07-15 {
    description
     "This revision adds the following new data types:
      - yang-identifier
      - hex-string
      - uuid
      - dotted-quad";
    reference
     "RFC 6991: Common YANG Data Types";
  }

  revision 2010-09-24 {
    description
     "Initial revision.";
    reference
     "RFC 6021: Common YANG Data Types";
  }

  /*** collection of counter and gauge types ***/

  typedef counter32 {
    type uint32;
    description
     "The counter32 type represents a non-negative integer
      that monotonically increases until it reaches a
      maximum value of 2^32-1 (4294967295 decimal), when it
      wraps around and starts increasing again from zero.

      Counters have no defined 'initial' value, and thus, a
      single value of a counter has (in general) no information
      content.  Discontinuities in the monotonically increasing
      value normally occur at re-initialization of the
      management system, and at other times as specified in the
      description of a schema node using this type.  If such
      other times can occur, for example, the creation of
      a schema node of type counter32 at times other than
      re-initialization, then a corresponding schema node
      should be defined, with an appropriate type, to indicate
      the last discontinuity.

      The counter32 type should not be used for configuration
      schema nodes.  A default statement SHOULD NOT be used in
      combination with the type counter32.

      In the value set and its semantics, this type is equivalent
      to the Counter32 type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef zero-based-counter32 {
    type yang:counter32;
    default "0";
    description
     "The zero-based-counter32 type represents a counter32
      that has the defined 'initial' value zero.

      A schema node of this type will be set to zero (0) on creation
      and will thereafter increase monotonically until it reaches
      a maximum value of 2^32-1 (4294967295 decimal), when it
      wraps around and starts increasing again from zero.

      Provided that an application discovers a new schema node
      of this type within the minimum time to wrap, it can use the
      'initial' value as a delta.  It is important for a management
      station to be aware of this minimum time and the actual time
      between polls, and to discard data if the actual time is too
      long or there is no defined minimum time.

      In the value set and its semantics, this type is equivalent
      to the ZeroBasedCounter32 textual convention of the SMIv2.";
    reference
      "RFC 4502: Remote Network Monitoring Management Information
                 Base Version 2";
  }

  typedef counter64 {
    type uint64;
    description
     "The counter64 type represents a non-negative integer
      that monotonically increases until it reaches a
      maximum value of 2^64-1 (18446744073709551615 decimal),
      when it wraps around and starts increasing again from zero.

      Counters have no defined 'initial' value, and thus, a
      single value of a counter has (in general) no information
      content.  Discontinuities in the monotonically increasing
      value normally occur at re-initialization of the
      management system, and at other times as specified in the
      description of a schema node using this type.  If such
      other times can occur, for example, the creation of
      a schema node of type counter64 at times other than
      re-initialization, then a corresponding schema node
      should be defined, with an appropriate type, to indicate
      the last discontinuity.

      The counter64 type should not be used for configuration
      schema nodes.  A default statement SHOULD NOT be used in
      combination with the type counter64.

      In the value set and its semantics, this type is equivalent
      to the Counter64 type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef zero-based-counter64 {
    type yang:counter64;
    default "0";
    description
     "The zero-based-counter64 type represents a counter64 that
      has the defined 'initial' value zero.

      A schema node of this type will be set to zero (0) on creation
      and will thereafter increase monotonically until it reaches
      a maximum value of 2^64-1 (18446744073709551615 decimal),
      when it wraps around and starts increasing again from zero.

      Provided that an application discovers a new schema node
      of this type within the minimum time to wrap, it can use the
      'initial' value as a delta.  It is important for a management
      station to be aware of this minimum time and the actual time
      between polls, and to discard data if the actual time is too
      long or there is no defined minimum time.

      In the value set and its semantics, this type is equivalent
      to the ZeroBasedCounter64 textual convention of the SMIv2.";
    reference
     "RFC 2856: Textual Conventions for Additional High Capacity
                Data Types";
  }

  typedef gauge32 {
    type uint32;
    description
     "The gauge32 type represents a non-negative integer, which
      may increase or decrease, but shall never exceed a maximum
      value, nor fall below a minimum value.  The maximum value
      cannot be greater than 2^32-1 (4294967295 decimal), and
      the minimum value cannot be smaller than 0.  The value of
      a gauge32 has its maximum value whenever the information
      being modeled is greater than or equal to its maximum
      value, and has its minimum value whenever the information
      being modeled is smaller than or equal to its minimum value.
      If the information being modeled subsequently decreases
      below (increases above) the maximum (minimum) value, the
      gauge32 also decreases (increases).

      In the value set and its semantics, this type is equivalent
      to the Gauge32 type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef gauge64 {
    type uint64;
    description
     "The gauge64 type represents a non-negative integer, which
      may increase or decrease, but shall never exceed a maximum
      value, nor fall below a minimum value.  The maximum value
      cannot be greater than 2^64-1 (18446744073709551615), and
      the minimum value cannot be smaller than 0.  The value of
      a gauge64 has its maximum value whenever the information
      being modeled is greater than or equal to its maximum
      value, and has its minimum value whenever the information
      being modeled is smaller than or equal to its minimum value.
      If the information being modeled subsequently decreases
      below (increases above) the maximum (minimum) value, the
      gauge64 also decreases (increases).

      In the value set and its semantics, this type is equivalent
      to the CounterBasedGauge64 SMIv2 textual convention defined
      in RFC 2856";
    reference
     "RFC 2856: Textual Conventions for Additional High Capacity
                Data Types";
  }

  /*** collection of identifier-related types ***/

  typedef object-identifier {
    type string {
      pattern '(([0-1](\\.[1-3]?[0-9]))|(2\\.(0|([1-9]\\d*))))'
            + '(\\.(0|([1-9]\\d*)))*';
    }
    description
     "The object-identifier type represents administratively
      assigned names in a registration-hierarchical-name tree.

      Values of this type are denoted as a sequence of numerical
      non-negative sub-identifier values.  Each sub-identifier
      value MUST NOT exceed 2^32-1 (4294967295).  Sub-identifiers
      are separated by single dots and without any intermediate
      whitespace.

      The ASN.1 standard restricts the value space of the first
      sub-identifier to 0, 1, or 2.  Furthermore, the value space
      of the second sub-identifier is restricted to the range
      0 to 39 if the first sub-identifier is 0 or 1.  Finally,
      the ASN.1 standard requires that an object identifier
      has always at least two sub-identifiers.  The pattern
      captures these restrictions.

      Although the number of sub-identifiers is not limited,
      module designers should realize that there may be
      implementations that stick with the SMIv2 limit of 128
      sub-identifiers.

      This type is a superset of the SMIv2 OBJECT IDENTIFIER type
      since it is not restricted to 128 sub-identifiers.  Hence,
      this type SHOULD NOT be used to represent the SMIv2 OBJECT
      IDENTIFIER type; the object-identifier-128 type SHOULD be
      used instead.";
    reference
     "ISO9834-1: Information technology -- Open Systems
      Interconnection -- Procedures for the operation of OSI
      Registration Authorities: General procedures and top
      arcs of the ASN.1 Object Identifier tree";
  }

  typedef object-identifier-128 {
    type object-identifier {
      pattern '\\d*(\\.\\d*){1,127}';
    }
    description
     "This type represents object-identifiers restricted to 128
      sub-identifiers.

      In the value set and its semantics, this type is equivalent
      to the OBJECT IDENTIFIER type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef yang-identifier {
    type string {
      length "1..max";
      pattern '[a-zA-Z_][a-zA-Z0-9\\-_.]*';
      pattern '.|..|[^xX].*|.[^mM].*|..[^lL].*';
    }
    description
      "A YANG identifier string as defined by the 'identifier'
       rule in Section 12 of RFC 6020.  An identifier must
       start with an alphabetic character or an underscore
       followed by an arbitrary sequence of alphabetic or
       numeric characters, underscores, hyphens, or dots.

       A YANG identifier MUST NOT start with any possible
       combination of the lowercase or uppercase character
       sequence 'xml'.";
    reference
      "RFC 6020: YANG - A Data Modeling Language for the Network
                 Configuration Protocol (NETCONF)";
  }

  /*** collection of types related to date and time***/

  typedef date-and-time {
    type string {
      pattern '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?'
            + '(Z|[\\+\\-]\\d{2}:\\d{2})';
    }
    description
     "The date-and-time type is a profile of the ISO 8601
      standard for representation of dates and times using the
      Gregorian calendar.  The profile is defined by the
      date-time production in Section 5.6 of RFC 3339.

      The date-and-time type is compatible with the dateTime XML
      schema type with the following notable exceptions:

      (a) The date-and-time type does not allow negative years.

      (b) The date-and-time time-offset -00:00 indicates an unknown
          time zone (see RFC 3339) while -00:00 and +00:00 and Z
          all represent the same time zone in dateTime.

      (c) The canonical format (see below) of data-and-time values
          differs from the canonical format used by the dateTime XML
          schema type, which requires all times to be in UTC using
          the time-offset 'Z'.

      This type is not equivalent to the DateAndTime textual
      convention of the SMIv2 since RFC 3339 uses a different
      separator between full-date and full-time and provides
      higher resolution of time-secfrac.

      The canonical format for date-and-time values with a known time
      zone uses a numeric time zone offset that is calculated using
      the device's configured known offset to UTC time.  A change of
      the device's offset to UTC time will cause date-and-time values
      to change accordingly.  Such changes might happen periodically
      in case a server follows automatically daylight saving time
      (DST) time zone offset changes.  The canonical format for
      date-and-time values with an unknown time zone (usually
      referring to the notion of local time) uses the time-offset
      -00:00.";
    reference
     "RFC 3339: Date and Time on the Internet: Timestamps
      RFC 2579: Textual Conventions for SMIv2
      XSD-TYPES: XML Schema Part 2: Datatypes Second Edition";
  }

  typedef timeticks {
    type uint32;
    description
     "The timeticks type represents a non-negative integer that
      represents the time, modulo 2^32 (4294967296 decimal), in
      hundredths of a second between two epochs.  When a schema
      node is defined that uses this type, the description of
      the schema node identifies both of the reference epochs.

      In the value set and its semantics, this type is equivalent
      to the TimeTicks type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef timestamp {
    type yang:timeticks;
    description
     "The timestamp type represents the value of an associated
      timeticks schema node at which a specific occurrence
      happened.  The specific occurrence must be defined in the
      description of any schema node defined using this type.  When
      the specific occurrence occurred prior to the last time the
      associated timeticks attribute was zero, then the timestamp
      value is zero.  Note that this requires all timestamp values
      to be reset to zero when the value of the associated timeticks
      attribute reaches 497+ days and wraps around to zero.

      The associated timeticks schema node must be specified
      in the description of any schema node using this type.

      In the value set and its semantics, this type is equivalent
      to the TimeStamp textual convention of the SMIv2.";
    reference
     "RFC 2579: Textual Conventions for SMIv2";
  }

  /*** collection of generic address types ***/

  typedef phys-address {
    type string {
      pattern '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?';
    }

    description
     "Represents media- or physical-level addresses represented
      as a sequence octets, each octet represented by two hexadecimal
      numbers.  Octets are separated by colons.  The canonical
      representation uses lowercase characters.

      In the value set and its semantics, this type is equivalent
      to the PhysAddress textual convention of the SMIv2.";
    reference
     "RFC 2579: Textual Conventions for SMIv2";
  }

  typedef mac-address {
    type string {
      pattern '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}';
    }
    description
     "The mac-address type represents an IEEE 802 MAC address.
      The canonical representation uses lowercase characters.

      In the value set and its semantics, this type is equivalent
      to the MacAddress textual convention of the SMIv2.";
    reference
     "IEEE 802: IEEE Standard for Local and Metropolitan Area
                Networks: Overview and Architecture
      RFC 2579: Textual Conventions for SMIv2";
  }

  /*** collection of XML-specific types ***/

  typedef xpath1.0 {
    type string;
    description
     "This type represents an XPATH 1.0 expression.

      When a schema node is defined that uses this type, the
      description of the schema node MUST specify the XPath
      context in which the XPath expression is evaluated.";
    reference
     "XPATH: XML Path Language (XPath) Version 1.0";
  }

  /*** collection of string types ***/

  typedef hex-string {
    type string {
      pattern '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?';
    }
    description
     "A hexadecimal string with octets represented as hex digits
      separated by colons.  The canonical representation uses
      lowercase characters.";
  }

  typedef uuid {
    type string {
      pattern '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-'
            + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}';
    }
    description
     "A Universally Unique IDentifier in the string representation
      defined in RFC 4122.  The canonical representation uses
      lowercase characters.

      The following is an example of a UUID in string representation:
      f81d4fae-7dec-11d0-a765-00a0c91e6bf6
      ";
    reference
     "RFC 4122: A Universally Unique IDentifier (UUID) URN
                Namespace";
  }

  typedef dotted-quad {
    type string {
      pattern
        '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}'
      + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
    }
    description
      "An unsigned 32-bit number expressed in the dotted-quad
       notation, i.e., four octets written as decimal numbers
       and separated with the '.' (full stop) character.";
  }
}
""")
    res.append(r"""module netinfra {
  yang-version "1.1";
  namespace "http://example.com/netinfra";
  prefix "netinfra";
  description "Network Infrastructure";
  revision 2019-01-01 {
    description "test revision";
    reference "ref1";
  }
  import ietf-inet-types {
    prefix inet;
  }

  container netinfra {
    description "Network infrastructure";
    list router {
      key name;

      orchestron:transform sorespo.cfs.Router;

      leaf name {
        type string;
      }
      leaf id {
        type uint32;
        description "router id";
        mandatory true;
      }
      leaf type {
        type string;
        mandatory true;
      }
      leaf role {
        type string;
      }
      leaf asn {
        type inet:as-number;
        mandatory true;
      }
      leaf mock {
        type enumeration {
          enum cisco-ios-xr;
          enum juniper-junos;
        }
      }
      leaf approval-required {
        type boolean;
        default false;
      }
    }

    list backbone-link {
      key "left-router left-interface right-router right-interface";

      orchestron:transform sorespo.cfs.BBLink;

      leaf left-router {
        type string;
      }
      leaf left-interface {
        type string;
      }
      leaf right-router {
        type string;
      }
      leaf right-interface {
        type string;
      }
      leaf monitor-health {
        type boolean;
        default false;
      }
    }
  }
}
""")
    res.append(r"""module ietf-inet-types {

  namespace "urn:ietf:params:xml:ns:yang:ietf-inet-types";
  prefix "inet";

  organization
   "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
   "WG Web:   <http://tools.ietf.org/wg/netmod/>
    WG List:  <mailto:netmod@ietf.org>

    WG Chair: David Kessens
              <mailto:david.kessens@nsn.com>

    WG Chair: Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>

    Editor:   Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>";

  description
   "This module contains a collection of generally useful derived
    YANG data types for Internet addresses and related things.

    Copyright (c) 2013 IETF Trust and the persons identified as
    authors of the code.  All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, is permitted pursuant to, and subject
    to the license terms contained in, the Simplified BSD License
    set forth in Section 4.c of the IETF Trust's Legal Provisions
    Relating to IETF Documents
    (http://trustee.ietf.org/license-info).

    This version of this YANG module is part of RFC 6991; see
    the RFC itself for full legal notices.";

  revision 2013-07-15 {
    description
     "This revision adds the following new data types:
      - ip-address-no-zone
      - ipv4-address-no-zone
      - ipv6-address-no-zone";
    reference
     "RFC 6991: Common YANG Data Types";
  }

  revision 2010-09-24 {
    description
     "Initial revision.";
    reference
     "RFC 6021: Common YANG Data Types";
  }

  /*** collection of types related to protocol fields ***/

  typedef ip-version {
    type enumeration {
      enum unknown {
        value "0";
        description
         "An unknown or unspecified version of the Internet
          protocol.";
      }
      enum ipv4 {
        value "1";
        description
         "The IPv4 protocol as defined in RFC 791.";
      }
      enum ipv6 {
        value "2";
        description
         "The IPv6 protocol as defined in RFC 2460.";
      }
    }
    description
     "This value represents the version of the IP protocol.

      In the value set and its semantics, this type is equivalent
      to the InetVersion textual convention of the SMIv2.";
    reference
     "RFC  791: Internet Protocol
      RFC 2460: Internet Protocol, Version 6 (IPv6) Specification
      RFC 4001: Textual Conventions for Internet Network Addresses";
  }

  typedef dscp {
    type uint8 {
      range "0..63";
    }
    description
     "The dscp type represents a Differentiated Services Code Point
      that may be used for marking packets in a traffic stream.
      In the value set and its semantics, this type is equivalent
      to the Dscp textual convention of the SMIv2.";
    reference
     "RFC 3289: Management Information Base for the Differentiated
                Services Architecture
      RFC 2474: Definition of the Differentiated Services Field
                (DS Field) in the IPv4 and IPv6 Headers
      RFC 2780: IANA Allocation Guidelines For Values In
                the Internet Protocol and Related Headers";
  }

  typedef ipv6-flow-label {
    type uint32 {
      range "0..1048575";
    }
    description
     "The ipv6-flow-label type represents the flow identifier or Flow
      Label in an IPv6 packet header that may be used to
      discriminate traffic flows.

      In the value set and its semantics, this type is equivalent
      to the IPv6FlowLabel textual convention of the SMIv2.";
    reference
     "RFC 3595: Textual Conventions for IPv6 Flow Label
      RFC 2460: Internet Protocol, Version 6 (IPv6) Specification";
  }

  typedef port-number {
    type uint16 {
      range "0..65535";
    }
    description
     "The port-number type represents a 16-bit port number of an
      Internet transport-layer protocol such as UDP, TCP, DCCP, or
      SCTP.  Port numbers are assigned by IANA.  A current list of
      all assignments is available from <http://www.iana.org/>.

      Note that the port number value zero is reserved by IANA.  In
      situations where the value zero does not make sense, it can
      be excluded by subtyping the port-number type.
      In the value set and its semantics, this type is equivalent
      to the InetPortNumber textual convention of the SMIv2.";
    reference
     "RFC  768: User Datagram Protocol
      RFC  793: Transmission Control Protocol
      RFC 4960: Stream Control Transmission Protocol
      RFC 4340: Datagram Congestion Control Protocol (DCCP)
      RFC 4001: Textual Conventions for Internet Network Addresses";
  }

  /*** collection of types related to autonomous systems ***/

  typedef as-number {
    type uint32;
    description
     "The as-number type represents autonomous system numbers
      which identify an Autonomous System (AS).  An AS is a set
      of routers under a single technical administration, using
      an interior gateway protocol and common metrics to route
      packets within the AS, and using an exterior gateway
      protocol to route packets to other ASes.  IANA maintains
      the AS number space and has delegated large parts to the
      regional registries.

      Autonomous system numbers were originally limited to 16
      bits.  BGP extensions have enlarged the autonomous system
      number space to 32 bits.  This type therefore uses an uint32
      base type without a range restriction in order to support
      a larger autonomous system number space.

      In the value set and its semantics, this type is equivalent
      to the InetAutonomousSystemNumber textual convention of
      the SMIv2.";
    reference
     "RFC 1930: Guidelines for creation, selection, and registration
                of an Autonomous System (AS)
      RFC 4271: A Border Gateway Protocol 4 (BGP-4)
      RFC 4001: Textual Conventions for Internet Network Addresses
      RFC 6793: BGP Support for Four-Octet Autonomous System (AS)
                Number Space";
  }

  /*** collection of types related to IP addresses and hostnames ***/

  typedef ip-address {
    type union {
      type inet:ipv4-address;
      type inet:ipv6-address;
    }
    description
     "The ip-address type represents an IP address and is IP
      version neutral.  The format of the textual representation
      implies the IP version.  This type supports scoped addresses
      by allowing zone identifiers in the address format.";
    reference
     "RFC 4007: IPv6 Scoped Address Architecture";
  }

  typedef ipv4-address {
    type string {
      pattern
        '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
      +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
      + '(%[\p{N}\p{L}]+)?';
    }
    description
      "The ipv4-address type represents an IPv4 address in
       dotted-quad notation.  The IPv4 address may include a zone
       index, separated by a % sign.

       The zone index is used to disambiguate identical address
       values.  For link-local addresses, the zone index will
       typically be the interface index number or the name of an
       interface.  If the zone index is not present, the default
       zone of the device will be used.

       The canonical format for the zone index is the numerical
       format";
  }

  typedef ipv6-address {
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
            + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
            + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
            + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
            + '(%[\p{N}\p{L}]+)?';
      pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
            + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
            + '(%.+)?';
    }
    description
     "The ipv6-address type represents an IPv6 address in full,
      mixed, shortened, and shortened-mixed notation.  The IPv6
      address may include a zone index, separated by a % sign.

      The zone index is used to disambiguate identical address
      values.  For link-local addresses, the zone index will
      typically be the interface index number or the name of an
      interface.  If the zone index is not present, the default
      zone of the device will be used.

      The canonical format of IPv6 addresses uses the textual
      representation defined in Section 4 of RFC 5952.  The
      canonical format for the zone index is the numerical
      format as described in Section 11.2 of RFC 4007.";
    reference
     "RFC 4291: IP Version 6 Addressing Architecture
      RFC 4007: IPv6 Scoped Address Architecture
      RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
  }

  typedef ip-address-no-zone {
    type union {
      type inet:ipv4-address-no-zone;
      type inet:ipv6-address-no-zone;
    }
    description
     "The ip-address-no-zone type represents an IP address and is
      IP version neutral.  The format of the textual representation
      implies the IP version.  This type does not support scoped
      addresses since it does not allow zone identifiers in the
      address format.";
    reference
     "RFC 4007: IPv6 Scoped Address Architecture";
  }

  typedef ipv4-address-no-zone {
    type inet:ipv4-address {
      pattern '[0-9\.]*';
    }
    description
      "An IPv4 address without a zone index.  This type, derived from
       ipv4-address, may be used in situations where the zone is
       known from the context and hence no zone index is needed.";
  }

  typedef ipv6-address-no-zone {
    type inet:ipv6-address {
      pattern '[0-9a-fA-F:\.]*';
    }
    description
      "An IPv6 address without a zone index.  This type, derived from
       ipv6-address, may be used in situations where the zone is
       known from the context and hence no zone index is needed.";
    reference
     "RFC 4291: IP Version 6 Addressing Architecture
      RFC 4007: IPv6 Scoped Address Architecture
      RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
  }

  typedef ip-prefix {
    type union {
      type inet:ipv4-prefix;
      type inet:ipv6-prefix;
    }
    description
     "The ip-prefix type represents an IP prefix and is IP
      version neutral.  The format of the textual representations
      implies the IP version.";
  }

  typedef ipv4-prefix {
    type string {
      pattern
         '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
       +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
       + '/(([0-9])|([1-2][0-9])|(3[0-2]))';
    }
    description
     "The ipv4-prefix type represents an IPv4 address prefix.
      The prefix length is given by the number following the
      slash character and must be less than or equal to 32.

      A prefix length value of n corresponds to an IP address
      mask that has n contiguous 1-bits from the most
      significant bit (MSB) and all other bits set to 0.

      The canonical format of an IPv4 prefix has all bits of
      the IPv4 address set to zero that are not part of the
      IPv4 prefix.";
  }

  typedef ipv6-prefix {
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
            + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
            + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
            + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
            + '(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))';
      pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
            + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
            + '(/.+)';
    }

    description
     "The ipv6-prefix type represents an IPv6 address prefix.
      The prefix length is given by the number following the
      slash character and must be less than or equal to 128.

      A prefix length value of n corresponds to an IP address
      mask that has n contiguous 1-bits from the most
      significant bit (MSB) and all other bits set to 0.

      The IPv6 address should have all bits that do not belong
      to the prefix set to zero.

      The canonical format of an IPv6 prefix has all bits of
      the IPv6 address set to zero that are not part of the
      IPv6 prefix.  Furthermore, the IPv6 address is represented
      as defined in Section 4 of RFC 5952.";
    reference
     "RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
  }

  /*** collection of domain name and URI types ***/

  typedef domain-name {
    type string {
      pattern
        '((([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.)*'
      + '([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.?)'
      + '|\.';
      length "1..253";
    }
    description
     "The domain-name type represents a DNS domain name.  The
      name SHOULD be fully qualified whenever possible.

      Internet domain names are only loosely specified.  Section
      3.5 of RFC 1034 recommends a syntax (modified in Section
      2.1 of RFC 1123).  The pattern above is intended to allow
      for current practice in domain name use, and some possible
      future expansion.  It is designed to hold various types of
      domain names, including names used for A or AAAA records
      (host names) and other records, such as SRV records.  Note
      that Internet host names have a stricter syntax (described
      in RFC 952) than the DNS recommendations in RFCs 1034 and
      1123, and that systems that want to store host names in
      schema nodes using the domain-name type are recommended to
      adhere to this stricter standard to ensure interoperability.

      The encoding of DNS names in the DNS protocol is limited
      to 255 characters.  Since the encoding consists of labels
      prefixed by a length bytes and there is a trailing NULL
      byte, only 253 characters can appear in the textual dotted
      notation.

      The description clause of schema nodes using the domain-name
      type MUST describe when and how these names are resolved to
      IP addresses.  Note that the resolution of a domain-name value
      may require to query multiple DNS records (e.g., A for IPv4
      and AAAA for IPv6).  The order of the resolution process and
      which DNS record takes precedence can either be defined
      explicitly or may depend on the configuration of the
      resolver.

      Domain-name values use the US-ASCII encoding.  Their canonical
      format uses lowercase US-ASCII characters.  Internationalized
      domain names MUST be A-labels as per RFC 5890.";
    reference
     "RFC  952: DoD Internet Host Table Specification
      RFC 1034: Domain Names - Concepts and Facilities
      RFC 1123: Requirements for Internet Hosts -- Application
                and Support
      RFC 2782: A DNS RR for specifying the location of services
                (DNS SRV)
      RFC 5890: Internationalized Domain Names in Applications
                (IDNA): Definitions and Document Framework";
  }

  typedef host {
    type union {
      type inet:ip-address;
      type inet:domain-name;
    }
    description
     "The host type represents either an IP address or a DNS
      domain name.";
  }

  typedef uri {
    type string;
    description
     "The uri type represents a Uniform Resource Identifier
      (URI) as defined by STD 66.

      Objects using the uri type MUST be in US-ASCII encoding,
      and MUST be normalized as described by RFC 3986 Sections
      6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary
      percent-encoding is removed, and all case-insensitive
      characters are set to lowercase except for hexadecimal
      digits, which are normalized to uppercase as described in
      Section 6.2.2.1.

      The purpose of this normalization is to help provide
      unique URIs.  Note that this normalization is not
      sufficient to provide uniqueness.  Two URIs that are
      textually distinct after this normalization may still be
      equivalent.

      Objects using the uri type may restrict the schemes that
      they permit.  For example, 'data:' and 'urn:' schemes
      might not be appropriate.

      A zero-length URI is not a valid URI.  This can be used to
      express 'URI absent' where required.

      In the value set and its semantics, this type is equivalent
      to the Uri SMIv2 textual convention defined in RFC 5017.";
    reference
     "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax
      RFC 3305: Report from the Joint W3C/IETF URI Planning Interest
                Group: Uniform Resource Identifiers (URIs), URLs,
                and Uniform Resource Names (URNs): Clarifications
                and Recommendations
      RFC 5017: MIB Textual Conventions for Uniform Resource
                Identifiers (URIs)";
  }

}
""")
    res.append(r"""module orchestron-tmf {
  yang-version "1.1";
  namespace "http://orchestron.org/yang/orchestron-tmf";
  prefix "otmf";
  import orchestron-tmf640 {
    prefix otmf640;
  }
  description "Orchestron TMF";
  revision 2025-10-26 {
    description "Initial revision";
  }

  container tmf-store {
    description "TMF Data Store";
    container tmf640 {
      description "TMF640 - Service Activation and Configuration";
      list service {
        key id;
        orchestron:transform sorespo.tmf.Tmf640Store;
        uses otmf640:Service;
      }
    }
  }
}
""")
    res.append(r"""module orchestron-tmf640 {
  yang-version "1.1";
  namespace "http://orchestron.org/yang/orchestron-tmf640";
  prefix "otmf640";
  import ietf-inet-types {
    prefix inet;
  }
  import ietf-yang-types {
    prefix yang;
  }
  description "TMF640 Service Activation and Configuration";
  revision 2025-10-26 {
    description "Initial revision";
  }

  typedef OrderItemActionType {
    type enumeration {
      enum add;
      enum modify;
      enum delete;
      enum noChange;
    }
    description "action to be performed on the product";
  }

  typedef ServiceStateType {
    type enumeration {
      enum feasibilityChecked;
      enum designed;
      enum reserved;
      enum inactive;
      enum active;
      enum terminated;
    }
    description
     "Valid values for the lifecycle state of theservice";
  }

  grouping Addressable {
    description "Base schema for adressable entities";
    leaf id {
      type string;
      description "unique identifier";
    }
    leaf href {
      type inet:uri;
      description "Hyperlink reference";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
  }

  grouping Characteristic {
    description
     "Describes a given characteristic of an object or entity through
      a name/value pair.";
    leaf id {
      type string;
      mandatory true;
      description "Unique identifier of the characteristic";
    }
    leaf name {
      type string;
      mandatory true;
      description "Name of the characteristic";
    }
    // The value and valueType are not stored in the TMF Store
    // because they are stored on the respective leaf
    // of the destination transform.
    list characteristicRelationship {
      key "id";
      uses CharacteristicRelationship;
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }     
  }

  grouping CharacteristicRelationship {
    description
     "Another Characteristic that is related to the current
      Characteristic;";
    leaf id {
      type string;
      description "Unique identifier of the characteristic";
    }
    leaf relationshipType {
      type string;
      description "The type of relationship";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
  }

  grouping Constraint {
    description
     "Constraint reference. The Constraint resource represents a
      policy/rule applied to an entity or entity spec.";
    leaf id {
      type string;
      mandatory true;
      description "reference id to the target constraint";
    }
    leaf href {
      type string;
      description "Hyperlink reference to the target constraint";
    }
    leaf name {
      type string;
      description "Name given to the constraint";
    }
    leaf version {
      type string;
      description "constraint version";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
    leaf referredType {
      type string;
      description "The (class) type of the referred constraint";
    }
  }

  grouping EntityRef {
    description
     "Entity reference schema to be use for all entityRef class.";
    leaf id {
      type string;
      mandatory true;
      description "unique identifier";
    }
    leaf href {
      type inet:uri;
      description "Hyperlink reference";
    }
    leaf name {
      type string;
      description "Name of the related entity.";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class Extensible
        name";
    }
    leaf referredType {
      type string;
      description
       "The actual type of the target instance when needed for
        disambiguation.";
    }
  }

  grouping EntityValue {
    description
     "Base entity value  schema for use in TMForum Open-APIs";
    leaf id {
      type string;
      description "Unique identifier of a related entity.";
    }
    leaf href {
      type string;
      description "Reference of the related entity.";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
  }

  grouping Extensible {
    description
     "Base Extensible schema for use in TMForum Open-APIs";
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class Extensible
        name";
    }
  }

  grouping Feature {
    description "Configuration feature.";
    leaf id {
      type string;
      description "Unique identifier of the feature.";
    }
    leaf isBundle {
      type boolean;
      description
       "True if this is a feature group. Default is false.";
    }
    leaf isEnabled {
      type boolean;
      description
       "True if this feature is enabled. Default is true.";
    }
    leaf name {
      type string;
      mandatory true;
      description "This is the name for the feature.";
    }
    list constraint {
      key "id";
      uses Constraint;
      description "This is a list of feature constraints.";
    }
    list featureCharacteristic {
        key "id";
        uses Characteristic;
        min-elements 1;
        description
         "This is a list of Characteristics for a particular
          feature.";
    }
    list featureRelationship {
      key "id";
      uses FeatureRelationship;
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional attributes
        and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
  }

  grouping FeatureRelationship {
    description "Configuration feature";
    leaf id {
      type string;
      description "Unique identifier of the target feature.";
    }
    leaf name {
      type string;
      mandatory true;
      description "This is the name of the target feature.";
    }
    leaf relationshipType {
      type string;
      mandatory true;
      description "This is the type of the feature relationship.";
    }
    container validFor {
      uses TimePeriod;
      description
       "The period for which this feature relationship is valid.";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
  }

  grouping HeaderItem {
    description
     "An item typically included in a request or response";
    leaf name {
      type string;
      mandatory true;
      description "The name of the header item, e.g. locale";
    }
    leaf value {
      type string;
      mandatory true;
      description "The value of the header item, e.g. en-us";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
  }

  grouping Monitor {
    description "Monitoring of resources";
    leaf id {
      type string;
      description
       "Identifier of an instance of the monitor. Required to be
        unique within the resource type.  Used in URIs as the
        identifier for specific instances of a type";
    }
    leaf href {
      type string;
      description "reference to this monitor";
    }
    leaf sourceHref {
      type string;
      description "The monitored resource href";
    }
    leaf state {
      type string;
      description
       "The Monitor state of the resource.  InProgress, InError,
        Completed";
    }
    container request {
      uses Request;
      description "Represents the request";
    }
    container response {
      uses Response;
      description "Represents the response";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
  }

  grouping Note {
    description "Extra information about a given entity";
    leaf id {
      type string;
      description
       "Identifier of the note within its containing entity (may or
        may not be globally unique, depending on provider
        implementation)";
    }
    leaf author {
      type string;
      description "Author of the note";
    }
    leaf date {
      type yang:date-and-time;
      description "Date of the note";
    }
    leaf text {
      type string;
      description "Text of the note";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
  }

  grouping Place {
    description
     "Place reference. Place defines the places where the products
      are sold or delivered.";
    leaf id {
      type string;
      description "Unique identifier of the place";
    }
    leaf href {
      type string;
      description "Unique reference of the place";
    }
    leaf name {
      type string;
      description
       "A user-friendly name for the place, such as [Paris Store],
        [London Store], [Main Home]";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
  }

  grouping PlaceRef {
    description
     "Place reference. PlaceRef defines the placeRefs where the
      products are sold or delivered.";
    leaf id {
      type string;
      mandatory true;
      description "unique identifier";
    }
    leaf href {
      type inet:uri;
      description "Hyperlink reference";
    }
    leaf name {
      type string;
      description "Name of the related entity.";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class Extensible
        name";
    }
    leaf referredType {
      type string;
      description
       "The actual type of the target instance when needed for
        disambiguation.";
    }
  }

  grouping RelatedEntityRefOrValue {
    description
     "A reference to an entity, where the type of the entity is not
      known in advance. A related entity defines a entity described
      by reference or by value linked to a specific entity. The
      polymorphic attributes type, schemaLocation & referredType are
      related to the Entity and not the RelatedEntityRefOrValue class
      itself";
    leaf id {
      type string;
      description "Unique identifier of a related entity.";
    }
    leaf href {
      type string;
      description "Reference of the related entity.";
    }
    leaf name {
      type string;
      description "Name of the related entity.";
    }
    leaf role {
      type string;
      mandatory true;
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class Extensible
        name";
    }
    leaf referredType {
      type string;
      description
       "The actual type of the target instance when needed for
        disambiguation.";
    }
  }

  grouping RelatedParty {
    description
     "Related Entity reference. A related party defines party or
      party role linked to a specific entity.";
    leaf id {
      type string;
      mandatory true;
      description "unique identifier";
    }
    leaf href {
      type inet:uri;
      description "Hyperlink reference";
    }
    leaf name {
      type string;
      description "Name of the related entity.";
    }
    leaf role {
      type string;
      description "Role played by the related party";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class Extensible
        name";
    }
    leaf referredType {
      type string;
      mandatory true;
      description
       "The actual type of the target instance when needed for
        disambiguation.";
    }
  }

  grouping RelatedPlaceRefOrValue {
    description
     "Related Entity reference. A related place defines a place
      described by reference or by value linked to a specific entity.
      The polymorphic attributes type, schemaLocation & referredType
      are related to the place entity and not the
      RelatedPlaceRefOrValue class itself";
    leaf id {
      type string;
      description "Unique identifier of the place";
    }
    leaf href {
      type string;
      description "Unique reference of the place";
    }
    leaf name {
      type string;
      description
       "A user-friendly name for the place, such as [Paris Store],
        [London Store], [Main Home]";
    }
    leaf role {
      type string;
      mandatory true;
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
       attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class Extensible
       name";
    }
    leaf referredType {
      type string;
      description
       "The actual type of the target instance when needed for
       disambiguation.";
    }
  }

  grouping RelatedServiceOrderItem {
    description
     "RelatedServiceOrderItem (a ServiceOrder item) .The service
      order item which triggered service
      creation/change/termination.";
    leaf itemId {
      type string;
      mandatory true;
      description
       "Identifier of the order item where the service was managed";
    }
    leaf role {
      type string;
      description
       "role of the service order item for this service";
    }
    leaf serviceOrderHref {
      type string;
      description "Reference of the related entity.";
    }
    leaf serviceOrderId {
      type string;
      mandatory true;
      description "Unique identifier of a related entity.";
    }
    leaf itemAction {
      type OrderItemActionType;
      description "Action of the order item for this service";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
    leaf referredType {
      type string;
      description
       "The actual type of the target instance when needed for
        disambiguation.";
    }
  }

  grouping Request {
    description "A response to a request";
    leaf body {
      type string;
      mandatory true;
      description
       "The body of the request. For example for an HTTP request
        might contain content of a form .";
    }
    leaf method {
      type string;
      description "The protocol of the request, e.g. http";
    }
    leaf to {
      type string;
      description
       "The target of the request, e.g. a URL for an HTTP request";
    }
    list header {
      uses HeaderItem;
      min-elements 1;
      description
       "Items included in the header of the request. For example for
        an HTTP request might contain requested locale, basic
        authentication.";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
  }

  grouping ResourceRef {
    leaf id {
      type string;
      mandatory true;
      description "unique identifier";
    }
    leaf href {
      type inet:uri;
      description "Hyperlink reference";
    }
    leaf name {
      type string;
      description "Name of the related entity.";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class Extensible
        name";
    }
    leaf referredType {
      type string;
      description
       "The actual type of the target instance when needed for
        disambiguation.";
    }
  }

  grouping Response {
    description "A response to a request";
    leaf body {
      type string;
      mandatory true;
      description
       "The body of the response. For example for an HTTP response
        might contain HTML for rendering.";
    }
    leaf statusCode {
      type string;
      description
       "The status of the response. For example for an HTTP
        response would be codes such as 200, 400, etc.";
    }
    list header {
      uses HeaderItem;
      min-elements 1;
      description
       "Items included in the header of the response. For example
        for an HTTP response might contain negotiated locale.";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
  }

  grouping Service {
    description
     "Service is a base class for defining the Service hierarchy.
      All Services are characterized as either being possibly
      visible and usable by a Customer or not. This gives rise to
      the two subclasses of Service: CustomerFacingService and
      ResourceFacingService.";
    leaf id {
      type string;
      mandatory true;
      description "Unique identifier of the service";
    }
    leaf href {
      type string;
      description "Reference of the service";
    }
    leaf category {
      type string;
      description
       "Is it a customer facing or resource facing service";
    }
    leaf description {
      type string;
      description "Free-text description of the service";
    }
    leaf endDate {
      type yang:date-and-time;
      description "Date when the service ends";
    }
    leaf hasStarted {
      type boolean;
      description "If TRUE, this Service has already been started";
    }
    leaf isBundle {
      type boolean;
      description
       "If true, the service is a ServiceBundle which regroup a
        service hierachy. If false, the service is a 'atomic' service
        (hierachy leaf).";
    }
    leaf isServiceEnabled {
      type boolean;
      description
       "If FALSE and hasStarted is FALSE, this particular Service has
        NOT been enabled for use - if FALSE and hasStarted is TRUE
        then the service has failed ";
    }
    leaf isStateful {
      type boolean;
      description
       "If TRUE, this Service can be changed without affecting any
        other services";
    }
    leaf name {
      type string;
      description "Name of the service";
    }
    leaf serviceDate {
      type string;
      description
       "Date when the service was created (whatever its status).";
    }
    leaf serviceType {
      type string;
      description "Business type of the service";
    }
    leaf startDate {
      type yang:date-and-time;
      description "Date when the service starts";
    }
    leaf startMode {
      type string;
      description
       "This attribute is an enumerated integer that indicates how
        the Service is started, such as: 0: Unknown; 1: Automatically
        by the managed environment; 2: Automatically by the owning
        device; 3: Manually by the Provider of the Service; 4:
        Manually by a Customer of the Provider; 5: Any of the above";
    }
    list feature {
      key "id";
      uses Feature;
      description
       "A list of feature associated with this service ";
    }
    list note {
      key "id";
      uses Note;
      description "A list of notes made on this service";
    }
    list place {
      key "id";
      uses RelatedPlaceRefOrValue;
      description
       "A list of places (Place [*]). Used to define a place useful 
        or the service (for example a geographical place whre the
        service is installed)";
    }
    list relatedEntity {
      key "id";
      uses RelatedEntityRefOrValue;
      description
       "A list of related  entity in relationship with this service";
    }
    list relatedParty {
      key "id";
      uses RelatedParty;
      description
       "A list of related party references (RelatedParty [*]). A
        related party defines party or party role linked to a
        specific entity";
    }
    list serviceCharacteristic {
      key "id";
      uses Characteristic;
       description
        "A list of characteristics that characterize this service
         (ServiceCharacteristic [*]) ";
    }
    list serviceOrderItem {
      key "itemId";
      uses RelatedServiceOrderItem;
      description
       "A list of service order items related to this service";
    }
    list serviceRelationship {
      key "service";
      uses ServiceRelationship;
      description
       "A list of service relationships (ServiceRelationship [*]).
        Describes links with other service(s) in the inventory
        (useful for describing relies-on, relies-from between CFS
        for example).";
    }
    container serviceSpecification {
      uses ServiceSpecificationRef;
      description
       "The specification from which this service was instantiated";
    }
    leaf state {
      type ServiceStateType;
      description
       "The life cycle state of the service, such as designed,
        reserved, active, etc...";
    }
    list supportingResource {
      key "id";
      uses ResourceRef;
      description
       "A list of supporting resources (SupportingResource [*]).Note:
        only Service of type RFS can be associated with Resources";
    }
    leaf-list supportingService {
      type leafref {
        path "../../service/id";
      }
      description
       "A list of supporting services (SupportingService [*]). A
        collection of services that support this service (bundling,
        link CFS to RFS)";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
  }

  grouping ServiceRef {
    description
     "Service reference, for when Service is used by other entities";
    leaf id {
      type string;
      mandatory true;
      description "unique identifier";
    }
    leaf href {
      type inet:uri;
      description "Hyperlink reference";
    }
    leaf name {
      type string;
      description "Name of the related entity.";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class Extensible
        name";
    }
    leaf referredType {
      type string;
      description
       "The actual type of the target instance when needed for
        disambiguation.";
    }
  }

  grouping ServiceRelationship {
    leaf relationshipType {
      type string;
      mandatory true;
    }
    list ServiceRelationshipCharacteristic {
      key "id";
      uses Characteristic;
    }
    leaf service {
      type leafref {
        path "../../../service/id";
      }
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
  }

  grouping ServiceSpecificationRef {
      description
       "Service specification reference: ServiceSpecification(s)
        required to realize a ProductSpecification.";
      leaf id {
        type string;
        mandatory true;
        description "unique identifier";
      }
      leaf href {
        type inet:uri;
        description "Hyperlink reference";
      }
      leaf name {
        type string;
        description "Name of the related entity.";
      }
      leaf version {
        type string;
        description "Service specification version";
      }
      leaf baseType {
        type string;
        description "When sub-classing, this defines the
         super-class";
      }
      leaf schemaLocation {
        type inet:uri;
        description "A URI to a JSON-Schema file that defines
         additional attributes and relationships";
      }
      leaf type {
        type string;
        description "When sub-classing, this defines the sub-class
         Extensible name";
      }
      leaf referredType {
        type string;
        description
         "The actual type of the target instance when needed for
          disambiguation.";
      }
  }

  grouping TimePeriod {
    description
     "A period of time, either as a deadline (endDateTime only)
      a startDateTime only, or both";
    leaf endDateTime {
      type yang:date-and-time;
      description
       "End of the time period, using IETC-RFC-3339 format";
    }
    leaf startDateTime {
      type yang:date-and-time;
      description
       "Start of the time period, using IETC-RFC-3339 format. If you
        define a start, you must also define an end";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name";
    }
  }

  grouping EventSubscription {
    description
     "Sets the communication endpoint address the service instance
      must use to deliver notification information";
    leaf id {
      type string;
      mandatory true;
      description "Id of the listener";
    }
    leaf callback {
      type string;
      mandatory true;
      description "The callback being registered.";
    }
    leaf query {
      type string;
      description "additional data to be passed";
    }
  }

  grouping EventSubscriptionInput {
    description
     "Sets the communication endpoint address the service instance
      must use to deliver notification information";
    leaf callback {
      type string;
      mandatory true;
      description "The callback being registered.";
    }
    leaf query {
      type string;
      description "additional data to be passed";
    }
  }

  grouping ServiceCreateEvent {
    description "The notification data structure";
    container event {
      description
       "The event payload linked to the involved resource object";
      uses ServiceCreateEventPayload;
    }
    leaf eventId {
      type string;
      description "The identifier of the notification.";
    }
    leaf eventTime {
      type yang:date-and-time;
      description "Time of the event occurrence.";
    }
    leaf eventType {
      type string;
      description "The type of the notification.";
    }
    leaf correlationId {
      type string;
      description "The correlation id for this event.";
    }
    leaf domain {
      type string;
      description "The domain of the event.";
    }
    leaf title {
      type string;
      description "The title of the event.";
    }
    leaf description {
      type string;
      description "An explnatory of the event.";
    }
    leaf priority {
      type string;
      description "A priority.";
    }
    leaf timeOcurred {
      type yang:date-and-time;
      description "The time the event occured.";
    }
  }

  grouping ServiceCreateEventPayload {
    description "The event data structure";
    container service {
      description "The involved resource data for the event";
      uses Service;
    }
  }

  grouping ServiceAttributeValueChangeEvent {
    description "The notification data structure";
    leaf eventId {
      type string;
      description "The identifier of the notification.";
    }
    leaf eventTime {
      type yang:date-and-time;
      description "Time of the event occurrence.";
    }
    leaf eventType {
      type string;
      description "The type of the notification.";
    }
    leaf correlationId {
      type string;
      description "The correlation id for this event.";
    }
    leaf domain {
      type string;
      description "The domain of the event.";
    }
    leaf title {
      type string;
      description "The title of the event.";
    }
    leaf description {
      type string;
      description "An explnatory of the event.";
    }
    leaf priority {
      type string;
      description "A priority.";
    }
    leaf timeOcurred {
      type yang:date-and-time;
      description "The time the event occured.";
    }
    leaf fieldPath {
      type string;
      description
       "The path identifying the object field concerned by this
        notification.";
    }
    container event {
      description
       "The event payload linked to the involved resource object";
      uses ServiceAttributeValueChangeEventPayload;
    }
  }

  grouping ServiceAttributeValueChangeEventPayload {
      description "The event data structure";
          container service {
              description "The involved resource data for the event";
              uses Service;
          }
  }

  grouping ServiceStateChangeEvent {
    description "The notification data structure";
    container event {
      description
       "The event payload linked to the involved resource object";
      uses ServiceStateChangeEventPayload;
    }
    leaf eventId {
      type string;
      description "The identifier of the notification.";
    }
    leaf eventTime {
      type yang:date-and-time;
      description "Time of the event occurrence.";
    }
    leaf eventType {
      type string;
      description "The type of the notification.";
    }
    leaf correlationId {
      type string;
      description "The correlation id for this event.";
    }
    leaf domain {
      type string;
      description "The domain of the event.";
    }
    leaf title {
      type string;
      description "The title of the event.";
    }
    leaf description {
      type string;
      description "An explnatory of the event.";
    }
    leaf priority {
      type string;
      description "A priority.";
    }
    leaf timeOcurred {
      type yang:date-and-time;
      description "The time the event occured.";
    }
  }

  grouping ServiceStateChangeEventPayload {
    description "The event data structure";
    container service {
      description "The involved resource data for the event";
      uses Service;
    }
  }

  grouping ServiceDeleteEvent {
    description "The notification data structure";
    container event {
      description
       "The event payload linked to the involved resource object";
      uses ServiceDeleteEventPayload;
    }
    leaf eventId {
      type string;
      description "The identifier of the notification.";
    }
    leaf eventTime {
      type yang:date-and-time;
      description "Time of the event occurrence.";
    }
    leaf eventType {
      type string;
      description "The type of the notification.";
    }
    leaf correlationId {
      type string;
      description "The correlation id for this event.";
    }
    leaf domain {
      type string;
      description "The domain of the event.";
    }
    leaf title {
      type string;
      description "The title of the event.";
    }
    leaf description {
      type string;
      description "An explnatory of the event.";
    }
    leaf priority {
      type string;
      description "A priority.";
    }
    leaf timeOcurred {
      type yang:date-and-time;
      description "The time the event occured.";
    }
  }

  grouping ServiceDeleteEventPayload {
    description "The event data structure";
    container service {
      description "The involved resource data for the event";
      uses Service;
    }
  }

  grouping MonitorCreateEvent {
    description "The notification data structure";
    container event {
      description
       "The event payload linked to the involved resource object";
      uses MonitorCreateEventPayload;
    }
    leaf eventId {
      type string;
      description "The identifier of the notification.";
    }
    leaf eventTime {
      type yang:date-and-time;
      description "Time of the event occurrence.";
    }
    leaf eventType {
      type string;
      description "The type of the notification.";
    }
    leaf correlationId {
      type string;
      description "The correlation id for this event.";
    }
    leaf domain {
      type string;
      description "The domain of the event.";
    }
    leaf title {
      type string;
      description "The title of the event.";
    }
    leaf description {
      type string;
      description "An explnatory of the event.";
    }
    leaf priority {
      type string;
      description "A priority.";
    }
    leaf timeOcurred {
      type yang:date-and-time;
      description "The time the event occured.";
    }
  }

  grouping MonitorCreateEventPayload {
    description "The event data structure";
    container monitor {
      description "The involved resource data for the event";
      uses Monitor;
    }
  }

  grouping MonitorAttributeValueChangeEvent {
    description "The notification data structure";
    leaf eventId {
      type string;
      description "The identifier of the notification.";
    }
    leaf eventTime {
      type yang:date-and-time;
      description "Time of the event occurrence.";
    }
    leaf eventType {
      type string;
      description "The type of the notification.";
    }
    leaf correlationId {
      type string;
      description "The correlation id for this event.";
    }
    leaf domain {
      type string;
      description "The domain of the event.";
    }
    leaf title {
      type string;
      description "The title of the event.";
    }
    leaf description {
      type string;
      description "An explnatory of the event.";
    }
    leaf priority {
      type string;
      description "A priority.";
    }
    leaf timeOcurred {
      type yang:date-and-time;
      description "The time the event occured.";
    }
    leaf fieldPath {
      type string;
      description
       "The path identifying the object field concerned by this
        notification.";
    }
    container event {
      description
       "The event payload linked to the involved resource object";
      uses MonitorAttributeValueChangeEventPayload;
    }
  }

  grouping MonitorAttributeValueChangeEventPayload {
    description "The event data structure";
    container monitor {
      description "The involved resource data for the event";
      uses Monitor;
    }
  }

  grouping MonitorStateChangeEvent {
    description "The notification data structure";
    container event {
      description
       "The event payload linked to the involved resource object";
      uses MonitorStateChangeEventPayload;
    }
    leaf eventId {
      type string;
      description "The identifier of the notification.";
    }
    leaf eventTime {
      type yang:date-and-time;
      description "Time of the event occurrence.";
    }
    leaf eventType {
      type string;
      description "The type of the notification.";
    }
    leaf correlationId {
      type string;
      description "The correlation id for this event.";
    }
    leaf domain {
      type string;
      description "The domain of the event.";
    }
    leaf title {
      type string;
      description "The title of the event.";
    }
    leaf description {
      type string;
      description "An explnatory of the event.";
    }
    leaf priority {
      type string;
      description "A priority.";
    }
    leaf timeOcurred {
      type yang:date-and-time;
      description "The time the event occured.";
    }
  }

  grouping MonitorStateChangeEventPayload {
    description "The event data structure";
    container monitor {
      description "The involved resource data for the event";
      uses Monitor;
    }
  }

  grouping MonitorDeleteEvent {
    description "The notification data structure";
    container event {
      description
       "The event payload linked to the involved resource object";
      uses MonitorDeleteEventPayload;
    }
    leaf eventId {
      type string;
      description "The identifier of the notification.";
    }
    leaf eventTime {
      type yang:date-and-time;
      description "Time of the event occurrence.";
    }
    leaf eventType {
      type string;
      description "The type of the notification.";
    }
    leaf correlationId {
      type string;
      description "The correlation id for this event.";
    }
    leaf domain {
      type string;
      description "The domain of the event.";
    }
    leaf title {
      type string;
      description "The title of the event.";
    }
    leaf description {
      type string;
      description "An explnatory of the event.";
    }
    leaf priority {
      type string;
      description "A priority.";
    }
    leaf timeOcurred {
      type yang:date-and-time;
      description "The time the event occured.";
    }
  }

  grouping MonitorDeleteEventPayload {
    description "The event data structure";
    container monitor {
      description "The involved resource data for the event";
      uses Monitor;
    }
  }

  grouping Error {
    description
     "Used when an API throws an Error, typically with a HTTP error
      response-code (3xx, 4xx, 5xx)";
    leaf code {
      type string;
      mandatory true;
      description
       "Application relevant detail, defined in the API or a common
        list.";
    }
    leaf reason {
      type string;
      mandatory true;
      description
       "Explanation of the reason for the error which can be shown
        to a client user.";
    }
    leaf message {
      type string;
      description
       "More details and corrective actions related to the error
        which can be shown to a client user.";
    }
    leaf status {
      type string;
      description "HTTP Error code extension";
    }
    leaf referenceError {
      type inet:uri;
      description "URI of documentation describing the error.";
    }
    leaf baseType {
      type string;
      description
       "When sub-classing, this defines the super-class.";
    }
    leaf schemaLocation {
      type inet:uri;
      description
       "A URI to a JSON-Schema file that defines additional
        attributes and relationships";
    }
    leaf type {
      type string;
      description
       "When sub-classing, this defines the sub-class entity name.";
    }
  }
}
""")
    return res


class orchestron_tmf__tmf_store__tmf640__service__feature__constraint_entry(yang.adata.MNode):
    id: str
    href: ?str
    name: ?str
    version: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str
    referredType: ?str

    mut def __init__(self, id: str, href: ?str, name: ?str, version: ?str, baseType: ?str, schemaLocation: ?str, type: ?str, referredType: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.href = href
        self.name = name
        self.version = version
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type
        self.referredType = referredType

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'href':
            return self.href
        if name == 'name':
            return self.name
        if name == 'version':
            return self.version
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        if name == 'referredType':
            return self.referredType
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__feature__constraint')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'feature', 'constraint'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__feature__constraint_entry:
        return orchestron_tmf__tmf_store__tmf640__service__feature__constraint_entry(id=n.get_str('id'), href=n.get_opt_str('href'), name=n.get_opt_str('name'), version=n.get_opt_str('version'), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'), referredType=n.get_opt_str('referredType'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__feature__constraint_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__feature__constraint(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__feature__constraint_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'constraint'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__feature__constraint_entry(id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__feature__constraint_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__feature__constraint_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__feature__constraint(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__feature__constraint(Iterable[orchestron_tmf__tmf_store__tmf640__service__feature__constraint_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__feature__constraint_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship_entry(yang.adata.MNode):
    id: str
    relationshipType: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    mut def __init__(self, id: str, relationshipType: ?str, baseType: ?str, schemaLocation: ?str, type: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.relationshipType = relationshipType
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'relationshipType':
            return self.relationshipType
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'feature', 'featureCharacteristic', 'characteristicRelationship'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship_entry:
        return orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship_entry(id=n.get_str('id'), relationshipType=n.get_opt_str('relationshipType'), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'characteristicRelationship'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship_entry(id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship(Iterable[orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic_entry(yang.adata.MNode):
    id: str
    name: str
    characteristicRelationship: orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    mut def __init__(self, id: str, name: str, characteristicRelationship: list[orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship_entry]=[], baseType: ?str, schemaLocation: ?str, type: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.name = name
        self.characteristicRelationship = orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship(elements=characteristicRelationship)
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'name':
            return self.name
        if name == 'characteristicRelationship':
            return iter(self.characteristicRelationship)
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'feature', 'featureCharacteristic'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic_entry:
        return orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic_entry(id=n.get_str('id'), name=n.get_str('name'), characteristicRelationship=orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic__characteristicRelationship.from_gdata(n.get_opt_list('characteristicRelationship')), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'featureCharacteristic'
        self.elements = elements

    mut def create(self, id, name):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic_entry(id, name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic(Iterable[orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship__validFor(yang.adata.MNode):
    endDateTime: ?str
    startDateTime: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    mut def __init__(self, endDateTime: ?str, startDateTime: ?str, baseType: ?str, schemaLocation: ?str, type: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.endDateTime = endDateTime
        self.startDateTime = startDateTime
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type

    def _get_attr(self, name: str) -> ?value:
        if name == 'endDateTime':
            return self.endDateTime
        if name == 'startDateTime':
            return self.startDateTime
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship__validFor')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'feature', 'featureRelationship', 'validFor'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship__validFor:
        if n is not None:
            return orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship__validFor(endDateTime=n.get_opt_str('endDateTime'), startDateTime=n.get_opt_str('startDateTime'), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'))
        return orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship__validFor()

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship__validFor.from_gdata(self.to_gdata())


class orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship_entry(yang.adata.MNode):
    id: str
    name: str
    relationshipType: str
    validFor: orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship__validFor
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    mut def __init__(self, id: str, name: str, relationshipType: str, validFor: ?orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship__validFor=None, baseType: ?str, schemaLocation: ?str, type: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.name = name
        self.relationshipType = relationshipType
        self.validFor = validFor if validFor is not None else orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship__validFor()
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'name':
            return self.name
        if name == 'relationshipType':
            return self.relationshipType
        if name == 'validFor':
            return self.validFor
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'feature', 'featureRelationship'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship_entry:
        return orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship_entry(id=n.get_str('id'), name=n.get_str('name'), relationshipType=n.get_str('relationshipType'), validFor=orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship__validFor.from_gdata(n.get_opt_cnt('validFor')), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'featureRelationship'
        self.elements = elements

    mut def create(self, id, name, relationshipType):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship_entry(id, name, relationshipType)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship(Iterable[orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service__feature_entry(yang.adata.MNode):
    id: str
    isBundle: ?bool
    isEnabled: ?bool
    name: str
    constraint: orchestron_tmf__tmf_store__tmf640__service__feature__constraint
    featureCharacteristic: orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic
    featureRelationship: orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    mut def __init__(self, id: str, name: str, isBundle: ?bool, isEnabled: ?bool, constraint: list[orchestron_tmf__tmf_store__tmf640__service__feature__constraint_entry]=[], featureCharacteristic: list[orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic_entry]=[], featureRelationship: list[orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship_entry]=[], baseType: ?str, schemaLocation: ?str, type: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.isBundle = isBundle
        self.isEnabled = isEnabled
        self.name = name
        self.constraint = orchestron_tmf__tmf_store__tmf640__service__feature__constraint(elements=constraint)
        self.featureCharacteristic = orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic(elements=featureCharacteristic)
        self.featureRelationship = orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship(elements=featureRelationship)
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'isBundle':
            return self.isBundle
        if name == 'isEnabled':
            return self.isEnabled
        if name == 'name':
            return self.name
        if name == 'constraint':
            return iter(self.constraint)
        if name == 'featureCharacteristic':
            return iter(self.featureCharacteristic)
        if name == 'featureRelationship':
            return iter(self.featureRelationship)
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__feature')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'feature'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__feature_entry:
        return orchestron_tmf__tmf_store__tmf640__service__feature_entry(id=n.get_str('id'), isBundle=n.get_opt_bool('isBundle'), isEnabled=n.get_opt_bool('isEnabled'), name=n.get_str('name'), constraint=orchestron_tmf__tmf_store__tmf640__service__feature__constraint.from_gdata(n.get_opt_list('constraint')), featureCharacteristic=orchestron_tmf__tmf_store__tmf640__service__feature__featureCharacteristic.from_gdata(n.get_list('featureCharacteristic')), featureRelationship=orchestron_tmf__tmf_store__tmf640__service__feature__featureRelationship.from_gdata(n.get_opt_list('featureRelationship')), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__feature_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__feature(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__feature_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'feature'
        self.elements = elements

    mut def create(self, id, name):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__feature_entry(id, name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__feature_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__feature_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__feature(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__feature(Iterable[orchestron_tmf__tmf_store__tmf640__service__feature_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__feature_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service__note_entry(yang.adata.MNode):
    id: str
    author: ?str
    date: ?str
    text: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    mut def __init__(self, id: str, author: ?str, date: ?str, text: ?str, baseType: ?str, schemaLocation: ?str, type: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.author = author
        self.date = date
        self.text = text
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'author':
            return self.author
        if name == 'date':
            return self.date
        if name == 'text':
            return self.text
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__note')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'note'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__note_entry:
        return orchestron_tmf__tmf_store__tmf640__service__note_entry(id=n.get_str('id'), author=n.get_opt_str('author'), date=n.get_opt_str('date'), text=n.get_opt_str('text'), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__note_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__note(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__note_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'note'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__note_entry(id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__note_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__note_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__note(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__note(Iterable[orchestron_tmf__tmf_store__tmf640__service__note_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__note_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service__place_entry(yang.adata.MNode):
    id: str
    href: ?str
    name: ?str
    role: str
    baseType: ?str
    schemaLocation: ?str
    type: ?str
    referredType: ?str

    mut def __init__(self, id: str, role: str, href: ?str, name: ?str, baseType: ?str, schemaLocation: ?str, type: ?str, referredType: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.href = href
        self.name = name
        self.role = role
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type
        self.referredType = referredType

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'href':
            return self.href
        if name == 'name':
            return self.name
        if name == 'role':
            return self.role
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        if name == 'referredType':
            return self.referredType
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__place')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'place'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__place_entry:
        return orchestron_tmf__tmf_store__tmf640__service__place_entry(id=n.get_str('id'), href=n.get_opt_str('href'), name=n.get_opt_str('name'), role=n.get_str('role'), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'), referredType=n.get_opt_str('referredType'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__place_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__place(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__place_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'place'
        self.elements = elements

    mut def create(self, id, role):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__place_entry(id, role)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__place_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__place_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__place(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__place(Iterable[orchestron_tmf__tmf_store__tmf640__service__place_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__place_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service__relatedEntity_entry(yang.adata.MNode):
    id: str
    href: ?str
    name: ?str
    role: str
    baseType: ?str
    schemaLocation: ?str
    type: ?str
    referredType: ?str

    mut def __init__(self, id: str, role: str, href: ?str, name: ?str, baseType: ?str, schemaLocation: ?str, type: ?str, referredType: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.href = href
        self.name = name
        self.role = role
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type
        self.referredType = referredType

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'href':
            return self.href
        if name == 'name':
            return self.name
        if name == 'role':
            return self.role
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        if name == 'referredType':
            return self.referredType
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__relatedEntity')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'relatedEntity'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__relatedEntity_entry:
        return orchestron_tmf__tmf_store__tmf640__service__relatedEntity_entry(id=n.get_str('id'), href=n.get_opt_str('href'), name=n.get_opt_str('name'), role=n.get_str('role'), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'), referredType=n.get_opt_str('referredType'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__relatedEntity_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__relatedEntity(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__relatedEntity_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'relatedEntity'
        self.elements = elements

    mut def create(self, id, role):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__relatedEntity_entry(id, role)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__relatedEntity_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__relatedEntity_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__relatedEntity(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__relatedEntity(Iterable[orchestron_tmf__tmf_store__tmf640__service__relatedEntity_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__relatedEntity_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service__relatedParty_entry(yang.adata.MNode):
    id: str
    href: ?str
    name: ?str
    role: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str
    referredType: str

    mut def __init__(self, id: str, referredType: str, href: ?str, name: ?str, role: ?str, baseType: ?str, schemaLocation: ?str, type: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.href = href
        self.name = name
        self.role = role
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type
        self.referredType = referredType

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'href':
            return self.href
        if name == 'name':
            return self.name
        if name == 'role':
            return self.role
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        if name == 'referredType':
            return self.referredType
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__relatedParty')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'relatedParty'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__relatedParty_entry:
        return orchestron_tmf__tmf_store__tmf640__service__relatedParty_entry(id=n.get_str('id'), href=n.get_opt_str('href'), name=n.get_opt_str('name'), role=n.get_opt_str('role'), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'), referredType=n.get_str('referredType'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__relatedParty_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__relatedParty(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__relatedParty_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'relatedParty'
        self.elements = elements

    mut def create(self, id, referredType):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__relatedParty_entry(id, referredType)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__relatedParty_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__relatedParty_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__relatedParty(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__relatedParty(Iterable[orchestron_tmf__tmf_store__tmf640__service__relatedParty_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__relatedParty_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship_entry(yang.adata.MNode):
    id: str
    relationshipType: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    mut def __init__(self, id: str, relationshipType: ?str, baseType: ?str, schemaLocation: ?str, type: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.relationshipType = relationshipType
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'relationshipType':
            return self.relationshipType
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'serviceCharacteristic', 'characteristicRelationship'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship_entry:
        return orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship_entry(id=n.get_str('id'), relationshipType=n.get_opt_str('relationshipType'), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'characteristicRelationship'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship_entry(id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship(Iterable[orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic_entry(yang.adata.MNode):
    id: str
    name: str
    characteristicRelationship: orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    mut def __init__(self, id: str, name: str, characteristicRelationship: list[orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship_entry]=[], baseType: ?str, schemaLocation: ?str, type: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.name = name
        self.characteristicRelationship = orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship(elements=characteristicRelationship)
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'name':
            return self.name
        if name == 'characteristicRelationship':
            return iter(self.characteristicRelationship)
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'serviceCharacteristic'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic_entry:
        return orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic_entry(id=n.get_str('id'), name=n.get_str('name'), characteristicRelationship=orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic__characteristicRelationship.from_gdata(n.get_opt_list('characteristicRelationship')), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'serviceCharacteristic'
        self.elements = elements

    mut def create(self, id, name):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic_entry(id, name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic(Iterable[orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem_entry(yang.adata.MNode):
    itemId: str
    role: ?str
    serviceOrderHref: ?str
    serviceOrderId: str
    itemAction: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str
    referredType: ?str

    mut def __init__(self, itemId: str, serviceOrderId: str, role: ?str, serviceOrderHref: ?str, itemAction: ?str, baseType: ?str, schemaLocation: ?str, type: ?str, referredType: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.itemId = itemId
        self.role = role
        self.serviceOrderHref = serviceOrderHref
        self.serviceOrderId = serviceOrderId
        self.itemAction = itemAction
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type
        self.referredType = referredType

    def _get_attr(self, name: str) -> ?value:
        if name == 'itemId':
            return self.itemId
        if name == 'role':
            return self.role
        if name == 'serviceOrderHref':
            return self.serviceOrderHref
        if name == 'serviceOrderId':
            return self.serviceOrderId
        if name == 'itemAction':
            return self.itemAction
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        if name == 'referredType':
            return self.referredType
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'serviceOrderItem'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem_entry:
        return orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem_entry(itemId=n.get_str('itemId'), role=n.get_opt_str('role'), serviceOrderHref=n.get_opt_str('serviceOrderHref'), serviceOrderId=n.get_str('serviceOrderId'), itemAction=n.get_opt_str('itemAction'), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'), referredType=n.get_opt_str('referredType'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'serviceOrderItem'
        self.elements = elements

    mut def create(self, itemId, serviceOrderId):
        for e in self:
            match = True
            if e.itemId != itemId:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem_entry(itemId, serviceOrderId)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem(Iterable[orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship_entry(yang.adata.MNode):
    id: str
    relationshipType: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    mut def __init__(self, id: str, relationshipType: ?str, baseType: ?str, schemaLocation: ?str, type: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.relationshipType = relationshipType
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'relationshipType':
            return self.relationshipType
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'serviceRelationship', 'ServiceRelationshipCharacteristic', 'characteristicRelationship'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship_entry:
        return orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship_entry(id=n.get_str('id'), relationshipType=n.get_opt_str('relationshipType'), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'characteristicRelationship'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship_entry(id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship(Iterable[orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic_entry(yang.adata.MNode):
    id: str
    name: str
    characteristicRelationship: orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    mut def __init__(self, id: str, name: str, characteristicRelationship: list[orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship_entry]=[], baseType: ?str, schemaLocation: ?str, type: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.name = name
        self.characteristicRelationship = orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship(elements=characteristicRelationship)
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'name':
            return self.name
        if name == 'characteristicRelationship':
            return iter(self.characteristicRelationship)
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'serviceRelationship', 'ServiceRelationshipCharacteristic'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic_entry:
        return orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic_entry(id=n.get_str('id'), name=n.get_str('name'), characteristicRelationship=orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic__characteristicRelationship.from_gdata(n.get_opt_list('characteristicRelationship')), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'ServiceRelationshipCharacteristic'
        self.elements = elements

    mut def create(self, id, name):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic_entry(id, name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic(Iterable[orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service__serviceRelationship_entry(yang.adata.MNode):
    service: str
    relationshipType: str
    ServiceRelationshipCharacteristic: orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    mut def __init__(self, service: str, relationshipType: str, ServiceRelationshipCharacteristic: list[orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic_entry]=[], baseType: ?str, schemaLocation: ?str, type: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.service = service
        self.relationshipType = relationshipType
        self.ServiceRelationshipCharacteristic = orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic(elements=ServiceRelationshipCharacteristic)
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type

    def _get_attr(self, name: str) -> ?value:
        if name == 'service':
            return self.service
        if name == 'relationshipType':
            return self.relationshipType
        if name == 'ServiceRelationshipCharacteristic':
            return iter(self.ServiceRelationshipCharacteristic)
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__serviceRelationship')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'serviceRelationship'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__serviceRelationship_entry:
        return orchestron_tmf__tmf_store__tmf640__service__serviceRelationship_entry(service=n.get_str('service'), relationshipType=n.get_str('relationshipType'), ServiceRelationshipCharacteristic=orchestron_tmf__tmf_store__tmf640__service__serviceRelationship__ServiceRelationshipCharacteristic.from_gdata(n.get_opt_list('ServiceRelationshipCharacteristic')), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__serviceRelationship_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__serviceRelationship(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__serviceRelationship_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'serviceRelationship'
        self.elements = elements

    mut def create(self, service, relationshipType):
        for e in self:
            match = True
            if e.service != service:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__serviceRelationship_entry(service, relationshipType)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__serviceRelationship_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__serviceRelationship_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__serviceRelationship(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__serviceRelationship(Iterable[orchestron_tmf__tmf_store__tmf640__service__serviceRelationship_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__serviceRelationship_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service__serviceSpecification(yang.adata.MNode):
    id: str
    href: ?str
    name: ?str
    version: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str
    referredType: ?str

    mut def __init__(self, id: str, href: ?str, name: ?str, version: ?str, baseType: ?str, schemaLocation: ?str, type: ?str, referredType: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.href = href
        self.name = name
        self.version = version
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type
        self.referredType = referredType

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'href':
            return self.href
        if name == 'name':
            return self.name
        if name == 'version':
            return self.version
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        if name == 'referredType':
            return self.referredType
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__serviceSpecification')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'serviceSpecification'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__serviceSpecification:
        if n is not None:
            return orchestron_tmf__tmf_store__tmf640__service__serviceSpecification(id=n.get_str('id'), href=n.get_opt_str('href'), name=n.get_opt_str('name'), version=n.get_opt_str('version'), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'), referredType=n.get_opt_str('referredType'))
        raise ValueError('Missing required subtree orchestron_tmf__tmf_store__tmf640__service__serviceSpecification')

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__serviceSpecification.from_gdata(self.to_gdata())


class orchestron_tmf__tmf_store__tmf640__service__supportingResource_entry(yang.adata.MNode):
    id: str
    href: ?str
    name: ?str
    baseType: ?str
    schemaLocation: ?str
    type: ?str
    referredType: ?str

    mut def __init__(self, id: str, href: ?str, name: ?str, baseType: ?str, schemaLocation: ?str, type: ?str, referredType: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.href = href
        self.name = name
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type
        self.referredType = referredType

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'href':
            return self.href
        if name == 'name':
            return self.name
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        if name == 'referredType':
            return self.referredType
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service__supportingResource')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service', 'supportingResource'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service__supportingResource_entry:
        return orchestron_tmf__tmf_store__tmf640__service__supportingResource_entry(id=n.get_str('id'), href=n.get_opt_str('href'), name=n.get_opt_str('name'), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'), referredType=n.get_opt_str('referredType'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service__supportingResource_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service__supportingResource(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service__supportingResource_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'supportingResource'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service__supportingResource_entry(id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service__supportingResource_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service__supportingResource_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service__supportingResource(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service__supportingResource(Iterable[orchestron_tmf__tmf_store__tmf640__service__supportingResource_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service__supportingResource_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640__service_entry(yang.adata.MNode):
    id: str
    href: ?str
    category: ?str
    description: ?str
    endDate: ?str
    hasStarted: ?bool
    isBundle: ?bool
    isServiceEnabled: ?bool
    isStateful: ?bool
    name: ?str
    serviceDate: ?str
    serviceType: ?str
    startDate: ?str
    startMode: ?str
    feature: orchestron_tmf__tmf_store__tmf640__service__feature
    note: orchestron_tmf__tmf_store__tmf640__service__note
    place: orchestron_tmf__tmf_store__tmf640__service__place
    relatedEntity: orchestron_tmf__tmf_store__tmf640__service__relatedEntity
    relatedParty: orchestron_tmf__tmf_store__tmf640__service__relatedParty
    serviceCharacteristic: orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic
    serviceOrderItem: orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem
    serviceRelationship: orchestron_tmf__tmf_store__tmf640__service__serviceRelationship
    serviceSpecification: orchestron_tmf__tmf_store__tmf640__service__serviceSpecification
    state: ?str
    supportingResource: orchestron_tmf__tmf_store__tmf640__service__supportingResource
    supportingService: list[str]
    baseType: ?str
    schemaLocation: ?str
    type: ?str

    mut def __init__(self, id: str, serviceSpecification: orchestron_tmf__tmf_store__tmf640__service__serviceSpecification, href: ?str, category: ?str, description: ?str, endDate: ?str, hasStarted: ?bool, isBundle: ?bool, isServiceEnabled: ?bool, isStateful: ?bool, name: ?str, serviceDate: ?str, serviceType: ?str, startDate: ?str, startMode: ?str, feature: list[orchestron_tmf__tmf_store__tmf640__service__feature_entry]=[], note: list[orchestron_tmf__tmf_store__tmf640__service__note_entry]=[], place: list[orchestron_tmf__tmf_store__tmf640__service__place_entry]=[], relatedEntity: list[orchestron_tmf__tmf_store__tmf640__service__relatedEntity_entry]=[], relatedParty: list[orchestron_tmf__tmf_store__tmf640__service__relatedParty_entry]=[], serviceCharacteristic: list[orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic_entry]=[], serviceOrderItem: list[orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem_entry]=[], serviceRelationship: list[orchestron_tmf__tmf_store__tmf640__service__serviceRelationship_entry]=[], state: ?str, supportingResource: list[orchestron_tmf__tmf_store__tmf640__service__supportingResource_entry]=[], supportingService: ?list[str]=None, baseType: ?str, schemaLocation: ?str, type: ?str):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.id = id
        self.href = href
        self.category = category
        self.description = description
        self.endDate = endDate
        self.hasStarted = hasStarted
        self.isBundle = isBundle
        self.isServiceEnabled = isServiceEnabled
        self.isStateful = isStateful
        self.name = name
        self.serviceDate = serviceDate
        self.serviceType = serviceType
        self.startDate = startDate
        self.startMode = startMode
        self.feature = orchestron_tmf__tmf_store__tmf640__service__feature(elements=feature)
        self.note = orchestron_tmf__tmf_store__tmf640__service__note(elements=note)
        self.place = orchestron_tmf__tmf_store__tmf640__service__place(elements=place)
        self.relatedEntity = orchestron_tmf__tmf_store__tmf640__service__relatedEntity(elements=relatedEntity)
        self.relatedParty = orchestron_tmf__tmf_store__tmf640__service__relatedParty(elements=relatedParty)
        self.serviceCharacteristic = orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic(elements=serviceCharacteristic)
        self.serviceOrderItem = orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem(elements=serviceOrderItem)
        self.serviceRelationship = orchestron_tmf__tmf_store__tmf640__service__serviceRelationship(elements=serviceRelationship)
        self.serviceSpecification = serviceSpecification
        self.state = state
        self.supportingResource = orchestron_tmf__tmf_store__tmf640__service__supportingResource(elements=supportingResource)
        self.supportingService = supportingService if supportingService is not None else []
        self.baseType = baseType
        self.schemaLocation = schemaLocation
        self.type = type

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'href':
            return self.href
        if name == 'category':
            return self.category
        if name == 'description':
            return self.description
        if name == 'endDate':
            return self.endDate
        if name == 'hasStarted':
            return self.hasStarted
        if name == 'isBundle':
            return self.isBundle
        if name == 'isServiceEnabled':
            return self.isServiceEnabled
        if name == 'isStateful':
            return self.isStateful
        if name == 'name':
            return self.name
        if name == 'serviceDate':
            return self.serviceDate
        if name == 'serviceType':
            return self.serviceType
        if name == 'startDate':
            return self.startDate
        if name == 'startMode':
            return self.startMode
        if name == 'feature':
            return iter(self.feature)
        if name == 'note':
            return iter(self.note)
        if name == 'place':
            return iter(self.place)
        if name == 'relatedEntity':
            return iter(self.relatedEntity)
        if name == 'relatedParty':
            return iter(self.relatedParty)
        if name == 'serviceCharacteristic':
            return iter(self.serviceCharacteristic)
        if name == 'serviceOrderItem':
            return iter(self.serviceOrderItem)
        if name == 'serviceRelationship':
            return iter(self.serviceRelationship)
        if name == 'serviceSpecification':
            return self.serviceSpecification
        if name == 'state':
            return self.state
        if name == 'supportingResource':
            return iter(self.supportingResource)
        if name == 'supportingService':
            return self.supportingService
        if name == 'baseType':
            return self.baseType
        if name == 'schemaLocation':
            return self.schemaLocation
        if name == 'type':
            return self.type
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640__service')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640', 'service'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640__service_entry:
        return orchestron_tmf__tmf_store__tmf640__service_entry(id=n.get_str('id'), href=n.get_opt_str('href'), category=n.get_opt_str('category'), description=n.get_opt_str('description'), endDate=n.get_opt_str('endDate'), hasStarted=n.get_opt_bool('hasStarted'), isBundle=n.get_opt_bool('isBundle'), isServiceEnabled=n.get_opt_bool('isServiceEnabled'), isStateful=n.get_opt_bool('isStateful'), name=n.get_opt_str('name'), serviceDate=n.get_opt_str('serviceDate'), serviceType=n.get_opt_str('serviceType'), startDate=n.get_opt_str('startDate'), startMode=n.get_opt_str('startMode'), feature=orchestron_tmf__tmf_store__tmf640__service__feature.from_gdata(n.get_opt_list('feature')), note=orchestron_tmf__tmf_store__tmf640__service__note.from_gdata(n.get_opt_list('note')), place=orchestron_tmf__tmf_store__tmf640__service__place.from_gdata(n.get_opt_list('place')), relatedEntity=orchestron_tmf__tmf_store__tmf640__service__relatedEntity.from_gdata(n.get_opt_list('relatedEntity')), relatedParty=orchestron_tmf__tmf_store__tmf640__service__relatedParty.from_gdata(n.get_opt_list('relatedParty')), serviceCharacteristic=orchestron_tmf__tmf_store__tmf640__service__serviceCharacteristic.from_gdata(n.get_opt_list('serviceCharacteristic')), serviceOrderItem=orchestron_tmf__tmf_store__tmf640__service__serviceOrderItem.from_gdata(n.get_opt_list('serviceOrderItem')), serviceRelationship=orchestron_tmf__tmf_store__tmf640__service__serviceRelationship.from_gdata(n.get_opt_list('serviceRelationship')), serviceSpecification=orchestron_tmf__tmf_store__tmf640__service__serviceSpecification.from_gdata(n.get_cnt('serviceSpecification')), state=n.get_opt_str('state'), supportingResource=orchestron_tmf__tmf_store__tmf640__service__supportingResource.from_gdata(n.get_opt_list('supportingResource')), supportingService=n.get_opt_strs('supportingService'), baseType=n.get_opt_str('baseType'), schemaLocation=n.get_opt_str('schemaLocation'), type=n.get_opt_str('type'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640__service_entry.from_gdata(self.to_gdata())

class orchestron_tmf__tmf_store__tmf640__service(yang.adata.MNode):
    elements: list[orchestron_tmf__tmf_store__tmf640__service_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self._name = 'service'
        self.elements = elements

    mut def create(self, id, serviceSpecification):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = orchestron_tmf__tmf_store__tmf640__service_entry(id, serviceSpecification)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[orchestron_tmf__tmf_store__tmf640__service_entry]:
        if n is not None:
            return [orchestron_tmf__tmf_store__tmf640__service_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return orchestron_tmf__tmf_store__tmf640__service(elements=copied_elements)

extension orchestron_tmf__tmf_store__tmf640__service(Iterable[orchestron_tmf__tmf_store__tmf640__service_entry]):
    def __iter__(self) -> Iterator[orchestron_tmf__tmf_store__tmf640__service_entry]:
        return self.elements.__iter__()

class orchestron_tmf__tmf_store__tmf640(yang.adata.MNode):
    service: orchestron_tmf__tmf_store__tmf640__service

    mut def __init__(self, service: list[orchestron_tmf__tmf_store__tmf640__service_entry]=[]):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.service = orchestron_tmf__tmf_store__tmf640__service(elements=service)

    def _get_attr(self, name: str) -> ?value:
        if name == 'service':
            return iter(self.service)
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store__tmf640')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store', 'tmf640'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> orchestron_tmf__tmf_store__tmf640:
        if n is not None:
            return orchestron_tmf__tmf_store__tmf640(service=orchestron_tmf__tmf_store__tmf640__service.from_gdata(n.get_opt_list('service')))
        return orchestron_tmf__tmf_store__tmf640()

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store__tmf640.from_gdata(self.to_gdata())


class orchestron_tmf__tmf_store(yang.adata.MNode):
    tmf640: orchestron_tmf__tmf_store__tmf640

    mut def __init__(self, tmf640: ?orchestron_tmf__tmf_store__tmf640=None):
        self._ns = 'http://orchestron.org/yang/orchestron-tmf'
        self.tmf640 = tmf640 if tmf640 is not None else orchestron_tmf__tmf_store__tmf640()

    def _get_attr(self, name: str) -> ?value:
        if name == 'tmf640':
            return self.tmf640
        raise ValueError('Attribute {name} not found in orchestron_tmf__tmf_store')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['orchestron-tmf:tmf-store'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> orchestron_tmf__tmf_store:
        if n is not None:
            return orchestron_tmf__tmf_store(tmf640=orchestron_tmf__tmf_store__tmf640.from_gdata(n.get_opt_cnt('tmf640')))
        return orchestron_tmf__tmf_store()

    def copy(self):
        """Create a deep copy of this adata object"""
        return orchestron_tmf__tmf_store.from_gdata(self.to_gdata())


class netinfra__netinfra__router_entry(yang.adata.MNode):
    name: str
    id: bigint
    type: str
    role: ?str
    asn: bigint
    mock: ?str
    approval_required: bool

    mut def __init__(self, name: str, id: bigint, type: str, asn: bigint, role: ?str, mock: ?str, approval_required: ?bool=None):
        self._ns = 'http://example.com/netinfra'
        self.name = name
        self.id = id
        self.type = type
        self.role = role
        self.asn = asn
        self.mock = mock
        self.approval_required = approval_required if approval_required is not None else False

    def _get_attr(self, name: str) -> ?value:
        if name == 'name':
            return self.name
        if name == 'id':
            return self.id
        if name == 'type':
            return self.type
        if name == 'role':
            return self.role
        if name == 'asn':
            return self.asn
        if name == 'mock':
            return self.mock
        if name == 'approval_required':
            return self.approval_required
        raise ValueError('Attribute {name} not found in netinfra__netinfra__router')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['netinfra:netinfra', 'router'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra__netinfra__router_entry:
        return netinfra__netinfra__router_entry(name=n.get_str('name'), id=n.get_bigint('id'), type=n.get_str('type'), role=n.get_opt_str('role'), asn=n.get_bigint('asn'), mock=n.get_opt_str('mock'), approval_required=n.get_opt_bool('approval-required'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return netinfra__netinfra__router_entry.from_gdata(self.to_gdata())

class netinfra__netinfra__router(yang.adata.MNode):
    elements: list[netinfra__netinfra__router_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/netinfra'
        self._name = 'router'
        self.elements = elements

    mut def create(self, name, id, type, asn):
        for e in self:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = netinfra__netinfra__router_entry(name, id, type, asn)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra__netinfra__router_entry]:
        if n is not None:
            return [netinfra__netinfra__router_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return netinfra__netinfra__router(elements=copied_elements)

extension netinfra__netinfra__router(Iterable[netinfra__netinfra__router_entry]):
    def __iter__(self) -> Iterator[netinfra__netinfra__router_entry]:
        return self.elements.__iter__()

class netinfra__netinfra__backbone_link_entry(yang.adata.MNode):
    left_router: str
    left_interface: str
    right_router: str
    right_interface: str
    monitor_health: bool

    mut def __init__(self, left_router: str, left_interface: str, right_router: str, right_interface: str, monitor_health: ?bool=None):
        self._ns = 'http://example.com/netinfra'
        self.left_router = left_router
        self.left_interface = left_interface
        self.right_router = right_router
        self.right_interface = right_interface
        self.monitor_health = monitor_health if monitor_health is not None else False

    def _get_attr(self, name: str) -> ?value:
        if name == 'left_router':
            return self.left_router
        if name == 'left_interface':
            return self.left_interface
        if name == 'right_router':
            return self.right_router
        if name == 'right_interface':
            return self.right_interface
        if name == 'monitor_health':
            return self.monitor_health
        raise ValueError('Attribute {name} not found in netinfra__netinfra__backbone_link')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['netinfra:netinfra', 'backbone-link'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra__netinfra__backbone_link_entry:
        return netinfra__netinfra__backbone_link_entry(left_router=n.get_str('left-router'), left_interface=n.get_str('left-interface'), right_router=n.get_str('right-router'), right_interface=n.get_str('right-interface'), monitor_health=n.get_opt_bool('monitor-health'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return netinfra__netinfra__backbone_link_entry.from_gdata(self.to_gdata())

class netinfra__netinfra__backbone_link(yang.adata.MNode):
    elements: list[netinfra__netinfra__backbone_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/netinfra'
        self._name = 'backbone-link'
        self.elements = elements

    mut def create(self, left_router, left_interface, right_router, right_interface):
        for e in self:
            match = True
            if e.left_router != left_router:
                match = False
                continue
            if e.left_interface != left_interface:
                match = False
                continue
            if e.right_router != right_router:
                match = False
                continue
            if e.right_interface != right_interface:
                match = False
                continue
            if match:
                return e

        res = netinfra__netinfra__backbone_link_entry(left_router, left_interface, right_router, right_interface)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra__netinfra__backbone_link_entry]:
        if n is not None:
            return [netinfra__netinfra__backbone_link_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return netinfra__netinfra__backbone_link(elements=copied_elements)

extension netinfra__netinfra__backbone_link(Iterable[netinfra__netinfra__backbone_link_entry]):
    def __iter__(self) -> Iterator[netinfra__netinfra__backbone_link_entry]:
        return self.elements.__iter__()

class netinfra__netinfra(yang.adata.MNode):
    router: netinfra__netinfra__router
    backbone_link: netinfra__netinfra__backbone_link

    mut def __init__(self, router: list[netinfra__netinfra__router_entry]=[], backbone_link: list[netinfra__netinfra__backbone_link_entry]=[]):
        self._ns = 'http://example.com/netinfra'
        self.router = netinfra__netinfra__router(elements=router)
        self.backbone_link = netinfra__netinfra__backbone_link(elements=backbone_link)

    def _get_attr(self, name: str) -> ?value:
        if name == 'router':
            return iter(self.router)
        if name == 'backbone_link':
            return iter(self.backbone_link)
        raise ValueError('Attribute {name} not found in netinfra__netinfra')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['netinfra:netinfra'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> netinfra__netinfra:
        if n is not None:
            return netinfra__netinfra(router=netinfra__netinfra__router.from_gdata(n.get_opt_list('router')), backbone_link=netinfra__netinfra__backbone_link.from_gdata(n.get_opt_list('backbone-link')))
        return netinfra__netinfra()

    def copy(self):
        """Create a deep copy of this adata object"""
        return netinfra__netinfra.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-profiles', 'valid-provider-identifiers', 'cloud-identifier'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(id=n.get_str('id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'cloud-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-profiles', 'valid-provider-identifiers', 'encryption-profile-identifier'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(id=n.get_str('id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'encryption-profile-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-profiles', 'valid-provider-identifiers', 'qos-profile-identifier'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(id=n.get_str('id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'qos-profile-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-profiles', 'valid-provider-identifiers', 'bfd-profile-identifier'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(id=n.get_str('id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'bfd-profile-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(yang.adata.MNode):
    cloud_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier
    encryption_profile_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier
    qos_profile_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier
    bfd_profile_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier

    mut def __init__(self, cloud_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]=[], encryption_profile_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]=[], qos_profile_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]=[], bfd_profile_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cloud_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(elements=cloud_identifier)
        self.encryption_profile_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(elements=encryption_profile_identifier)
        self.qos_profile_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(elements=qos_profile_identifier)
        self.bfd_profile_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(elements=bfd_profile_identifier)

    def _get_attr(self, name: str) -> ?value:
        if name == 'cloud_identifier':
            return iter(self.cloud_identifier)
        if name == 'encryption_profile_identifier':
            return iter(self.encryption_profile_identifier)
        if name == 'qos_profile_identifier':
            return iter(self.qos_profile_identifier)
        if name == 'bfd_profile_identifier':
            return iter(self.bfd_profile_identifier)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-profiles', 'valid-provider-identifiers'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(cloud_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier.from_gdata(n.get_opt_list('cloud-identifier')), encryption_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier.from_gdata(n.get_opt_list('encryption-profile-identifier')), qos_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier.from_gdata(n.get_opt_list('qos-profile-identifier')), bfd_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier.from_gdata(n.get_opt_list('bfd-profile-identifier')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(yang.adata.MNode):
    valid_provider_identifiers: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers

    mut def __init__(self, valid_provider_identifiers: ?ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.valid_provider_identifiers = valid_provider_identifiers if valid_provider_identifiers is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers()

    def _get_attr(self, name: str) -> ?value:
        if name == 'valid_provider_identifiers':
            return self.valid_provider_identifiers
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_profiles')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-profiles'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(valid_provider_identifiers=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers.from_gdata(n.get_opt_cnt('valid-provider-identifiers')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(yang.adata.MNode):
    enabled: bool
    nat44_customer_address: ?str

    mut def __init__(self, enabled: ?bool=None, nat44_customer_address: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.nat44_customer_address = nat44_customer_address

    def _get_attr(self, name: str) -> ?value:
        if name == 'enabled':
            return self.enabled
        if name == 'nat44_customer_address':
            return self.nat44_customer_address
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'cloud-accesses', 'cloud-access', 'address-translation', 'nat44'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(enabled=n.get_opt_bool('enabled'), nat44_customer_address=n.get_opt_str('nat44-customer-address'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(yang.adata.MNode):
    nat44: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44

    mut def __init__(self, nat44: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.nat44 = nat44 if nat44 is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44()

    def _get_attr(self, name: str) -> ?value:
        if name == 'nat44':
            return self.nat44
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'cloud-accesses', 'cloud-access', 'address-translation'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(nat44=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44.from_gdata(n.get_opt_cnt('nat44')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(yang.adata.MNode):
    cloud_identifier: str
    permit_any: ?bool
    permit_site: list[str]
    deny_site: list[str]
    address_translation: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation

    mut def __init__(self, cloud_identifier: str, permit_any: ?bool, permit_site: ?list[str]=None, deny_site: ?list[str]=None, address_translation: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cloud_identifier = cloud_identifier
        self.permit_any = permit_any
        self.permit_site = permit_site if permit_site is not None else []
        self.deny_site = deny_site if deny_site is not None else []
        self.address_translation = address_translation if address_translation is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation()

    def _get_attr(self, name: str) -> ?value:
        if name == 'cloud_identifier':
            return self.cloud_identifier
        if name == 'permit_any':
            return self.permit_any
        if name == 'permit_site':
            return self.permit_site
        if name == 'deny_site':
            return self.deny_site
        if name == 'address_translation':
            return self.address_translation
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'cloud-accesses', 'cloud-access'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(cloud_identifier=n.get_str('cloud-identifier'), permit_any=n.get_opt_empty('permit-any'), permit_site=n.get_opt_strs('permit-site'), deny_site=n.get_opt_strs('deny-site'), address_translation=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation.from_gdata(n.get_opt_cnt('address-translation')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'cloud-access'
        self.elements = elements

    mut def create(self, cloud_identifier):
        for e in self:
            match = True
            if e.cloud_identifier != cloud_identifier:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(cloud_identifier)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(yang.adata.MNode):
    cloud_access: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access

    mut def __init__(self, cloud_access: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cloud_access = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(elements=cloud_access)

    def _get_attr(self, name: str) -> ?value:
        if name == 'cloud_access':
            return iter(self.cloud_access)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'cloud-accesses'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(cloud_access=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access.from_gdata(n.get_opt_list('cloud-access')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(yang.adata.MNode):
    tree_flavor: list[Identityref]

    mut def __init__(self, tree_flavor: ?list[Identityref]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.tree_flavor = tree_flavor if tree_flavor is not None else []

    def _get_attr(self, name: str) -> ?value:
        if name == 'tree_flavor':
            return self.tree_flavor
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'customer-tree-flavors'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(tree_flavor=n.get_opt_Identityrefs('tree-flavor'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(yang.adata.MNode):
    enabled: bool
    rp_redundancy: bool
    optimal_traffic_delivery: bool

    mut def __init__(self, enabled: ?bool=None, rp_redundancy: ?bool=None, optimal_traffic_delivery: ?bool=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.rp_redundancy = rp_redundancy if rp_redundancy is not None else False
        self.optimal_traffic_delivery = optimal_traffic_delivery if optimal_traffic_delivery is not None else False

    def _get_attr(self, name: str) -> ?value:
        if name == 'enabled':
            return self.enabled
        if name == 'rp_redundancy':
            return self.rp_redundancy
        if name == 'optimal_traffic_delivery':
            return self.optimal_traffic_delivery
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp', 'rp-group-mappings', 'rp-group-mapping', 'provider-managed'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(enabled=n.get_opt_bool('enabled'), rp_redundancy=n.get_opt_bool('rp-redundancy'), optimal_traffic_delivery=n.get_opt_bool('optimal-traffic-delivery'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(yang.adata.MNode):
    id: bigint
    group_address: ?str
    group_start: ?str
    group_end: ?str

    mut def __init__(self, id: bigint, group_address: ?str, group_start: ?str, group_end: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.group_address = group_address
        self.group_start = group_start
        self.group_end = group_end

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'group_address':
            return self.group_address
        if name == 'group_start':
            return self.group_start
        if name == 'group_end':
            return self.group_end
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp', 'rp-group-mappings', 'rp-group-mapping', 'groups', 'group'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(id=n.get_bigint('id'), group_address=n.get_opt_str('group-address'), group_start=n.get_opt_str('group-start'), group_end=n.get_opt_str('group-end'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(elements=group)

    def _get_attr(self, name: str) -> ?value:
        if name == 'group':
            return iter(self.group)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp', 'rp-group-mappings', 'rp-group-mapping', 'groups'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(group=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group.from_gdata(n.get_opt_list('group')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(yang.adata.MNode):
    id: bigint
    provider_managed: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed
    rp_address: str
    groups: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups

    mut def __init__(self, id: bigint, rp_address: str, provider_managed: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed=None, groups: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.provider_managed = provider_managed if provider_managed is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed()
        self.rp_address = rp_address
        self.groups = groups if groups is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups()

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'provider_managed':
            return self.provider_managed
        if name == 'rp_address':
            return self.rp_address
        if name == 'groups':
            return self.groups
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp', 'rp-group-mappings', 'rp-group-mapping'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(id=n.get_bigint('id'), provider_managed=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed.from_gdata(n.get_opt_cnt('provider-managed')), rp_address=n.get_str('rp-address'), groups=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups.from_gdata(n.get_opt_cnt('groups')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'rp-group-mapping'
        self.elements = elements

    mut def create(self, id, rp_address):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(id, rp_address)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(yang.adata.MNode):
    rp_group_mapping: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping

    mut def __init__(self, rp_group_mapping: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rp_group_mapping = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(elements=rp_group_mapping)

    def _get_attr(self, name: str) -> ?value:
        if name == 'rp_group_mapping':
            return iter(self.rp_group_mapping)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp', 'rp-group-mappings'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(rp_group_mapping=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping.from_gdata(n.get_opt_list('rp-group-mapping')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(yang.adata.MNode):
    bsr_candidate_address: list[str]

    mut def __init__(self, bsr_candidate_address: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.bsr_candidate_address = bsr_candidate_address if bsr_candidate_address is not None else []

    def _get_attr(self, name: str) -> ?value:
        if name == 'bsr_candidate_address':
            return self.bsr_candidate_address
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp', 'rp-discovery', 'bsr-candidates'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(bsr_candidate_address=n.get_opt_strs('bsr-candidate-address'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(yang.adata.MNode):
    rp_discovery_type: Identityref
    bsr_candidates: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates

    mut def __init__(self, rp_discovery_type: ?Identityref=None, bsr_candidates: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        _default_rp_discovery_type, error = complete_and_validate_identityref(Identityref.from_adata('static-rp'), _identities, [_base_ietf_l3vpn_svc_multicast_rp_discovery_type], 'ietf-l3vpn-svc')
        if _default_rp_discovery_type is not None:
            self.rp_discovery_type = rp_discovery_type if rp_discovery_type is not None else _default_rp_discovery_type
        else:
            raise ValueError('Invalid default value for identityref leaf rp-discovery: {error}')
        self.bsr_candidates = bsr_candidates if bsr_candidates is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates()

    def _get_attr(self, name: str) -> ?value:
        if name == 'rp_discovery_type':
            return self.rp_discovery_type
        if name == 'bsr_candidates':
            return self.bsr_candidates
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp', 'rp-discovery'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(rp_discovery_type=n.get_opt_Identityref('rp-discovery-type'), bsr_candidates=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates.from_gdata(n.get_opt_cnt('bsr-candidates')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(yang.adata.MNode):
    rp_group_mappings: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings
    rp_discovery: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery

    mut def __init__(self, rp_group_mappings: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings=None, rp_discovery: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rp_group_mappings = rp_group_mappings if rp_group_mappings is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings()
        self.rp_discovery = rp_discovery if rp_discovery is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery()

    def _get_attr(self, name: str) -> ?value:
        if name == 'rp_group_mappings':
            return self.rp_group_mappings
        if name == 'rp_discovery':
            return self.rp_discovery
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast', 'rp'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(rp_group_mappings=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings.from_gdata(n.get_opt_cnt('rp-group-mappings')), rp_discovery=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery.from_gdata(n.get_opt_cnt('rp-discovery')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(yang.adata.MNode):
    enabled: bool
    customer_tree_flavors: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors
    rp: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp

    mut def __init__(self, enabled: ?bool=None, customer_tree_flavors: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors=None, rp: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.customer_tree_flavors = customer_tree_flavors if customer_tree_flavors is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors()
        self.rp = rp if rp is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp()

    def _get_attr(self, name: str) -> ?value:
        if name == 'enabled':
            return self.enabled
        if name == 'customer_tree_flavors':
            return self.customer_tree_flavors
        if name == 'rp':
            return self.rp
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'multicast'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(enabled=n.get_opt_bool('enabled'), customer_tree_flavors=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors.from_gdata(n.get_opt_cnt('customer-tree-flavors')), rp=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp.from_gdata(n.get_opt_cnt('rp')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(yang.adata.MNode):
    vpn_id: str
    local_sites_role: Identityref

    mut def __init__(self, vpn_id: str, local_sites_role: ?Identityref=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_id = vpn_id
        _default_local_sites_role, error = complete_and_validate_identityref(Identityref.from_adata('any-to-any-role'), _identities, [_base_ietf_l3vpn_svc_site_role], 'ietf-l3vpn-svc')
        if _default_local_sites_role is not None:
            self.local_sites_role = local_sites_role if local_sites_role is not None else _default_local_sites_role
        else:
            raise ValueError('Invalid default value for identityref leaf extranet-vpn: {error}')

    def _get_attr(self, name: str) -> ?value:
        if name == 'vpn_id':
            return self.vpn_id
        if name == 'local_sites_role':
            return self.local_sites_role
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'extranet-vpns', 'extranet-vpn'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(vpn_id=n.get_str('vpn-id'), local_sites_role=n.get_opt_Identityref('local-sites-role'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'extranet-vpn'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(vpn_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(yang.adata.MNode):
    extranet_vpn: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn

    mut def __init__(self, extranet_vpn: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.extranet_vpn = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(elements=extranet_vpn)

    def _get_attr(self, name: str) -> ?value:
        if name == 'extranet_vpn':
            return iter(self.extranet_vpn)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service', 'extranet-vpns'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(extranet_vpn=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn.from_gdata(n.get_opt_list('extranet-vpn')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(yang.adata.MNode):
    vpn_id: str
    customer_name: ?str
    vpn_service_topology: Identityref
    cloud_accesses: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses
    multicast: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast
    carrierscarrier: bool
    extranet_vpns: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns

    mut def __init__(self, vpn_id: str, customer_name: ?str, vpn_service_topology: ?Identityref=None, cloud_accesses: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses=None, multicast: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast=None, carrierscarrier: ?bool=None, extranet_vpns: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_id = vpn_id
        self.customer_name = customer_name
        _default_vpn_service_topology, error = complete_and_validate_identityref(Identityref.from_adata('any-to-any'), _identities, [_base_ietf_l3vpn_svc_vpn_topology], 'ietf-l3vpn-svc')
        if _default_vpn_service_topology is not None:
            self.vpn_service_topology = vpn_service_topology if vpn_service_topology is not None else _default_vpn_service_topology
        else:
            raise ValueError('Invalid default value for identityref leaf vpn-service: {error}')
        self.cloud_accesses = cloud_accesses if cloud_accesses is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses()
        self.multicast = multicast if multicast is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast()
        self.carrierscarrier = carrierscarrier if carrierscarrier is not None else False
        self.extranet_vpns = extranet_vpns if extranet_vpns is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns()

    def _get_attr(self, name: str) -> ?value:
        if name == 'vpn_id':
            return self.vpn_id
        if name == 'customer_name':
            return self.customer_name
        if name == 'vpn_service_topology':
            return self.vpn_service_topology
        if name == 'cloud_accesses':
            return self.cloud_accesses
        if name == 'multicast':
            return self.multicast
        if name == 'carrierscarrier':
            return self.carrierscarrier
        if name == 'extranet_vpns':
            return self.extranet_vpns
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services', 'vpn-service'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(vpn_id=n.get_str('vpn-id'), customer_name=n.get_opt_str('customer-name'), vpn_service_topology=n.get_opt_Identityref('vpn-service-topology'), cloud_accesses=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses.from_gdata(n.get_opt_cnt('cloud-accesses')), multicast=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast.from_gdata(n.get_opt_cnt('multicast')), carrierscarrier=n.get_opt_bool('carrierscarrier'), extranet_vpns=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns.from_gdata(n.get_opt_cnt('extranet-vpns')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'vpn-service'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(vpn_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(Iterable[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__vpn_services(yang.adata.MNode):
    vpn_service: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service

    mut def __init__(self, vpn_service: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_service = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(elements=vpn_service)

    def _get_attr(self, name: str) -> ?value:
        if name == 'vpn_service':
            return iter(self.vpn_service)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__vpn_services')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'vpn-services'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services(vpn_service=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service.from_gdata(n.get_opt_list('vpn-service')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(yang.adata.MNode):
    location_id: str
    address: ?str
    postal_code: ?str
    state: ?str
    city: ?str
    country_code: ?str

    mut def __init__(self, location_id: str, address: ?str, postal_code: ?str, state: ?str, city: ?str, country_code: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.location_id = location_id
        self.address = address
        self.postal_code = postal_code
        self.state = state
        self.city = city
        self.country_code = country_code

    def _get_attr(self, name: str) -> ?value:
        if name == 'location_id':
            return self.location_id
        if name == 'address':
            return self.address
        if name == 'postal_code':
            return self.postal_code
        if name == 'state':
            return self.state
        if name == 'city':
            return self.city
        if name == 'country_code':
            return self.country_code
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'locations', 'location'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(location_id=n.get_str('location-id'), address=n.get_opt_str('address'), postal_code=n.get_opt_str('postal-code'), state=n.get_opt_str('state'), city=n.get_opt_str('city'), country_code=n.get_opt_str('country-code'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'location'
        self.elements = elements

    mut def create(self, location_id):
        for e in self:
            match = True
            if e.location_id != location_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(location_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(yang.adata.MNode):
    location: ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location

    mut def __init__(self, location: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.location = ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(elements=location)

    def _get_attr(self, name: str) -> ?value:
        if name == 'location':
            return iter(self.location)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__locations')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'locations'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__locations:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(location=ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location.from_gdata(n.get_opt_list('location')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(yang.adata.MNode):
    address_family: ?str
    address: str

    mut def __init__(self, address: str, address_family: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family
        self.address = address

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return self.address_family
        if name == 'address':
            return self.address
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'devices', 'device', 'management'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(address_family=n.get_opt_str('address-family'), address=n.get_str('address'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management')

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(yang.adata.MNode):
    device_id: str
    location: str
    management: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management

    mut def __init__(self, device_id: str, location: str, management: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.device_id = device_id
        self.location = location
        self.management = management

    def _get_attr(self, name: str) -> ?value:
        if name == 'device_id':
            return self.device_id
        if name == 'location':
            return self.location
        if name == 'management':
            return self.management
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'devices', 'device'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(device_id=n.get_str('device-id'), location=n.get_str('location'), management=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management.from_gdata(n.get_cnt('management')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'device'
        self.elements = elements

    mut def create(self, device_id, location, management):
        for e in self:
            match = True
            if e.device_id != device_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(device_id, location, management)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(yang.adata.MNode):
    device: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device

    mut def __init__(self, device: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.device = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(elements=device)

    def _get_attr(self, name: str) -> ?value:
        if name == 'device':
            return iter(self.device)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__devices')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'devices'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(device=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device.from_gdata(n.get_opt_list('device')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(yang.adata.MNode):
    group_id: str

    mut def __init__(self, group_id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id

    def _get_attr(self, name: str) -> ?value:
        if name == 'group_id':
            return self.group_id
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-diversity', 'groups', 'group'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(group_id=n.get_str('group-id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(group_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(elements=group)

    def _get_attr(self, name: str) -> ?value:
        if name == 'group':
            return iter(self.group)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-diversity', 'groups'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group.from_gdata(n.get_opt_list('group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(yang.adata.MNode):
    groups: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups

    mut def __init__(self, groups: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.groups = groups if groups is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups()

    def _get_attr(self, name: str) -> ?value:
        if name == 'groups':
            return self.groups
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-diversity'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(groups=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups.from_gdata(n.get_opt_cnt('groups')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__management(yang.adata.MNode):
    type: Identityref

    mut def __init__(self, type: Identityref):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type

    def _get_attr(self, name: str) -> ?value:
        if name == 'type':
            return self.type
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__management')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'management'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__management:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__management(type=n.get_Identityref('type'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__management')

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__management.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(yang.adata.MNode):
    type: Identityref
    lan_tag: list[str]
    ipv4_lan_prefix: list[str]
    ipv6_lan_prefix: list[str]

    mut def __init__(self, type: Identityref, lan_tag: ?list[str]=None, ipv4_lan_prefix: ?list[str]=None, ipv6_lan_prefix: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type
        self.lan_tag = lan_tag if lan_tag is not None else []
        self.ipv4_lan_prefix = ipv4_lan_prefix if ipv4_lan_prefix is not None else []
        self.ipv6_lan_prefix = ipv6_lan_prefix if ipv6_lan_prefix is not None else []

    def _get_attr(self, name: str) -> ?value:
        if name == 'type':
            return self.type
        if name == 'lan_tag':
            return self.lan_tag
        if name == 'ipv4_lan_prefix':
            return self.ipv4_lan_prefix
        if name == 'ipv6_lan_prefix':
            return self.ipv6_lan_prefix
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'vpn-policies', 'vpn-policy', 'entries', 'filters', 'filter'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(type=n.get_Identityref('type'), lan_tag=n.get_opt_strs('lan-tag'), ipv4_lan_prefix=n.get_opt_strs('ipv4-lan-prefix'), ipv6_lan_prefix=n.get_opt_strs('ipv6-lan-prefix'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'filter'
        self.elements = elements

    mut def create(self, type):
        for e in self:
            match = True
            if e.type != type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(type)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(yang.adata.MNode):
    filter: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter

    mut def __init__(self, filter: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.filter = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(elements=filter)

    def _get_attr(self, name: str) -> ?value:
        if name == 'filter':
            return iter(self.filter)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'vpn-policies', 'vpn-policy', 'entries', 'filters'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(filter=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter.from_gdata(n.get_opt_list('filter')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(yang.adata.MNode):
    vpn_id: str
    site_role: Identityref

    mut def __init__(self, vpn_id: str, site_role: ?Identityref=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_id = vpn_id
        _default_site_role, error = complete_and_validate_identityref(Identityref.from_adata('any-to-any-role'), _identities, [_base_ietf_l3vpn_svc_site_role], 'ietf-l3vpn-svc')
        if _default_site_role is not None:
            self.site_role = site_role if site_role is not None else _default_site_role
        else:
            raise ValueError('Invalid default value for identityref leaf vpn: {error}')

    def _get_attr(self, name: str) -> ?value:
        if name == 'vpn_id':
            return self.vpn_id
        if name == 'site_role':
            return self.site_role
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'vpn-policies', 'vpn-policy', 'entries', 'vpn'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(vpn_id=n.get_str('vpn-id'), site_role=n.get_opt_Identityref('site-role'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'vpn'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(vpn_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(yang.adata.MNode):
    id: str
    filters: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters
    vpn: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn

    mut def __init__(self, id: str, filters: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters=None, vpn: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.filters = filters if filters is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters()
        self.vpn = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(elements=vpn)

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'filters':
            return self.filters
        if name == 'vpn':
            return iter(self.vpn)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'vpn-policies', 'vpn-policy', 'entries'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(id=n.get_str('id'), filters=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters.from_gdata(n.get_opt_cnt('filters')), vpn=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn.from_gdata(n.get_opt_list('vpn')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'entries'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(yang.adata.MNode):
    vpn_policy_id: str
    entries: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries

    mut def __init__(self, vpn_policy_id: str, entries: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_policy_id = vpn_policy_id
        self.entries = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(elements=entries)

    def _get_attr(self, name: str) -> ?value:
        if name == 'vpn_policy_id':
            return self.vpn_policy_id
        if name == 'entries':
            return iter(self.entries)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'vpn-policies', 'vpn-policy'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(vpn_policy_id=n.get_str('vpn-policy-id'), entries=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries.from_gdata(n.get_opt_list('entries')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'vpn-policy'
        self.elements = elements

    mut def create(self, vpn_policy_id):
        for e in self:
            match = True
            if e.vpn_policy_id != vpn_policy_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(vpn_policy_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(yang.adata.MNode):
    vpn_policy: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy

    mut def __init__(self, vpn_policy: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_policy = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(elements=vpn_policy)

    def _get_attr(self, name: str) -> ?value:
        if name == 'vpn_policy':
            return iter(self.vpn_policy)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'vpn-policies'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(vpn_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy.from_gdata(n.get_opt_list('vpn-policy')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(yang.adata.MNode):
    af: str
    maximum_routes: ?bigint

    mut def __init__(self, af: str, maximum_routes: ?bigint):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.af = af
        self.maximum_routes = maximum_routes

    def _get_attr(self, name: str) -> ?value:
        if name == 'af':
            return self.af
        if name == 'maximum_routes':
            return self.maximum_routes
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'maximum-routes', 'address-family'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(af=n.get_str('af'), maximum_routes=n.get_opt_bigint('maximum-routes'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af):
        for e in self:
            match = True
            if e.af != af:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(af)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(yang.adata.MNode):
    address_family: ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family

    mut def __init__(self, address_family: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(elements=address_family)

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return iter(self.address_family)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'maximum-routes'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family.from_gdata(n.get_opt_list('address-family')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'security', 'authentication'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(yang.adata.MNode):
    profile_name: ?str
    algorithm: ?str
    preshared_key: ?str

    mut def __init__(self, profile_name: ?str, algorithm: ?str, preshared_key: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile_name = profile_name
        self.algorithm = algorithm
        self.preshared_key = preshared_key

    def _get_attr(self, name: str) -> ?value:
        if name == 'profile_name':
            return self.profile_name
        if name == 'algorithm':
            return self.algorithm
        if name == 'preshared_key':
            return self.preshared_key
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'security', 'encryption', 'encryption-profile'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(profile_name=n.get_opt_str('profile-name'), algorithm=n.get_opt_str('algorithm'), preshared_key=n.get_opt_str('preshared-key'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(yang.adata.MNode):
    enabled: bool
    layer: ?str
    encryption_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile

    mut def __init__(self, enabled: ?bool=None, layer: ?str, encryption_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.layer = layer
        self.encryption_profile = encryption_profile if encryption_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile()

    def _get_attr(self, name: str) -> ?value:
        if name == 'enabled':
            return self.enabled
        if name == 'layer':
            return self.layer
        if name == 'encryption_profile':
            return self.encryption_profile
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'security', 'encryption'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(enabled=n.get_opt_bool('enabled'), layer=n.get_opt_str('layer'), encryption_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile.from_gdata(n.get_opt_cnt('encryption-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__security(yang.adata.MNode):
    authentication: ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication
    encryption: ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption

    mut def __init__(self, authentication: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication=None, encryption: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.authentication = authentication if authentication is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()
        self.encryption = encryption if encryption is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption()

    def _get_attr(self, name: str) -> ?value:
        if name == 'authentication':
            return self.authentication
        if name == 'encryption':
            return self.encryption
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__security')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'security'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security(authentication=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication.from_gdata(n.get_opt_cnt('authentication')), encryption=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption.from_gdata(n.get_opt_cnt('encryption')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.adata.MNode):
    lower_port: ?bigint
    upper_port: ?bigint

    mut def __init__(self, lower_port: ?bigint, upper_port: ?bigint):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    def _get_attr(self, name: str) -> ?value:
        if name == 'lower_port':
            return self.lower_port
        if name == 'upper_port':
            return self.upper_port
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-classification-policy', 'rule', 'match-flow', 'l4-src-port-range'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(lower_port=n.get_opt_bigint('lower-port'), upper_port=n.get_opt_bigint('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.adata.MNode):
    lower_port: ?bigint
    upper_port: ?bigint

    mut def __init__(self, lower_port: ?bigint, upper_port: ?bigint):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    def _get_attr(self, name: str) -> ?value:
        if name == 'lower_port':
            return self.lower_port
        if name == 'upper_port':
            return self.upper_port
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-classification-policy', 'rule', 'match-flow', 'l4-dst-port-range'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(lower_port=n.get_opt_bigint('lower-port'), upper_port=n.get_opt_bigint('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(yang.adata.MNode):
    dscp: ?bigint
    dot1p: ?bigint
    ipv4_src_prefix: ?str
    ipv6_src_prefix: ?str
    ipv4_dst_prefix: ?str
    ipv6_dst_prefix: ?str
    l4_src_port: ?bigint
    target_sites: list[str]
    l4_src_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range
    l4_dst_port: ?bigint
    l4_dst_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range
    protocol_field: ?value

    mut def __init__(self, dscp: ?bigint, dot1p: ?bigint, ipv4_src_prefix: ?str, ipv6_src_prefix: ?str, ipv4_dst_prefix: ?str, ipv6_dst_prefix: ?str, l4_src_port: ?bigint, target_sites: ?list[str]=None, l4_src_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range=None, l4_dst_port: ?bigint, l4_dst_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range=None, protocol_field: ?value):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.dscp = dscp
        self.dot1p = dot1p
        self.ipv4_src_prefix = ipv4_src_prefix
        self.ipv6_src_prefix = ipv6_src_prefix
        self.ipv4_dst_prefix = ipv4_dst_prefix
        self.ipv6_dst_prefix = ipv6_dst_prefix
        self.l4_src_port = l4_src_port
        self.target_sites = target_sites if target_sites is not None else []
        self.l4_src_port_range = l4_src_port_range if l4_src_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()
        self.l4_dst_port = l4_dst_port
        self.l4_dst_port_range = l4_dst_port_range if l4_dst_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()
        self.protocol_field = protocol_field

    def _get_attr(self, name: str) -> ?value:
        if name == 'dscp':
            return self.dscp
        if name == 'dot1p':
            return self.dot1p
        if name == 'ipv4_src_prefix':
            return self.ipv4_src_prefix
        if name == 'ipv6_src_prefix':
            return self.ipv6_src_prefix
        if name == 'ipv4_dst_prefix':
            return self.ipv4_dst_prefix
        if name == 'ipv6_dst_prefix':
            return self.ipv6_dst_prefix
        if name == 'l4_src_port':
            return self.l4_src_port
        if name == 'target_sites':
            return self.target_sites
        if name == 'l4_src_port_range':
            return self.l4_src_port_range
        if name == 'l4_dst_port':
            return self.l4_dst_port
        if name == 'l4_dst_port_range':
            return self.l4_dst_port_range
        if name == 'protocol_field':
            return self.protocol_field
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-classification-policy', 'rule', 'match-flow'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(dscp=n.get_opt_bigint('dscp'), dot1p=n.get_opt_bigint('dot1p'), ipv4_src_prefix=n.get_opt_str('ipv4-src-prefix'), ipv6_src_prefix=n.get_opt_str('ipv6-src-prefix'), ipv4_dst_prefix=n.get_opt_str('ipv4-dst-prefix'), ipv6_dst_prefix=n.get_opt_str('ipv6-dst-prefix'), l4_src_port=n.get_opt_bigint('l4-src-port'), target_sites=n.get_opt_strs('target-sites'), l4_src_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_gdata(n.get_opt_cnt('l4-src-port-range')), l4_dst_port=n.get_opt_bigint('l4-dst-port'), l4_dst_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_gdata(n.get_opt_cnt('l4-dst-port-range')), protocol_field=n.get_opt_value('protocol-field'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(yang.adata.MNode):
    id: str
    match_flow: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow
    match_application: ?Identityref
    target_class_id: ?str

    mut def __init__(self, id: str, match_flow: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow=None, match_application: ?Identityref, target_class_id: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.match_flow = match_flow if match_flow is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow()
        self.match_application = match_application
        self.target_class_id = target_class_id

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'match_flow':
            return self.match_flow
        if name == 'match_application':
            return self.match_application
        if name == 'target_class_id':
            return self.target_class_id
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-classification-policy', 'rule'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(id=n.get_str('id'), match_flow=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow.from_gdata(n.get_opt_cnt('match-flow')), match_application=n.get_opt_Identityref('match-application'), target_class_id=n.get_opt_str('target-class-id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'rule'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(yang.adata.MNode):
    rule: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule

    mut def __init__(self, rule: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rule = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(elements=rule)

    def _get_attr(self, name: str) -> ?value:
        if name == 'rule':
            return iter(self.rule)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-classification-policy'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(rule=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule.from_gdata(n.get_opt_list('rule')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(yang.adata.MNode):
    use_lowest_latency: ?bool
    latency_boundary: bigint

    mut def __init__(self, use_lowest_latency: ?bool, latency_boundary: ?bigint=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_latency = use_lowest_latency
        self.latency_boundary = latency_boundary if latency_boundary is not None else bigint(400)

    def _get_attr(self, name: str) -> ?value:
        if name == 'use_lowest_latency':
            return self.use_lowest_latency
        if name == 'latency_boundary':
            return self.latency_boundary
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-profile', 'classes', 'class', 'latency'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(use_lowest_latency=n.get_opt_empty('use-lowest-latency'), latency_boundary=n.get_opt_bigint('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(yang.adata.MNode):
    use_lowest_jitter: ?bool
    latency_boundary: bigint

    mut def __init__(self, use_lowest_jitter: ?bool, latency_boundary: ?bigint=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_jitter = use_lowest_jitter
        self.latency_boundary = latency_boundary if latency_boundary is not None else bigint(40000)

    def _get_attr(self, name: str) -> ?value:
        if name == 'use_lowest_jitter':
            return self.use_lowest_jitter
        if name == 'latency_boundary':
            return self.latency_boundary
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-profile', 'classes', 'class', 'jitter'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(use_lowest_jitter=n.get_opt_empty('use-lowest-jitter'), latency_boundary=n.get_opt_bigint('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(yang.adata.MNode):
    guaranteed_bw_percent: Decimal
    end_to_end: ?bool

    mut def __init__(self, guaranteed_bw_percent: Decimal, end_to_end: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.guaranteed_bw_percent = guaranteed_bw_percent
        self.end_to_end = end_to_end

    def _get_attr(self, name: str) -> ?value:
        if name == 'guaranteed_bw_percent':
            return self.guaranteed_bw_percent
        if name == 'end_to_end':
            return self.end_to_end
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-profile', 'classes', 'class', 'bandwidth'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(guaranteed_bw_percent=n.get_Decimal('guaranteed-bw-percent'), end_to_end=n.get_opt_empty('end-to-end'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth')

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(yang.adata.MNode):
    class_id: str
    direction: Identityref
    rate_limit: ?Decimal
    latency: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency
    jitter: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter
    bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth

    mut def __init__(self, class_id: str, bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth, direction: ?Identityref=None, rate_limit: ?Decimal, latency: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency=None, jitter: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_id = class_id
        _default_direction, error = complete_and_validate_identityref(Identityref.from_adata('both'), _identities, [_base_ietf_l3vpn_svc_qos_profile_direction], 'ietf-l3vpn-svc')
        if _default_direction is not None:
            self.direction = direction if direction is not None else _default_direction
        else:
            raise ValueError('Invalid default value for identityref leaf class: {error}')
        self.rate_limit = rate_limit
        self.latency = latency if latency is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency()
        self.jitter = jitter if jitter is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter()
        self.bandwidth = bandwidth

    def _get_attr(self, name: str) -> ?value:
        if name == 'class_id':
            return self.class_id
        if name == 'direction':
            return self.direction
        if name == 'rate_limit':
            return self.rate_limit
        if name == 'latency':
            return self.latency
        if name == 'jitter':
            return self.jitter
        if name == 'bandwidth':
            return self.bandwidth
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-profile', 'classes', 'class'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(class_id=n.get_str('class-id'), direction=n.get_opt_Identityref('direction'), rate_limit=n.get_opt_Decimal('rate-limit'), latency=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency.from_gdata(n.get_opt_cnt('latency')), jitter=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter.from_gdata(n.get_opt_cnt('jitter')), bandwidth=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth.from_gdata(n.get_cnt('bandwidth')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'class'
        self.elements = elements

    mut def create(self, class_id, bandwidth):
        for e in self:
            match = True
            if e.class_id != class_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(class_id, bandwidth)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(yang.adata.MNode):
    class_: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class

    mut def __init__(self, class_: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_ = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(elements=class_)

    def _get_attr(self, name: str) -> ?value:
        if name == 'class_':
            return iter(self.class_)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-profile', 'classes'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(class_=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class.from_gdata(n.get_opt_list('class')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(yang.adata.MNode):
    profile: ?str
    classes: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes

    mut def __init__(self, profile: ?str, classes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile = profile
        self.classes = classes if classes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes()

    def _get_attr(self, name: str) -> ?value:
        if name == 'profile':
            return self.profile
        if name == 'classes':
            return self.classes
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos', 'qos-profile'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(profile=n.get_opt_str('profile'), classes=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes.from_gdata(n.get_opt_cnt('classes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(yang.adata.MNode):
    qos_classification_policy: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy
    qos_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile

    mut def __init__(self, qos_classification_policy: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy=None, qos_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.qos_classification_policy = qos_classification_policy if qos_classification_policy is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy()
        self.qos_profile = qos_profile if qos_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile()

    def _get_attr(self, name: str) -> ?value:
        if name == 'qos_classification_policy':
            return self.qos_classification_policy
        if name == 'qos_profile':
            return self.qos_profile
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'qos'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(qos_classification_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy.from_gdata(n.get_opt_cnt('qos-classification-policy')), qos_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile.from_gdata(n.get_opt_cnt('qos-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(yang.adata.MNode):
    signalling_type: str

    mut def __init__(self, signalling_type: ?str=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.signalling_type = signalling_type if signalling_type is not None else "bgp"

    def _get_attr(self, name: str) -> ?value:
        if name == 'signalling_type':
            return self.signalling_type
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'carrierscarrier'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(signalling_type=n.get_opt_str('signalling-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(yang.adata.MNode):
    ipv4: bool
    ipv6: bool

    mut def __init__(self, ipv4: ?bool=None, ipv6: ?bool=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4 = ipv4 if ipv4 is not None else False
        self.ipv6 = ipv6 if ipv6 is not None else False

    def _get_attr(self, name: str) -> ?value:
        if name == 'ipv4':
            return self.ipv4
        if name == 'ipv6':
            return self.ipv6
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'multicast', 'multicast-address-family'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(ipv4=n.get_opt_bool('ipv4'), ipv6=n.get_opt_bool('ipv6'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(yang.adata.MNode):
    multicast_site_type: str
    multicast_address_family: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family
    protocol_type: str

    mut def __init__(self, multicast_site_type: ?str=None, multicast_address_family: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family=None, protocol_type: ?str=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.multicast_site_type = multicast_site_type if multicast_site_type is not None else "source-receiver"
        self.multicast_address_family = multicast_address_family if multicast_address_family is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family()
        self.protocol_type = protocol_type if protocol_type is not None else "both"

    def _get_attr(self, name: str) -> ?value:
        if name == 'multicast_site_type':
            return self.multicast_site_type
        if name == 'multicast_address_family':
            return self.multicast_address_family
        if name == 'protocol_type':
            return self.protocol_type
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service', 'multicast'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(multicast_site_type=n.get_opt_str('multicast-site-type'), multicast_address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family.from_gdata(n.get_opt_cnt('multicast-address-family')), protocol_type=n.get_opt_str('protocol-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__service(yang.adata.MNode):
    qos: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos
    carrierscarrier: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier
    multicast: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast

    mut def __init__(self, qos: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos=None, carrierscarrier: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier=None, multicast: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.qos = qos if qos is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos()
        self.carrierscarrier = carrierscarrier if carrierscarrier is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier()
        self.multicast = multicast if multicast is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast()

    def _get_attr(self, name: str) -> ?value:
        if name == 'qos':
            return self.qos
        if name == 'carrierscarrier':
            return self.carrierscarrier
        if name == 'multicast':
            return self.multicast
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__service')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'service'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service(qos=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos.from_gdata(n.get_opt_cnt('qos')), carrierscarrier=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier.from_gdata(n.get_opt_cnt('carrierscarrier')), multicast=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast.from_gdata(n.get_opt_cnt('multicast')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(yang.adata.MNode):
    enabled: bool

    mut def __init__(self, enabled: ?bool=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False

    def _get_attr(self, name: str) -> ?value:
        if name == 'enabled':
            return self.enabled
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'traffic-protection'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(enabled=n.get_opt_bool('enabled'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(yang.adata.MNode):
    target_site: str
    metric: bigint

    mut def __init__(self, target_site: str, metric: ?bigint=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.target_site = target_site
        self.metric = metric if metric is not None else bigint(1)

    def _get_attr(self, name: str) -> ?value:
        if name == 'target_site':
            return self.target_site
        if name == 'metric':
            return self.metric
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'ospf', 'sham-links', 'sham-link'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site=n.get_str('target-site'), metric=n.get_opt_bigint('metric'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'sham-link'
        self.elements = elements

    mut def create(self, target_site):
        for e in self:
            match = True
            if e.target_site != target_site:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(yang.adata.MNode):
    sham_link: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link

    mut def __init__(self, sham_link: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.sham_link = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(elements=sham_link)

    def _get_attr(self, name: str) -> ?value:
        if name == 'sham_link':
            return iter(self.sham_link)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'ospf', 'sham-links'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(sham_link=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link.from_gdata(n.get_opt_list('sham-link')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(yang.adata.MNode):
    address_family: list[str]
    area_address: str
    metric: bigint
    sham_links: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links

    mut def __init__(self, area_address: str, address_family: ?list[str]=None, metric: ?bigint=None, sham_links: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []
        self.area_address = area_address
        self.metric = metric if metric is not None else bigint(1)
        self.sham_links = sham_links if sham_links is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links()

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return self.address_family
        if name == 'area_address':
            return self.area_address
        if name == 'metric':
            return self.metric
        if name == 'sham_links':
            return self.sham_links
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'ospf'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(address_family=n.get_strs('address-family'), area_address=n.get_str('area-address'), metric=n.get_opt_bigint('metric'), sham_links=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links.from_gdata(n.get_opt_cnt('sham-links')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf.copy()')


class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(yang.adata.MNode):
    autonomous_system: bigint
    address_family: list[str]

    mut def __init__(self, autonomous_system: bigint, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.autonomous_system = autonomous_system
        self.address_family = address_family if address_family is not None else []

    def _get_attr(self, name: str) -> ?value:
        if name == 'autonomous_system':
            return self.autonomous_system
        if name == 'address_family':
            return self.address_family
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'bgp'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(autonomous_system=n.get_bigint('autonomous-system'), address_family=n.get_strs('address-family'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp.copy()')


class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    def _get_attr(self, name: str) -> ?value:
        if name == 'lan':
            return self.lan
        if name == 'next_hop':
            return self.next_hop
        if name == 'lan_tag':
            return self.lan_tag
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'static', 'cascaded-lan-prefixes', 'ipv4-lan-prefixes'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv4-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    def _get_attr(self, name: str) -> ?value:
        if name == 'lan':
            return self.lan
        if name == 'next_hop':
            return self.next_hop
        if name == 'lan_tag':
            return self.lan_tag
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'static', 'cascaded-lan-prefixes', 'ipv6-lan-prefixes'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv6-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.adata.MNode):
    ipv4_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes
    ipv6_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes

    mut def __init__(self, ipv4_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]=[], ipv6_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(elements=ipv4_lan_prefixes)
        self.ipv6_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(elements=ipv6_lan_prefixes)

    def _get_attr(self, name: str) -> ?value:
        if name == 'ipv4_lan_prefixes':
            return iter(self.ipv4_lan_prefixes)
        if name == 'ipv6_lan_prefixes':
            return iter(self.ipv6_lan_prefixes)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'static', 'cascaded-lan-prefixes'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(ipv4_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes.from_gdata(n.get_opt_list('ipv4-lan-prefixes')), ipv6_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes.from_gdata(n.get_opt_list('ipv6-lan-prefixes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(yang.adata.MNode):
    cascaded_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes

    mut def __init__(self, cascaded_lan_prefixes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cascaded_lan_prefixes = cascaded_lan_prefixes if cascaded_lan_prefixes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    def _get_attr(self, name: str) -> ?value:
        if name == 'cascaded_lan_prefixes':
            return self.cascaded_lan_prefixes
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'static'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(cascaded_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_gdata(n.get_opt_cnt('cascaded-lan-prefixes')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static.copy()')


class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return self.address_family
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'rip'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(address_family=n.get_strs('address-family'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip.copy()')


class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return self.address_family
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol', 'vrrp'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(address_family=n.get_strs('address-family'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp.copy()')


class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(yang.adata.MNode):
    type: Identityref
    ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf
    bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp
    static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static
    rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip
    vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp

    mut def __init__(self, type: Identityref, ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf=None, bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp=None, static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static=None, rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip=None, vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type
        self.ospf = ospf
        self.bgp = bgp
        self.static = static
        self.rip = rip
        self.vrrp = vrrp

    mut def create_ospf(self, area_address):
        existing = self.ospf
        if existing is not None:
            return existing
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(area_address)
        self.ospf = res
        return res

    mut def create_bgp(self, autonomous_system):
        existing = self.bgp
        if existing is not None:
            return existing
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(autonomous_system)
        self.bgp = res
        return res

    mut def create_static(self):
        existing = self.static
        if existing is not None:
            return existing
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static()
        self.static = res
        return res

    mut def create_rip(self):
        existing = self.rip
        if existing is not None:
            return existing
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip()
        self.rip = res
        return res

    mut def create_vrrp(self):
        existing = self.vrrp
        if existing is not None:
            return existing
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp()
        self.vrrp = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'type':
            return self.type
        if name == 'ospf':
            return self.ospf
        if name == 'bgp':
            return self.bgp
        if name == 'static':
            return self.static
        if name == 'rip':
            return self.rip
        if name == 'vrrp':
            return self.vrrp
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols', 'routing-protocol'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(type=n.get_Identityref('type'), ospf=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf.from_gdata(n.get_opt_cnt('ospf')), bgp=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp.from_gdata(n.get_opt_cnt('bgp')), static=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static.from_gdata(n.get_opt_cnt('static')), rip=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip.from_gdata(n.get_opt_cnt('rip')), vrrp=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp.from_gdata(n.get_opt_cnt('vrrp')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'routing-protocol'
        self.elements = elements

    mut def create(self, type):
        for e in self:
            match = True
            if e.type != type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(type)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(yang.adata.MNode):
    routing_protocol: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol

    mut def __init__(self, routing_protocol: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.routing_protocol = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(elements=routing_protocol)

    def _get_attr(self, name: str) -> ?value:
        if name == 'routing_protocol':
            return iter(self.routing_protocol)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'routing-protocols'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(routing_protocol=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol.from_gdata(n.get_opt_list('routing-protocol')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(yang.adata.MNode):
    group_id: str

    mut def __init__(self, group_id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id

    def _get_attr(self, name: str) -> ?value:
        if name == 'group_id':
            return self.group_id
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'access-diversity', 'groups', 'group'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(group_id=n.get_str('group-id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(group_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(elements=group)

    def _get_attr(self, name: str) -> ?value:
        if name == 'group':
            return iter(self.group)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'access-diversity', 'groups'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group.from_gdata(n.get_opt_list('group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(yang.adata.MNode):
    group_id: str

    mut def __init__(self, group_id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id

    def _get_attr(self, name: str) -> ?value:
        if name == 'group_id':
            return self.group_id
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'access-diversity', 'constraints', 'constraint', 'target', 'group'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(group_id=n.get_str('group-id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(group_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group
    all_other_accesses: ?bool
    all_other_groups: ?bool

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]=[], all_other_accesses: ?bool, all_other_groups: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(elements=group)
        self.all_other_accesses = all_other_accesses
        self.all_other_groups = all_other_groups

    def _get_attr(self, name: str) -> ?value:
        if name == 'group':
            return iter(self.group)
        if name == 'all_other_accesses':
            return self.all_other_accesses
        if name == 'all_other_groups':
            return self.all_other_groups
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'access-diversity', 'constraints', 'constraint', 'target'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group.from_gdata(n.get_opt_list('group')), all_other_accesses=n.get_opt_empty('all-other-accesses'), all_other_groups=n.get_opt_empty('all-other-groups'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(yang.adata.MNode):
    constraint_type: Identityref
    target: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target

    mut def __init__(self, constraint_type: Identityref, target: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.constraint_type = constraint_type
        self.target = target if target is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target()

    def _get_attr(self, name: str) -> ?value:
        if name == 'constraint_type':
            return self.constraint_type
        if name == 'target':
            return self.target
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'access-diversity', 'constraints', 'constraint'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(constraint_type=n.get_Identityref('constraint-type'), target=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target.from_gdata(n.get_opt_cnt('target')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'constraint'
        self.elements = elements

    mut def create(self, constraint_type):
        for e in self:
            match = True
            if e.constraint_type != constraint_type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(constraint_type)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(yang.adata.MNode):
    constraint: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint

    mut def __init__(self, constraint: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.constraint = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(elements=constraint)

    def _get_attr(self, name: str) -> ?value:
        if name == 'constraint':
            return iter(self.constraint)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'access-diversity', 'constraints'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(constraint=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint.from_gdata(n.get_opt_list('constraint')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(yang.adata.MNode):
    groups: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups
    constraints: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints

    mut def __init__(self, groups: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups=None, constraints: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.groups = groups if groups is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups()
        self.constraints = constraints if constraints is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints()

    def _get_attr(self, name: str) -> ?value:
        if name == 'groups':
            return self.groups
        if name == 'constraints':
            return self.constraints
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'access-diversity'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(groups=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups.from_gdata(n.get_opt_cnt('groups')), constraints=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints.from_gdata(n.get_opt_cnt('constraints')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(yang.adata.MNode):
    requested_type: ?str
    strict: bool

    mut def __init__(self, requested_type: ?str, strict: ?bool=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.requested_type = requested_type
        self.strict = strict if strict is not None else False

    def _get_attr(self, name: str) -> ?value:
        if name == 'requested_type':
            return self.requested_type
        if name == 'strict':
            return self.strict
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'bearer', 'requested-type'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(requested_type=n.get_opt_str('requested-type'), strict=n.get_opt_bool('strict'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(yang.adata.MNode):
    requested_type: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type
    always_on: bool
    bearer_reference: ?str

    mut def __init__(self, requested_type: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type=None, always_on: ?bool=None, bearer_reference: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.requested_type = requested_type if requested_type is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type()
        self.always_on = always_on if always_on is not None else True
        self.bearer_reference = bearer_reference

    def _get_attr(self, name: str) -> ?value:
        if name == 'requested_type':
            return self.requested_type
        if name == 'always_on':
            return self.always_on
        if name == 'bearer_reference':
            return self.bearer_reference
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'bearer'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(requested_type=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type.from_gdata(n.get_opt_cnt('requested-type')), always_on=n.get_opt_bool('always-on'), bearer_reference=n.get_opt_str('bearer-reference'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(yang.adata.MNode):
    group_id: str
    start_address: ?str
    end_address: ?str

    mut def __init__(self, group_id: str, start_address: ?str, end_address: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id
        self.start_address = start_address
        self.end_address = end_address

    def _get_attr(self, name: str) -> ?value:
        if name == 'group_id':
            return self.group_id
        if name == 'start_address':
            return self.start_address
        if name == 'end_address':
            return self.end_address
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv4', 'provider-dhcp', 'customer-addresses', 'address-group'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(group_id=n.get_str('group-id'), start_address=n.get_opt_str('start-address'), end_address=n.get_opt_str('end-address'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'address-group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(group_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(yang.adata.MNode):
    address_group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group

    mut def __init__(self, address_group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(elements=address_group)

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_group':
            return iter(self.address_group)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv4', 'provider-dhcp', 'customer-addresses'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(address_group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group.from_gdata(n.get_opt_list('address-group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?bigint
    number_of_dynamic_address: bigint
    customer_addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses

    mut def __init__(self, provider_address: ?str, prefix_length: ?bigint, number_of_dynamic_address: ?bigint=None, customer_addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.number_of_dynamic_address = number_of_dynamic_address if number_of_dynamic_address is not None else bigint(1)
        self.customer_addresses = customer_addresses if customer_addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses()

    def _get_attr(self, name: str) -> ?value:
        if name == 'provider_address':
            return self.provider_address
        if name == 'prefix_length':
            return self.prefix_length
        if name == 'number_of_dynamic_address':
            return self.number_of_dynamic_address
        if name == 'customer_addresses':
            return self.customer_addresses
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv4', 'provider-dhcp'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_bigint('prefix-length'), number_of_dynamic_address=n.get_opt_bigint('number-of-dynamic-address'), customer_addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses.from_gdata(n.get_opt_cnt('customer-addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(yang.adata.MNode):
    server_ip_address: list[str]

    mut def __init__(self, server_ip_address: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.server_ip_address = server_ip_address if server_ip_address is not None else []

    def _get_attr(self, name: str) -> ?value:
        if name == 'server_ip_address':
            return self.server_ip_address
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv4', 'dhcp-relay', 'customer-dhcp-servers'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(server_ip_address=n.get_opt_strs('server-ip-address'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?bigint
    customer_dhcp_servers: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers

    mut def __init__(self, provider_address: ?str, prefix_length: ?bigint, customer_dhcp_servers: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.customer_dhcp_servers = customer_dhcp_servers if customer_dhcp_servers is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers()

    def _get_attr(self, name: str) -> ?value:
        if name == 'provider_address':
            return self.provider_address
        if name == 'prefix_length':
            return self.prefix_length
        if name == 'customer_dhcp_servers':
            return self.customer_dhcp_servers
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv4', 'dhcp-relay'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_bigint('prefix-length'), customer_dhcp_servers=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers.from_gdata(n.get_opt_cnt('customer-dhcp-servers')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(yang.adata.MNode):
    provider_address: ?str
    customer_address: ?str
    prefix_length: ?bigint

    mut def __init__(self, provider_address: ?str, customer_address: ?str, prefix_length: ?bigint):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.customer_address = customer_address
        self.prefix_length = prefix_length

    def _get_attr(self, name: str) -> ?value:
        if name == 'provider_address':
            return self.provider_address
        if name == 'customer_address':
            return self.customer_address
        if name == 'prefix_length':
            return self.prefix_length
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv4', 'addresses'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(provider_address=n.get_opt_str('provider-address'), customer_address=n.get_opt_str('customer-address'), prefix_length=n.get_opt_bigint('prefix-length'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(yang.adata.MNode):
    address_allocation_type: ?Identityref
    provider_dhcp: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp
    dhcp_relay: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay
    addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses

    mut def __init__(self, address_allocation_type: ?Identityref, provider_dhcp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp=None, dhcp_relay: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay=None, addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_allocation_type = address_allocation_type
        self.provider_dhcp = provider_dhcp if provider_dhcp is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp()
        self.dhcp_relay = dhcp_relay if dhcp_relay is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay()
        self.addresses = addresses if addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses()

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_allocation_type':
            return self.address_allocation_type
        if name == 'provider_dhcp':
            return self.provider_dhcp
        if name == 'dhcp_relay':
            return self.dhcp_relay
        if name == 'addresses':
            return self.addresses
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv4'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(address_allocation_type=n.get_opt_Identityref('address-allocation-type'), provider_dhcp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp.from_gdata(n.get_opt_cnt('provider-dhcp')), dhcp_relay=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay.from_gdata(n.get_opt_cnt('dhcp-relay')), addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses.from_gdata(n.get_opt_cnt('addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(yang.adata.MNode):
    group_id: str
    start_address: ?str
    end_address: ?str

    mut def __init__(self, group_id: str, start_address: ?str, end_address: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id
        self.start_address = start_address
        self.end_address = end_address

    def _get_attr(self, name: str) -> ?value:
        if name == 'group_id':
            return self.group_id
        if name == 'start_address':
            return self.start_address
        if name == 'end_address':
            return self.end_address
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv6', 'provider-dhcp', 'customer-addresses', 'address-group'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(group_id=n.get_str('group-id'), start_address=n.get_opt_str('start-address'), end_address=n.get_opt_str('end-address'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'address-group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(group_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(yang.adata.MNode):
    address_group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group

    mut def __init__(self, address_group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(elements=address_group)

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_group':
            return iter(self.address_group)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv6', 'provider-dhcp', 'customer-addresses'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(address_group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group.from_gdata(n.get_opt_list('address-group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?bigint
    number_of_dynamic_address: bigint
    customer_addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses

    mut def __init__(self, provider_address: ?str, prefix_length: ?bigint, number_of_dynamic_address: ?bigint=None, customer_addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.number_of_dynamic_address = number_of_dynamic_address if number_of_dynamic_address is not None else bigint(1)
        self.customer_addresses = customer_addresses if customer_addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses()

    def _get_attr(self, name: str) -> ?value:
        if name == 'provider_address':
            return self.provider_address
        if name == 'prefix_length':
            return self.prefix_length
        if name == 'number_of_dynamic_address':
            return self.number_of_dynamic_address
        if name == 'customer_addresses':
            return self.customer_addresses
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv6', 'provider-dhcp'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_bigint('prefix-length'), number_of_dynamic_address=n.get_opt_bigint('number-of-dynamic-address'), customer_addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses.from_gdata(n.get_opt_cnt('customer-addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(yang.adata.MNode):
    server_ip_address: list[str]

    mut def __init__(self, server_ip_address: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.server_ip_address = server_ip_address if server_ip_address is not None else []

    def _get_attr(self, name: str) -> ?value:
        if name == 'server_ip_address':
            return self.server_ip_address
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv6', 'dhcp-relay', 'customer-dhcp-servers'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(server_ip_address=n.get_opt_strs('server-ip-address'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?bigint
    customer_dhcp_servers: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers

    mut def __init__(self, provider_address: ?str, prefix_length: ?bigint, customer_dhcp_servers: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.customer_dhcp_servers = customer_dhcp_servers if customer_dhcp_servers is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers()

    def _get_attr(self, name: str) -> ?value:
        if name == 'provider_address':
            return self.provider_address
        if name == 'prefix_length':
            return self.prefix_length
        if name == 'customer_dhcp_servers':
            return self.customer_dhcp_servers
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv6', 'dhcp-relay'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_bigint('prefix-length'), customer_dhcp_servers=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers.from_gdata(n.get_opt_cnt('customer-dhcp-servers')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(yang.adata.MNode):
    provider_address: ?str
    customer_address: ?str
    prefix_length: ?bigint

    mut def __init__(self, provider_address: ?str, customer_address: ?str, prefix_length: ?bigint):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.customer_address = customer_address
        self.prefix_length = prefix_length

    def _get_attr(self, name: str) -> ?value:
        if name == 'provider_address':
            return self.provider_address
        if name == 'customer_address':
            return self.customer_address
        if name == 'prefix_length':
            return self.prefix_length
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv6', 'addresses'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(provider_address=n.get_opt_str('provider-address'), customer_address=n.get_opt_str('customer-address'), prefix_length=n.get_opt_bigint('prefix-length'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(yang.adata.MNode):
    address_allocation_type: ?Identityref
    provider_dhcp: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp
    dhcp_relay: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay
    addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses

    mut def __init__(self, address_allocation_type: ?Identityref, provider_dhcp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp=None, dhcp_relay: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay=None, addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_allocation_type = address_allocation_type
        self.provider_dhcp = provider_dhcp if provider_dhcp is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp()
        self.dhcp_relay = dhcp_relay if dhcp_relay is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay()
        self.addresses = addresses if addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses()

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_allocation_type':
            return self.address_allocation_type
        if name == 'provider_dhcp':
            return self.provider_dhcp
        if name == 'dhcp_relay':
            return self.dhcp_relay
        if name == 'addresses':
            return self.addresses
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'ipv6'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(address_allocation_type=n.get_opt_Identityref('address-allocation-type'), provider_dhcp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp.from_gdata(n.get_opt_cnt('provider-dhcp')), dhcp_relay=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay.from_gdata(n.get_opt_cnt('dhcp-relay')), addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses.from_gdata(n.get_opt_cnt('addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(yang.adata.MNode):
    enabled: bool
    fixed_value: ?bigint
    profile_name: ?str

    mut def __init__(self, enabled: ?bool=None, fixed_value: ?bigint, profile_name: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.fixed_value = fixed_value
        self.profile_name = profile_name

    def _get_attr(self, name: str) -> ?value:
        if name == 'enabled':
            return self.enabled
        if name == 'fixed_value':
            return self.fixed_value
        if name == 'profile_name':
            return self.profile_name
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'oam', 'bfd'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(enabled=n.get_opt_bool('enabled'), fixed_value=n.get_opt_bigint('fixed-value'), profile_name=n.get_opt_str('profile-name'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(yang.adata.MNode):
    bfd: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd

    mut def __init__(self, bfd: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.bfd = bfd if bfd is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd()

    def _get_attr(self, name: str) -> ?value:
        if name == 'bfd':
            return self.bfd
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection', 'oam'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(bfd=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd.from_gdata(n.get_opt_cnt('bfd')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(yang.adata.MNode):
    ipv4: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4
    ipv6: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6
    oam: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam

    mut def __init__(self, ipv4: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4=None, ipv6: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6=None, oam: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4 = ipv4 if ipv4 is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4()
        self.ipv6 = ipv6 if ipv6 is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6()
        self.oam = oam if oam is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam()

    def _get_attr(self, name: str) -> ?value:
        if name == 'ipv4':
            return self.ipv4
        if name == 'ipv6':
            return self.ipv6
        if name == 'oam':
            return self.oam
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'ip-connection'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(ipv4=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4.from_gdata(n.get_opt_cnt('ipv4')), ipv6=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6.from_gdata(n.get_opt_cnt('ipv6')), oam=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam.from_gdata(n.get_opt_cnt('oam')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'security', 'authentication'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(yang.adata.MNode):
    profile_name: ?str
    algorithm: ?str
    preshared_key: ?str

    mut def __init__(self, profile_name: ?str, algorithm: ?str, preshared_key: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile_name = profile_name
        self.algorithm = algorithm
        self.preshared_key = preshared_key

    def _get_attr(self, name: str) -> ?value:
        if name == 'profile_name':
            return self.profile_name
        if name == 'algorithm':
            return self.algorithm
        if name == 'preshared_key':
            return self.preshared_key
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'security', 'encryption', 'encryption-profile'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(profile_name=n.get_opt_str('profile-name'), algorithm=n.get_opt_str('algorithm'), preshared_key=n.get_opt_str('preshared-key'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(yang.adata.MNode):
    enabled: bool
    layer: ?str
    encryption_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile

    mut def __init__(self, enabled: ?bool=None, layer: ?str, encryption_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.layer = layer
        self.encryption_profile = encryption_profile if encryption_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile()

    def _get_attr(self, name: str) -> ?value:
        if name == 'enabled':
            return self.enabled
        if name == 'layer':
            return self.layer
        if name == 'encryption_profile':
            return self.encryption_profile
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'security', 'encryption'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(enabled=n.get_opt_bool('enabled'), layer=n.get_opt_str('layer'), encryption_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile.from_gdata(n.get_opt_cnt('encryption-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(yang.adata.MNode):
    authentication: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication
    encryption: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption

    mut def __init__(self, authentication: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication=None, encryption: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.authentication = authentication if authentication is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()
        self.encryption = encryption if encryption is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption()

    def _get_attr(self, name: str) -> ?value:
        if name == 'authentication':
            return self.authentication
        if name == 'encryption':
            return self.encryption
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'security'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(authentication=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication.from_gdata(n.get_opt_cnt('authentication')), encryption=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption.from_gdata(n.get_opt_cnt('encryption')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.adata.MNode):
    lower_port: ?bigint
    upper_port: ?bigint

    mut def __init__(self, lower_port: ?bigint, upper_port: ?bigint):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    def _get_attr(self, name: str) -> ?value:
        if name == 'lower_port':
            return self.lower_port
        if name == 'upper_port':
            return self.upper_port
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-classification-policy', 'rule', 'match-flow', 'l4-src-port-range'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(lower_port=n.get_opt_bigint('lower-port'), upper_port=n.get_opt_bigint('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.adata.MNode):
    lower_port: ?bigint
    upper_port: ?bigint

    mut def __init__(self, lower_port: ?bigint, upper_port: ?bigint):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    def _get_attr(self, name: str) -> ?value:
        if name == 'lower_port':
            return self.lower_port
        if name == 'upper_port':
            return self.upper_port
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-classification-policy', 'rule', 'match-flow', 'l4-dst-port-range'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(lower_port=n.get_opt_bigint('lower-port'), upper_port=n.get_opt_bigint('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(yang.adata.MNode):
    dscp: ?bigint
    dot1p: ?bigint
    ipv4_src_prefix: ?str
    ipv6_src_prefix: ?str
    ipv4_dst_prefix: ?str
    ipv6_dst_prefix: ?str
    l4_src_port: ?bigint
    target_sites: list[str]
    l4_src_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range
    l4_dst_port: ?bigint
    l4_dst_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range
    protocol_field: ?value

    mut def __init__(self, dscp: ?bigint, dot1p: ?bigint, ipv4_src_prefix: ?str, ipv6_src_prefix: ?str, ipv4_dst_prefix: ?str, ipv6_dst_prefix: ?str, l4_src_port: ?bigint, target_sites: ?list[str]=None, l4_src_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range=None, l4_dst_port: ?bigint, l4_dst_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range=None, protocol_field: ?value):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.dscp = dscp
        self.dot1p = dot1p
        self.ipv4_src_prefix = ipv4_src_prefix
        self.ipv6_src_prefix = ipv6_src_prefix
        self.ipv4_dst_prefix = ipv4_dst_prefix
        self.ipv6_dst_prefix = ipv6_dst_prefix
        self.l4_src_port = l4_src_port
        self.target_sites = target_sites if target_sites is not None else []
        self.l4_src_port_range = l4_src_port_range if l4_src_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()
        self.l4_dst_port = l4_dst_port
        self.l4_dst_port_range = l4_dst_port_range if l4_dst_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()
        self.protocol_field = protocol_field

    def _get_attr(self, name: str) -> ?value:
        if name == 'dscp':
            return self.dscp
        if name == 'dot1p':
            return self.dot1p
        if name == 'ipv4_src_prefix':
            return self.ipv4_src_prefix
        if name == 'ipv6_src_prefix':
            return self.ipv6_src_prefix
        if name == 'ipv4_dst_prefix':
            return self.ipv4_dst_prefix
        if name == 'ipv6_dst_prefix':
            return self.ipv6_dst_prefix
        if name == 'l4_src_port':
            return self.l4_src_port
        if name == 'target_sites':
            return self.target_sites
        if name == 'l4_src_port_range':
            return self.l4_src_port_range
        if name == 'l4_dst_port':
            return self.l4_dst_port
        if name == 'l4_dst_port_range':
            return self.l4_dst_port_range
        if name == 'protocol_field':
            return self.protocol_field
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-classification-policy', 'rule', 'match-flow'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(dscp=n.get_opt_bigint('dscp'), dot1p=n.get_opt_bigint('dot1p'), ipv4_src_prefix=n.get_opt_str('ipv4-src-prefix'), ipv6_src_prefix=n.get_opt_str('ipv6-src-prefix'), ipv4_dst_prefix=n.get_opt_str('ipv4-dst-prefix'), ipv6_dst_prefix=n.get_opt_str('ipv6-dst-prefix'), l4_src_port=n.get_opt_bigint('l4-src-port'), target_sites=n.get_opt_strs('target-sites'), l4_src_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_gdata(n.get_opt_cnt('l4-src-port-range')), l4_dst_port=n.get_opt_bigint('l4-dst-port'), l4_dst_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_gdata(n.get_opt_cnt('l4-dst-port-range')), protocol_field=n.get_opt_value('protocol-field'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(yang.adata.MNode):
    id: str
    match_flow: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow
    match_application: ?Identityref
    target_class_id: ?str

    mut def __init__(self, id: str, match_flow: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow=None, match_application: ?Identityref, target_class_id: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.match_flow = match_flow if match_flow is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow()
        self.match_application = match_application
        self.target_class_id = target_class_id

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        if name == 'match_flow':
            return self.match_flow
        if name == 'match_application':
            return self.match_application
        if name == 'target_class_id':
            return self.target_class_id
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-classification-policy', 'rule'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(id=n.get_str('id'), match_flow=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow.from_gdata(n.get_opt_cnt('match-flow')), match_application=n.get_opt_Identityref('match-application'), target_class_id=n.get_opt_str('target-class-id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'rule'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(yang.adata.MNode):
    rule: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule

    mut def __init__(self, rule: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rule = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(elements=rule)

    def _get_attr(self, name: str) -> ?value:
        if name == 'rule':
            return iter(self.rule)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-classification-policy'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(rule=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule.from_gdata(n.get_opt_list('rule')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(yang.adata.MNode):
    use_lowest_latency: ?bool
    latency_boundary: bigint

    mut def __init__(self, use_lowest_latency: ?bool, latency_boundary: ?bigint=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_latency = use_lowest_latency
        self.latency_boundary = latency_boundary if latency_boundary is not None else bigint(400)

    def _get_attr(self, name: str) -> ?value:
        if name == 'use_lowest_latency':
            return self.use_lowest_latency
        if name == 'latency_boundary':
            return self.latency_boundary
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-profile', 'classes', 'class', 'latency'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(use_lowest_latency=n.get_opt_empty('use-lowest-latency'), latency_boundary=n.get_opt_bigint('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(yang.adata.MNode):
    use_lowest_jitter: ?bool
    latency_boundary: bigint

    mut def __init__(self, use_lowest_jitter: ?bool, latency_boundary: ?bigint=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_jitter = use_lowest_jitter
        self.latency_boundary = latency_boundary if latency_boundary is not None else bigint(40000)

    def _get_attr(self, name: str) -> ?value:
        if name == 'use_lowest_jitter':
            return self.use_lowest_jitter
        if name == 'latency_boundary':
            return self.latency_boundary
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-profile', 'classes', 'class', 'jitter'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(use_lowest_jitter=n.get_opt_empty('use-lowest-jitter'), latency_boundary=n.get_opt_bigint('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(yang.adata.MNode):
    guaranteed_bw_percent: Decimal
    end_to_end: ?bool

    mut def __init__(self, guaranteed_bw_percent: Decimal, end_to_end: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.guaranteed_bw_percent = guaranteed_bw_percent
        self.end_to_end = end_to_end

    def _get_attr(self, name: str) -> ?value:
        if name == 'guaranteed_bw_percent':
            return self.guaranteed_bw_percent
        if name == 'end_to_end':
            return self.end_to_end
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-profile', 'classes', 'class', 'bandwidth'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(guaranteed_bw_percent=n.get_Decimal('guaranteed-bw-percent'), end_to_end=n.get_opt_empty('end-to-end'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth')

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(yang.adata.MNode):
    class_id: str
    direction: Identityref
    rate_limit: ?Decimal
    latency: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency
    jitter: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter
    bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth

    mut def __init__(self, class_id: str, bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth, direction: ?Identityref=None, rate_limit: ?Decimal, latency: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency=None, jitter: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_id = class_id
        _default_direction, error = complete_and_validate_identityref(Identityref.from_adata('both'), _identities, [_base_ietf_l3vpn_svc_qos_profile_direction], 'ietf-l3vpn-svc')
        if _default_direction is not None:
            self.direction = direction if direction is not None else _default_direction
        else:
            raise ValueError('Invalid default value for identityref leaf class: {error}')
        self.rate_limit = rate_limit
        self.latency = latency if latency is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency()
        self.jitter = jitter if jitter is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter()
        self.bandwidth = bandwidth

    def _get_attr(self, name: str) -> ?value:
        if name == 'class_id':
            return self.class_id
        if name == 'direction':
            return self.direction
        if name == 'rate_limit':
            return self.rate_limit
        if name == 'latency':
            return self.latency
        if name == 'jitter':
            return self.jitter
        if name == 'bandwidth':
            return self.bandwidth
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-profile', 'classes', 'class'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(class_id=n.get_str('class-id'), direction=n.get_opt_Identityref('direction'), rate_limit=n.get_opt_Decimal('rate-limit'), latency=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency.from_gdata(n.get_opt_cnt('latency')), jitter=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter.from_gdata(n.get_opt_cnt('jitter')), bandwidth=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth.from_gdata(n.get_cnt('bandwidth')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'class'
        self.elements = elements

    mut def create(self, class_id, bandwidth):
        for e in self:
            match = True
            if e.class_id != class_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(class_id, bandwidth)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(yang.adata.MNode):
    class_: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class

    mut def __init__(self, class_: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_ = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(elements=class_)

    def _get_attr(self, name: str) -> ?value:
        if name == 'class_':
            return iter(self.class_)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-profile', 'classes'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(class_=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class.from_gdata(n.get_opt_list('class')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(yang.adata.MNode):
    profile: ?str
    classes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes

    mut def __init__(self, profile: ?str, classes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile = profile
        self.classes = classes if classes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes()

    def _get_attr(self, name: str) -> ?value:
        if name == 'profile':
            return self.profile
        if name == 'classes':
            return self.classes
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos', 'qos-profile'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(profile=n.get_opt_str('profile'), classes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes.from_gdata(n.get_opt_cnt('classes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(yang.adata.MNode):
    qos_classification_policy: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy
    qos_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile

    mut def __init__(self, qos_classification_policy: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy=None, qos_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.qos_classification_policy = qos_classification_policy if qos_classification_policy is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy()
        self.qos_profile = qos_profile if qos_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile()

    def _get_attr(self, name: str) -> ?value:
        if name == 'qos_classification_policy':
            return self.qos_classification_policy
        if name == 'qos_profile':
            return self.qos_profile
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'qos'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(qos_classification_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy.from_gdata(n.get_opt_cnt('qos-classification-policy')), qos_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile.from_gdata(n.get_opt_cnt('qos-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(yang.adata.MNode):
    signalling_type: str

    mut def __init__(self, signalling_type: ?str=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.signalling_type = signalling_type if signalling_type is not None else "bgp"

    def _get_attr(self, name: str) -> ?value:
        if name == 'signalling_type':
            return self.signalling_type
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'carrierscarrier'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(signalling_type=n.get_opt_str('signalling-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(yang.adata.MNode):
    ipv4: bool
    ipv6: bool

    mut def __init__(self, ipv4: ?bool=None, ipv6: ?bool=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4 = ipv4 if ipv4 is not None else False
        self.ipv6 = ipv6 if ipv6 is not None else False

    def _get_attr(self, name: str) -> ?value:
        if name == 'ipv4':
            return self.ipv4
        if name == 'ipv6':
            return self.ipv6
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'multicast', 'multicast-address-family'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(ipv4=n.get_opt_bool('ipv4'), ipv6=n.get_opt_bool('ipv6'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(yang.adata.MNode):
    multicast_site_type: str
    multicast_address_family: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family
    protocol_type: str

    mut def __init__(self, multicast_site_type: ?str=None, multicast_address_family: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family=None, protocol_type: ?str=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.multicast_site_type = multicast_site_type if multicast_site_type is not None else "source-receiver"
        self.multicast_address_family = multicast_address_family if multicast_address_family is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family()
        self.protocol_type = protocol_type if protocol_type is not None else "both"

    def _get_attr(self, name: str) -> ?value:
        if name == 'multicast_site_type':
            return self.multicast_site_type
        if name == 'multicast_address_family':
            return self.multicast_address_family
        if name == 'protocol_type':
            return self.protocol_type
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service', 'multicast'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(multicast_site_type=n.get_opt_str('multicast-site-type'), multicast_address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family.from_gdata(n.get_opt_cnt('multicast-address-family')), protocol_type=n.get_opt_str('protocol-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(yang.adata.MNode):
    svc_input_bandwidth: bigint
    svc_output_bandwidth: bigint
    svc_mtu: bigint
    qos: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos
    carrierscarrier: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier
    multicast: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast

    mut def __init__(self, svc_input_bandwidth: bigint, svc_output_bandwidth: bigint, svc_mtu: bigint, qos: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos=None, carrierscarrier: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier=None, multicast: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.svc_input_bandwidth = svc_input_bandwidth
        self.svc_output_bandwidth = svc_output_bandwidth
        self.svc_mtu = svc_mtu
        self.qos = qos if qos is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos()
        self.carrierscarrier = carrierscarrier if carrierscarrier is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier()
        self.multicast = multicast if multicast is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast()

    def _get_attr(self, name: str) -> ?value:
        if name == 'svc_input_bandwidth':
            return self.svc_input_bandwidth
        if name == 'svc_output_bandwidth':
            return self.svc_output_bandwidth
        if name == 'svc_mtu':
            return self.svc_mtu
        if name == 'qos':
            return self.qos
        if name == 'carrierscarrier':
            return self.carrierscarrier
        if name == 'multicast':
            return self.multicast
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'service'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(svc_input_bandwidth=n.get_bigint('svc-input-bandwidth'), svc_output_bandwidth=n.get_bigint('svc-output-bandwidth'), svc_mtu=n.get_bigint('svc-mtu'), qos=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos.from_gdata(n.get_opt_cnt('qos')), carrierscarrier=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier.from_gdata(n.get_opt_cnt('carrierscarrier')), multicast=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast.from_gdata(n.get_opt_cnt('multicast')))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service')

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(yang.adata.MNode):
    target_site: str
    metric: bigint

    mut def __init__(self, target_site: str, metric: ?bigint=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.target_site = target_site
        self.metric = metric if metric is not None else bigint(1)

    def _get_attr(self, name: str) -> ?value:
        if name == 'target_site':
            return self.target_site
        if name == 'metric':
            return self.metric
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'ospf', 'sham-links', 'sham-link'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site=n.get_str('target-site'), metric=n.get_opt_bigint('metric'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'sham-link'
        self.elements = elements

    mut def create(self, target_site):
        for e in self:
            match = True
            if e.target_site != target_site:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(yang.adata.MNode):
    sham_link: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link

    mut def __init__(self, sham_link: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.sham_link = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(elements=sham_link)

    def _get_attr(self, name: str) -> ?value:
        if name == 'sham_link':
            return iter(self.sham_link)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'ospf', 'sham-links'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(sham_link=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link.from_gdata(n.get_opt_list('sham-link')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(yang.adata.MNode):
    address_family: list[str]
    area_address: str
    metric: bigint
    sham_links: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links

    mut def __init__(self, area_address: str, address_family: ?list[str]=None, metric: ?bigint=None, sham_links: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []
        self.area_address = area_address
        self.metric = metric if metric is not None else bigint(1)
        self.sham_links = sham_links if sham_links is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links()

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return self.address_family
        if name == 'area_address':
            return self.area_address
        if name == 'metric':
            return self.metric
        if name == 'sham_links':
            return self.sham_links
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'ospf'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(address_family=n.get_strs('address-family'), area_address=n.get_str('area-address'), metric=n.get_opt_bigint('metric'), sham_links=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links.from_gdata(n.get_opt_cnt('sham-links')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf.copy()')


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(yang.adata.MNode):
    autonomous_system: bigint
    address_family: list[str]

    mut def __init__(self, autonomous_system: bigint, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.autonomous_system = autonomous_system
        self.address_family = address_family if address_family is not None else []

    def _get_attr(self, name: str) -> ?value:
        if name == 'autonomous_system':
            return self.autonomous_system
        if name == 'address_family':
            return self.address_family
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'bgp'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(autonomous_system=n.get_bigint('autonomous-system'), address_family=n.get_strs('address-family'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp.copy()')


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    def _get_attr(self, name: str) -> ?value:
        if name == 'lan':
            return self.lan
        if name == 'next_hop':
            return self.next_hop
        if name == 'lan_tag':
            return self.lan_tag
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'static', 'cascaded-lan-prefixes', 'ipv4-lan-prefixes'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv4-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    def _get_attr(self, name: str) -> ?value:
        if name == 'lan':
            return self.lan
        if name == 'next_hop':
            return self.next_hop
        if name == 'lan_tag':
            return self.lan_tag
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'static', 'cascaded-lan-prefixes', 'ipv6-lan-prefixes'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv6-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.adata.MNode):
    ipv4_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes
    ipv6_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes

    mut def __init__(self, ipv4_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]=[], ipv6_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(elements=ipv4_lan_prefixes)
        self.ipv6_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(elements=ipv6_lan_prefixes)

    def _get_attr(self, name: str) -> ?value:
        if name == 'ipv4_lan_prefixes':
            return iter(self.ipv4_lan_prefixes)
        if name == 'ipv6_lan_prefixes':
            return iter(self.ipv6_lan_prefixes)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'static', 'cascaded-lan-prefixes'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(ipv4_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes.from_gdata(n.get_opt_list('ipv4-lan-prefixes')), ipv6_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes.from_gdata(n.get_opt_list('ipv6-lan-prefixes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(yang.adata.MNode):
    cascaded_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes

    mut def __init__(self, cascaded_lan_prefixes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cascaded_lan_prefixes = cascaded_lan_prefixes if cascaded_lan_prefixes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    def _get_attr(self, name: str) -> ?value:
        if name == 'cascaded_lan_prefixes':
            return self.cascaded_lan_prefixes
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'static'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(cascaded_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_gdata(n.get_opt_cnt('cascaded-lan-prefixes')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static.copy()')


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return self.address_family
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'rip'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(address_family=n.get_strs('address-family'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip.copy()')


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return self.address_family
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol', 'vrrp'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(address_family=n.get_strs('address-family'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp.copy()')


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(yang.adata.MNode):
    type: Identityref
    ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf
    bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp
    static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static
    rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip
    vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp

    mut def __init__(self, type: Identityref, ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf=None, bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp=None, static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static=None, rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip=None, vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type
        self.ospf = ospf
        self.bgp = bgp
        self.static = static
        self.rip = rip
        self.vrrp = vrrp

    mut def create_ospf(self, area_address):
        existing = self.ospf
        if existing is not None:
            return existing
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(area_address)
        self.ospf = res
        return res

    mut def create_bgp(self, autonomous_system):
        existing = self.bgp
        if existing is not None:
            return existing
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(autonomous_system)
        self.bgp = res
        return res

    mut def create_static(self):
        existing = self.static
        if existing is not None:
            return existing
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static()
        self.static = res
        return res

    mut def create_rip(self):
        existing = self.rip
        if existing is not None:
            return existing
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip()
        self.rip = res
        return res

    mut def create_vrrp(self):
        existing = self.vrrp
        if existing is not None:
            return existing
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp()
        self.vrrp = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'type':
            return self.type
        if name == 'ospf':
            return self.ospf
        if name == 'bgp':
            return self.bgp
        if name == 'static':
            return self.static
        if name == 'rip':
            return self.rip
        if name == 'vrrp':
            return self.vrrp
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols', 'routing-protocol'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(type=n.get_Identityref('type'), ospf=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf.from_gdata(n.get_opt_cnt('ospf')), bgp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp.from_gdata(n.get_opt_cnt('bgp')), static=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static.from_gdata(n.get_opt_cnt('static')), rip=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip.from_gdata(n.get_opt_cnt('rip')), vrrp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp.from_gdata(n.get_opt_cnt('vrrp')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'routing-protocol'
        self.elements = elements

    mut def create(self, type):
        for e in self:
            match = True
            if e.type != type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(type)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(yang.adata.MNode):
    routing_protocol: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol

    mut def __init__(self, routing_protocol: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.routing_protocol = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(elements=routing_protocol)

    def _get_attr(self, name: str) -> ?value:
        if name == 'routing_protocol':
            return iter(self.routing_protocol)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'routing-protocols'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(routing_protocol=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol.from_gdata(n.get_opt_list('routing-protocol')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(yang.adata.MNode):
    access_priority: bigint

    mut def __init__(self, access_priority: ?bigint=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.access_priority = access_priority if access_priority is not None else bigint(100)

    def _get_attr(self, name: str) -> ?value:
        if name == 'access_priority':
            return self.access_priority
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'availability'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(access_priority=n.get_opt_bigint('access-priority'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(yang.adata.MNode):
    vpn_policy_id: ?str
    vpn_id: ?str
    site_role: Identityref

    mut def __init__(self, vpn_policy_id: ?str, vpn_id: ?str, site_role: ?Identityref=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_policy_id = vpn_policy_id
        self.vpn_id = vpn_id
        _default_site_role, error = complete_and_validate_identityref(Identityref.from_adata('any-to-any-role'), _identities, [_base_ietf_l3vpn_svc_site_role], 'ietf-l3vpn-svc')
        if _default_site_role is not None:
            self.site_role = site_role if site_role is not None else _default_site_role
        else:
            raise ValueError('Invalid default value for identityref leaf vpn-attachment: {error}')

    def _get_attr(self, name: str) -> ?value:
        if name == 'vpn_policy_id':
            return self.vpn_policy_id
        if name == 'vpn_id':
            return self.vpn_id
        if name == 'site_role':
            return self.site_role
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access', 'vpn-attachment'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(vpn_policy_id=n.get_opt_str('vpn-policy-id'), vpn_id=n.get_opt_str('vpn-id'), site_role=n.get_opt_Identityref('site-role'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(yang.adata.MNode):
    site_network_access_id: str
    site_network_access_type: Identityref
    location_reference: ?str
    device_reference: ?str
    access_diversity: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity
    bearer: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer
    ip_connection: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection
    security: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security
    service: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service
    routing_protocols: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols
    availability: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability
    vpn_attachment: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment

    mut def __init__(self, site_network_access_id: str, service: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service, site_network_access_type: ?Identityref=None, location_reference: ?str, device_reference: ?str, access_diversity: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity=None, bearer: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer=None, ip_connection: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection=None, security: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security=None, routing_protocols: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols=None, availability: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability=None, vpn_attachment: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site_network_access_id = site_network_access_id
        _default_site_network_access_type, error = complete_and_validate_identityref(Identityref.from_adata('point-to-point'), _identities, [_base_ietf_l3vpn_svc_site_network_access_type], 'ietf-l3vpn-svc')
        if _default_site_network_access_type is not None:
            self.site_network_access_type = site_network_access_type if site_network_access_type is not None else _default_site_network_access_type
        else:
            raise ValueError('Invalid default value for identityref leaf site-network-access: {error}')
        self.location_reference = location_reference
        self.device_reference = device_reference
        self.access_diversity = access_diversity if access_diversity is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity()
        self.bearer = bearer if bearer is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer()
        self.ip_connection = ip_connection if ip_connection is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection()
        self.security = security if security is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security()
        self.service = service
        self.routing_protocols = routing_protocols if routing_protocols is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols()
        self.availability = availability if availability is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability()
        self.vpn_attachment = vpn_attachment if vpn_attachment is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment()

    def _get_attr(self, name: str) -> ?value:
        if name == 'site_network_access_id':
            return self.site_network_access_id
        if name == 'site_network_access_type':
            return self.site_network_access_type
        if name == 'location_reference':
            return self.location_reference
        if name == 'device_reference':
            return self.device_reference
        if name == 'access_diversity':
            return self.access_diversity
        if name == 'bearer':
            return self.bearer
        if name == 'ip_connection':
            return self.ip_connection
        if name == 'security':
            return self.security
        if name == 'service':
            return self.service
        if name == 'routing_protocols':
            return self.routing_protocols
        if name == 'availability':
            return self.availability
        if name == 'vpn_attachment':
            return self.vpn_attachment
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses', 'site-network-access'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(site_network_access_id=n.get_str('site-network-access-id'), site_network_access_type=n.get_opt_Identityref('site-network-access-type'), location_reference=n.get_opt_str('location-reference'), device_reference=n.get_opt_str('device-reference'), access_diversity=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity.from_gdata(n.get_opt_cnt('access-diversity')), bearer=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer.from_gdata(n.get_opt_cnt('bearer')), ip_connection=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection.from_gdata(n.get_opt_cnt('ip-connection')), security=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security.from_gdata(n.get_opt_cnt('security')), service=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service.from_gdata(n.get_cnt('service')), routing_protocols=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols.from_gdata(n.get_opt_cnt('routing-protocols')), availability=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability.from_gdata(n.get_opt_cnt('availability')), vpn_attachment=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment.from_gdata(n.get_opt_cnt('vpn-attachment')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'site-network-access'
        self.elements = elements

    mut def create(self, site_network_access_id, service):
        for e in self:
            match = True
            if e.site_network_access_id != site_network_access_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(site_network_access_id, service)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(yang.adata.MNode):
    site_network_access: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access

    mut def __init__(self, site_network_access: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site_network_access = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(elements=site_network_access)

    def _get_attr(self, name: str) -> ?value:
        if name == 'site_network_access':
            return iter(self.site_network_access)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site', 'site-network-accesses'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(site_network_access=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access.from_gdata(n.get_opt_list('site-network-access')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(yang.adata.MNode):
    site_id: str
    requested_site_start: ?str
    requested_site_stop: ?str
    locations: ietf_l3vpn_svc__l3vpn_svc__sites__site__locations
    devices: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices
    site_diversity: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity
    management: ietf_l3vpn_svc__l3vpn_svc__sites__site__management
    vpn_policies: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies
    site_vpn_flavor: Identityref
    maximum_routes: ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes
    security: ietf_l3vpn_svc__l3vpn_svc__sites__site__security
    service: ietf_l3vpn_svc__l3vpn_svc__sites__site__service
    traffic_protection: ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection
    routing_protocols: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols
    site_network_accesses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses

    mut def __init__(self, site_id: str, management: ietf_l3vpn_svc__l3vpn_svc__sites__site__management, requested_site_start: ?str, requested_site_stop: ?str, locations: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__locations=None, devices: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__devices=None, site_diversity: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity=None, vpn_policies: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies=None, site_vpn_flavor: ?Identityref=None, maximum_routes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes=None, security: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security=None, service: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service=None, traffic_protection: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection=None, routing_protocols: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols=None, site_network_accesses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site_id = site_id
        self.requested_site_start = requested_site_start
        self.requested_site_stop = requested_site_stop
        self.locations = locations if locations is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__locations()
        self.devices = devices if devices is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__devices()
        self.site_diversity = site_diversity if site_diversity is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity()
        self.management = management
        self.vpn_policies = vpn_policies if vpn_policies is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies()
        _default_site_vpn_flavor, error = complete_and_validate_identityref(Identityref.from_adata('site-vpn-flavor-single'), _identities, [_base_ietf_l3vpn_svc_site_vpn_flavor], 'ietf-l3vpn-svc')
        if _default_site_vpn_flavor is not None:
            self.site_vpn_flavor = site_vpn_flavor if site_vpn_flavor is not None else _default_site_vpn_flavor
        else:
            raise ValueError('Invalid default value for identityref leaf site: {error}')
        self.maximum_routes = maximum_routes if maximum_routes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes()
        self.security = security if security is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security()
        self.service = service if service is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service()
        self.traffic_protection = traffic_protection if traffic_protection is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection()
        self.routing_protocols = routing_protocols if routing_protocols is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols()
        self.site_network_accesses = site_network_accesses if site_network_accesses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses()

    def _get_attr(self, name: str) -> ?value:
        if name == 'site_id':
            return self.site_id
        if name == 'requested_site_start':
            return self.requested_site_start
        if name == 'requested_site_stop':
            return self.requested_site_stop
        if name == 'locations':
            return self.locations
        if name == 'devices':
            return self.devices
        if name == 'site_diversity':
            return self.site_diversity
        if name == 'management':
            return self.management
        if name == 'vpn_policies':
            return self.vpn_policies
        if name == 'site_vpn_flavor':
            return self.site_vpn_flavor
        if name == 'maximum_routes':
            return self.maximum_routes
        if name == 'security':
            return self.security
        if name == 'service':
            return self.service
        if name == 'traffic_protection':
            return self.traffic_protection
        if name == 'routing_protocols':
            return self.routing_protocols
        if name == 'site_network_accesses':
            return self.site_network_accesses
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites__site')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites', 'site'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(site_id=n.get_str('site-id'), requested_site_start=n.get_opt_str('requested-site-start'), requested_site_stop=n.get_opt_str('requested-site-stop'), locations=ietf_l3vpn_svc__l3vpn_svc__sites__site__locations.from_gdata(n.get_opt_cnt('locations')), devices=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices.from_gdata(n.get_opt_cnt('devices')), site_diversity=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity.from_gdata(n.get_opt_cnt('site-diversity')), management=ietf_l3vpn_svc__l3vpn_svc__sites__site__management.from_gdata(n.get_cnt('management')), vpn_policies=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies.from_gdata(n.get_opt_cnt('vpn-policies')), site_vpn_flavor=n.get_opt_Identityref('site-vpn-flavor'), maximum_routes=ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes.from_gdata(n.get_opt_cnt('maximum-routes')), security=ietf_l3vpn_svc__l3vpn_svc__sites__site__security.from_gdata(n.get_opt_cnt('security')), service=ietf_l3vpn_svc__l3vpn_svc__sites__site__service.from_gdata(n.get_opt_cnt('service')), traffic_protection=ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection.from_gdata(n.get_opt_cnt('traffic-protection')), routing_protocols=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols.from_gdata(n.get_opt_cnt('routing-protocols')), site_network_accesses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses.from_gdata(n.get_opt_cnt('site-network-accesses')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites__site_entry.from_gdata(self.to_gdata())

class ietf_l3vpn_svc__l3vpn_svc__sites__site(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'site'
        self.elements = elements

    mut def create(self, site_id, management):
        for e in self:
            match = True
            if e.site_id != site_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(site_id, management)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return ietf_l3vpn_svc__l3vpn_svc__sites__site(elements=copied_elements)

extension ietf_l3vpn_svc__l3vpn_svc__sites__site(Iterable[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]):
    def __iter__(self) -> Iterator[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]:
        return self.elements.__iter__()

class ietf_l3vpn_svc__l3vpn_svc__sites(yang.adata.MNode):
    site: ietf_l3vpn_svc__l3vpn_svc__sites__site

    mut def __init__(self, site: list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site = ietf_l3vpn_svc__l3vpn_svc__sites__site(elements=site)

    def _get_attr(self, name: str) -> ?value:
        if name == 'site':
            return iter(self.site)
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc__sites')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc', 'sites'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites(site=ietf_l3vpn_svc__l3vpn_svc__sites__site.from_gdata(n.get_opt_list('site')))
        return ietf_l3vpn_svc__l3vpn_svc__sites()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc__sites.from_gdata(self.to_gdata())


class ietf_l3vpn_svc__l3vpn_svc(yang.adata.MNode):
    vpn_profiles: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles
    vpn_services: ietf_l3vpn_svc__l3vpn_svc__vpn_services
    sites: ietf_l3vpn_svc__l3vpn_svc__sites

    mut def __init__(self, vpn_profiles: ?ietf_l3vpn_svc__l3vpn_svc__vpn_profiles=None, vpn_services: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services=None, sites: ?ietf_l3vpn_svc__l3vpn_svc__sites=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_profiles = vpn_profiles if vpn_profiles is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_profiles()
        self.vpn_services = vpn_services if vpn_services is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services()
        self.sites = sites if sites is not None else ietf_l3vpn_svc__l3vpn_svc__sites()

    def _get_attr(self, name: str) -> ?value:
        if name == 'vpn_profiles':
            return self.vpn_profiles
        if name == 'vpn_services':
            return self.vpn_services
        if name == 'sites':
            return self.sites
        raise ValueError('Attribute {name} not found in ietf_l3vpn_svc__l3vpn_svc')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False, root_path=['ietf-l3vpn-svc:l3vpn-svc'])
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc(vpn_profiles=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles.from_gdata(n.get_opt_cnt('vpn-profiles')), vpn_services=ietf_l3vpn_svc__l3vpn_svc__vpn_services.from_gdata(n.get_opt_cnt('vpn-services')), sites=ietf_l3vpn_svc__l3vpn_svc__sites.from_gdata(n.get_opt_cnt('sites')))
        return ietf_l3vpn_svc__l3vpn_svc()

    def copy(self):
        """Create a deep copy of this adata object"""
        return ietf_l3vpn_svc__l3vpn_svc.from_gdata(self.to_gdata())


class root(yang.adata.MNode):
    tmf_store: orchestron_tmf__tmf_store
    netinfra: netinfra__netinfra
    l3vpn_svc: ietf_l3vpn_svc__l3vpn_svc

    mut def __init__(self, tmf_store: ?orchestron_tmf__tmf_store=None, netinfra: ?netinfra__netinfra=None, l3vpn_svc: ?ietf_l3vpn_svc__l3vpn_svc=None):
        self._ns = ''
        self.tmf_store = tmf_store if tmf_store is not None else orchestron_tmf__tmf_store()
        self.netinfra = netinfra if netinfra is not None else netinfra__netinfra()
        self.l3vpn_svc = l3vpn_svc if l3vpn_svc is not None else ietf_l3vpn_svc__l3vpn_svc()

    def _get_attr(self, name: str) -> ?value:
        if name == 'tmf_store':
            return self.tmf_store
        if name == 'netinfra':
            return self.netinfra
        if name == 'l3vpn_svc':
            return self.l3vpn_svc
        raise ValueError('Attribute {name} not found in root')

    mut def to_gdata(self) -> yang.gdata.Node:
        if isinstance(self, yang.adata.MNode):
            return yang.gen3.from_data(src_dnode(), self, loose=False)
        raise ValueError('unreachable')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> root:
        if n is not None:
            return root(tmf_store=orchestron_tmf__tmf_store.from_gdata(n.get_opt_cnt('tmf-store')), netinfra=netinfra__netinfra.from_gdata(n.get_opt_cnt('netinfra')), l3vpn_svc=ietf_l3vpn_svc__l3vpn_svc.from_gdata(n.get_opt_cnt('l3vpn-svc')))
        return root()

    def copy(self):
        """Create a deep copy of this adata object"""
        return root.from_gdata(self.to_gdata())


def src_dnode():
    return DRoot(identities=[
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-network-access-type'),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='point-to-point', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-network-access-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multipoint', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-network-access-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='placement-diversity'),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bearer-diverse', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='placement-diversity')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='pe-diverse', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='placement-diversity')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='pop-diverse', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='placement-diversity')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='linecard-diverse', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='placement-diversity')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='same-pe', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='placement-diversity')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='same-bearer', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='placement-diversity')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application'),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='web', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='mail', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='file-transfer', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='database', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='social', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='games', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='p2p', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='network-management', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='voice', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='video', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='embb', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='urllc', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='mmtc', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor'),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-single', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-multi', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-sub', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-nni', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='management'),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='co-managed', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='management')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-managed', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='management')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-managed', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='management')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-allocation-type'),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-dhcp', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-allocation-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-dhcp-relay', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-allocation-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-dhcp-slaac', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-allocation-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='static-address', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-allocation-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='slaac', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-allocation-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-role'),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='any-to-any-role', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-role')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='spoke-role', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-role')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hub-role', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-role')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-topology'),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='any-to-any', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-topology')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hub-spoke', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-topology')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hub-spoke-disjoint', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-topology')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-tree-type'),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ssm-tree-type', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-tree-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='asm-tree-type', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-tree-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bidir-tree-type', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-tree-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-rp-discovery-type'),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='auto-rp', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-rp-discovery-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='static-rp', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-rp-discovery-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bsr-rp', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-rp-discovery-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing-protocol-type'),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ospf', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing-protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bgp', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing-protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='static', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing-protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rip', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing-protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vrrp', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing-protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='direct', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing-protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type'),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='tcp', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='udp', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='icmp', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='icmp6', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='gre', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipip', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hop-by-hop', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='esp', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ah', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-policy-filter-type'),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv4', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-policy-filter-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv6', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-policy-filter-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lan', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-policy-filter-type')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='qos-profile-direction'),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-to-wan', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='qos-profile-direction')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='wan-to-site', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='qos-profile-direction')
            ]),
        DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='both', base=[
                DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='qos-profile-direction')
            ])
    ], children=[
    DContainer(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='tmf-store', config=True, description='TMF Data Store', presence=False, children=[
        DContainer(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='tmf640', config=True, description='TMF640 - Service Activation and Configuration', presence=False, children=[
            DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='service', key=['id'], config=True, min_elements=0, ordered_by='system', exts=[
                    Ext('orchestron', 'transform', arg='sorespo.tmf.Tmf640Store')
                ], children=[
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='Unique identifier of the service', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='href', config=True, description='Reference of the service', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='category', config=True, description='Is it a customer facing or resource facing service', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='description', config=True, description='Free-text description of the service', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='endDate', config=True, description='Date when the service ends', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='yang:date-and-time', description="The date-and-time type is a profile of the ISO 8601\nstandard for representation of dates and times using the\nGregorian calendar.  The profile is defined by the\ndate-time production in Section 5.6 of RFC 3339.\n\nThe date-and-time type is compatible with the dateTime XML\nschema type with the following notable exceptions:\n\n(a) The date-and-time type does not allow negative years.\n\n(b) The date-and-time time-offset -00:00 indicates an unknown\n    time zone (see RFC 3339) while -00:00 and +00:00 and Z\n    all represent the same time zone in dateTime.\n\n(c) The canonical format (see below) of data-and-time values\n    differs from the canonical format used by the dateTime XML\n    schema type, which requires all times to be in UTC using\n    the time-offset 'Z'.\n\nThis type is not equivalent to the DateAndTime textual\nconvention of the SMIv2 since RFC 3339 uses a different\nseparator between full-date and full-time and provides\nhigher resolution of time-secfrac.\n\nThe canonical format for date-and-time values with a known time\nzone uses a numeric time zone offset that is calculated using\nthe device's configured known offset to UTC time.  A change of\nthe device's offset to UTC time will cause date-and-time values\nto change accordingly.  Such changes might happen periodically\nin case a server follows automatically daylight saving time\n(DST) time zone offset changes.  The canonical format for\ndate-and-time values with an unknown time zone (usually\nreferring to the notion of local time) uses the time-offset\n-00:00.", reference='RFC 3339: Date and Time on the Internet: Timestamps\nRFC 2579: Textual Conventions for SMIv2\nXSD-TYPES: XML Schema Part 2: Datatypes Second Edition', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='\\\\d{{4}}-\\\\d{{2}}-\\\\d{{2}}T\\\\d{{2}}:\\\\d{{2}}:\\\\d{{2}}(\\\\.\\\\d+)?(Z|[\\\\+\\\\-]\\\\d{{2}}:\\\\d{{2}})', pcre='^(\\\\d{{4}}-\\\\d{{2}}-\\\\d{{2}}T\\\\d{{2}}:\\\\d{{2}}:\\\\d{{2}}(\\\\.\\\\d+)?(Z|[\\\\+\\\\-]\\\\d{{2}}:\\\\d{{2}}))$', invert=False)])),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='hasStarted', config=True, description='If TRUE, this Service has already been started', mandatory=False, type_=DTypeBoolean(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='isBundle', config=True, description="If true, the service is a ServiceBundle which regroup a\nservice hierachy. If false, the service is a 'atomic' service\n(hierachy leaf).", mandatory=False, type_=DTypeBoolean(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='isServiceEnabled', config=True, description='If FALSE and hasStarted is FALSE, this particular Service has\nNOT been enabled for use - if FALSE and hasStarted is TRUE\nthen the service has failed ', mandatory=False, type_=DTypeBoolean(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='isStateful', config=True, description='If TRUE, this Service can be changed without affecting any\nother services', mandatory=False, type_=DTypeBoolean(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='name', config=True, description='Name of the service', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='serviceDate', config=True, description='Date when the service was created (whatever its status).', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='serviceType', config=True, description='Business type of the service', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='startDate', config=True, description='Date when the service starts', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='yang:date-and-time', description="The date-and-time type is a profile of the ISO 8601\nstandard for representation of dates and times using the\nGregorian calendar.  The profile is defined by the\ndate-time production in Section 5.6 of RFC 3339.\n\nThe date-and-time type is compatible with the dateTime XML\nschema type with the following notable exceptions:\n\n(a) The date-and-time type does not allow negative years.\n\n(b) The date-and-time time-offset -00:00 indicates an unknown\n    time zone (see RFC 3339) while -00:00 and +00:00 and Z\n    all represent the same time zone in dateTime.\n\n(c) The canonical format (see below) of data-and-time values\n    differs from the canonical format used by the dateTime XML\n    schema type, which requires all times to be in UTC using\n    the time-offset 'Z'.\n\nThis type is not equivalent to the DateAndTime textual\nconvention of the SMIv2 since RFC 3339 uses a different\nseparator between full-date and full-time and provides\nhigher resolution of time-secfrac.\n\nThe canonical format for date-and-time values with a known time\nzone uses a numeric time zone offset that is calculated using\nthe device's configured known offset to UTC time.  A change of\nthe device's offset to UTC time will cause date-and-time values\nto change accordingly.  Such changes might happen periodically\nin case a server follows automatically daylight saving time\n(DST) time zone offset changes.  The canonical format for\ndate-and-time values with an unknown time zone (usually\nreferring to the notion of local time) uses the time-offset\n-00:00.", reference='RFC 3339: Date and Time on the Internet: Timestamps\nRFC 2579: Textual Conventions for SMIv2\nXSD-TYPES: XML Schema Part 2: Datatypes Second Edition', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='\\\\d{{4}}-\\\\d{{2}}-\\\\d{{2}}T\\\\d{{2}}:\\\\d{{2}}:\\\\d{{2}}(\\\\.\\\\d+)?(Z|[\\\\+\\\\-]\\\\d{{2}}:\\\\d{{2}})', pcre='^(\\\\d{{4}}-\\\\d{{2}}-\\\\d{{2}}T\\\\d{{2}}:\\\\d{{2}}:\\\\d{{2}}(\\\\.\\\\d+)?(Z|[\\\\+\\\\-]\\\\d{{2}}:\\\\d{{2}}))$', invert=False)])),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='startMode', config=True, description='This attribute is an enumerated integer that indicates how\nthe Service is started, such as: 0: Unknown; 1: Automatically\nby the managed environment; 2: Automatically by the owning\ndevice; 3: Manually by the Provider of the Service; 4:\nManually by a Customer of the Provider; 5: Any of the above', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='feature', key=['id'], config=True, description='A list of feature associated with this service ', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='Unique identifier of the feature.', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='isBundle', config=True, description='True if this is a feature group. Default is false.', mandatory=False, type_=DTypeBoolean(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='isEnabled', config=True, description='True if this feature is enabled. Default is true.', mandatory=False, type_=DTypeBoolean(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='name', config=True, description='This is the name for the feature.', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='constraint', key=['id'], config=True, description='This is a list of feature constraints.', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='reference id to the target constraint', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='href', config=True, description='Hyperlink reference to the target constraint', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='name', config=True, description='Name given to the constraint', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='version', config=True, description='constraint version', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class entity name', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='referredType', config=True, description='The (class) type of the referred constraint', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                    ]),
                    DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='featureCharacteristic', key=['id'], config=True, description='This is a list of Characteristics for a particular\nfeature.', min_elements=1, ordered_by='system', children=[
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='Unique identifier of the characteristic', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='name', config=True, description='Name of the characteristic', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='characteristicRelationship', key=['id'], config=True, min_elements=0, ordered_by='system', children=[
                            DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='Unique identifier of the characteristic', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                            DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='relationshipType', config=True, description='The type of relationship', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                            DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                            DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                            DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class entity name', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                        ]),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class entity name', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                    ]),
                    DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='featureRelationship', key=['id'], config=True, min_elements=0, ordered_by='system', children=[
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='Unique identifier of the target feature.', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='name', config=True, description='This is the name of the target feature.', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='relationshipType', config=True, description='This is the type of the feature relationship.', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DContainer(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='validFor', config=True, description='The period for which this feature relationship is valid.', presence=False, children=[
                            DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='endDateTime', config=True, description='End of the time period, using IETC-RFC-3339 format', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='yang:date-and-time', description="The date-and-time type is a profile of the ISO 8601\nstandard for representation of dates and times using the\nGregorian calendar.  The profile is defined by the\ndate-time production in Section 5.6 of RFC 3339.\n\nThe date-and-time type is compatible with the dateTime XML\nschema type with the following notable exceptions:\n\n(a) The date-and-time type does not allow negative years.\n\n(b) The date-and-time time-offset -00:00 indicates an unknown\n    time zone (see RFC 3339) while -00:00 and +00:00 and Z\n    all represent the same time zone in dateTime.\n\n(c) The canonical format (see below) of data-and-time values\n    differs from the canonical format used by the dateTime XML\n    schema type, which requires all times to be in UTC using\n    the time-offset 'Z'.\n\nThis type is not equivalent to the DateAndTime textual\nconvention of the SMIv2 since RFC 3339 uses a different\nseparator between full-date and full-time and provides\nhigher resolution of time-secfrac.\n\nThe canonical format for date-and-time values with a known time\nzone uses a numeric time zone offset that is calculated using\nthe device's configured known offset to UTC time.  A change of\nthe device's offset to UTC time will cause date-and-time values\nto change accordingly.  Such changes might happen periodically\nin case a server follows automatically daylight saving time\n(DST) time zone offset changes.  The canonical format for\ndate-and-time values with an unknown time zone (usually\nreferring to the notion of local time) uses the time-offset\n-00:00.", reference='RFC 3339: Date and Time on the Internet: Timestamps\nRFC 2579: Textual Conventions for SMIv2\nXSD-TYPES: XML Schema Part 2: Datatypes Second Edition', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='\\\\d{{4}}-\\\\d{{2}}-\\\\d{{2}}T\\\\d{{2}}:\\\\d{{2}}:\\\\d{{2}}(\\\\.\\\\d+)?(Z|[\\\\+\\\\-]\\\\d{{2}}:\\\\d{{2}})', pcre='^(\\\\d{{4}}-\\\\d{{2}}-\\\\d{{2}}T\\\\d{{2}}:\\\\d{{2}}:\\\\d{{2}}(\\\\.\\\\d+)?(Z|[\\\\+\\\\-]\\\\d{{2}}:\\\\d{{2}}))$', invert=False)])),
                            DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='startDateTime', config=True, description='Start of the time period, using IETC-RFC-3339 format. If you\ndefine a start, you must also define an end', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='yang:date-and-time', description="The date-and-time type is a profile of the ISO 8601\nstandard for representation of dates and times using the\nGregorian calendar.  The profile is defined by the\ndate-time production in Section 5.6 of RFC 3339.\n\nThe date-and-time type is compatible with the dateTime XML\nschema type with the following notable exceptions:\n\n(a) The date-and-time type does not allow negative years.\n\n(b) The date-and-time time-offset -00:00 indicates an unknown\n    time zone (see RFC 3339) while -00:00 and +00:00 and Z\n    all represent the same time zone in dateTime.\n\n(c) The canonical format (see below) of data-and-time values\n    differs from the canonical format used by the dateTime XML\n    schema type, which requires all times to be in UTC using\n    the time-offset 'Z'.\n\nThis type is not equivalent to the DateAndTime textual\nconvention of the SMIv2 since RFC 3339 uses a different\nseparator between full-date and full-time and provides\nhigher resolution of time-secfrac.\n\nThe canonical format for date-and-time values with a known time\nzone uses a numeric time zone offset that is calculated using\nthe device's configured known offset to UTC time.  A change of\nthe device's offset to UTC time will cause date-and-time values\nto change accordingly.  Such changes might happen periodically\nin case a server follows automatically daylight saving time\n(DST) time zone offset changes.  The canonical format for\ndate-and-time values with an unknown time zone (usually\nreferring to the notion of local time) uses the time-offset\n-00:00.", reference='RFC 3339: Date and Time on the Internet: Timestamps\nRFC 2579: Textual Conventions for SMIv2\nXSD-TYPES: XML Schema Part 2: Datatypes Second Edition', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='\\\\d{{4}}-\\\\d{{2}}-\\\\d{{2}}T\\\\d{{2}}:\\\\d{{2}}:\\\\d{{2}}(\\\\.\\\\d+)?(Z|[\\\\+\\\\-]\\\\d{{2}}:\\\\d{{2}})', pcre='^(\\\\d{{4}}-\\\\d{{2}}-\\\\d{{2}}T\\\\d{{2}}:\\\\d{{2}}:\\\\d{{2}}(\\\\.\\\\d+)?(Z|[\\\\+\\\\-]\\\\d{{2}}:\\\\d{{2}}))$', invert=False)])),
                            DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                            DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                            DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class entity name', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                        ]),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class entity name', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                    ]),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional attributes\nand relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class entity name', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ]),
                DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='note', key=['id'], config=True, description='A list of notes made on this service', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='Identifier of the note within its containing entity (may or\nmay not be globally unique, depending on provider\nimplementation)', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='author', config=True, description='Author of the note', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='date', config=True, description='Date of the note', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='yang:date-and-time', description="The date-and-time type is a profile of the ISO 8601\nstandard for representation of dates and times using the\nGregorian calendar.  The profile is defined by the\ndate-time production in Section 5.6 of RFC 3339.\n\nThe date-and-time type is compatible with the dateTime XML\nschema type with the following notable exceptions:\n\n(a) The date-and-time type does not allow negative years.\n\n(b) The date-and-time time-offset -00:00 indicates an unknown\n    time zone (see RFC 3339) while -00:00 and +00:00 and Z\n    all represent the same time zone in dateTime.\n\n(c) The canonical format (see below) of data-and-time values\n    differs from the canonical format used by the dateTime XML\n    schema type, which requires all times to be in UTC using\n    the time-offset 'Z'.\n\nThis type is not equivalent to the DateAndTime textual\nconvention of the SMIv2 since RFC 3339 uses a different\nseparator between full-date and full-time and provides\nhigher resolution of time-secfrac.\n\nThe canonical format for date-and-time values with a known time\nzone uses a numeric time zone offset that is calculated using\nthe device's configured known offset to UTC time.  A change of\nthe device's offset to UTC time will cause date-and-time values\nto change accordingly.  Such changes might happen periodically\nin case a server follows automatically daylight saving time\n(DST) time zone offset changes.  The canonical format for\ndate-and-time values with an unknown time zone (usually\nreferring to the notion of local time) uses the time-offset\n-00:00.", reference='RFC 3339: Date and Time on the Internet: Timestamps\nRFC 2579: Textual Conventions for SMIv2\nXSD-TYPES: XML Schema Part 2: Datatypes Second Edition', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='\\\\d{{4}}-\\\\d{{2}}-\\\\d{{2}}T\\\\d{{2}}:\\\\d{{2}}:\\\\d{{2}}(\\\\.\\\\d+)?(Z|[\\\\+\\\\-]\\\\d{{2}}:\\\\d{{2}})', pcre='^(\\\\d{{4}}-\\\\d{{2}}-\\\\d{{2}}T\\\\d{{2}}:\\\\d{{2}}:\\\\d{{2}}(\\\\.\\\\d+)?(Z|[\\\\+\\\\-]\\\\d{{2}}:\\\\d{{2}}))$', invert=False)])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='text', config=True, description='Text of the note', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class entity name', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ]),
                DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='place', key=['id'], config=True, description='A list of places (Place [*]). Used to define a place useful\nor the service (for example a geographical place whre the\nservice is installed)', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='Unique identifier of the place', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='href', config=True, description='Unique reference of the place', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='name', config=True, description='A user-friendly name for the place, such as [Paris Store],\n[London Store], [Main Home]', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='role', config=True, mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class Extensible\nname', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='referredType', config=True, description='The actual type of the target instance when needed for\ndisambiguation.', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ]),
                DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='relatedEntity', key=['id'], config=True, description='A list of related  entity in relationship with this service', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='Unique identifier of a related entity.', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='href', config=True, description='Reference of the related entity.', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='name', config=True, description='Name of the related entity.', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='role', config=True, mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class Extensible\nname', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='referredType', config=True, description='The actual type of the target instance when needed for\ndisambiguation.', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ]),
                DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='relatedParty', key=['id'], config=True, description='A list of related party references (RelatedParty [*]). A\nrelated party defines party or party role linked to a\nspecific entity', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='unique identifier', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='href', config=True, description='Hyperlink reference', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='name', config=True, description='Name of the related entity.', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='role', config=True, description='Role played by the related party', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class Extensible\nname', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='referredType', config=True, description='The actual type of the target instance when needed for\ndisambiguation.', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ]),
                DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='serviceCharacteristic', key=['id'], config=True, description='A list of characteristics that characterize this service\n(ServiceCharacteristic [*]) ', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='Unique identifier of the characteristic', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='name', config=True, description='Name of the characteristic', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='characteristicRelationship', key=['id'], config=True, min_elements=0, ordered_by='system', children=[
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='Unique identifier of the characteristic', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='relationshipType', config=True, description='The type of relationship', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class entity name', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                    ]),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class entity name', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ]),
                DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='serviceOrderItem', key=['itemId'], config=True, description='A list of service order items related to this service', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='itemId', config=True, description='Identifier of the order item where the service was managed', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='role', config=True, description='role of the service order item for this service', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='serviceOrderHref', config=True, description='Reference of the related entity.', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='serviceOrderId', config=True, description='Unique identifier of a related entity.', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='itemAction', config=True, description='Action of the order item for this service', mandatory=False, type_=DTypeEnum(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='otmf640:OrderItemActionType', description='action to be performed on the product', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'add':0, 'modify':1, 'delete':2, 'noChange':3})),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class entity name', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='referredType', config=True, description='The actual type of the target instance when needed for\ndisambiguation.', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ]),
                DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='serviceRelationship', key=['service'], config=True, description='A list of service relationships (ServiceRelationship [*]).\nDescribes links with other service(s) in the inventory\n(useful for describing relies-on, relies-from between CFS\nfor example).', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='service', config=True, mandatory=False, type_=DTypeLeafref(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='../../../service/id', require_instance=False)),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='relationshipType', config=True, mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='ServiceRelationshipCharacteristic', key=['id'], config=True, min_elements=0, ordered_by='system', children=[
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='Unique identifier of the characteristic', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='name', config=True, description='Name of the characteristic', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='characteristicRelationship', key=['id'], config=True, min_elements=0, ordered_by='system', children=[
                            DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='Unique identifier of the characteristic', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                            DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='relationshipType', config=True, description='The type of relationship', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                            DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                            DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                            DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class entity name', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                        ]),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class entity name', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                    ]),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class entity name', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ]),
                DContainer(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='serviceSpecification', config=True, description='The specification from which this service was instantiated', presence=False, children=[
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='unique identifier', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='href', config=True, description='Hyperlink reference', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='name', config=True, description='Name of the related entity.', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='version', config=True, description='Service specification version', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the\nsuper-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines\nadditional attributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class\nExtensible name', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='referredType', config=True, description='The actual type of the target instance when needed for\ndisambiguation.', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ]),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='state', config=True, description='The life cycle state of the service, such as designed,\nreserved, active, etc...', mandatory=False, type_=DTypeEnum(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='otmf640:ServiceStateType', description='Valid values for the lifecycle state of theservice', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'feasibilityChecked':0, 'designed':1, 'reserved':2, 'inactive':3, 'active':4, 'terminated':5})),
                DList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='supportingResource', key=['id'], config=True, description='A list of supporting resources (SupportingResource [*]).Note:\nonly Service of type RFS can be associated with Resources', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='id', config=True, description='unique identifier', mandatory=True, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='href', config=True, description='Hyperlink reference', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='name', config=True, description='Name of the related entity.', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class Extensible\nname', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                    DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='referredType', config=True, description='The actual type of the target instance when needed for\ndisambiguation.', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ]),
                DLeafList(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='supportingService', config=True, description='A list of supporting services (SupportingService [*]). A\ncollection of services that support this service (bundling,\nlink CFS to RFS)', min_elements=0, ordered_by='system', type_=DTypeLeafref(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='../../service/id', require_instance=False)),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='baseType', config=True, description='When sub-classing, this defines the super-class', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='schemaLocation', config=True, description='A URI to a JSON-Schema file that defines additional\nattributes and relationships', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='inet:uri', description="The uri type represents a Uniform Resource Identifier\n(URI) as defined by STD 66.\n\nObjects using the uri type MUST be in US-ASCII encoding,\nand MUST be normalized as described by RFC 3986 Sections\n6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary\npercent-encoding is removed, and all case-insensitive\ncharacters are set to lowercase except for hexadecimal\ndigits, which are normalized to uppercase as described in\nSection 6.2.2.1.\n\nThe purpose of this normalization is to help provide\nunique URIs.  Note that this normalization is not\nsufficient to provide uniqueness.  Two URIs that are\ntextually distinct after this normalization may still be\nequivalent.\n\nObjects using the uri type may restrict the schemes that\nthey permit.  For example, 'data:' and 'urn:' schemes\nmight not be appropriate.\n\nA zero-length URI is not a valid URI.  This can be used to\nexpress 'URI absent' where required.\n\nIn the value set and its semantics, this type is equivalent\nto the Uri SMIv2 textual convention defined in RFC 5017.", reference='RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\nRFC 3305: Report from the Joint W3C/IETF URI Planning Interest\n          Group: Uniform Resource Identifiers (URIs), URLs,\n          and Uniform Resource Names (URNs): Clarifications\n          and Recommendations\nRFC 5017: MIB Textual Conventions for Uniform Resource\n          Identifiers (URIs)', exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DLeaf(module='orchestron-tmf', namespace='http://orchestron.org/yang/orchestron-tmf', prefix='otmf', name='type', config=True, description='When sub-classing, this defines the sub-class entity name', mandatory=False, type_=DTypeString(module='orchestron-tmf', namespace='orchestron-tmf', prefix='otmf', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
            ])
        ])
    ]),
    DContainer(module='netinfra', namespace='http://example.com/netinfra', prefix='netinfra', name='netinfra', config=True, description='Network infrastructure', presence=False, children=[
        DList(module='netinfra', namespace='http://example.com/netinfra', prefix='netinfra', name='router', key=['name'], config=True, min_elements=0, ordered_by='system', exts=[
                Ext('orchestron', 'transform', arg='sorespo.cfs.Router')
            ], children=[
            DLeaf(module='netinfra', namespace='http://example.com/netinfra', prefix='netinfra', name='name', config=True, mandatory=False, type_=DTypeString(module='netinfra', namespace='netinfra', prefix='netinfra', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
            DLeaf(module='netinfra', namespace='http://example.com/netinfra', prefix='netinfra', name='id', config=True, description='router id', mandatory=True, type_=DTypeInteger(module='netinfra', namespace='netinfra', prefix='netinfra', name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(bigint("0"), bigint("4294967295"))]))),
            DLeaf(module='netinfra', namespace='http://example.com/netinfra', prefix='netinfra', name='type', config=True, mandatory=True, type_=DTypeString(module='netinfra', namespace='netinfra', prefix='netinfra', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
            DLeaf(module='netinfra', namespace='http://example.com/netinfra', prefix='netinfra', name='role', config=True, mandatory=False, type_=DTypeString(module='netinfra', namespace='netinfra', prefix='netinfra', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
            DLeaf(module='netinfra', namespace='http://example.com/netinfra', prefix='netinfra', name='asn', config=True, mandatory=True, type_=DTypeInteger(module='netinfra', namespace='netinfra', prefix='netinfra', name='inet:as-number', description='The as-number type represents autonomous system numbers\nwhich identify an Autonomous System (AS).  An AS is a set\nof routers under a single technical administration, using\nan interior gateway protocol and common metrics to route\npackets within the AS, and using an exterior gateway\nprotocol to route packets to other ASes.  IANA maintains\nthe AS number space and has delegated large parts to the\nregional registries.\n\nAutonomous system numbers were originally limited to 16\nbits.  BGP extensions have enlarged the autonomous system\nnumber space to 32 bits.  This type therefore uses an uint32\nbase type without a range restriction in order to support\na larger autonomous system number space.\n\nIn the value set and its semantics, this type is equivalent\nto the InetAutonomousSystemNumber textual convention of\nthe SMIv2.', reference='RFC 1930: Guidelines for creation, selection, and registration\n          of an Autonomous System (AS)\nRFC 4271: A Border Gateway Protocol 4 (BGP-4)\nRFC 4001: Textual Conventions for Internet Network Addresses\nRFC 6793: BGP Support for Four-Octet Autonomous System (AS)\n          Number Space', exts=[], builtin_type='uint32', default=None, ranges=Ranges([(bigint("0"), bigint("4294967295"))]))),
            DLeaf(module='netinfra', namespace='http://example.com/netinfra', prefix='netinfra', name='mock', config=True, mandatory=False, type_=DTypeEnum(module='netinfra', namespace='netinfra', prefix='netinfra', name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'cisco-ios-xr':0, 'juniper-junos':1})),
            DLeaf(module='netinfra', namespace='http://example.com/netinfra', prefix='netinfra', name='approval-required', config=True, default='false', mandatory=False, type_=DTypeBoolean(module='netinfra', namespace='netinfra', prefix='netinfra', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None))
        ]),
        DList(module='netinfra', namespace='http://example.com/netinfra', prefix='netinfra', name='backbone-link', key=[
'left-router',
'left-interface',
'right-router',
'right-interface'
            ], config=True, min_elements=0, ordered_by='system', exts=[
                Ext('orchestron', 'transform', arg='sorespo.cfs.BBLink')
            ], children=[
            DLeaf(module='netinfra', namespace='http://example.com/netinfra', prefix='netinfra', name='left-router', config=True, mandatory=False, type_=DTypeString(module='netinfra', namespace='netinfra', prefix='netinfra', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
            DLeaf(module='netinfra', namespace='http://example.com/netinfra', prefix='netinfra', name='left-interface', config=True, mandatory=False, type_=DTypeString(module='netinfra', namespace='netinfra', prefix='netinfra', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
            DLeaf(module='netinfra', namespace='http://example.com/netinfra', prefix='netinfra', name='right-router', config=True, mandatory=False, type_=DTypeString(module='netinfra', namespace='netinfra', prefix='netinfra', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
            DLeaf(module='netinfra', namespace='http://example.com/netinfra', prefix='netinfra', name='right-interface', config=True, mandatory=False, type_=DTypeString(module='netinfra', namespace='netinfra', prefix='netinfra', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
            DLeaf(module='netinfra', namespace='http://example.com/netinfra', prefix='netinfra', name='monitor-health', config=True, default='false', mandatory=False, type_=DTypeBoolean(module='netinfra', namespace='netinfra', prefix='netinfra', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None))
        ])
    ]),
    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='l3vpn-svc', config=True, description='Main container for L3VPN service configuration.', presence=False, children=[
        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-profiles', config=True, description='Container for VPN Profiles.', presence=False, children=[
            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='valid-provider-identifiers', config=True, description='Container for Valid Provider Identifies.', presence=False, children=[
                DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='cloud-identifier', key=['id'], config=True, description='List for Cloud Identifiers.', if_feature=['cloud-access'], min_elements=0, ordered_by='system', children=[
                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='id', config=True, description='Identification of cloud service.\nLocal administration meaning.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ]),
                DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='encryption-profile-identifier', key=['id'], config=True, description='List for encryption profile identifiers.', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='id', config=True, description='Identification of the SP encryption profile\nto be used.  Local administration meaning.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ]),
                DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='qos-profile-identifier', key=['id'], config=True, description='List for QoS Profile Identifiers.', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='id', config=True, description='Identification of the QoS Profile to be used.\nLocal administration meaning.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ]),
                DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bfd-profile-identifier', key=['id'], config=True, description='List for BFD Profile identifiers.', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='id', config=True, description='Identification of the SP BFD Profile to be used.\nLocal administration meaning.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                ])
            ])
        ]),
        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-services', config=True, description='Top-level container for the VPN services.', presence=False, children=[
            DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-service', key=['vpn-id'], config=True, description='List of VPN services.', min_elements=0, ordered_by='system', exts=[
                    Ext('orchestron', 'transform', arg='sorespo.cfs.L3VpnVpnService')
                ], children=[
                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-id', config=True, description='VPN identifier.  Local administration meaning.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='svc-id', description='Defines a type of service component identifier.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-name', config=True, description='Name of the customer that actually uses the VPN service.\nIn the case that any intermediary (e.g., Tier-2 provider\nor partner) sells the VPN service to their end user\non behalf of the original service provider (e.g., Tier-1\nprovider), the original service provider may require the\ncustomer name to provide smooth activation/commissioning\nand operation for the service.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-service-topology', config=True, description='VPN service topology.', default='any-to-any', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_vpn_topology], identities=_identities)),
                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='cloud-accesses', config=True, description='Container for cloud access configurations.', if_feature=['cloud-access'], presence=False, children=[
                    DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='cloud-access', key=['cloud-identifier'], config=True, description='Cloud access configuration.', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='cloud-identifier', config=True, description='Identification of cloud service.\nLocal administration meaning.', mandatory=False, type_=DTypeLeafref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='/l3vpn-svc/vpn-profiles/valid-provider-identifiers/cloud-identifier/id', require_instance=False)),
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='permit-any', config=True, description='Allows all sites.', mandatory=False, type_=DTypeEmpty(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='empty', description=None, reference=None, exts=[], builtin_type='empty', default=None)),
                        DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='permit-site', config=True, description='Site ID to be authorized.', min_elements=0, ordered_by='system', type_=DTypeLeafref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='/l3vpn-svc/sites/site/site-id', require_instance=False)),
                        DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='deny-site', config=True, description='Site ID to be denied.', min_elements=0, ordered_by='system', type_=DTypeLeafref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='/l3vpn-svc/sites/site/site-id', require_instance=False)),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-translation', config=True, description='Container for NAT.', presence=False, children=[
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='nat44', config=True, description='IPv4-to-IPv4 translation.', presence=False, children=[
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='enabled', config=True, description='Controls whether or not Network address\ntranslation from IPv4 to IPv4 (NAT44)\n[RFC3022] is required.', default='false', mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='nat44-customer-address', config=True, description='Address to be used for network address\ntranslation from IPv4 to IPv4.  This is\nto be used if the customer is providing\nthe IPv4 address.  If the customer address\nis not set, the model assumes that the\nprovider will allocate the address.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)]))
                            ])
                        ])
                    ])
                ]),
                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast', config=True, description='Multicast global parameters for the VPN service.', if_feature=['multicast'], presence=False, children=[
                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='enabled', config=True, description='Enables multicast.', default='false', mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-tree-flavors', config=True, description='Type of trees used by customer.', presence=False, children=[
                        DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='tree-flavor', config=True, description='Type of tree to be used.', min_elements=0, ordered_by='system', type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_multicast_tree_type], identities=_identities))
                    ]),
                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rp', config=True, description='RP parameters.', presence=False, children=[
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rp-group-mappings', config=True, description='RP-to-group mappings parameters.', presence=False, children=[
                            DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rp-group-mapping', key=['id'], config=True, description='List of RP-to-group mappings.', min_elements=0, ordered_by='system', children=[
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='id', config=True, description='Unique identifier for the mapping.', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint16', description=None, reference=None, exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))]))),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-managed', config=True, description='Parameters for a provider-managed RP.', presence=False, children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='enabled', config=True, description='Set to true if the Rendezvous Point (RP)\nmust be a provider-managed node.  Set to false\nif it is a customer-managed node.', default='false', mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rp-redundancy', config=True, description='If true, a redundancy mechanism for the RP\nis required.', default='false', mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='optimal-traffic-delivery', config=True, description='If true, the SP must ensure that\ntraffic uses an optimal path.  An SP may use\nAnycast RP or RP-tree-to-SPT switchover\narchitectures.', default='false', mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None))
                                ]),
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rp-address', config=True, description='Defines the address of the RP.\nUsed if the RP is customer-managed.', mandatory=True, type_=DTypeUnion(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ip-address', description='The ip-address type represents an IP address and is IP\nversion neutral.  The format of the textual representation\nimplies the IP version.  This type supports scoped addresses\nby allowing zone identifiers in the address format.', reference='RFC 4007: IPv6 Scoped Address Architecture', exts=[], builtin_type='union', default=None, types=[DTypeString(module='ietf-inet-types', namespace='ietf-inet-types', prefix='inet', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)]), DTypeString(module='ietf-inet-types', namespace='ietf-inet-types', prefix='inet', name='inet:ipv6-address', description='The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False)])]), when="../provider-managed/enabled = 'false'"),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='groups', config=True, description='Multicast groups associated with the RP.', presence=False, children=[
                                    DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='group', key=['id'], config=True, description='List of multicast groups.', min_elements=0, ordered_by='system', children=[
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='id', config=True, description='Identifier for the group.', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint16', description=None, reference=None, exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))]))),
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='group-address', config=True, description='A single multicast group address.', mandatory=False, type_=DTypeUnion(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ip-address', description='The ip-address type represents an IP address and is IP\nversion neutral.  The format of the textual representation\nimplies the IP version.  This type supports scoped addresses\nby allowing zone identifiers in the address format.', reference='RFC 4007: IPv6 Scoped Address Architecture', exts=[], builtin_type='union', default=None, types=[DTypeString(module='ietf-inet-types', namespace='ietf-inet-types', prefix='inet', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)]), DTypeString(module='ietf-inet-types', namespace='ietf-inet-types', prefix='inet', name='inet:ipv6-address', description='The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False)])])),
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='group-start', config=True, description='The first multicast group address in\nthe multicast group address range.', mandatory=False, type_=DTypeUnion(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ip-address', description='The ip-address type represents an IP address and is IP\nversion neutral.  The format of the textual representation\nimplies the IP version.  This type supports scoped addresses\nby allowing zone identifiers in the address format.', reference='RFC 4007: IPv6 Scoped Address Architecture', exts=[], builtin_type='union', default=None, types=[DTypeString(module='ietf-inet-types', namespace='ietf-inet-types', prefix='inet', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)]), DTypeString(module='ietf-inet-types', namespace='ietf-inet-types', prefix='inet', name='inet:ipv6-address', description='The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False)])])),
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='group-end', config=True, description='The last multicast group address in\nthe multicast group address range.', mandatory=False, type_=DTypeUnion(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ip-address', description='The ip-address type represents an IP address and is IP\nversion neutral.  The format of the textual representation\nimplies the IP version.  This type supports scoped addresses\nby allowing zone identifiers in the address format.', reference='RFC 4007: IPv6 Scoped Address Architecture', exts=[], builtin_type='union', default=None, types=[DTypeString(module='ietf-inet-types', namespace='ietf-inet-types', prefix='inet', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)]), DTypeString(module='ietf-inet-types', namespace='ietf-inet-types', prefix='inet', name='inet:ipv6-address', description='The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False)])]))
                                    ])
                                ])
                            ])
                        ]),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rp-discovery', config=True, description='RP discovery parameters.', presence=False, children=[
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rp-discovery-type', config=True, description='Type of RP discovery used.', default='static-rp', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_multicast_rp_discovery_type], identities=_identities)),
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bsr-candidates', config=True, description="Container for List of Customer\nBSR candidate's addresses.", presence=False, when="derived-from-or-self(../rp-discovery-type, 'l3vpn-svc:bsr-rp')", children=[
                                DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bsr-candidate-address', config=True, description='Address of BSR candidate.', min_elements=0, ordered_by='system', type_=DTypeUnion(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ip-address', description='The ip-address type represents an IP address and is IP\nversion neutral.  The format of the textual representation\nimplies the IP version.  This type supports scoped addresses\nby allowing zone identifiers in the address format.', reference='RFC 4007: IPv6 Scoped Address Architecture', exts=[], builtin_type='union', default=None, types=[DTypeString(module='ietf-inet-types', namespace='ietf-inet-types', prefix='inet', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)]), DTypeString(module='ietf-inet-types', namespace='ietf-inet-types', prefix='inet', name='inet:ipv6-address', description='The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False)])]))
                            ])
                        ])
                    ])
                ]),
                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='carrierscarrier', config=True, description='The VPN is using CsC, and so MPLS is required.', default='false', if_feature=['carrierscarrier'], mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='extranet-vpns', config=True, description='Container for extranet VPN configuration.', if_feature=['extranet-vpn'], presence=False, children=[
                    DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='extranet-vpn', key=['vpn-id'], config=True, description='List of extranet VPNs or target VPNs the local VPN is\nattached to.', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-id', config=True, description='Identifies the target VPN the local VPN want to access.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='svc-id', description='Defines a type of service component identifier.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='local-sites-role', config=True, description="This describes the role of the\nlocal sites in the target VPN topology.  In the any-to-any VPN\nservice topology, the local sites must have the same role, which\nwill be 'any-to-any-role'.  In the Hub-and-Spoke VPN service\ntopology or the Hub-and-Spoke disjoint VPN service topology,\nthe local sites must have a Hub role or a Spoke role.", default='any-to-any-role', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_site_role], identities=_identities))
                    ])
                ])
            ])
        ]),
        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='sites', config=True, description='Container for sites.', presence=False, children=[
            DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site', key=['site-id'], config=True, description='List of sites.', min_elements=0, ordered_by='system', exts=[
                    Ext('orchestron', 'transform', arg='sorespo.cfs.L3VpnSite')
                ], children=[
                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-id', config=True, description='Identifier of the site.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='svc-id', description='Defines a type of service component identifier.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='requested-site-start', config=True, description='Optional leaf indicating requested date and\ntime when the service at a particular site is\nexpected to start.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='yang:date-and-time', description="The date-and-time type is a profile of the ISO 8601\nstandard for representation of dates and times using the\nGregorian calendar.  The profile is defined by the\ndate-time production in Section 5.6 of RFC 3339.\n\nThe date-and-time type is compatible with the dateTime XML\nschema type with the following notable exceptions:\n\n(a) The date-and-time type does not allow negative years.\n\n(b) The date-and-time time-offset -00:00 indicates an unknown\n    time zone (see RFC 3339) while -00:00 and +00:00 and Z\n    all represent the same time zone in dateTime.\n\n(c) The canonical format (see below) of data-and-time values\n    differs from the canonical format used by the dateTime XML\n    schema type, which requires all times to be in UTC using\n    the time-offset 'Z'.\n\nThis type is not equivalent to the DateAndTime textual\nconvention of the SMIv2 since RFC 3339 uses a different\nseparator between full-date and full-time and provides\nhigher resolution of time-secfrac.\n\nThe canonical format for date-and-time values with a known time\nzone uses a numeric time zone offset that is calculated using\nthe device's configured known offset to UTC time.  A change of\nthe device's offset to UTC time will cause date-and-time values\nto change accordingly.  Such changes might happen periodically\nin case a server follows automatically daylight saving time\n(DST) time zone offset changes.  The canonical format for\ndate-and-time values with an unknown time zone (usually\nreferring to the notion of local time) uses the time-offset\n-00:00.", reference='RFC 3339: Date and Time on the Internet: Timestamps\nRFC 2579: Textual Conventions for SMIv2\nXSD-TYPES: XML Schema Part 2: Datatypes Second Edition', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='\\\\d{{4}}-\\\\d{{2}}-\\\\d{{2}}T\\\\d{{2}}:\\\\d{{2}}:\\\\d{{2}}(\\\\.\\\\d+)?(Z|[\\\\+\\\\-]\\\\d{{2}}:\\\\d{{2}})', pcre='^(\\\\d{{4}}-\\\\d{{2}}-\\\\d{{2}}T\\\\d{{2}}:\\\\d{{2}}:\\\\d{{2}}(\\\\.\\\\d+)?(Z|[\\\\+\\\\-]\\\\d{{2}}:\\\\d{{2}}))$', invert=False)])),
                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='requested-site-stop', config=True, description='Optional leaf indicating requested date and\ntime when the service at a particular site is\nexpected to stop.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='yang:date-and-time', description="The date-and-time type is a profile of the ISO 8601\nstandard for representation of dates and times using the\nGregorian calendar.  The profile is defined by the\ndate-time production in Section 5.6 of RFC 3339.\n\nThe date-and-time type is compatible with the dateTime XML\nschema type with the following notable exceptions:\n\n(a) The date-and-time type does not allow negative years.\n\n(b) The date-and-time time-offset -00:00 indicates an unknown\n    time zone (see RFC 3339) while -00:00 and +00:00 and Z\n    all represent the same time zone in dateTime.\n\n(c) The canonical format (see below) of data-and-time values\n    differs from the canonical format used by the dateTime XML\n    schema type, which requires all times to be in UTC using\n    the time-offset 'Z'.\n\nThis type is not equivalent to the DateAndTime textual\nconvention of the SMIv2 since RFC 3339 uses a different\nseparator between full-date and full-time and provides\nhigher resolution of time-secfrac.\n\nThe canonical format for date-and-time values with a known time\nzone uses a numeric time zone offset that is calculated using\nthe device's configured known offset to UTC time.  A change of\nthe device's offset to UTC time will cause date-and-time values\nto change accordingly.  Such changes might happen periodically\nin case a server follows automatically daylight saving time\n(DST) time zone offset changes.  The canonical format for\ndate-and-time values with an unknown time zone (usually\nreferring to the notion of local time) uses the time-offset\n-00:00.", reference='RFC 3339: Date and Time on the Internet: Timestamps\nRFC 2579: Textual Conventions for SMIv2\nXSD-TYPES: XML Schema Part 2: Datatypes Second Edition', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='\\\\d{{4}}-\\\\d{{2}}-\\\\d{{2}}T\\\\d{{2}}:\\\\d{{2}}:\\\\d{{2}}(\\\\.\\\\d+)?(Z|[\\\\+\\\\-]\\\\d{{2}}:\\\\d{{2}})', pcre='^(\\\\d{{4}}-\\\\d{{2}}-\\\\d{{2}}T\\\\d{{2}}:\\\\d{{2}}:\\\\d{{2}}(\\\\.\\\\d+)?(Z|[\\\\+\\\\-]\\\\d{{2}}:\\\\d{{2}}))$', invert=False)])),
                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='locations', config=True, description='List of locations for the site.', presence=False, children=[
                    DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='location', key=['location-id'], config=True, description='Location of the site.', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='location-id', config=True, description='Identifier for a particular location.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='svc-id', description='Defines a type of service component identifier.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address', config=True, description='Address (number and street) of the site.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='postal-code', config=True, description='Postal code of the site.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='state', config=True, description='State of the site.  This leaf can also be\nused to describe a region for a country that\ndoes not have states.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='city', config=True, description='City of the site.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='country-code', config=True, description='Country of the site.\nExpressed as ISO ALPHA-2 code.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='[A-Z]{{2}}', pcre='^([A-Z]{{2}})$', invert=False)]))
                    ])
                ]),
                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='devices', config=True, description='Device configuration.', presence=False, when="derived-from-or-self(../management/type, 'l3vpn-svc:provider-managed') or derived-from-or-self(../management/type, 'l3vpn-svc:co-managed')", children=[
                    DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='device', key=['device-id'], config=True, description='List of devices requested by customer.', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='device-id', config=True, description='Identifier for the device.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='svc-id', description='Defines a type of service component identifier.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='location', config=True, description='Location of the device.', mandatory=True, type_=DTypeLeafref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='../../../locations/location/location-id', require_instance=False)),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='management', config=True, description='Management configuration.  Applicable only for\nco-managed device.', presence=False, when="derived-from-or-self(../../../management/type,'l3vpn-svc:co-managed')", children=[
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', config=True, description='Address family used for management.', mandatory=False, type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', description='Defines a type for the address family.', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4':0, 'ipv6':1})),
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address', config=True, description='Management address.', mandatory=True, type_=DTypeUnion(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ip-address', description='The ip-address type represents an IP address and is IP\nversion neutral.  The format of the textual representation\nimplies the IP version.  This type supports scoped addresses\nby allowing zone identifiers in the address format.', reference='RFC 4007: IPv6 Scoped Address Architecture', exts=[], builtin_type='union', default=None, types=[DTypeString(module='ietf-inet-types', namespace='ietf-inet-types', prefix='inet', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)]), DTypeString(module='ietf-inet-types', namespace='ietf-inet-types', prefix='inet', name='inet:ipv6-address', description='The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False)])]), when='(../address-family)')
                        ])
                    ])
                ]),
                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-diversity', config=True, description='Diversity constraint type.  All\nsite-network-accesses will inherit\nthe group values defined here.', if_feature=['site-diversity'], presence=False, children=[
                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='groups', config=True, description='Groups the site or site-network-access belongs to.', presence=False, children=[
                        DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='group', key=['group-id'], config=True, description='List of group-ids.', min_elements=0, ordered_by='system', children=[
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='group-id', config=True, description='Group-id the site belongs to.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                        ])
                    ])
                ]),
                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='management', config=True, description='Management configuration.', presence=False, children=[
                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='type', config=True, description='Management type of the connection.', mandatory=True, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_management], identities=_identities))
                ]),
                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-policies', config=True, description='VPN policy.', presence=False, children=[
                    DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-policy', key=['vpn-policy-id'], config=True, description='List of VPN policies.', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-policy-id', config=True, description='Unique identifier for the VPN policy.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='svc-id', description='Defines a type of service component identifier.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='entries', key=['id'], config=True, description='List of entries for export policy.', min_elements=0, ordered_by='system', children=[
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='id', config=True, description='Unique identifier for the policy entry.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='svc-id', description='Defines a type of service component identifier.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='filters', config=True, description='If a more-granular VPN attachment is necessary, filtering can\nbe used.  If used, it permits the splitting of site LANs among\nmultiple VPNs.  The Site LAN can be split based on either LAN\nTag or LAN prefix.  If no filter is used, all the LANs will be\npart of the same VPNs with the same role.', presence=False, children=[
                                DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='filter', key=['type'], config=True, description='List of filters used on the site.  This list can\nbe augmented.', min_elements=0, ordered_by='user', children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='type', config=True, description='Type of VPN Policy filter.', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_vpn_policy_filter_type], identities=_identities)),
                                    DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lan-tag', config=True, description="List of 'lan-tag' items to be matched.  LAN Tag\nis an Internal tag to be used in VPN policies ", if_feature=['lan-tag'], min_elements=0, ordered_by='system', type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]), when="derived-from-or-self(../type, 'l3vpn-svc:lan')"),
                                    DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv4-lan-prefix', config=True, description='List of IPv4 prefixes as LAN Prefixes to be matched.', if_feature=['ipv4'], min_elements=0, ordered_by='system', type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-prefix', description='The ipv4-prefix type represents an IPv4 address prefix.\nThe prefix length is given by the number following the\nslash character and must be less than or equal to 32.\n\nA prefix length value of n corresponds to an IP address\nmask that has n contiguous 1-bits from the most\nsignificant bit (MSB) and all other bits set to 0.\n\nThe canonical format of an IPv4 prefix has all bits of\nthe IPv4 address set to zero that are not part of the\nIPv4 prefix.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2])))$', invert=False)]), when="derived-from-or-self(../type, 'l3vpn-svc:ipv4')"),
                                    DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv6-lan-prefix', config=True, description='List of IPv6 prefixes as LAN prefixes to be matched.', if_feature=['ipv6'], min_elements=0, ordered_by='system', type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-prefix', description='The ipv6-prefix type represents an IPv6 address prefix.\nThe prefix length is given by the number following the\nslash character and must be less than or equal to 128.\n\nA prefix length value of n corresponds to an IP address\nmask that has n contiguous 1-bits from the most\nsignificant bit (MSB) and all other bits set to 0.\n\nThe IPv6 address should have all bits that do not belong\nto the prefix set to zero.\n\nThe canonical format of an IPv6 prefix has all bits of\nthe IPv6 address set to zero that are not part of the\nIPv6 prefix.  Furthermore, the IPv6 address is represented\nas defined in Section 4 of RFC 5952.', reference='RFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{{2}})|(1[0-1][0-9])|(12[0-8])))', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{{2}})|(1[0-1][0-9])|(12[0-8]))))$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(/.+)', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(/.+))$', invert=False)]), when="derived-from-or-self(../type, 'l3vpn-svc:ipv6')")
                                ])
                            ]),
                            DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn', key=['vpn-id'], config=True, description='List of VPNs the LAN is associated with.', min_elements=0, ordered_by='system', children=[
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-id', config=True, description='Reference to an IP VPN.', mandatory=False, type_=DTypeLeafref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='/l3vpn-svc/vpn-services/vpn-service/vpn-id', require_instance=False)),
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-role', config=True, description='Role of the site in the IP VPN.', default='any-to-any-role', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_site_role], identities=_identities))
                            ])
                        ])
                    ])
                ]),
                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor', config=True, description='Defines the way the VPN multiplexing is done, e.g., whether\nthe site belongs to a single VPN site or a multiVPN; or, in the case\nof a multiVPN, whether the logical accesses of the sites belong\nto the same set of VPNs or each logical access maps to\ndifferent VPNs.', default='site-vpn-flavor-single', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_site_vpn_flavor], identities=_identities)),
                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='maximum-routes', config=True, description="Defines 'maximum-routes' for the VRF.", presence=False, children=[
                    DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', key=['af'], config=True, description='List of address families.', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='af', config=True, description='Address family.', mandatory=False, type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', description='Defines a type for the address family.', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4':0, 'ipv6':1})),
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='maximum-routes', config=True, description='Maximum prefixes the VRF can accept\nfor this address family.', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(bigint("0"), bigint("4294967295"))])))
                    ])
                ]),
                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='security', config=True, description='Site-specific security parameters.', presence=False, children=[
                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='authentication', config=True, description='Authentication parameters.', presence=False),
                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='encryption', config=True, description='Encryption parameters.', if_feature=['encryption'], presence=False, children=[
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='enabled', config=True, description='If true, traffic encryption on the connection is required.', default='false', mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='layer', config=True, description='Layer on which encryption is applied.', mandatory=False, type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'layer2':0, 'layer3':1}), when="../enabled = 'true'"),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='encryption-profile', config=True, description='Profile of encryption to be applied.', presence=False, children=[
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='profile-name', config=True, description='Name of the SP profile to be applied.', mandatory=False, type_=DTypeLeafref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='/l3vpn-svc/vpn-profiles/valid-provider-identifiers/encryption-profile-identifier/id', require_instance=False)),
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='algorithm', config=True, description='Encryption algorithm to be used.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='preshared-key', config=True, description='Pre-Shared Key (PSK) coming from the customer.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                        ])
                    ])
                ]),
                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='service', config=True, description='Service parameters on the attachment.', presence=False, children=[
                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='qos', config=True, description='QoS configuration.', if_feature=['qos'], presence=False, children=[
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='qos-classification-policy', config=True, description='Configuration of the traffic classification policy.', presence=False, children=[
                            DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rule', key=['id'], config=True, description='List of marking rules.', min_elements=0, ordered_by='user', children=[
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='id', config=True, description='A description identifying the\nqos-classification-policy rule.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='match-flow', config=True, description='Describes flow-matching criteria.', presence=False, children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='dscp', config=True, description='DSCP value.', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:dscp', description='The dscp type represents a Differentiated Services Code Point\nthat may be used for marking packets in a traffic stream.\nIn the value set and its semantics, this type is equivalent\nto the Dscp textual convention of the SMIv2.', reference='RFC 3289: Management Information Base for the Differentiated\n          Services Architecture\nRFC 2474: Definition of the Differentiated Services Field\n          (DS Field) in the IPv4 and IPv6 Headers\nRFC 2780: IANA Allocation Guidelines For Values In\n          the Internet Protocol and Related Headers', exts=[], builtin_type='uint8', default=None, ranges=Ranges([(bigint("0"), bigint("63"))]))),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='dot1p', config=True, description='802.1p matching.', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint8', description=None, reference=None, exts=[], builtin_type='uint8', default=None, ranges=Ranges([(bigint("0"), bigint("7"))]))),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv4-src-prefix', config=True, description='Match on IPv4 src address.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-prefix', description='The ipv4-prefix type represents an IPv4 address prefix.\nThe prefix length is given by the number following the\nslash character and must be less than or equal to 32.\n\nA prefix length value of n corresponds to an IP address\nmask that has n contiguous 1-bits from the most\nsignificant bit (MSB) and all other bits set to 0.\n\nThe canonical format of an IPv4 prefix has all bits of\nthe IPv4 address set to zero that are not part of the\nIPv4 prefix.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2])))$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv6-src-prefix', config=True, description='Match on IPv6 src address.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-prefix', description='The ipv6-prefix type represents an IPv6 address prefix.\nThe prefix length is given by the number following the\nslash character and must be less than or equal to 128.\n\nA prefix length value of n corresponds to an IP address\nmask that has n contiguous 1-bits from the most\nsignificant bit (MSB) and all other bits set to 0.\n\nThe IPv6 address should have all bits that do not belong\nto the prefix set to zero.\n\nThe canonical format of an IPv6 prefix has all bits of\nthe IPv6 address set to zero that are not part of the\nIPv6 prefix.  Furthermore, the IPv6 address is represented\nas defined in Section 4 of RFC 5952.', reference='RFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{{2}})|(1[0-1][0-9])|(12[0-8])))', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{{2}})|(1[0-1][0-9])|(12[0-8]))))$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(/.+)', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(/.+))$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv4-dst-prefix', config=True, description='Match on IPv4 dst address.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-prefix', description='The ipv4-prefix type represents an IPv4 address prefix.\nThe prefix length is given by the number following the\nslash character and must be less than or equal to 32.\n\nA prefix length value of n corresponds to an IP address\nmask that has n contiguous 1-bits from the most\nsignificant bit (MSB) and all other bits set to 0.\n\nThe canonical format of an IPv4 prefix has all bits of\nthe IPv4 address set to zero that are not part of the\nIPv4 prefix.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2])))$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv6-dst-prefix', config=True, description='Match on IPv6 dst address.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-prefix', description='The ipv6-prefix type represents an IPv6 address prefix.\nThe prefix length is given by the number following the\nslash character and must be less than or equal to 128.\n\nA prefix length value of n corresponds to an IP address\nmask that has n contiguous 1-bits from the most\nsignificant bit (MSB) and all other bits set to 0.\n\nThe IPv6 address should have all bits that do not belong\nto the prefix set to zero.\n\nThe canonical format of an IPv6 prefix has all bits of\nthe IPv6 address set to zero that are not part of the\nIPv6 prefix.  Furthermore, the IPv6 address is represented\nas defined in Section 4 of RFC 5952.', reference='RFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{{2}})|(1[0-1][0-9])|(12[0-8])))', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{{2}})|(1[0-1][0-9])|(12[0-8]))))$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(/.+)', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(/.+))$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='l4-src-port', config=True, description='Match on Layer 4 src port.', mandatory=False, must=[
                                            Must('current() < ../l4-src-port-range/lower-port or current() > ../l4-src-port-range/upper-port', description='If l4-src-port and l4-src-port-range/lower-port and\nupper-port are set at the same time, l4-src-port\nshould not overlap with l4-src-port-range.')
                                        ], type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:port-number', description='The port-number type represents a 16-bit port number of an\nInternet transport-layer protocol such as UDP, TCP, DCCP, or\nSCTP.  Port numbers are assigned by IANA.  A current list of\nall assignments is available from <http://www.iana.org/>.\n\nNote that the port number value zero is reserved by IANA.  In\nsituations where the value zero does not make sense, it can\nbe excluded by subtyping the port-number type.\nIn the value set and its semantics, this type is equivalent\nto the InetPortNumber textual convention of the SMIv2.', reference='RFC  768: User Datagram Protocol\nRFC  793: Transmission Control Protocol\nRFC 4960: Stream Control Transmission Protocol\nRFC 4340: Datagram Congestion Control Protocol (DCCP)\nRFC 4001: Textual Conventions for Internet Network Addresses', exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))]))),
                                    DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='target-sites', config=True, description='Identify a site as traffic destination.', if_feature=['target-sites'], min_elements=0, ordered_by='system', type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='svc-id', description='Defines a type of service component identifier.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='l4-src-port-range', config=True, description='Match on Layer 4 src port range.  When\nonly the lower-port is present, it represents\na single port.  When both the lower-port and\nupper-port are specified, it implies\na range inclusive of both values.', presence=False, children=[
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lower-port', config=True, description='Lower boundary for port.', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:port-number', description='The port-number type represents a 16-bit port number of an\nInternet transport-layer protocol such as UDP, TCP, DCCP, or\nSCTP.  Port numbers are assigned by IANA.  A current list of\nall assignments is available from <http://www.iana.org/>.\n\nNote that the port number value zero is reserved by IANA.  In\nsituations where the value zero does not make sense, it can\nbe excluded by subtyping the port-number type.\nIn the value set and its semantics, this type is equivalent\nto the InetPortNumber textual convention of the SMIv2.', reference='RFC  768: User Datagram Protocol\nRFC  793: Transmission Control Protocol\nRFC 4960: Stream Control Transmission Protocol\nRFC 4340: Datagram Congestion Control Protocol (DCCP)\nRFC 4001: Textual Conventions for Internet Network Addresses', exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))]))),
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='upper-port', config=True, description='Upper boundary for port.', mandatory=False, must=[
                                                Must('. >= ../lower-port', description='Upper boundary for port.  If it\nexists, the upper boundary must be\nhigher than the lower boundary.')
                                            ], type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:port-number', description='The port-number type represents a 16-bit port number of an\nInternet transport-layer protocol such as UDP, TCP, DCCP, or\nSCTP.  Port numbers are assigned by IANA.  A current list of\nall assignments is available from <http://www.iana.org/>.\n\nNote that the port number value zero is reserved by IANA.  In\nsituations where the value zero does not make sense, it can\nbe excluded by subtyping the port-number type.\nIn the value set and its semantics, this type is equivalent\nto the InetPortNumber textual convention of the SMIv2.', reference='RFC  768: User Datagram Protocol\nRFC  793: Transmission Control Protocol\nRFC 4960: Stream Control Transmission Protocol\nRFC 4340: Datagram Congestion Control Protocol (DCCP)\nRFC 4001: Textual Conventions for Internet Network Addresses', exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))])))
                                    ]),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='l4-dst-port', config=True, description='Match on Layer 4 dst port.', mandatory=False, must=[
                                            Must('current() < ../l4-dst-port-range/lower-port or current() > ../l4-dst-port-range/upper-port', description='If l4-dst-port and l4-dst-port-range/lower-port\nand upper-port are set at the same time,\nl4-dst-port should not overlap with\nl4-src-port-range.')
                                        ], type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:port-number', description='The port-number type represents a 16-bit port number of an\nInternet transport-layer protocol such as UDP, TCP, DCCP, or\nSCTP.  Port numbers are assigned by IANA.  A current list of\nall assignments is available from <http://www.iana.org/>.\n\nNote that the port number value zero is reserved by IANA.  In\nsituations where the value zero does not make sense, it can\nbe excluded by subtyping the port-number type.\nIn the value set and its semantics, this type is equivalent\nto the InetPortNumber textual convention of the SMIv2.', reference='RFC  768: User Datagram Protocol\nRFC  793: Transmission Control Protocol\nRFC 4960: Stream Control Transmission Protocol\nRFC 4340: Datagram Congestion Control Protocol (DCCP)\nRFC 4001: Textual Conventions for Internet Network Addresses', exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))]))),
                                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='l4-dst-port-range', config=True, description='Match on Layer 4 dst port range.  When only\nlower-port is present, it represents a single\nport.  When both lower-port and upper-port are\nspecified, it implies a range inclusive of both\nvalues.', presence=False, children=[
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lower-port', config=True, description='Lower boundary for port.', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:port-number', description='The port-number type represents a 16-bit port number of an\nInternet transport-layer protocol such as UDP, TCP, DCCP, or\nSCTP.  Port numbers are assigned by IANA.  A current list of\nall assignments is available from <http://www.iana.org/>.\n\nNote that the port number value zero is reserved by IANA.  In\nsituations where the value zero does not make sense, it can\nbe excluded by subtyping the port-number type.\nIn the value set and its semantics, this type is equivalent\nto the InetPortNumber textual convention of the SMIv2.', reference='RFC  768: User Datagram Protocol\nRFC  793: Transmission Control Protocol\nRFC 4960: Stream Control Transmission Protocol\nRFC 4340: Datagram Congestion Control Protocol (DCCP)\nRFC 4001: Textual Conventions for Internet Network Addresses', exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))]))),
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='upper-port', config=True, description='Upper boundary for port.  If it exists,\nupper boundary must be higher than lower\nboundary.', mandatory=False, must=[
                                                Must('. >= ../lower-port', description='Upper boundary must be\nhigher than lower boundary.')
                                            ], type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:port-number', description='The port-number type represents a 16-bit port number of an\nInternet transport-layer protocol such as UDP, TCP, DCCP, or\nSCTP.  Port numbers are assigned by IANA.  A current list of\nall assignments is available from <http://www.iana.org/>.\n\nNote that the port number value zero is reserved by IANA.  In\nsituations where the value zero does not make sense, it can\nbe excluded by subtyping the port-number type.\nIn the value set and its semantics, this type is equivalent\nto the InetPortNumber textual convention of the SMIv2.', reference='RFC  768: User Datagram Protocol\nRFC  793: Transmission Control Protocol\nRFC 4960: Stream Control Transmission Protocol\nRFC 4340: Datagram Congestion Control Protocol (DCCP)\nRFC 4001: Textual Conventions for Internet Network Addresses', exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))])))
                                    ]),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-field', config=True, description='Match on IPv4 protocol or IPv6 Next Header field.', mandatory=False, type_=DTypeUnion(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='union', description=None, reference=None, exts=[], builtin_type='union', default=None, types=[DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint8', description=None, reference=None, exts=[], builtin_type='uint8', default=None, ranges=Ranges([(bigint("0"), bigint("255"))])), DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_protocol_type], identities=_identities)]))
                                ]),
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='match-application', config=True, description='Defines the application to match.', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_customer_application], identities=_identities)),
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='target-class-id', config=True, description='Identification of the class of service.\nThis identifier is internal to the administration.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                            ])
                        ]),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='qos-profile', config=True, description='QoS profile configuration.', presence=False, children=[
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='profile', config=True, description='QoS profile to be used.', mandatory=False, type_=DTypeLeafref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='/l3vpn-svc/vpn-profiles/valid-provider-identifiers/qos-profile-identifier/id', require_instance=False)),
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='classes', config=True, description='Container for list of classes of services.', if_feature=['qos-custom'], presence=False, children=[
                                DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='class', key=['class-id'], config=True, description='List of classes of services.', min_elements=0, ordered_by='system', children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='class-id', config=True, description='Identification of the class of service.\nThis identifier is internal to the\nadministration.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='direction', config=True, description='The direction to which the QoS profile\nis applied.', default='both', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_qos_profile_direction], identities=_identities)),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rate-limit', config=True, description='To be used if the class must be rate-limited.\nExpressed as percentage of the service\nbandwidth.', mandatory=False, type_=DTypeDecimal64(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='decimal64', description=None, reference=None, exts=[], builtin_type='decimal64', default=None, fraction_digits=5, ranges=Ranges([(Decimal(bigint("0"), bigint("0")), Decimal(bigint("100"), bigint("0")))])), units='percent'),
                                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='latency', config=True, description='Latency constraint on the traffic class.', presence=False, children=[
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='use-lowest-latency', config=True, description='The traffic class should use the path with the\nlowest latency.', mandatory=False, type_=DTypeEmpty(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='empty', description=None, reference=None, exts=[], builtin_type='empty', default=None)),
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='latency-boundary', config=True, description='The traffic class should use a path with a\ndefined maximum latency.', default='400', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint16', description=None, reference=None, exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))])), units='msec')
                                    ]),
                                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='jitter', config=True, description='Jitter constraint on the traffic class.', presence=False, children=[
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='use-lowest-jitter', config=True, description='The traffic class should use the path with the\nlowest jitter.', mandatory=False, type_=DTypeEmpty(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='empty', description=None, reference=None, exts=[], builtin_type='empty', default=None)),
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='latency-boundary', config=True, description='The traffic class should use a path with a\ndefined maximum jitter.', default='40000', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(bigint("0"), bigint("4294967295"))])), units='usec')
                                    ]),
                                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bandwidth', config=True, description='Bandwidth constraint on the traffic class.', presence=False, children=[
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='guaranteed-bw-percent', config=True, description='To be used to define the guaranteed bandwidth\nas a percentage of the available service bandwidth.', mandatory=True, type_=DTypeDecimal64(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='decimal64', description=None, reference=None, exts=[], builtin_type='decimal64', default=None, fraction_digits=5, ranges=Ranges([(Decimal(bigint("0"), bigint("0")), Decimal(bigint("100"), bigint("0")))])), units='percent'),
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='end-to-end', config=True, description='Used if the bandwidth reservation\nmust be done on the MPLS network too.', mandatory=False, type_=DTypeEmpty(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='empty', description=None, reference=None, exts=[], builtin_type='empty', default=None))
                                    ])
                                ])
                            ])
                        ])
                    ]),
                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='carrierscarrier', config=True, description='This container is used when the customer provides\nMPLS-based services.  This is only used in the case\nof CsC (i.e., a customer builds an MPLS service using\nan IP VPN to carry its traffic).', if_feature=['carrierscarrier'], presence=False, children=[
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='signalling-type', config=True, description='MPLS signalling type.', default='bgp', mandatory=False, type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ldp':0, 'bgp':1}))
                    ]),
                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast', config=True, description='Multicast parameters for the site.', if_feature=['multicast'], presence=False, children=[
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-site-type', config=True, description='Type of multicast site.', default='source-receiver', mandatory=False, type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'receiver-only':0, 'source-only':1, 'source-receiver':2})),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-address-family', config=True, description='Defines protocol to carry multicast.', presence=False, children=[
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv4', config=True, description='Enables IPv4 multicast.', default='false', if_feature=['ipv4'], mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv6', config=True, description='Enables IPv6 multicast.', default='false', if_feature=['ipv6'], mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None))
                        ]),
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type', config=True, description='Multicast protocol type to be used with the customer site.', default='both', mandatory=False, type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'host':0, 'router':1, 'both':2}))
                    ])
                ]),
                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='traffic-protection', config=True, description='Fast Reroute service parameters for the site.', if_feature=['fast-reroute'], presence=False, children=[
                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='enabled', config=True, description='Enables traffic protection of access link.', default='false', mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None))
                ]),
                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing-protocols', config=True, description='Defines routing protocols.', presence=False, children=[
                    DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing-protocol', key=['type'], config=True, description='List of routing protocols used on\nthe site.  This list can be augmented.', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='type', config=True, description='Type of routing protocol.', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_routing_protocol_type], identities=_identities)),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ospf', config=True, description='OSPF-specific configuration.', if_feature=['rtg-ospf'], presence=True, when="derived-from-or-self(../type, 'l3vpn-svc:ospf')", children=[
                            DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', config=True, description='If OSPF is used on this site, this node\ncontains a configured value.  This node\ncontains at least one address family\nto be activated.', min_elements=1, ordered_by='system', type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', description='Defines a type for the address family.', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4':0, 'ipv6':1})),
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='area-address', config=True, description='Area address.', mandatory=True, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='yang:dotted-quad', description="An unsigned 32-bit number expressed in the dotted-quad\nnotation, i.e., four octets written as decimal numbers\nand separated with the '.' (full stop) character.", reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))$', invert=False)])),
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='metric', config=True, description='Metric of the PE-CE link.  It is used\nin the routing state calculation and\npath selection.', default='1', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint16', description=None, reference=None, exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))]))),
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='sham-links', config=True, description='List of sham links.', if_feature=[
'rtg-ospf-sham-link'
                                ], presence=False, children=[
                                DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='sham-link', key=['target-site'], config=True, description='Creates a sham link with another site.', min_elements=0, ordered_by='system', children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='target-site', config=True, description='Target site for the sham link connection.\nThe site is referred to by its ID.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='svc-id', description='Defines a type of service component identifier.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='metric', config=True, description='Metric of the sham link.  It is used in\nthe routing state calculation and path\nselection.  The default value is set\nto 1.', default='1', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint16', description=None, reference=None, exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))])))
                                ])
                            ])
                        ]),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bgp', config=True, description='BGP-specific configuration.', if_feature=['rtg-bgp'], presence=True, when="derived-from-or-self(../type, 'l3vpn-svc:bgp')", children=[
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='autonomous-system', config=True, description='Customer AS number in case the customer\nrequests BGP routing.', mandatory=True, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(bigint("0"), bigint("4294967295"))]))),
                            DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', config=True, description='If BGP is used on this site, this node\ncontains a configured value.  This node\ncontains at least one address family\nto be activated.', min_elements=1, ordered_by='system', type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', description='Defines a type for the address family.', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4':0, 'ipv6':1}))
                        ]),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='static', config=True, description='Configuration specific to static routing.', presence=True, when="derived-from-or-self(../type, 'l3vpn-svc:static')", children=[
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='cascaded-lan-prefixes', config=True, description='LAN prefixes from the customer.', presence=False, children=[
                                DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv4-lan-prefixes', key=[
'lan',
'next-hop'
                                    ], config=True, description='List of LAN prefixes for the site.', if_feature=['ipv4'], min_elements=0, ordered_by='system', children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lan', config=True, description='LAN prefixes.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-prefix', description='The ipv4-prefix type represents an IPv4 address prefix.\nThe prefix length is given by the number following the\nslash character and must be less than or equal to 32.\n\nA prefix length value of n corresponds to an IP address\nmask that has n contiguous 1-bits from the most\nsignificant bit (MSB) and all other bits set to 0.\n\nThe canonical format of an IPv4 prefix has all bits of\nthe IPv4 address set to zero that are not part of the\nIPv4 prefix.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2])))$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='next-hop', config=True, description='Next-hop address to use on the customer side.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lan-tag', config=True, description='Internal tag to be used in VPN policies.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                                ]),
                                DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv6-lan-prefixes', key=[
'lan',
'next-hop'
                                    ], config=True, description='List of LAN prefixes for the site.', if_feature=['ipv6'], min_elements=0, ordered_by='system', children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lan', config=True, description='LAN prefixes.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-prefix', description='The ipv6-prefix type represents an IPv6 address prefix.\nThe prefix length is given by the number following the\nslash character and must be less than or equal to 128.\n\nA prefix length value of n corresponds to an IP address\nmask that has n contiguous 1-bits from the most\nsignificant bit (MSB) and all other bits set to 0.\n\nThe IPv6 address should have all bits that do not belong\nto the prefix set to zero.\n\nThe canonical format of an IPv6 prefix has all bits of\nthe IPv6 address set to zero that are not part of the\nIPv6 prefix.  Furthermore, the IPv6 address is represented\nas defined in Section 4 of RFC 5952.', reference='RFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{{2}})|(1[0-1][0-9])|(12[0-8])))', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{{2}})|(1[0-1][0-9])|(12[0-8]))))$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(/.+)', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(/.+))$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='next-hop', config=True, description='Next-hop address to use on the customer side.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-address', description='The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lan-tag', config=True, description='Internal tag to be used in VPN policies.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                                ])
                            ])
                        ]),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rip', config=True, description='Configuration specific to RIP routing.', if_feature=['rtg-rip'], presence=True, when="derived-from-or-self(../type, 'l3vpn-svc:rip')", children=[
                            DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', config=True, description='If RIP is used on this site, this node\ncontains a configured value.  This node\ncontains at least one address family\nto be activated.', min_elements=1, ordered_by='system', type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', description='Defines a type for the address family.', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4':0, 'ipv6':1}))
                        ]),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vrrp', config=True, description='Configuration specific to VRRP routing.', if_feature=['rtg-vrrp'], presence=True, when="derived-from-or-self(../type, 'l3vpn-svc:vrrp')", children=[
                            DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', config=True, description='If VRRP is used on this site, this node\ncontains a configured value.  This node contains\nat least one address family to be activated.', min_elements=1, ordered_by='system', type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', description='Defines a type for the address family.', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4':0, 'ipv6':1}))
                        ])
                    ])
                ]),
                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-network-accesses', config=True, description='List of accesses for a site.', presence=False, children=[
                    DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-network-access', key=[
'site-network-access-id'
                        ], config=True, description='List of accesses for a site.', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-network-access-id', config=True, description='Identifier for the access.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='svc-id', description='Defines a type of service component identifier.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-network-access-type', config=True, description='Describes the type of connection, e.g.,\npoint-to-point or multipoint.', default='point-to-point', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_site_network_access_type], identities=_identities)),
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='location-reference', config=True, description='Location of the site-network-access.', mandatory=False, type_=DTypeLeafref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='../../../locations/location/location-id', require_instance=False)),
                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='device-reference', config=True, description='Identifier of CE to use.', mandatory=False, type_=DTypeLeafref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='../../../devices/device/device-id', require_instance=False)),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='access-diversity', config=True, description='Diversity parameters.', if_feature=['site-diversity'], presence=False, children=[
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='groups', config=True, description='Groups the site or site-network-access belongs to.', presence=False, children=[
                                DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='group', key=['group-id'], config=True, description='List of group-ids.', min_elements=0, ordered_by='system', children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='group-id', config=True, description='Group-id the site belongs to.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                                ])
                            ]),
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='constraints', config=True, description='Placement constraints for this site network access.', presence=False, children=[
                                DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='constraint', key=['constraint-type'], config=True, description='List of constraints.', min_elements=0, ordered_by='system', children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='constraint-type', config=True, description='Diversity constraint type.', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_placement_diversity], identities=_identities)),
                                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='target', config=True, description='The constraint will be applied against a\nSpecific target, and the target can be a list\nof group-ids,all other site network accesses of\nthis site, or all other groups managed by the\ncustomer.', presence=False, children=[
                                        DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='group', key=['group-id'], config=True, description='List of group-ids associated with one specific\nconstraint for this site network access level.', min_elements=0, ordered_by='system', children=[
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='group-id', config=True, description='The constraint will be applied against\nthis particular group-id for this site\nnetwork access level.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                                        ]),
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='all-other-accesses', config=True, description='The constraint will be applied against\nall other site network accesses of this site.', mandatory=False, type_=DTypeEmpty(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='empty', description=None, reference=None, exts=[], builtin_type='empty', default=None)),
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='all-other-groups', config=True, description='The constraint will be applied against\nall other groups managed by the customer.', mandatory=False, type_=DTypeEmpty(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='empty', description=None, reference=None, exts=[], builtin_type='empty', default=None))
                                    ])
                                ])
                            ])
                        ]),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bearer', config=True, description='Bearer-specific parameters.\nTo be augmented.', presence=False, children=[
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='requested-type', config=True, description='Container for requested-type.', if_feature=['requested-type'], presence=False, children=[
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='requested-type', config=True, description='Type of requested bearer: Ethernet, DSL,\nWireless, etc. Operator specific.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='strict', config=True, description='Defines whether requested-type is a preference\nor a strict requirement.', default='false', mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None))
                            ]),
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='always-on', config=True, description='Request for an always-on access type.\nFor example, this could mean no dial access type.', default='true', if_feature=['always-on'], mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bearer-reference', config=True, description='This is an internal reference for the SP.', if_feature=['bearer-reference'], mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                        ]),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ip-connection', config=True, description='Defines connection parameters.', presence=False, children=[
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv4', config=True, description='IPv4-specific parameters.', if_feature=['ipv4'], presence=False, children=[
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-allocation-type', config=True, description='Defines how addresses are allocated.\nIf there is no value for the address\nallocation type, then IPv4 is not enabled.', mandatory=False, must=[
                                        Must("not(derived-from-or-self(current(), 'l3vpn-svc:slaac') or derived-from-or-self(current(), 'l3vpn-svc:provider-dhcp-slaac'))", error_message='SLAAC is only applicable to IPv6')
                                    ], type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_address_allocation_type], identities=_identities)),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-dhcp', config=True, description='DHCP allocated addresses related parameters.', presence=False, when="derived-from-or-self(../address-allocation-type, 'l3vpn-svc:provider-dhcp')", children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-address', config=True, description='Address of provider side.  If provider-address is not\nspecified, then prefix length should not be specified\neither.  It also implies provider-dhcp allocation is\nnot enabled.  If provider-address is specified, then\nthe prefix length may or may not be specified.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='prefix-length', config=True, description='Subnet prefix length expressed in bits.\nIf not specified, or specified as zero,\nthis means the customer leaves the actual\nprefix length value to the provider.', mandatory=False, must=[
                                            Must('(../provider-address)', description='If the prefix length is specified, provider-address\nmust also be specified.', error_message='If the prefix length is specified, provider-address\nmust also be specified.')
                                        ], type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint8', description=None, reference=None, exts=[], builtin_type='uint8', default=None, ranges=Ranges([(bigint("0"), bigint("32"))]))),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='number-of-dynamic-address', config=True, description='Describes the number of IP addresses\nthe customer requires.', default='1', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint16', description=None, reference=None, exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))]))),
                                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-addresses', config=True, description='Container for customer addresses is allocated by DHCP.', presence=False, children=[
                                        DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-group', key=['group-id'], config=True, description='Describes IP addresses allocated by DHCP.\nWhen only start-address or only end-address\nis present, it represents a single address.\nWhen both start-address and end-address are\nspecified, it implies a range inclusive of both\naddresses.  If no address is specified, it implies\ncustomer addresses group is not supported.', min_elements=0, ordered_by='system', children=[
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='group-id', config=True, description='Group-id for the address range from\nstart-address to end-address.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='start-address', config=True, description='First address.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)])),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='end-address', config=True, description='Last address.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)]))
                                        ])
                                    ])
                                ]),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='dhcp-relay', config=True, description='DHCP relay provided by operator.', presence=False, when="derived-from-or-self(../address-allocation-type, 'l3vpn-svc:provider-dhcp-relay')", children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-address', config=True, description='Address of provider side.  If provider-address is not\nspecified, then prefix length should not be specified\neither.  It also implies provider-dhcp allocation is\nnot enabled.  If provider-address is specified, then\nprefix length may or may not be specified.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='prefix-length', config=True, description='Subnet prefix length expressed in bits.  If not\nspecified, or specified as zero, this means the\ncustomer leaves the actual prefix length value\nto the provider.', mandatory=False, must=[
                                            Must('(../provider-address)', description='If prefix length is specified, provider-address\nmust also be specified.', error_message='If prefix length is specified, provider-address\nmust also be specified.')
                                        ], type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint8', description=None, reference=None, exts=[], builtin_type='uint8', default=None, ranges=Ranges([(bigint("0"), bigint("32"))]))),
                                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-dhcp-servers', config=True, description='Container for list of customer DHCP servers.', presence=False, children=[
                                        DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='server-ip-address', config=True, description='IP address of customer DHCP server.', min_elements=0, ordered_by='system', type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)]))
                                    ])
                                ]),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='addresses', config=True, description='Describes IPv4 addresses used.', presence=False, when="derived-from-or-self(../address-allocation-type, 'l3vpn-svc:static-address')", children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-address', config=True, description='IPv4 Address List of the provider side.\nWhen the protocol allocation type is static,\nthe provider address must be configured.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-address', config=True, description='IPv4 Address of customer side.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='prefix-length', config=True, description='Subnet prefix length expressed in bits.\nIt is applied to both provider-address\nand customer-address.', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint8', description=None, reference=None, exts=[], builtin_type='uint8', default=None, ranges=Ranges([(bigint("0"), bigint("32"))])))
                                ])
                            ]),
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv6', config=True, description='IPv6-specific parameters.', if_feature=['ipv6'], presence=False, children=[
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-allocation-type', config=True, description='Defines how addresses are allocated.\nIf there is no value for the address\nallocation type, then IPv6 is\nnot enabled.', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_address_allocation_type], identities=_identities)),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-dhcp', config=True, description='DHCP allocated addresses related parameters.', presence=False, when="derived-from-or-self(../address-allocation-type, 'l3vpn-svc:provider-dhcp') or derived-from-or-self(../address-allocation-type, 'l3vpn-svc:provider-dhcp-slaac')", children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-address', config=True, description='Address of the provider side.  If provider-address\nis not specified, then prefix length should not be\nspecified either.  It also implies provider-dhcp\nallocation is not enabled.  If provider-address is\nspecified, then prefix length may or may\nnot be specified.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-address', description='The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='prefix-length', config=True, description='Subnet prefix length expressed in bits.  If not\nspecified, or specified as zero, this means the\ncustomer leaves the actual prefix length value\nto the provider.', mandatory=False, must=[
                                            Must('(../provider-address)', description='If prefix length is specified, provider-address\nmust also be specified.', error_message='If prefix length is specified, provider-address\nmust also be specified.')
                                        ], type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint8', description=None, reference=None, exts=[], builtin_type='uint8', default=None, ranges=Ranges([(bigint("0"), bigint("128"))]))),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='number-of-dynamic-address', config=True, description='Describes the number of IP addresses the customer\nrequires.', default='1', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint16', description=None, reference=None, exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))]))),
                                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-addresses', config=True, description='Container for customer addresses allocated by DHCP.', presence=False, children=[
                                        DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-group', key=['group-id'], config=True, description='Describes IP addresses allocated by DHCP.  When only\nstart-address or only end-address is present, it\nrepresents a single address.  When both start-address\nand end-address are specified, it implies a range\ninclusive of both addresses.  If no address is\nspecified, it implies customer addresses group is\nnot supported.', min_elements=0, ordered_by='system', children=[
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='group-id', config=True, description='Group-id for the address range from\nstart-address to end-address.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='start-address', config=True, description='First address.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-address', description='The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False)])),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='end-address', config=True, description='Last address.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-address', description='The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False)]))
                                        ])
                                    ])
                                ]),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='dhcp-relay', config=True, description='DHCP relay provided by operator.', presence=False, when="derived-from-or-self(../address-allocation-type, 'l3vpn-svc:provider-dhcp-relay')", children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-address', config=True, description='Address of the provider side.  If provider-address is\nnot specified, then prefix length should not be\nspecified either.  It also implies provider-dhcp\nallocation is not enabled.  If provider address\nis specified, then prefix length may or may\nnot be specified.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-address', description='The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='prefix-length', config=True, description='Subnet prefix length expressed in bits.  If not\nspecified, or specified as zero, this means the\ncustomer leaves the actual prefix length value\nto the provider.', mandatory=False, must=[
                                            Must('(../provider-address)', description='If prefix length is specified, provider-address\nmust also be specified.', error_message='If prefix length is specified, provider-address\nmust also be specified.')
                                        ], type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint8', description=None, reference=None, exts=[], builtin_type='uint8', default=None, ranges=Ranges([(bigint("0"), bigint("128"))]))),
                                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-dhcp-servers', config=True, description='Container for list of customer DHCP servers.', presence=False, children=[
                                        DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='server-ip-address', config=True, description='This node contains the IP address of\nthe customer DHCP server.  If the DHCP relay\nfunction is implemented by the\nprovider, this node contains the\nconfigured value.', min_elements=0, ordered_by='system', type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-address', description='The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False)]))
                                    ])
                                ]),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='addresses', config=True, description='Describes IPv6 addresses used.', presence=False, when="derived-from-or-self(../address-allocation-type, 'l3vpn-svc:static-address')", children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-address', config=True, description='IPv6 Address of the provider side.  When the protocol\nallocation type is static, the provider address\nmust be configured.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-address', description='The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-address', config=True, description='The IPv6 Address of the customer side.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-address', description='The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='prefix-length', config=True, description='Subnet prefix length expressed in bits.\nIt is applied to both provider-address and\ncustomer-address.', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint8', description=None, reference=None, exts=[], builtin_type='uint8', default=None, ranges=Ranges([(bigint("0"), bigint("128"))])))
                                ])
                            ]),
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='oam', config=True, description="Defines the Operations, Administration, and Maintenance (OAM)\nmechanisms used on the connection.  BFD is set as a fault\ndetection mechanism, but the 'oam' container can easily\nbe augmented by other mechanisms", presence=False, children=[
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bfd', config=True, description='Container for BFD.', if_feature=['bfd'], presence=False, children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='enabled', config=True, description='If true, BFD activation is required.', default='false', mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='fixed-value', config=True, description="Expected BFD holdtime expressed in msec.  The customer\nmay impose some fixed values for the holdtime period\nif the provider allows the customer use this function.\nIf the provider doesn't allow the customer to use this\nfunction, the fixed-value will not be set.", mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(bigint("0"), bigint("4294967295"))])), units='msec'),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='profile-name', config=True, description='Well-known SP profile name.  The provider can propose\nsome profiles to the customer, depending on the service\nlevel the customer wants to achieve.  Profile names\nmust be communicated to the customer.', mandatory=False, type_=DTypeLeafref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='/l3vpn-svc/vpn-profiles/valid-provider-identifiers/bfd-profile-identifier/id', require_instance=False))
                                ])
                            ])
                        ]),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='security', config=True, description='Site-specific security parameters.', presence=False, children=[
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='authentication', config=True, description='Authentication parameters.', presence=False),
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='encryption', config=True, description='Encryption parameters.', if_feature=['encryption'], presence=False, children=[
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='enabled', config=True, description='If true, traffic encryption on the connection is required.', default='false', mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='layer', config=True, description='Layer on which encryption is applied.', mandatory=False, type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'layer2':0, 'layer3':1}), when="../enabled = 'true'"),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='encryption-profile', config=True, description='Profile of encryption to be applied.', presence=False, children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='profile-name', config=True, description='Name of the SP profile to be applied.', mandatory=False, type_=DTypeLeafref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='/l3vpn-svc/vpn-profiles/valid-provider-identifiers/encryption-profile-identifier/id', require_instance=False)),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='algorithm', config=True, description='Encryption algorithm to be used.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='preshared-key', config=True, description='Pre-Shared Key (PSK) coming from the customer.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                                ])
                            ])
                        ]),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='service', config=True, description='Service parameters on the attachment.', presence=False, children=[
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='svc-input-bandwidth', config=True, description="From the customer site's perspective, the service\ninput bandwidth of the connection or download\nbandwidth from the SP to the site.", mandatory=True, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint64', description=None, reference=None, exts=[], builtin_type='uint64', default=None, ranges=Ranges([(bigint("0"), bigint("18446744073709551615"))])), units='bps'),
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='svc-output-bandwidth', config=True, description="From the customer site's perspective, the service\noutput bandwidth of the connection or upload\nbandwidth from the site to the SP.", mandatory=True, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint64', description=None, reference=None, exts=[], builtin_type='uint64', default=None, ranges=Ranges([(bigint("0"), bigint("18446744073709551615"))])), units='bps'),
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='svc-mtu', config=True, description="MTU at service level.  If the service is IP,\nit refers to the IP MTU.  If CsC is enabled,\nthe requested 'svc-mtu' leaf will refer to the\nMPLS MTU and not to the IP MTU.", mandatory=True, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint16', description=None, reference=None, exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))])), units='bytes'),
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='qos', config=True, description='QoS configuration.', if_feature=['qos'], presence=False, children=[
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='qos-classification-policy', config=True, description='Configuration of the traffic classification policy.', presence=False, children=[
                                    DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rule', key=['id'], config=True, description='List of marking rules.', min_elements=0, ordered_by='user', children=[
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='id', config=True, description='A description identifying the\nqos-classification-policy rule.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='match-flow', config=True, description='Describes flow-matching criteria.', presence=False, children=[
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='dscp', config=True, description='DSCP value.', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:dscp', description='The dscp type represents a Differentiated Services Code Point\nthat may be used for marking packets in a traffic stream.\nIn the value set and its semantics, this type is equivalent\nto the Dscp textual convention of the SMIv2.', reference='RFC 3289: Management Information Base for the Differentiated\n          Services Architecture\nRFC 2474: Definition of the Differentiated Services Field\n          (DS Field) in the IPv4 and IPv6 Headers\nRFC 2780: IANA Allocation Guidelines For Values In\n          the Internet Protocol and Related Headers', exts=[], builtin_type='uint8', default=None, ranges=Ranges([(bigint("0"), bigint("63"))]))),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='dot1p', config=True, description='802.1p matching.', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint8', description=None, reference=None, exts=[], builtin_type='uint8', default=None, ranges=Ranges([(bigint("0"), bigint("7"))]))),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv4-src-prefix', config=True, description='Match on IPv4 src address.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-prefix', description='The ipv4-prefix type represents an IPv4 address prefix.\nThe prefix length is given by the number following the\nslash character and must be less than or equal to 32.\n\nA prefix length value of n corresponds to an IP address\nmask that has n contiguous 1-bits from the most\nsignificant bit (MSB) and all other bits set to 0.\n\nThe canonical format of an IPv4 prefix has all bits of\nthe IPv4 address set to zero that are not part of the\nIPv4 prefix.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2])))$', invert=False)])),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv6-src-prefix', config=True, description='Match on IPv6 src address.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-prefix', description='The ipv6-prefix type represents an IPv6 address prefix.\nThe prefix length is given by the number following the\nslash character and must be less than or equal to 128.\n\nA prefix length value of n corresponds to an IP address\nmask that has n contiguous 1-bits from the most\nsignificant bit (MSB) and all other bits set to 0.\n\nThe IPv6 address should have all bits that do not belong\nto the prefix set to zero.\n\nThe canonical format of an IPv6 prefix has all bits of\nthe IPv6 address set to zero that are not part of the\nIPv6 prefix.  Furthermore, the IPv6 address is represented\nas defined in Section 4 of RFC 5952.', reference='RFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{{2}})|(1[0-1][0-9])|(12[0-8])))', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{{2}})|(1[0-1][0-9])|(12[0-8]))))$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(/.+)', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(/.+))$', invert=False)])),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv4-dst-prefix', config=True, description='Match on IPv4 dst address.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-prefix', description='The ipv4-prefix type represents an IPv4 address prefix.\nThe prefix length is given by the number following the\nslash character and must be less than or equal to 32.\n\nA prefix length value of n corresponds to an IP address\nmask that has n contiguous 1-bits from the most\nsignificant bit (MSB) and all other bits set to 0.\n\nThe canonical format of an IPv4 prefix has all bits of\nthe IPv4 address set to zero that are not part of the\nIPv4 prefix.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2])))$', invert=False)])),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv6-dst-prefix', config=True, description='Match on IPv6 dst address.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-prefix', description='The ipv6-prefix type represents an IPv6 address prefix.\nThe prefix length is given by the number following the\nslash character and must be less than or equal to 128.\n\nA prefix length value of n corresponds to an IP address\nmask that has n contiguous 1-bits from the most\nsignificant bit (MSB) and all other bits set to 0.\n\nThe IPv6 address should have all bits that do not belong\nto the prefix set to zero.\n\nThe canonical format of an IPv6 prefix has all bits of\nthe IPv6 address set to zero that are not part of the\nIPv6 prefix.  Furthermore, the IPv6 address is represented\nas defined in Section 4 of RFC 5952.', reference='RFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{{2}})|(1[0-1][0-9])|(12[0-8])))', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{{2}})|(1[0-1][0-9])|(12[0-8]))))$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(/.+)', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(/.+))$', invert=False)])),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='l4-src-port', config=True, description='Match on Layer 4 src port.', mandatory=False, must=[
                                                    Must('current() < ../l4-src-port-range/lower-port or current() > ../l4-src-port-range/upper-port', description='If l4-src-port and l4-src-port-range/lower-port and\nupper-port are set at the same time, l4-src-port\nshould not overlap with l4-src-port-range.')
                                                ], type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:port-number', description='The port-number type represents a 16-bit port number of an\nInternet transport-layer protocol such as UDP, TCP, DCCP, or\nSCTP.  Port numbers are assigned by IANA.  A current list of\nall assignments is available from <http://www.iana.org/>.\n\nNote that the port number value zero is reserved by IANA.  In\nsituations where the value zero does not make sense, it can\nbe excluded by subtyping the port-number type.\nIn the value set and its semantics, this type is equivalent\nto the InetPortNumber textual convention of the SMIv2.', reference='RFC  768: User Datagram Protocol\nRFC  793: Transmission Control Protocol\nRFC 4960: Stream Control Transmission Protocol\nRFC 4340: Datagram Congestion Control Protocol (DCCP)\nRFC 4001: Textual Conventions for Internet Network Addresses', exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))]))),
                                            DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='target-sites', config=True, description='Identify a site as traffic destination.', if_feature=['target-sites'], min_elements=0, ordered_by='system', type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='svc-id', description='Defines a type of service component identifier.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='l4-src-port-range', config=True, description='Match on Layer 4 src port range.  When\nonly the lower-port is present, it represents\na single port.  When both the lower-port and\nupper-port are specified, it implies\na range inclusive of both values.', presence=False, children=[
                                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lower-port', config=True, description='Lower boundary for port.', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:port-number', description='The port-number type represents a 16-bit port number of an\nInternet transport-layer protocol such as UDP, TCP, DCCP, or\nSCTP.  Port numbers are assigned by IANA.  A current list of\nall assignments is available from <http://www.iana.org/>.\n\nNote that the port number value zero is reserved by IANA.  In\nsituations where the value zero does not make sense, it can\nbe excluded by subtyping the port-number type.\nIn the value set and its semantics, this type is equivalent\nto the InetPortNumber textual convention of the SMIv2.', reference='RFC  768: User Datagram Protocol\nRFC  793: Transmission Control Protocol\nRFC 4960: Stream Control Transmission Protocol\nRFC 4340: Datagram Congestion Control Protocol (DCCP)\nRFC 4001: Textual Conventions for Internet Network Addresses', exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))]))),
                                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='upper-port', config=True, description='Upper boundary for port.', mandatory=False, must=[
                                                        Must('. >= ../lower-port', description='Upper boundary for port.  If it\nexists, the upper boundary must be\nhigher than the lower boundary.')
                                                    ], type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:port-number', description='The port-number type represents a 16-bit port number of an\nInternet transport-layer protocol such as UDP, TCP, DCCP, or\nSCTP.  Port numbers are assigned by IANA.  A current list of\nall assignments is available from <http://www.iana.org/>.\n\nNote that the port number value zero is reserved by IANA.  In\nsituations where the value zero does not make sense, it can\nbe excluded by subtyping the port-number type.\nIn the value set and its semantics, this type is equivalent\nto the InetPortNumber textual convention of the SMIv2.', reference='RFC  768: User Datagram Protocol\nRFC  793: Transmission Control Protocol\nRFC 4960: Stream Control Transmission Protocol\nRFC 4340: Datagram Congestion Control Protocol (DCCP)\nRFC 4001: Textual Conventions for Internet Network Addresses', exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))])))
                                            ]),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='l4-dst-port', config=True, description='Match on Layer 4 dst port.', mandatory=False, must=[
                                                    Must('current() < ../l4-dst-port-range/lower-port or current() > ../l4-dst-port-range/upper-port', description='If l4-dst-port and l4-dst-port-range/lower-port\nand upper-port are set at the same time,\nl4-dst-port should not overlap with\nl4-src-port-range.')
                                                ], type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:port-number', description='The port-number type represents a 16-bit port number of an\nInternet transport-layer protocol such as UDP, TCP, DCCP, or\nSCTP.  Port numbers are assigned by IANA.  A current list of\nall assignments is available from <http://www.iana.org/>.\n\nNote that the port number value zero is reserved by IANA.  In\nsituations where the value zero does not make sense, it can\nbe excluded by subtyping the port-number type.\nIn the value set and its semantics, this type is equivalent\nto the InetPortNumber textual convention of the SMIv2.', reference='RFC  768: User Datagram Protocol\nRFC  793: Transmission Control Protocol\nRFC 4960: Stream Control Transmission Protocol\nRFC 4340: Datagram Congestion Control Protocol (DCCP)\nRFC 4001: Textual Conventions for Internet Network Addresses', exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))]))),
                                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='l4-dst-port-range', config=True, description='Match on Layer 4 dst port range.  When only\nlower-port is present, it represents a single\nport.  When both lower-port and upper-port are\nspecified, it implies a range inclusive of both\nvalues.', presence=False, children=[
                                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lower-port', config=True, description='Lower boundary for port.', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:port-number', description='The port-number type represents a 16-bit port number of an\nInternet transport-layer protocol such as UDP, TCP, DCCP, or\nSCTP.  Port numbers are assigned by IANA.  A current list of\nall assignments is available from <http://www.iana.org/>.\n\nNote that the port number value zero is reserved by IANA.  In\nsituations where the value zero does not make sense, it can\nbe excluded by subtyping the port-number type.\nIn the value set and its semantics, this type is equivalent\nto the InetPortNumber textual convention of the SMIv2.', reference='RFC  768: User Datagram Protocol\nRFC  793: Transmission Control Protocol\nRFC 4960: Stream Control Transmission Protocol\nRFC 4340: Datagram Congestion Control Protocol (DCCP)\nRFC 4001: Textual Conventions for Internet Network Addresses', exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))]))),
                                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='upper-port', config=True, description='Upper boundary for port.  If it exists,\nupper boundary must be higher than lower\nboundary.', mandatory=False, must=[
                                                        Must('. >= ../lower-port', description='Upper boundary must be\nhigher than lower boundary.')
                                                    ], type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:port-number', description='The port-number type represents a 16-bit port number of an\nInternet transport-layer protocol such as UDP, TCP, DCCP, or\nSCTP.  Port numbers are assigned by IANA.  A current list of\nall assignments is available from <http://www.iana.org/>.\n\nNote that the port number value zero is reserved by IANA.  In\nsituations where the value zero does not make sense, it can\nbe excluded by subtyping the port-number type.\nIn the value set and its semantics, this type is equivalent\nto the InetPortNumber textual convention of the SMIv2.', reference='RFC  768: User Datagram Protocol\nRFC  793: Transmission Control Protocol\nRFC 4960: Stream Control Transmission Protocol\nRFC 4340: Datagram Congestion Control Protocol (DCCP)\nRFC 4001: Textual Conventions for Internet Network Addresses', exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))])))
                                            ]),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-field', config=True, description='Match on IPv4 protocol or IPv6 Next Header field.', mandatory=False, type_=DTypeUnion(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='union', description=None, reference=None, exts=[], builtin_type='union', default=None, types=[DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint8', description=None, reference=None, exts=[], builtin_type='uint8', default=None, ranges=Ranges([(bigint("0"), bigint("255"))])), DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_protocol_type], identities=_identities)]))
                                        ]),
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='match-application', config=True, description='Defines the application to match.', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_customer_application], identities=_identities)),
                                        DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='target-class-id', config=True, description='Identification of the class of service.\nThis identifier is internal to the administration.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                                    ])
                                ]),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='qos-profile', config=True, description='QoS profile configuration.', presence=False, children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='profile', config=True, description='QoS profile to be used.', mandatory=False, type_=DTypeLeafref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='/l3vpn-svc/vpn-profiles/valid-provider-identifiers/qos-profile-identifier/id', require_instance=False)),
                                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='classes', config=True, description='Container for list of classes of services.', if_feature=['qos-custom'], presence=False, children=[
                                        DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='class', key=['class-id'], config=True, description='List of classes of services.', min_elements=0, ordered_by='system', children=[
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='class-id', config=True, description='Identification of the class of service.\nThis identifier is internal to the\nadministration.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='direction', config=True, description='The direction to which the QoS profile\nis applied.', default='both', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_qos_profile_direction], identities=_identities)),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rate-limit', config=True, description='To be used if the class must be rate-limited.\nExpressed as percentage of the service\nbandwidth.', mandatory=False, type_=DTypeDecimal64(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='decimal64', description=None, reference=None, exts=[], builtin_type='decimal64', default=None, fraction_digits=5, ranges=Ranges([(Decimal(bigint("0"), bigint("0")), Decimal(bigint("100"), bigint("0")))])), units='percent'),
                                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='latency', config=True, description='Latency constraint on the traffic class.', presence=False, children=[
                                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='use-lowest-latency', config=True, description='The traffic class should use the path with the\nlowest latency.', mandatory=False, type_=DTypeEmpty(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='empty', description=None, reference=None, exts=[], builtin_type='empty', default=None)),
                                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='latency-boundary', config=True, description='The traffic class should use a path with a\ndefined maximum latency.', default='400', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint16', description=None, reference=None, exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))])), units='msec')
                                            ]),
                                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='jitter', config=True, description='Jitter constraint on the traffic class.', presence=False, children=[
                                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='use-lowest-jitter', config=True, description='The traffic class should use the path with the\nlowest jitter.', mandatory=False, type_=DTypeEmpty(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='empty', description=None, reference=None, exts=[], builtin_type='empty', default=None)),
                                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='latency-boundary', config=True, description='The traffic class should use a path with a\ndefined maximum jitter.', default='40000', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(bigint("0"), bigint("4294967295"))])), units='usec')
                                            ]),
                                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bandwidth', config=True, description='Bandwidth constraint on the traffic class.', presence=False, children=[
                                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='guaranteed-bw-percent', config=True, description='To be used to define the guaranteed bandwidth\nas a percentage of the available service bandwidth.', mandatory=True, type_=DTypeDecimal64(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='decimal64', description=None, reference=None, exts=[], builtin_type='decimal64', default=None, fraction_digits=5, ranges=Ranges([(Decimal(bigint("0"), bigint("0")), Decimal(bigint("100"), bigint("0")))])), units='percent'),
                                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='end-to-end', config=True, description='Used if the bandwidth reservation\nmust be done on the MPLS network too.', mandatory=False, type_=DTypeEmpty(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='empty', description=None, reference=None, exts=[], builtin_type='empty', default=None))
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='carrierscarrier', config=True, description='This container is used when the customer provides\nMPLS-based services.  This is only used in the case\nof CsC (i.e., a customer builds an MPLS service using\nan IP VPN to carry its traffic).', if_feature=['carrierscarrier'], presence=False, children=[
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='signalling-type', config=True, description='MPLS signalling type.', default='bgp', mandatory=False, type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ldp':0, 'bgp':1}))
                            ]),
                            DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast', config=True, description='Multicast parameters for the site.', if_feature=['multicast'], presence=False, children=[
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-site-type', config=True, description='Type of multicast site.', default='source-receiver', mandatory=False, type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'receiver-only':0, 'source-only':1, 'source-receiver':2})),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-address-family', config=True, description='Defines protocol to carry multicast.', presence=False, children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv4', config=True, description='Enables IPv4 multicast.', default='false', if_feature=['ipv4'], mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None)),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv6', config=True, description='Enables IPv6 multicast.', default='false', if_feature=['ipv6'], mandatory=False, type_=DTypeBoolean(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None))
                                ]),
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type', config=True, description='Multicast protocol type to be used with the customer site.', default='both', mandatory=False, type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'host':0, 'router':1, 'both':2}))
                            ])
                        ]),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing-protocols', config=True, description='Defines routing protocols.', presence=False, children=[
                            DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing-protocol', key=['type'], config=True, description='List of routing protocols used on\nthe site.  This list can be augmented.', min_elements=0, ordered_by='system', children=[
                                DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='type', config=True, description='Type of routing protocol.', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_routing_protocol_type], identities=_identities)),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ospf', config=True, description='OSPF-specific configuration.', if_feature=['rtg-ospf'], presence=True, when="derived-from-or-self(../type, 'l3vpn-svc:ospf')", children=[
                                    DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', config=True, description='If OSPF is used on this site, this node\ncontains a configured value.  This node\ncontains at least one address family\nto be activated.', min_elements=1, ordered_by='system', type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', description='Defines a type for the address family.', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4':0, 'ipv6':1})),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='area-address', config=True, description='Area address.', mandatory=True, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='yang:dotted-quad', description="An unsigned 32-bit number expressed in the dotted-quad\nnotation, i.e., four octets written as decimal numbers\nand separated with the '.' (full stop) character.", reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))$', invert=False)])),
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='metric', config=True, description='Metric of the PE-CE link.  It is used\nin the routing state calculation and\npath selection.', default='1', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint16', description=None, reference=None, exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))]))),
                                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='sham-links', config=True, description='List of sham links.', if_feature=[
'rtg-ospf-sham-link'
                                        ], presence=False, children=[
                                        DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='sham-link', key=['target-site'], config=True, description='Creates a sham link with another site.', min_elements=0, ordered_by='system', children=[
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='target-site', config=True, description='Target site for the sham link connection.\nThe site is referred to by its ID.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='svc-id', description='Defines a type of service component identifier.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[])),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='metric', config=True, description='Metric of the sham link.  It is used in\nthe routing state calculation and path\nselection.  The default value is set\nto 1.', default='1', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint16', description=None, reference=None, exts=[], builtin_type='uint16', default=None, ranges=Ranges([(bigint("0"), bigint("65535"))])))
                                        ])
                                    ])
                                ]),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bgp', config=True, description='BGP-specific configuration.', if_feature=['rtg-bgp'], presence=True, when="derived-from-or-self(../type, 'l3vpn-svc:bgp')", children=[
                                    DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='autonomous-system', config=True, description='Customer AS number in case the customer\nrequests BGP routing.', mandatory=True, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(bigint("0"), bigint("4294967295"))]))),
                                    DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', config=True, description='If BGP is used on this site, this node\ncontains a configured value.  This node\ncontains at least one address family\nto be activated.', min_elements=1, ordered_by='system', type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', description='Defines a type for the address family.', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4':0, 'ipv6':1}))
                                ]),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='static', config=True, description='Configuration specific to static routing.', presence=True, when="derived-from-or-self(../type, 'l3vpn-svc:static')", children=[
                                    DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='cascaded-lan-prefixes', config=True, description='LAN prefixes from the customer.', presence=False, children=[
                                        DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv4-lan-prefixes', key=[
'lan',
'next-hop'
                                            ], config=True, description='List of LAN prefixes for the site.', if_feature=['ipv4'], min_elements=0, ordered_by='system', children=[
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lan', config=True, description='LAN prefixes.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-prefix', description='The ipv4-prefix type represents an IPv4 address prefix.\nThe prefix length is given by the number following the\nslash character and must be less than or equal to 32.\n\nA prefix length value of n corresponds to an IP address\nmask that has n contiguous 1-bits from the most\nsignificant bit (MSB) and all other bits set to 0.\n\nThe canonical format of an IPv4 prefix has all bits of\nthe IPv4 address set to zero that are not part of the\nIPv4 prefix.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2])))$', invert=False)])),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='next-hop', config=True, description='Next-hop address to use on the customer side.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv4-address', description='The ipv4-address type represents an IPv4 address in\ndotted-quad notation.  The IPv4 address may include a zone\nindex, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format for the zone index is the numerical\nformat', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False)])),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lan-tag', config=True, description='Internal tag to be used in VPN policies.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                                        ]),
                                        DList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv6-lan-prefixes', key=[
'lan',
'next-hop'
                                            ], config=True, description='List of LAN prefixes for the site.', if_feature=['ipv6'], min_elements=0, ordered_by='system', children=[
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lan', config=True, description='LAN prefixes.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-prefix', description='The ipv6-prefix type represents an IPv6 address prefix.\nThe prefix length is given by the number following the\nslash character and must be less than or equal to 128.\n\nA prefix length value of n corresponds to an IP address\nmask that has n contiguous 1-bits from the most\nsignificant bit (MSB) and all other bits set to 0.\n\nThe IPv6 address should have all bits that do not belong\nto the prefix set to zero.\n\nThe canonical format of an IPv6 prefix has all bits of\nthe IPv6 address set to zero that are not part of the\nIPv6 prefix.  Furthermore, the IPv6 address is represented\nas defined in Section 4 of RFC 5952.', reference='RFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{{2}})|(1[0-1][0-9])|(12[0-8])))', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{{2}})|(1[0-1][0-9])|(12[0-8]))))$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(/.+)', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(/.+))$', invert=False)])),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='next-hop', config=True, description='Next-hop address to use on the customer side.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='inet:ipv6-address', description='The ipv6-address type represents an IPv6 address in full,\nmixed, shortened, and shortened-mixed notation.  The IPv6\naddress may include a zone index, separated by a % sign.\n\nThe zone index is used to disambiguate identical address\nvalues.  For link-local addresses, the zone index will\ntypically be the interface index number or the name of an\ninterface.  If the zone index is not present, the default\nzone of the device will be used.\n\nThe canonical format of IPv6 addresses uses the textual\nrepresentation defined in Section 4 of RFC 5952.  The\ncanonical format for the zone index is the numerical\nformat as described in Section 11.2 of RFC 4007.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False)])),
                                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lan-tag', config=True, description='Internal tag to be used in VPN policies.', mandatory=False, type_=DTypeString(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
                                        ])
                                    ])
                                ]),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rip', config=True, description='Configuration specific to RIP routing.', if_feature=['rtg-rip'], presence=True, when="derived-from-or-self(../type, 'l3vpn-svc:rip')", children=[
                                    DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', config=True, description='If RIP is used on this site, this node\ncontains a configured value.  This node\ncontains at least one address family\nto be activated.', min_elements=1, ordered_by='system', type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', description='Defines a type for the address family.', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4':0, 'ipv6':1}))
                                ]),
                                DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vrrp', config=True, description='Configuration specific to VRRP routing.', if_feature=['rtg-vrrp'], presence=True, when="derived-from-or-self(../type, 'l3vpn-svc:vrrp')", children=[
                                    DLeafList(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', config=True, description='If VRRP is used on this site, this node\ncontains a configured value.  This node contains\nat least one address family to be activated.', min_elements=1, ordered_by='system', type_=DTypeEnum(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-family', description='Defines a type for the address family.', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4':0, 'ipv6':1}))
                                ])
                            ])
                        ]),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='availability', config=True, description='Availability parameters (used for multihoming).', presence=False, children=[
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='access-priority', config=True, description='Defines the priority for the access.\nThe higher the access-priority value,\nthe higher the preference of the\naccess will be.', default='100', mandatory=False, type_=DTypeInteger(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(bigint("0"), bigint("4294967295"))])))
                        ]),
                        DContainer(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-attachment', config=True, description='Defines VPN attachment of a site.', presence=False, children=[
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-policy-id', config=True, description='Reference to a VPN policy.  When referencing VPN\npolicy for attachment, the vpn-policy-id must be\nconfigured.', mandatory=False, type_=DTypeLeafref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='../../../../vpn-policies/vpn-policy/vpn-policy-id', require_instance=False)),
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-id', config=True, description='Reference to an IP VPN.  Referencing a vpn-id provides\nan easy way to attach a particular logical access to\na VPN.  In this case, vpn-id must be configured.', mandatory=False, type_=DTypeLeafref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='leafref', description=None, reference=None, exts=[], builtin_type='leafref', default=None, path='/l3vpn-svc/vpn-services/vpn-service/vpn-id', require_instance=False)),
                            DLeaf(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-role', config=True, description='Role of the site in the IP VPN.  When referencing a vpn-id,\nthe site-role setting must be added to express the role of\nthe site in the target VPN service topology.', default='any-to-any-role', mandatory=False, type_=DTypeIdentityref(module='ietf-l3vpn-svc', namespace='ietf-l3vpn-svc', prefix='l3vpn-svc', name='identityref', description=None, reference=None, exts=[], builtin_type='identityref', default=None, identity_bases=[_base_ietf_l3vpn_svc_site_role], identities=_identities))
                        ])
                    ])
                ])
            ])
        ])
    ])
])

schema_namespaces: set[str] = {
    'http://example.com/netinfra',
    'http://orchestron.org/yang/orchestron-tmf',
    'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc',
}
