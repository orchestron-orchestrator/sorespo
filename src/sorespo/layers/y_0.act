import base64
import json
import xml
import yang.adata
import yang.gdata
from yang.identity import complete_and_validate_identityref
from yang.identityref import Identityref, PartialIdentityref
from yang.schema import DIdentity

# == This file is generated ==


_base_ietf_l3vpn_svc_site_network_access_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-network-access-type', base=[])
_base_ietf_l3vpn_svc_placement_diversity = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='placement-diversity', base=[])
_base_ietf_l3vpn_svc_customer_application = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-application', base=[])
_base_ietf_l3vpn_svc_site_vpn_flavor = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor', base=[])
_base_ietf_l3vpn_svc_management = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='management', base=[])
_base_ietf_l3vpn_svc_address_allocation_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='address-allocation-type', base=[])
_base_ietf_l3vpn_svc_site_role = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-role', base=[])
_base_ietf_l3vpn_svc_vpn_topology = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-topology', base=[])
_base_ietf_l3vpn_svc_multicast_tree_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-tree-type', base=[])
_base_ietf_l3vpn_svc_multicast_rp_discovery_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multicast-rp-discovery-type', base=[])
_base_ietf_l3vpn_svc_routing_protocol_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing-protocol-type', base=[])
_base_ietf_l3vpn_svc_protocol_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='protocol-type', base=[])
_base_ietf_l3vpn_svc_vpn_policy_filter_type = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vpn-policy-filter-type', base=[])
_base_ietf_l3vpn_svc_qos_profile_direction = DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='qos-profile-direction', base=[])
_identities = [
    _base_ietf_l3vpn_svc_site_network_access_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='point-to-point', base=[_base_ietf_l3vpn_svc_site_network_access_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='multipoint', base=[_base_ietf_l3vpn_svc_site_network_access_type]),
    _base_ietf_l3vpn_svc_placement_diversity,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bearer-diverse', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='pe-diverse', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='pop-diverse', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='linecard-diverse', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='same-pe', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='same-bearer', base=[_base_ietf_l3vpn_svc_placement_diversity]),
    _base_ietf_l3vpn_svc_customer_application,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='web', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='mail', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='file-transfer', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='database', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='social', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='games', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='p2p', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='network-management', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='voice', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='video', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='embb', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='urllc', base=[_base_ietf_l3vpn_svc_customer_application]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='mmtc', base=[_base_ietf_l3vpn_svc_customer_application]),
    _base_ietf_l3vpn_svc_site_vpn_flavor,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-single', base=[_base_ietf_l3vpn_svc_site_vpn_flavor]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-multi', base=[_base_ietf_l3vpn_svc_site_vpn_flavor]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-sub', base=[_base_ietf_l3vpn_svc_site_vpn_flavor]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-vpn-flavor-nni', base=[_base_ietf_l3vpn_svc_site_vpn_flavor]),
    _base_ietf_l3vpn_svc_management,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='co-managed', base=[_base_ietf_l3vpn_svc_management]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='customer-managed', base=[_base_ietf_l3vpn_svc_management]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-managed', base=[_base_ietf_l3vpn_svc_management]),
    _base_ietf_l3vpn_svc_address_allocation_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-dhcp', base=[_base_ietf_l3vpn_svc_address_allocation_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-dhcp-relay', base=[_base_ietf_l3vpn_svc_address_allocation_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='provider-dhcp-slaac', base=[_base_ietf_l3vpn_svc_address_allocation_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='static-address', base=[_base_ietf_l3vpn_svc_address_allocation_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='slaac', base=[_base_ietf_l3vpn_svc_address_allocation_type]),
    _base_ietf_l3vpn_svc_site_role,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='any-to-any-role', base=[_base_ietf_l3vpn_svc_site_role]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='spoke-role', base=[_base_ietf_l3vpn_svc_site_role]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hub-role', base=[_base_ietf_l3vpn_svc_site_role]),
    _base_ietf_l3vpn_svc_vpn_topology,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='any-to-any', base=[_base_ietf_l3vpn_svc_vpn_topology]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hub-spoke', base=[_base_ietf_l3vpn_svc_vpn_topology]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hub-spoke-disjoint', base=[_base_ietf_l3vpn_svc_vpn_topology]),
    _base_ietf_l3vpn_svc_multicast_tree_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ssm-tree-type', base=[_base_ietf_l3vpn_svc_multicast_tree_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='asm-tree-type', base=[_base_ietf_l3vpn_svc_multicast_tree_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bidir-tree-type', base=[_base_ietf_l3vpn_svc_multicast_tree_type]),
    _base_ietf_l3vpn_svc_multicast_rp_discovery_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='auto-rp', base=[_base_ietf_l3vpn_svc_multicast_rp_discovery_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='static-rp', base=[_base_ietf_l3vpn_svc_multicast_rp_discovery_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bsr-rp', base=[_base_ietf_l3vpn_svc_multicast_rp_discovery_type]),
    _base_ietf_l3vpn_svc_routing_protocol_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ospf', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='bgp', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='static', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='rip', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='vrrp', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='direct', base=[_base_ietf_l3vpn_svc_routing_protocol_type]),
    _base_ietf_l3vpn_svc_protocol_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='tcp', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='udp', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='icmp', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='icmp6', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='gre', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipip', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='hop-by-hop', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='routing', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='esp', base=[_base_ietf_l3vpn_svc_protocol_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ah', base=[_base_ietf_l3vpn_svc_protocol_type]),
    _base_ietf_l3vpn_svc_vpn_policy_filter_type,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv4', base=[_base_ietf_l3vpn_svc_vpn_policy_filter_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='ipv6', base=[_base_ietf_l3vpn_svc_vpn_policy_filter_type]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='lan', base=[_base_ietf_l3vpn_svc_vpn_policy_filter_type]),
    _base_ietf_l3vpn_svc_qos_profile_direction,
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='site-to-wan', base=[_base_ietf_l3vpn_svc_qos_profile_direction]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='wan-to-site', base=[_base_ietf_l3vpn_svc_qos_profile_direction]),
    DIdentity(module='ietf-l3vpn-svc', namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', prefix='l3vpn-svc', name='both', base=[_base_ietf_l3vpn_svc_qos_profile_direction]),
]


# Identityref constants
ietf_l3vpn_svc_site_network_access_type = Identityref('site-network-access-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_point_to_point = Identityref('point-to-point', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_multipoint = Identityref('multipoint', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_placement_diversity = Identityref('placement-diversity', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_bearer_diverse = Identityref('bearer-diverse', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_pe_diverse = Identityref('pe-diverse', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_pop_diverse = Identityref('pop-diverse', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_linecard_diverse = Identityref('linecard-diverse', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_same_pe = Identityref('same-pe', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_same_bearer = Identityref('same-bearer', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_customer_application = Identityref('customer-application', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_web = Identityref('web', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_mail = Identityref('mail', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_file_transfer = Identityref('file-transfer', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_database = Identityref('database', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_social = Identityref('social', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_games = Identityref('games', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_p2p = Identityref('p2p', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_network_management = Identityref('network-management', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_voice = Identityref('voice', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_video = Identityref('video', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_embb = Identityref('embb', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_urllc = Identityref('urllc', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_mmtc = Identityref('mmtc', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_vpn_flavor = Identityref('site-vpn-flavor', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_vpn_flavor_single = Identityref('site-vpn-flavor-single', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_vpn_flavor_multi = Identityref('site-vpn-flavor-multi', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_vpn_flavor_sub = Identityref('site-vpn-flavor-sub', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_vpn_flavor_nni = Identityref('site-vpn-flavor-nni', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_management = Identityref('management', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_co_managed = Identityref('co-managed', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_customer_managed = Identityref('customer-managed', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_provider_managed = Identityref('provider-managed', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_address_allocation_type = Identityref('address-allocation-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_provider_dhcp = Identityref('provider-dhcp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_provider_dhcp_relay = Identityref('provider-dhcp-relay', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_provider_dhcp_slaac = Identityref('provider-dhcp-slaac', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_static_address = Identityref('static-address', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_slaac = Identityref('slaac', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_role = Identityref('site-role', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_any_to_any_role = Identityref('any-to-any-role', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_spoke_role = Identityref('spoke-role', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_hub_role = Identityref('hub-role', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_vpn_topology = Identityref('vpn-topology', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_any_to_any = Identityref('any-to-any', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_hub_spoke = Identityref('hub-spoke', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_hub_spoke_disjoint = Identityref('hub-spoke-disjoint', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_multicast_tree_type = Identityref('multicast-tree-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ssm_tree_type = Identityref('ssm-tree-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_asm_tree_type = Identityref('asm-tree-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_bidir_tree_type = Identityref('bidir-tree-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_multicast_rp_discovery_type = Identityref('multicast-rp-discovery-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_auto_rp = Identityref('auto-rp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_static_rp = Identityref('static-rp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_bsr_rp = Identityref('bsr-rp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_routing_protocol_type = Identityref('routing-protocol-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ospf = Identityref('ospf', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_bgp = Identityref('bgp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_static = Identityref('static', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_rip = Identityref('rip', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_vrrp = Identityref('vrrp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_direct = Identityref('direct', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_protocol_type = Identityref('protocol-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_tcp = Identityref('tcp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_udp = Identityref('udp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_icmp = Identityref('icmp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_icmp6 = Identityref('icmp6', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_gre = Identityref('gre', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ipip = Identityref('ipip', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_hop_by_hop = Identityref('hop-by-hop', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_routing = Identityref('routing', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_esp = Identityref('esp', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ah = Identityref('ah', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_vpn_policy_filter_type = Identityref('vpn-policy-filter-type', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ipv4 = Identityref('ipv4', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_ipv6 = Identityref('ipv6', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_lan = Identityref('lan', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_qos_profile_direction = Identityref('qos-profile-direction', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_site_to_wan = Identityref('site-to-wan', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_wan_to_site = Identityref('wan-to-site', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')
ietf_l3vpn_svc_both = Identityref('both', ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', mod='ietf-l3vpn-svc', pfx='l3vpn-svc')


mut def from_json_netinfra__netinfra__router__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra__netinfra__router__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__router__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_netinfra__netinfra__router__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_netinfra__netinfra__router__type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra__netinfra__router__type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__router__role(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra__netinfra__router__role(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__router__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_netinfra__netinfra__router__asn(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_netinfra__netinfra__router__mock(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_netinfra__netinfra__router__mock(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class netinfra__netinfra__router_entry(yang.adata.MNode):
    name: str
    id: int
    type: ?str
    role: ?str
    asn: int
    mock: ?str

    mut def __init__(self, name: str, id: int, asn: int, type: ?str, role: ?str, mock: ?str):
        self._ns = 'http://example.com/netinfra'
        self.name = name
        self.id = id
        self.type = type
        self.role = role
        self.asn = asn
        self.mock = mock

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint32', _id)
        _type = self.type
        if _type is not None:
            children['type'] = yang.gdata.Leaf('string', _type)
        _role = self.role
        if _role is not None:
            children['role'] = yang.gdata.Leaf('string', _role)
        _asn = self.asn
        if _asn is not None:
            children['asn'] = yang.gdata.Leaf('uint32', _asn)
        _mock = self.mock
        if _mock is not None:
            children['mock'] = yang.gdata.Leaf('enumeration', _mock)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra__netinfra__router_entry:
        return netinfra__netinfra__router_entry(name=n.get_str('name'), id=n.get_int('id'), type=n.get_opt_str('type'), role=n.get_opt_str('role'), asn=n.get_int('asn'), mock=n.get_opt_str('mock'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /netinfra/router')
            res.append('{self_name} = netinfra__netinfra__router({repr(self.name)}, {repr(self.id)}, {repr(self.asn)})')
        leaves = []
        _type = self.type
        if _type is not None:
            leaves.append('{self_name}.type = {repr(_type)}')
        _role = self.role
        if _role is not None:
            leaves.append('{self_name}.role = {repr(_role)}')
        _mock = self.mock
        if _mock is not None:
            leaves.append('{self_name}.mock = {repr(_mock)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /netinfra/router'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class netinfra__netinfra__router(yang.adata.MNode):
    elements: list[netinfra__netinfra__router_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/netinfra'
        self._name = 'router'
        self.elements = elements

    mut def create(self, name, id, asn):
        for e in self.elements:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = netinfra__netinfra__router_entry(name, id, asn)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra__netinfra__router_entry]:
        if n is not None:
            return [netinfra__netinfra__router_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_netinfra__netinfra__router_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_netinfra__netinfra__router__name, child_name)
    child_id = yang.gdata.from_xml_int(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_netinfra__netinfra__router__id, child_id)
    child_type = yang.gdata.from_xml_opt_str(node, 'type')
    yang.gdata.maybe_add(children, 'type', from_xml_netinfra__netinfra__router__type, child_type)
    child_role = yang.gdata.from_xml_opt_str(node, 'role')
    yang.gdata.maybe_add(children, 'role', from_xml_netinfra__netinfra__router__role, child_role)
    child_asn = yang.gdata.from_xml_int(node, 'asn')
    yang.gdata.maybe_add(children, 'asn', from_xml_netinfra__netinfra__router__asn, child_asn)
    child_mock = yang.gdata.from_xml_opt_str(node, 'mock')
    yang.gdata.maybe_add(children, 'mock', from_xml_netinfra__netinfra__router__mock, child_mock)
    return yang.gdata.Container(children)

mut def from_xml_netinfra__netinfra__router(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_netinfra__netinfra__router_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_json_path_netinfra__netinfra__router_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra__netinfra__router_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['name']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['name'] = from_json_netinfra__netinfra__router__name(keys[0])
        if point == 'id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'role':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'asn':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'mock':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra__netinfra__router(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra__netinfra__router_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['name'])))
        return yang.gdata.List(['name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['name'], [from_json_path_netinfra__netinfra__router_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra__netinfra__router_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.take_json_str(jd, 'name')
    yang.gdata.maybe_add(children, 'name', from_json_netinfra__netinfra__router__name, child_name)
    child_id = yang.gdata.take_json_int(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_netinfra__netinfra__router__id, child_id)
    child_type = yang.gdata.take_json_opt_str(jd, 'type')
    yang.gdata.maybe_add(children, 'type', from_json_netinfra__netinfra__router__type, child_type)
    child_role = yang.gdata.take_json_opt_str(jd, 'role')
    yang.gdata.maybe_add(children, 'role', from_json_netinfra__netinfra__router__role, child_role)
    child_asn = yang.gdata.take_json_int(jd, 'asn')
    yang.gdata.maybe_add(children, 'asn', from_json_netinfra__netinfra__router__asn, child_asn)
    child_mock = yang.gdata.take_json_opt_str(jd, 'mock')
    yang.gdata.maybe_add(children, 'mock', from_json_netinfra__netinfra__router__mock, child_mock)
    return yang.gdata.Container(children)

mut def from_json_netinfra__netinfra__router(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_netinfra__netinfra__router_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_json_netinfra__netinfra__backbone_link__left_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra__netinfra__backbone_link__left_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__backbone_link__left_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra__netinfra__backbone_link__left_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__backbone_link__right_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra__netinfra__backbone_link__right_router(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_netinfra__netinfra__backbone_link__right_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_netinfra__netinfra__backbone_link__right_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class netinfra__netinfra__backbone_link_entry(yang.adata.MNode):
    left_router: str
    left_interface: str
    right_router: str
    right_interface: str

    mut def __init__(self, left_router: str, left_interface: str, right_router: str, right_interface: str):
        self._ns = 'http://example.com/netinfra'
        self.left_router = left_router
        self.left_interface = left_interface
        self.right_router = right_router
        self.right_interface = right_interface

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _left_router = self.left_router
        if _left_router is not None:
            children['left-router'] = yang.gdata.Leaf('string', _left_router)
        _left_interface = self.left_interface
        if _left_interface is not None:
            children['left-interface'] = yang.gdata.Leaf('string', _left_interface)
        _right_router = self.right_router
        if _right_router is not None:
            children['right-router'] = yang.gdata.Leaf('string', _right_router)
        _right_interface = self.right_interface
        if _right_interface is not None:
            children['right-interface'] = yang.gdata.Leaf('string', _right_interface)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> netinfra__netinfra__backbone_link_entry:
        return netinfra__netinfra__backbone_link_entry(left_router=n.get_str('left-router'), left_interface=n.get_str('left-interface'), right_router=n.get_str('right-router'), right_interface=n.get_str('right-interface'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /netinfra/backbone-link')
            res.append('{self_name} = netinfra__netinfra__backbone_link({repr(self.left_router)}, {repr(self.left_interface)}, {repr(self.right_router)}, {repr(self.right_interface)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /netinfra/backbone-link'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class netinfra__netinfra__backbone_link(yang.adata.MNode):
    elements: list[netinfra__netinfra__backbone_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://example.com/netinfra'
        self._name = 'backbone-link'
        self.elements = elements

    mut def create(self, left_router, left_interface, right_router, right_interface):
        for e in self.elements:
            match = True
            if e.left_router != left_router:
                match = False
                continue
            if e.left_interface != left_interface:
                match = False
                continue
            if e.right_router != right_router:
                match = False
                continue
            if e.right_interface != right_interface:
                match = False
                continue
            if match:
                return e

        res = netinfra__netinfra__backbone_link_entry(left_router, left_interface, right_router, right_interface)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[netinfra__netinfra__backbone_link_entry]:
        if n is not None:
            return [netinfra__netinfra__backbone_link_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_netinfra__netinfra__backbone_link_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_left_router = yang.gdata.from_xml_str(node, 'left-router')
    yang.gdata.maybe_add(children, 'left-router', from_xml_netinfra__netinfra__backbone_link__left_router, child_left_router)
    child_left_interface = yang.gdata.from_xml_str(node, 'left-interface')
    yang.gdata.maybe_add(children, 'left-interface', from_xml_netinfra__netinfra__backbone_link__left_interface, child_left_interface)
    child_right_router = yang.gdata.from_xml_str(node, 'right-router')
    yang.gdata.maybe_add(children, 'right-router', from_xml_netinfra__netinfra__backbone_link__right_router, child_right_router)
    child_right_interface = yang.gdata.from_xml_str(node, 'right-interface')
    yang.gdata.maybe_add(children, 'right-interface', from_xml_netinfra__netinfra__backbone_link__right_interface, child_right_interface)
    return yang.gdata.Container(children)

mut def from_xml_netinfra__netinfra__backbone_link(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_netinfra__netinfra__backbone_link_element(e) for e in nodes]
    return yang.gdata.List(keys=['left-router', 'left-interface', 'right-router', 'right-interface'], elements=elements)

mut def from_json_path_netinfra__netinfra__backbone_link_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_netinfra__netinfra__backbone_link_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['left-router', 'left-interface', 'right-router', 'right-interface']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['left-router'] = from_json_netinfra__netinfra__backbone_link__left_router(keys[0])
        children['left-interface'] = from_json_netinfra__netinfra__backbone_link__left_interface(keys[1])
        children['right-router'] = from_json_netinfra__netinfra__backbone_link__right_router(keys[2])
        children['right-interface'] = from_json_netinfra__netinfra__backbone_link__right_interface(keys[3])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_netinfra__netinfra__backbone_link(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['left-router', 'left-interface', 'right-router', 'right-interface']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_netinfra__netinfra__backbone_link_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['left-router', 'left-interface', 'right-router', 'right-interface'])))
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['left-router', 'left-interface', 'right-router', 'right-interface'], [from_json_path_netinfra__netinfra__backbone_link_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_netinfra__netinfra__backbone_link_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_left_router = yang.gdata.take_json_str(jd, 'left-router')
    yang.gdata.maybe_add(children, 'left-router', from_json_netinfra__netinfra__backbone_link__left_router, child_left_router)
    child_left_interface = yang.gdata.take_json_str(jd, 'left-interface')
    yang.gdata.maybe_add(children, 'left-interface', from_json_netinfra__netinfra__backbone_link__left_interface, child_left_interface)
    child_right_router = yang.gdata.take_json_str(jd, 'right-router')
    yang.gdata.maybe_add(children, 'right-router', from_json_netinfra__netinfra__backbone_link__right_router, child_right_router)
    child_right_interface = yang.gdata.take_json_str(jd, 'right-interface')
    yang.gdata.maybe_add(children, 'right-interface', from_json_netinfra__netinfra__backbone_link__right_interface, child_right_interface)
    return yang.gdata.Container(children)

mut def from_json_netinfra__netinfra__backbone_link(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_netinfra__netinfra__backbone_link_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['left-router', 'left-interface', 'right-router', 'right-interface'], elements=elements)

class netinfra__netinfra(yang.adata.MNode):
    router: netinfra__netinfra__router
    backbone_link: netinfra__netinfra__backbone_link

    mut def __init__(self, router: list[netinfra__netinfra__router_entry]=[], backbone_link: list[netinfra__netinfra__backbone_link_entry]=[]):
        self._ns = 'http://example.com/netinfra'
        self.router = netinfra__netinfra__router(elements=router)
        self.backbone_link = netinfra__netinfra__backbone_link(elements=backbone_link)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _router = self.router
        if _router is not None:
            children['router'] = _router.to_gdata()
        _backbone_link = self.backbone_link
        if _backbone_link is not None:
            children['backbone-link'] = _backbone_link.to_gdata()
        return yang.gdata.Container(children, ns='http://example.com/netinfra', module='netinfra')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> netinfra__netinfra:
        if n is not None:
            return netinfra__netinfra(router=netinfra__netinfra__router.from_gdata(n.get_opt_list('router')), backbone_link=netinfra__netinfra__backbone_link.from_gdata(n.get_opt_list('backbone-link')))
        return netinfra__netinfra()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /netinfra')
            res.append('{self_name} = netinfra__netinfra()')
        leaves = []
        _router = self.router
        for _element in _router.elements:
            res.append('')
            res.append("# List /netinfra/router element: {_element.to_gdata().key_str(['name'])}")
            list_elem = 'router_element = {self_name}.router.create({repr(_element.name)}, {repr(_element.id)}, {repr(_element.asn)})'
            res.append(list_elem)
            res.extend(_element.prsrc('router_element', False, list_element=True).splitlines())
        _backbone_link = self.backbone_link
        for _element in _backbone_link.elements:
            res.append('')
            res.append("# List /netinfra/backbone-link element: {_element.to_gdata().key_str(['left-router', 'left-interface', 'right-router', 'right-interface'])}")
            list_elem = 'backbone_link_element = {self_name}.backbone_link.create({repr(_element.left_router)}, {repr(_element.left_interface)}, {repr(_element.right_router)}, {repr(_element.right_interface)})'
            res.append(list_elem)
            res.extend(_element.prsrc('backbone_link_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /netinfra'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_netinfra__netinfra(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_router = yang.gdata.from_xml_opt_list(node, 'router')
    yang.gdata.maybe_add(children, 'router', from_xml_netinfra__netinfra__router, child_router)
    child_backbone_link = yang.gdata.from_xml_opt_list(node, 'backbone-link')
    yang.gdata.maybe_add(children, 'backbone-link', from_xml_netinfra__netinfra__backbone_link, child_backbone_link)
    return yang.gdata.Container(children, ns='http://example.com/netinfra', module='netinfra')

mut def from_json_path_netinfra__netinfra(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'router':
            child = {'router': from_json_path_netinfra__netinfra__router(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/netinfra', module='netinfra')
        if point == 'backbone-link':
            child = {'backbone-link': from_json_path_netinfra__netinfra__backbone_link(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='http://example.com/netinfra', module='netinfra')
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_netinfra__netinfra(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_netinfra__netinfra(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_router = yang.gdata.take_json_opt_list(jd, 'router')
    yang.gdata.maybe_add(children, 'router', from_json_netinfra__netinfra__router, child_router)
    child_backbone_link = yang.gdata.take_json_opt_list(jd, 'backbone-link')
    yang.gdata.maybe_add(children, 'backbone-link', from_json_netinfra__netinfra__backbone_link, child_backbone_link)
    return yang.gdata.Container(children, ns='http://example.com/netinfra', module='netinfra')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(id=n.get_str('id'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/cloud-identifier')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier({repr(self.id)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/cloud-identifier'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'cloud-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_str(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier__id(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(id=n.get_str('id'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/encryption-profile-identifier')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier({repr(self.id)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/encryption-profile-identifier'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'encryption-profile-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_str(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier__id(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(id=n.get_str('id'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/qos-profile-identifier')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier({repr(self.id)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/qos-profile-identifier'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'qos-profile-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_str(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier__id(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(yang.adata.MNode):
    id: str

    mut def __init__(self, id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(id=n.get_str('id'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/bfd-profile-identifier')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier({repr(self.id)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-profiles/valid-provider-identifiers/bfd-profile-identifier'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'bfd-profile-identifier'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_str(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier__id(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier__id, child_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(yang.adata.MNode):
    cloud_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier
    encryption_profile_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier
    qos_profile_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier
    bfd_profile_identifier: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier

    mut def __init__(self, cloud_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier_entry]=[], encryption_profile_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier_entry]=[], qos_profile_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier_entry]=[], bfd_profile_identifier: list[ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cloud_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(elements=cloud_identifier)
        self.encryption_profile_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(elements=encryption_profile_identifier)
        self.qos_profile_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(elements=qos_profile_identifier)
        self.bfd_profile_identifier = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(elements=bfd_profile_identifier)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cloud_identifier = self.cloud_identifier
        if _cloud_identifier is not None:
            children['cloud-identifier'] = _cloud_identifier.to_gdata()
        _encryption_profile_identifier = self.encryption_profile_identifier
        if _encryption_profile_identifier is not None:
            children['encryption-profile-identifier'] = _encryption_profile_identifier.to_gdata()
        _qos_profile_identifier = self.qos_profile_identifier
        if _qos_profile_identifier is not None:
            children['qos-profile-identifier'] = _qos_profile_identifier.to_gdata()
        _bfd_profile_identifier = self.bfd_profile_identifier
        if _bfd_profile_identifier is not None:
            children['bfd-profile-identifier'] = _bfd_profile_identifier.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(cloud_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier.from_gdata(n.get_opt_list('cloud-identifier')), encryption_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier.from_gdata(n.get_opt_list('encryption-profile-identifier')), qos_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier.from_gdata(n.get_opt_list('qos-profile-identifier')), bfd_profile_identifier=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier.from_gdata(n.get_opt_list('bfd-profile-identifier')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-profiles/valid-provider-identifiers')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers()')
        leaves = []
        _cloud_identifier = self.cloud_identifier
        for _element in _cloud_identifier.elements:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-profiles/valid-provider-identifiers/cloud-identifier element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'cloud_identifier_element = {self_name}.cloud_identifier.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('cloud_identifier_element', False, list_element=True).splitlines())
        _encryption_profile_identifier = self.encryption_profile_identifier
        for _element in _encryption_profile_identifier.elements:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-profiles/valid-provider-identifiers/encryption-profile-identifier element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'encryption_profile_identifier_element = {self_name}.encryption_profile_identifier.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('encryption_profile_identifier_element', False, list_element=True).splitlines())
        _qos_profile_identifier = self.qos_profile_identifier
        for _element in _qos_profile_identifier.elements:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-profiles/valid-provider-identifiers/qos-profile-identifier element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'qos_profile_identifier_element = {self_name}.qos_profile_identifier.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('qos_profile_identifier_element', False, list_element=True).splitlines())
        _bfd_profile_identifier = self.bfd_profile_identifier
        for _element in _bfd_profile_identifier.elements:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-profiles/valid-provider-identifiers/bfd-profile-identifier element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'bfd_profile_identifier_element = {self_name}.bfd_profile_identifier.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('bfd_profile_identifier_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-profiles/valid-provider-identifiers'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_cloud_identifier = yang.gdata.from_xml_opt_list(node, 'cloud-identifier')
    yang.gdata.maybe_add(children, 'cloud-identifier', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier, child_cloud_identifier)
    child_encryption_profile_identifier = yang.gdata.from_xml_opt_list(node, 'encryption-profile-identifier')
    yang.gdata.maybe_add(children, 'encryption-profile-identifier', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier, child_encryption_profile_identifier)
    child_qos_profile_identifier = yang.gdata.from_xml_opt_list(node, 'qos-profile-identifier')
    yang.gdata.maybe_add(children, 'qos-profile-identifier', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier, child_qos_profile_identifier)
    child_bfd_profile_identifier = yang.gdata.from_xml_opt_list(node, 'bfd-profile-identifier')
    yang.gdata.maybe_add(children, 'bfd-profile-identifier', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier, child_bfd_profile_identifier)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'cloud-identifier':
            child = {'cloud-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'encryption-profile-identifier':
            child = {'encryption-profile-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'qos-profile-identifier':
            child = {'qos-profile-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'bfd-profile-identifier':
            child = {'bfd-profile-identifier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cloud_identifier = yang.gdata.take_json_opt_list(jd, 'cloud-identifier')
    yang.gdata.maybe_add(children, 'cloud-identifier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__cloud_identifier, child_cloud_identifier)
    child_encryption_profile_identifier = yang.gdata.take_json_opt_list(jd, 'encryption-profile-identifier')
    yang.gdata.maybe_add(children, 'encryption-profile-identifier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__encryption_profile_identifier, child_encryption_profile_identifier)
    child_qos_profile_identifier = yang.gdata.take_json_opt_list(jd, 'qos-profile-identifier')
    yang.gdata.maybe_add(children, 'qos-profile-identifier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__qos_profile_identifier, child_qos_profile_identifier)
    child_bfd_profile_identifier = yang.gdata.take_json_opt_list(jd, 'bfd-profile-identifier')
    yang.gdata.maybe_add(children, 'bfd-profile-identifier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers__bfd_profile_identifier, child_bfd_profile_identifier)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(yang.adata.MNode):
    valid_provider_identifiers: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers

    mut def __init__(self, valid_provider_identifiers: ?ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.valid_provider_identifiers = valid_provider_identifiers if valid_provider_identifiers is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _valid_provider_identifiers = self.valid_provider_identifiers
        if _valid_provider_identifiers is not None:
            children['valid-provider-identifiers'] = _valid_provider_identifiers.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_profiles:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(valid_provider_identifiers=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers.from_gdata(n.get_opt_cnt('valid-provider-identifiers')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_profiles()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-profiles')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_profiles()')
        leaves = []
        _valid_provider_identifiers = self.valid_provider_identifiers
        if _valid_provider_identifiers is not None:
            res.extend(_valid_provider_identifiers.prsrc('{self_name}.valid_provider_identifiers', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-profiles'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_valid_provider_identifiers = yang.gdata.from_xml_opt_cnt(node, 'valid-provider-identifiers')
    yang.gdata.maybe_add(children, 'valid-provider-identifiers', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers, child_valid_provider_identifiers)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'valid-provider-identifiers':
            child = {'valid-provider-identifiers': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_valid_provider_identifiers = yang.gdata.take_json_opt_cnt(jd, 'valid-provider-identifiers')
    yang.gdata.maybe_add(children, 'valid-provider-identifiers', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles__valid_provider_identifiers, child_valid_provider_identifiers)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__customer_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__customer_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_service_topology(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:vpn-topology'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf vpn-service-topology: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_service_topology(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:vpn-topology'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf vpn-service-topology: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__cloud_identifier(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__cloud_identifier(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_any(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_any(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_site(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_site(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__deny_site(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__deny_site(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__nat44_customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__nat44_customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(yang.adata.MNode):
    enabled: bool
    nat44_customer_address: ?str

    mut def __init__(self, enabled: ?bool=None, nat44_customer_address: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.nat44_customer_address = nat44_customer_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _nat44_customer_address = self.nat44_customer_address
        if _nat44_customer_address is not None:
            children['nat44-customer-address'] = yang.gdata.Leaf('string', _nat44_customer_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(enabled=n.get_opt_bool('enabled'), nat44_customer_address=n.get_opt_str('nat44-customer-address'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses/cloud-access/address-translation/nat44')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44()')
        leaves = []
        _enabled = self.enabled
        if _enabled is not None:
            leaves.append('{self_name}.enabled = {repr(_enabled)}')
        _nat44_customer_address = self.nat44_customer_address
        if _nat44_customer_address is not None:
            leaves.append('{self_name}.nat44_customer_address = {repr(_nat44_customer_address)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses/cloud-access/address-translation/nat44'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.from_xml_opt_bool(node, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__enabled, child_enabled)
    child_nat44_customer_address = yang.gdata.from_xml_opt_str(node, 'nat44-customer-address')
    yang.gdata.maybe_add(children, 'nat44-customer-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__nat44_customer_address, child_nat44_customer_address)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'nat44-customer-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__enabled, child_enabled)
    child_nat44_customer_address = yang.gdata.take_json_opt_str(jd, 'nat44-customer-address')
    yang.gdata.maybe_add(children, 'nat44-customer-address', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44__nat44_customer_address, child_nat44_customer_address)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(yang.adata.MNode):
    nat44: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44

    mut def __init__(self, nat44: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.nat44 = nat44 if nat44 is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _nat44 = self.nat44
        if _nat44 is not None:
            children['nat44'] = _nat44.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(nat44=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44.from_gdata(n.get_opt_cnt('nat44')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses/cloud-access/address-translation')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation()')
        leaves = []
        _nat44 = self.nat44
        if _nat44 is not None:
            res.extend(_nat44.prsrc('{self_name}.nat44', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses/cloud-access/address-translation'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_nat44 = yang.gdata.from_xml_opt_cnt(node, 'nat44')
    yang.gdata.maybe_add(children, 'nat44', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44, child_nat44)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'nat44':
            child = {'nat44': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_nat44 = yang.gdata.take_json_opt_cnt(jd, 'nat44')
    yang.gdata.maybe_add(children, 'nat44', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation__nat44, child_nat44)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(yang.adata.MNode):
    cloud_identifier: str
    permit_any: ?bool
    permit_site: list[str]
    deny_site: list[str]
    address_translation: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation

    mut def __init__(self, cloud_identifier: str, permit_any: ?bool, permit_site: ?list[str]=None, deny_site: ?list[str]=None, address_translation: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cloud_identifier = cloud_identifier
        self.permit_any = permit_any
        self.permit_site = permit_site if permit_site is not None else []
        self.deny_site = deny_site if deny_site is not None else []
        self.address_translation = address_translation if address_translation is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cloud_identifier = self.cloud_identifier
        if _cloud_identifier is not None:
            children['cloud-identifier'] = yang.gdata.Leaf('leafref', _cloud_identifier)
        _permit_any = self.permit_any
        if _permit_any is not None:
            children['permit-any'] = yang.gdata.Leaf('empty', _permit_any)
        _permit_site = self.permit_site
        if _permit_site is not None:
            children['permit-site'] = yang.gdata.LeafList('leafref', _permit_site)
        _deny_site = self.deny_site
        if _deny_site is not None:
            children['deny-site'] = yang.gdata.LeafList('leafref', _deny_site)
        _address_translation = self.address_translation
        if _address_translation is not None:
            children['address-translation'] = _address_translation.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(cloud_identifier=n.get_str('cloud-identifier'), permit_any=n.get_opt_empty('permit-any'), permit_site=n.get_opt_strs('permit-site'), deny_site=n.get_opt_strs('deny-site'), address_translation=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation.from_gdata(n.get_opt_cnt('address-translation')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses/cloud-access')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access({repr(self.cloud_identifier)})')
        leaves = []
        _permit_any = self.permit_any
        if _permit_any is not None:
            leaves.append('{self_name}.permit_any = {repr(_permit_any)}')
        _permit_site = self.permit_site
        if _permit_site is not None:
            leaves.append('{self_name}.permit_site = {repr(_permit_site)}')
        _deny_site = self.deny_site
        if _deny_site is not None:
            leaves.append('{self_name}.deny_site = {repr(_deny_site)}')
        _address_translation = self.address_translation
        if _address_translation is not None:
            res.extend(_address_translation.prsrc('{self_name}.address_translation', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses/cloud-access'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'cloud-access'
        self.elements = elements

    mut def create(self, cloud_identifier):
        for e in self.elements:
            match = True
            if e.cloud_identifier != cloud_identifier:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry(cloud_identifier)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['cloud-identifier'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_cloud_identifier = yang.gdata.from_xml_str(node, 'cloud-identifier')
    yang.gdata.maybe_add(children, 'cloud-identifier', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__cloud_identifier, child_cloud_identifier)
    child_permit_any = yang.gdata.from_xml_opt_empty(node, 'permit-any')
    yang.gdata.maybe_add(children, 'permit-any', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_any, child_permit_any)
    child_permit_site = yang.gdata.from_xml_opt_strs(node, 'permit-site')
    yang.gdata.maybe_add(children, 'permit-site', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_site, child_permit_site)
    child_deny_site = yang.gdata.from_xml_opt_strs(node, 'deny-site')
    yang.gdata.maybe_add(children, 'deny-site', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__deny_site, child_deny_site)
    child_address_translation = yang.gdata.from_xml_opt_cnt(node, 'address-translation')
    yang.gdata.maybe_add(children, 'address-translation', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation, child_address_translation)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(e) for e in nodes]
    return yang.gdata.List(keys=['cloud-identifier'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['cloud-identifier']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['cloud-identifier'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__cloud_identifier(keys[0])
        if point == 'permit-any':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'permit-site':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'deny-site':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'address-translation':
            children['address-translation'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['cloud-identifier']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['cloud-identifier'])))
        return yang.gdata.List(['cloud-identifier'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['cloud-identifier'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_cloud_identifier = yang.gdata.take_json_str(jd, 'cloud-identifier')
    yang.gdata.maybe_add(children, 'cloud-identifier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__cloud_identifier, child_cloud_identifier)
    child_permit_any = yang.gdata.take_json_opt_empty(jd, 'permit-any')
    yang.gdata.maybe_add(children, 'permit-any', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_any, child_permit_any)
    child_permit_site = yang.gdata.take_json_opt_strs(jd, 'permit-site')
    yang.gdata.maybe_add(children, 'permit-site', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__permit_site, child_permit_site)
    child_deny_site = yang.gdata.take_json_opt_strs(jd, 'deny-site')
    yang.gdata.maybe_add(children, 'deny-site', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__deny_site, child_deny_site)
    child_address_translation = yang.gdata.take_json_opt_cnt(jd, 'address-translation')
    yang.gdata.maybe_add(children, 'address-translation', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access__address_translation, child_address_translation)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['cloud-identifier'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(yang.adata.MNode):
    cloud_access: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access

    mut def __init__(self, cloud_access: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cloud_access = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(elements=cloud_access)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cloud_access = self.cloud_access
        if _cloud_access is not None:
            children['cloud-access'] = _cloud_access.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(cloud_access=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access.from_gdata(n.get_opt_list('cloud-access')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses()')
        leaves = []
        _cloud_access = self.cloud_access
        for _element in _cloud_access.elements:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-services/vpn-service/cloud-accesses/cloud-access element: {_element.to_gdata().key_str(['cloud-identifier'])}")
            list_elem = 'cloud_access_element = {self_name}.cloud_access.create({repr(_element.cloud_identifier)})'
            res.append(list_elem)
            res.extend(_element.prsrc('cloud_access_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/cloud-accesses'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_cloud_access = yang.gdata.from_xml_opt_list(node, 'cloud-access')
    yang.gdata.maybe_add(children, 'cloud-access', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access, child_cloud_access)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'cloud-access':
            child = {'cloud-access': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cloud_access = yang.gdata.take_json_opt_list(jd, 'cloud-access')
    yang.gdata.maybe_add(children, 'cloud-access', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses__cloud_access, child_cloud_access)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors__tree_flavor(val: list[PartialIdentityref]) -> yang.gdata.LeafList:
    new_val = []
    for v in val:
        nv, error = complete_and_validate_identityref(v, _identities, ['l3vpn-svc:multicast-tree-type'], 'ietf-l3vpn-svc')
        if nv is not None:
            new_val.append(nv)
        else:
            raise ValueError('Invalid value for identityref leaf-list tree-flavor: {error}')
    return yang.gdata.LeafList('identityref', new_val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors__tree_flavor(val: list[PartialIdentityref]) -> yang.gdata.LeafList:
    new_val = []
    for v in val:
        nv, error = complete_and_validate_identityref(v, _identities, ['l3vpn-svc:multicast-tree-type'], 'ietf-l3vpn-svc')
        if nv is not None:
            new_val.append(nv)
        else:
            raise ValueError('Invalid value for identityref leaf-list tree-flavor: {error}')
    return yang.gdata.LeafList('identityref', new_val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(yang.adata.MNode):
    tree_flavor: list[Identityref]

    mut def __init__(self, tree_flavor: ?list[Identityref]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.tree_flavor = tree_flavor if tree_flavor is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _tree_flavor = self.tree_flavor
        if _tree_flavor is not None:
            _identityref_tree_flavor = []
            for v in _tree_flavor:
                nv, error = complete_and_validate_identityref(v, _identities, ['l3vpn-svc:multicast-tree-type'], 'ietf-l3vpn-svc')
                if nv is not None:
                    _identityref_tree_flavor.append(nv)
                else:
                    raise ValueError('Invalid value for identityref leaf-list tree-flavor: {error}')
            _tree_flavor = _identityref_tree_flavor
            children['tree-flavor'] = yang.gdata.LeafList('identityref', _tree_flavor)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(tree_flavor=n.get_opt_Identityrefs('tree-flavor'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/customer-tree-flavors')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors()')
        leaves = []
        _tree_flavor = self.tree_flavor
        if _tree_flavor is not None:
            leaves.append('{self_name}.tree_flavor = {repr(_tree_flavor)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/customer-tree-flavors'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_tree_flavor = yang.gdata.from_xml_opt_Identityrefs(node, 'tree-flavor')
    yang.gdata.maybe_add(children, 'tree-flavor', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors__tree_flavor, child_tree_flavor)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'tree-flavor':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_tree_flavor = yang.gdata.take_json_opt_Identityrefs(jd, 'tree-flavor')
    yang.gdata.maybe_add(children, 'tree-flavor', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors__tree_flavor, child_tree_flavor)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__rp_redundancy(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__rp_redundancy(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__optimal_traffic_delivery(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__optimal_traffic_delivery(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(yang.adata.MNode):
    enabled: bool
    rp_redundancy: bool
    optimal_traffic_delivery: bool

    mut def __init__(self, enabled: ?bool=None, rp_redundancy: ?bool=None, optimal_traffic_delivery: ?bool=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.rp_redundancy = rp_redundancy if rp_redundancy is not None else False
        self.optimal_traffic_delivery = optimal_traffic_delivery if optimal_traffic_delivery is not None else False

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _rp_redundancy = self.rp_redundancy
        if _rp_redundancy is not None:
            children['rp-redundancy'] = yang.gdata.Leaf('boolean', _rp_redundancy)
        _optimal_traffic_delivery = self.optimal_traffic_delivery
        if _optimal_traffic_delivery is not None:
            children['optimal-traffic-delivery'] = yang.gdata.Leaf('boolean', _optimal_traffic_delivery)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(enabled=n.get_opt_bool('enabled'), rp_redundancy=n.get_opt_bool('rp-redundancy'), optimal_traffic_delivery=n.get_opt_bool('optimal-traffic-delivery'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping/provider-managed')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed()')
        leaves = []
        _enabled = self.enabled
        if _enabled is not None:
            leaves.append('{self_name}.enabled = {repr(_enabled)}')
        _rp_redundancy = self.rp_redundancy
        if _rp_redundancy is not None:
            leaves.append('{self_name}.rp_redundancy = {repr(_rp_redundancy)}')
        _optimal_traffic_delivery = self.optimal_traffic_delivery
        if _optimal_traffic_delivery is not None:
            leaves.append('{self_name}.optimal_traffic_delivery = {repr(_optimal_traffic_delivery)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping/provider-managed'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.from_xml_opt_bool(node, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__enabled, child_enabled)
    child_rp_redundancy = yang.gdata.from_xml_opt_bool(node, 'rp-redundancy')
    yang.gdata.maybe_add(children, 'rp-redundancy', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__rp_redundancy, child_rp_redundancy)
    child_optimal_traffic_delivery = yang.gdata.from_xml_opt_bool(node, 'optimal-traffic-delivery')
    yang.gdata.maybe_add(children, 'optimal-traffic-delivery', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__optimal_traffic_delivery, child_optimal_traffic_delivery)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'rp-redundancy':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'optimal-traffic-delivery':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__enabled, child_enabled)
    child_rp_redundancy = yang.gdata.take_json_opt_bool(jd, 'rp-redundancy')
    yang.gdata.maybe_add(children, 'rp-redundancy', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__rp_redundancy, child_rp_redundancy)
    child_optimal_traffic_delivery = yang.gdata.take_json_opt_bool(jd, 'optimal-traffic-delivery')
    yang.gdata.maybe_add(children, 'optimal-traffic-delivery', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed__optimal_traffic_delivery, child_optimal_traffic_delivery)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__rp_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__rp_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_start(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_start(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(yang.adata.MNode):
    id: int
    group_address: ?str
    group_start: ?str
    group_end: ?str

    mut def __init__(self, id: int, group_address: ?str, group_start: ?str, group_end: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.group_address = group_address
        self.group_start = group_start
        self.group_end = group_end

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint16', _id)
        _group_address = self.group_address
        if _group_address is not None:
            children['group-address'] = yang.gdata.Leaf('union', _group_address)
        _group_start = self.group_start
        if _group_start is not None:
            children['group-start'] = yang.gdata.Leaf('union', _group_start)
        _group_end = self.group_end
        if _group_end is not None:
            children['group-end'] = yang.gdata.Leaf('union', _group_end)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(id=n.get_int('id'), group_address=n.get_opt_str('group-address'), group_start=n.get_opt_str('group-start'), group_end=n.get_opt_str('group-end'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping/groups/group')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group({repr(self.id)})')
        leaves = []
        _group_address = self.group_address
        if _group_address is not None:
            leaves.append('{self_name}.group_address = {repr(_group_address)}')
        _group_start = self.group_start
        if _group_start is not None:
            leaves.append('{self_name}.group_start = {repr(_group_start)}')
        _group_end = self.group_end
        if _group_end is not None:
            leaves.append('{self_name}.group_end = {repr(_group_end)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping/groups/group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_int(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__id, child_id)
    child_group_address = yang.gdata.from_xml_opt_str(node, 'group-address')
    yang.gdata.maybe_add(children, 'group-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_address, child_group_address)
    child_group_start = yang.gdata.from_xml_opt_str(node, 'group-start')
    yang.gdata.maybe_add(children, 'group-start', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_start, child_group_start)
    child_group_end = yang.gdata.from_xml_opt_str(node, 'group-end')
    yang.gdata.maybe_add(children, 'group-end', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_end, child_group_end)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__id(keys[0])
        if point == 'group-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'group-start':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'group-end':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_int(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__id, child_id)
    child_group_address = yang.gdata.take_json_opt_str(jd, 'group-address')
    yang.gdata.maybe_add(children, 'group-address', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_address, child_group_address)
    child_group_start = yang.gdata.take_json_opt_str(jd, 'group-start')
    yang.gdata.maybe_add(children, 'group-start', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_start, child_group_start)
    child_group_end = yang.gdata.take_json_opt_str(jd, 'group-end')
    yang.gdata.maybe_add(children, 'group-end', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group__group_end, child_group_end)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(elements=group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(group=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group.from_gdata(n.get_opt_list('group')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping/groups')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups()')
        leaves = []
        _group = self.group
        for _element in _group.elements:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping/groups/group element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'group_element = {self_name}.group.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('group_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping/groups'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.from_xml_opt_list(node, 'group')
    yang.gdata.maybe_add(children, 'group', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group, child_group)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.take_json_opt_list(jd, 'group')
    yang.gdata.maybe_add(children, 'group', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups__group, child_group)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(yang.adata.MNode):
    id: int
    provider_managed: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed
    rp_address: str
    groups: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups

    mut def __init__(self, id: int, rp_address: str, provider_managed: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed=None, groups: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.provider_managed = provider_managed if provider_managed is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed()
        self.rp_address = rp_address
        self.groups = groups if groups is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint16', _id)
        _provider_managed = self.provider_managed
        if _provider_managed is not None:
            children['provider-managed'] = _provider_managed.to_gdata()
        _rp_address = self.rp_address
        if _rp_address is not None:
            children['rp-address'] = yang.gdata.Leaf('union', _rp_address)
        _groups = self.groups
        if _groups is not None:
            children['groups'] = _groups.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(id=n.get_int('id'), provider_managed=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed.from_gdata(n.get_opt_cnt('provider-managed')), rp_address=n.get_str('rp-address'), groups=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups.from_gdata(n.get_opt_cnt('groups')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping({repr(self.id)}, {repr(self.rp_address)})')
        leaves = []
        _provider_managed = self.provider_managed
        if _provider_managed is not None:
            res.extend(_provider_managed.prsrc('{self_name}.provider_managed', False).splitlines())
        _groups = self.groups
        if _groups is not None:
            res.extend(_groups.prsrc('{self_name}.groups', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'rp-group-mapping'
        self.elements = elements

    mut def create(self, id, rp_address):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry(id, rp_address)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_int(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__id, child_id)
    child_provider_managed = yang.gdata.from_xml_opt_cnt(node, 'provider-managed')
    yang.gdata.maybe_add(children, 'provider-managed', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed, child_provider_managed)
    child_rp_address = yang.gdata.from_xml_str(node, 'rp-address')
    yang.gdata.maybe_add(children, 'rp-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__rp_address, child_rp_address)
    child_groups = yang.gdata.from_xml_opt_cnt(node, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups, child_groups)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__id(keys[0])
        if point == 'provider-managed':
            children['provider-managed'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed(jd, rest_path, op)
        if point == 'rp-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'groups':
            children['groups'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_int(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__id, child_id)
    child_provider_managed = yang.gdata.take_json_opt_cnt(jd, 'provider-managed')
    yang.gdata.maybe_add(children, 'provider-managed', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__provider_managed, child_provider_managed)
    child_rp_address = yang.gdata.take_json_str(jd, 'rp-address')
    yang.gdata.maybe_add(children, 'rp-address', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__rp_address, child_rp_address)
    child_groups = yang.gdata.take_json_opt_cnt(jd, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping__groups, child_groups)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(yang.adata.MNode):
    rp_group_mapping: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping

    mut def __init__(self, rp_group_mapping: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rp_group_mapping = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(elements=rp_group_mapping)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rp_group_mapping = self.rp_group_mapping
        if _rp_group_mapping is not None:
            children['rp-group-mapping'] = _rp_group_mapping.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(rp_group_mapping=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping.from_gdata(n.get_opt_list('rp-group-mapping')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings()')
        leaves = []
        _rp_group_mapping = self.rp_group_mapping
        for _element in _rp_group_mapping.elements:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings/rp-group-mapping element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'rp_group_mapping_element = {self_name}.rp_group_mapping.create({repr(_element.id)}, {repr(_element.rp_address)})'
            res.append(list_elem)
            res.extend(_element.prsrc('rp_group_mapping_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-group-mappings'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_rp_group_mapping = yang.gdata.from_xml_opt_list(node, 'rp-group-mapping')
    yang.gdata.maybe_add(children, 'rp-group-mapping', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping, child_rp_group_mapping)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'rp-group-mapping':
            child = {'rp-group-mapping': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rp_group_mapping = yang.gdata.take_json_opt_list(jd, 'rp-group-mapping')
    yang.gdata.maybe_add(children, 'rp-group-mapping', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings__rp_group_mapping, child_rp_group_mapping)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__rp_discovery_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:multicast-rp-discovery-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf rp-discovery-type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__rp_discovery_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:multicast-rp-discovery-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf rp-discovery-type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates__bsr_candidate_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates__bsr_candidate_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('union', val)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(yang.adata.MNode):
    bsr_candidate_address: list[str]

    mut def __init__(self, bsr_candidate_address: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.bsr_candidate_address = bsr_candidate_address if bsr_candidate_address is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _bsr_candidate_address = self.bsr_candidate_address
        if _bsr_candidate_address is not None:
            children['bsr-candidate-address'] = yang.gdata.LeafList('union', _bsr_candidate_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(bsr_candidate_address=n.get_opt_strs('bsr-candidate-address'))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-discovery/bsr-candidates')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates()')
        leaves = []
        _bsr_candidate_address = self.bsr_candidate_address
        if _bsr_candidate_address is not None:
            leaves.append('{self_name}.bsr_candidate_address = {repr(_bsr_candidate_address)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-discovery/bsr-candidates'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_bsr_candidate_address = yang.gdata.from_xml_opt_strs(node, 'bsr-candidate-address')
    yang.gdata.maybe_add(children, 'bsr-candidate-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates__bsr_candidate_address, child_bsr_candidate_address)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'bsr-candidate-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_bsr_candidate_address = yang.gdata.take_json_opt_strs(jd, 'bsr-candidate-address')
    yang.gdata.maybe_add(children, 'bsr-candidate-address', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates__bsr_candidate_address, child_bsr_candidate_address)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(yang.adata.MNode):
    rp_discovery_type: Identityref
    bsr_candidates: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates

    mut def __init__(self, rp_discovery_type: ?Identityref=None, bsr_candidates: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        _default_rp_discovery_type, error = complete_and_validate_identityref(Identityref.from_adata('static-rp'), _identities, ['l3vpn-svc:multicast-rp-discovery-type'], 'ietf-l3vpn-svc')
        if _default_rp_discovery_type is not None:
            self.rp_discovery_type = rp_discovery_type if rp_discovery_type is not None else _default_rp_discovery_type
        else:
            raise ValueError('Invalid default value for identityref leaf rp-discovery: {error}')
        self.bsr_candidates = bsr_candidates if bsr_candidates is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rp_discovery_type = self.rp_discovery_type
        if _rp_discovery_type is not None:
            _identityref_rp_discovery_type, error = complete_and_validate_identityref(_rp_discovery_type, _identities, ['l3vpn-svc:multicast-rp-discovery-type'], 'ietf-l3vpn-svc')
            if _identityref_rp_discovery_type is not None:
                _rp_discovery_type = _identityref_rp_discovery_type
            else:
                raise ValueError('Invalid value for identityref leaf rp-discovery-type: {error}')
            children['rp-discovery-type'] = yang.gdata.Leaf('identityref', _rp_discovery_type)
        _bsr_candidates = self.bsr_candidates
        if _bsr_candidates is not None:
            children['bsr-candidates'] = _bsr_candidates.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(rp_discovery_type=n.get_opt_Identityref('rp-discovery-type'), bsr_candidates=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates.from_gdata(n.get_opt_cnt('bsr-candidates')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-discovery')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery()')
        leaves = []
        _rp_discovery_type = self.rp_discovery_type
        if _rp_discovery_type is not None:
            leaves.append('{self_name}.rp_discovery_type = {repr(_rp_discovery_type)}')
        _bsr_candidates = self.bsr_candidates
        if _bsr_candidates is not None:
            res.extend(_bsr_candidates.prsrc('{self_name}.bsr_candidates', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp/rp-discovery'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_rp_discovery_type = yang.gdata.from_xml_opt_Identityref(node, 'rp-discovery-type')
    yang.gdata.maybe_add(children, 'rp-discovery-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__rp_discovery_type, child_rp_discovery_type)
    child_bsr_candidates = yang.gdata.from_xml_opt_cnt(node, 'bsr-candidates')
    yang.gdata.maybe_add(children, 'bsr-candidates', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates, child_bsr_candidates)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'rp-discovery-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bsr-candidates':
            child = {'bsr-candidates': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rp_discovery_type = yang.gdata.take_json_opt_Identityref(jd, 'rp-discovery-type')
    yang.gdata.maybe_add(children, 'rp-discovery-type', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__rp_discovery_type, child_rp_discovery_type)
    child_bsr_candidates = yang.gdata.take_json_opt_cnt(jd, 'bsr-candidates')
    yang.gdata.maybe_add(children, 'bsr-candidates', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery__bsr_candidates, child_bsr_candidates)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(yang.adata.MNode):
    rp_group_mappings: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings
    rp_discovery: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery

    mut def __init__(self, rp_group_mappings: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings=None, rp_discovery: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rp_group_mappings = rp_group_mappings if rp_group_mappings is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings()
        self.rp_discovery = rp_discovery if rp_discovery is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rp_group_mappings = self.rp_group_mappings
        if _rp_group_mappings is not None:
            children['rp-group-mappings'] = _rp_group_mappings.to_gdata()
        _rp_discovery = self.rp_discovery
        if _rp_discovery is not None:
            children['rp-discovery'] = _rp_discovery.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(rp_group_mappings=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings.from_gdata(n.get_opt_cnt('rp-group-mappings')), rp_discovery=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery.from_gdata(n.get_opt_cnt('rp-discovery')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast/rp')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp()')
        leaves = []
        _rp_group_mappings = self.rp_group_mappings
        if _rp_group_mappings is not None:
            res.extend(_rp_group_mappings.prsrc('{self_name}.rp_group_mappings', False).splitlines())
        _rp_discovery = self.rp_discovery
        if _rp_discovery is not None:
            res.extend(_rp_discovery.prsrc('{self_name}.rp_discovery', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast/rp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_rp_group_mappings = yang.gdata.from_xml_opt_cnt(node, 'rp-group-mappings')
    yang.gdata.maybe_add(children, 'rp-group-mappings', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings, child_rp_group_mappings)
    child_rp_discovery = yang.gdata.from_xml_opt_cnt(node, 'rp-discovery')
    yang.gdata.maybe_add(children, 'rp-discovery', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery, child_rp_discovery)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'rp-group-mappings':
            child = {'rp-group-mappings': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'rp-discovery':
            child = {'rp-discovery': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rp_group_mappings = yang.gdata.take_json_opt_cnt(jd, 'rp-group-mappings')
    yang.gdata.maybe_add(children, 'rp-group-mappings', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_group_mappings, child_rp_group_mappings)
    child_rp_discovery = yang.gdata.take_json_opt_cnt(jd, 'rp-discovery')
    yang.gdata.maybe_add(children, 'rp-discovery', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp__rp_discovery, child_rp_discovery)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(yang.adata.MNode):
    enabled: bool
    customer_tree_flavors: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors
    rp: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp

    mut def __init__(self, enabled: ?bool=None, customer_tree_flavors: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors=None, rp: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.customer_tree_flavors = customer_tree_flavors if customer_tree_flavors is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors()
        self.rp = rp if rp is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _customer_tree_flavors = self.customer_tree_flavors
        if _customer_tree_flavors is not None:
            children['customer-tree-flavors'] = _customer_tree_flavors.to_gdata()
        _rp = self.rp
        if _rp is not None:
            children['rp'] = _rp.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(enabled=n.get_opt_bool('enabled'), customer_tree_flavors=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors.from_gdata(n.get_opt_cnt('customer-tree-flavors')), rp=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp.from_gdata(n.get_opt_cnt('rp')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/multicast')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast()')
        leaves = []
        _enabled = self.enabled
        if _enabled is not None:
            leaves.append('{self_name}.enabled = {repr(_enabled)}')
        _customer_tree_flavors = self.customer_tree_flavors
        if _customer_tree_flavors is not None:
            res.extend(_customer_tree_flavors.prsrc('{self_name}.customer_tree_flavors', False).splitlines())
        _rp = self.rp
        if _rp is not None:
            res.extend(_rp.prsrc('{self_name}.rp', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/multicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.from_xml_opt_bool(node, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__enabled, child_enabled)
    child_customer_tree_flavors = yang.gdata.from_xml_opt_cnt(node, 'customer-tree-flavors')
    yang.gdata.maybe_add(children, 'customer-tree-flavors', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors, child_customer_tree_flavors)
    child_rp = yang.gdata.from_xml_opt_cnt(node, 'rp')
    yang.gdata.maybe_add(children, 'rp', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp, child_rp)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-tree-flavors':
            child = {'customer-tree-flavors': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'rp':
            child = {'rp': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__enabled, child_enabled)
    child_customer_tree_flavors = yang.gdata.take_json_opt_cnt(jd, 'customer-tree-flavors')
    yang.gdata.maybe_add(children, 'customer-tree-flavors', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__customer_tree_flavors, child_customer_tree_flavors)
    child_rp = yang.gdata.take_json_opt_cnt(jd, 'rp')
    yang.gdata.maybe_add(children, 'rp', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast__rp, child_rp)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__carrierscarrier(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__carrierscarrier(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__local_sites_role(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf local-sites-role: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__local_sites_role(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf local-sites-role: {error}')

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(yang.adata.MNode):
    vpn_id: str
    local_sites_role: Identityref

    mut def __init__(self, vpn_id: str, local_sites_role: ?Identityref=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_id = vpn_id
        _default_local_sites_role, error = complete_and_validate_identityref(Identityref.from_adata('any-to-any-role'), _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
        if _default_local_sites_role is not None:
            self.local_sites_role = local_sites_role if local_sites_role is not None else _default_local_sites_role
        else:
            raise ValueError('Invalid default value for identityref leaf extranet-vpn: {error}')

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('string', _vpn_id)
        _local_sites_role = self.local_sites_role
        if _local_sites_role is not None:
            _identityref_local_sites_role, error = complete_and_validate_identityref(_local_sites_role, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
            if _identityref_local_sites_role is not None:
                _local_sites_role = _identityref_local_sites_role
            else:
                raise ValueError('Invalid value for identityref leaf local-sites-role: {error}')
            children['local-sites-role'] = yang.gdata.Leaf('identityref', _local_sites_role)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(vpn_id=n.get_str('vpn-id'), local_sites_role=n.get_opt_Identityref('local-sites-role'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/extranet-vpns/extranet-vpn')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn({repr(self.vpn_id)})')
        leaves = []
        _local_sites_role = self.local_sites_role
        if _local_sites_role is not None:
            leaves.append('{self_name}.local_sites_role = {repr(_local_sites_role)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/extranet-vpns/extranet-vpn'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'extranet-vpn'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self.elements:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry(vpn_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.from_xml_str(node, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__vpn_id, child_vpn_id)
    child_local_sites_role = yang.gdata.from_xml_opt_Identityref(node, 'local-sites-role')
    yang.gdata.maybe_add(children, 'local-sites-role', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__local_sites_role, child_local_sites_role)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(e) for e in nodes]
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['vpn-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['vpn-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__vpn_id(keys[0])
        if point == 'local-sites-role':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['vpn-id'])))
        return yang.gdata.List(['vpn-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.take_json_str(jd, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__vpn_id, child_vpn_id)
    child_local_sites_role = yang.gdata.take_json_opt_Identityref(jd, 'local-sites-role')
    yang.gdata.maybe_add(children, 'local-sites-role', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn__local_sites_role, child_local_sites_role)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(yang.adata.MNode):
    extranet_vpn: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn

    mut def __init__(self, extranet_vpn: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.extranet_vpn = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(elements=extranet_vpn)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _extranet_vpn = self.extranet_vpn
        if _extranet_vpn is not None:
            children['extranet-vpn'] = _extranet_vpn.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(extranet_vpn=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn.from_gdata(n.get_opt_list('extranet-vpn')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service/extranet-vpns')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns()')
        leaves = []
        _extranet_vpn = self.extranet_vpn
        for _element in _extranet_vpn.elements:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-services/vpn-service/extranet-vpns/extranet-vpn element: {_element.to_gdata().key_str(['vpn-id'])}")
            list_elem = 'extranet_vpn_element = {self_name}.extranet_vpn.create({repr(_element.vpn_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('extranet_vpn_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service/extranet-vpns'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_extranet_vpn = yang.gdata.from_xml_opt_list(node, 'extranet-vpn')
    yang.gdata.maybe_add(children, 'extranet-vpn', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn, child_extranet_vpn)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'extranet-vpn':
            child = {'extranet-vpn': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_extranet_vpn = yang.gdata.take_json_opt_list(jd, 'extranet-vpn')
    yang.gdata.maybe_add(children, 'extranet-vpn', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns__extranet_vpn, child_extranet_vpn)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(yang.adata.MNode):
    vpn_id: str
    customer_name: ?str
    vpn_service_topology: Identityref
    cloud_accesses: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses
    multicast: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast
    carrierscarrier: bool
    extranet_vpns: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns

    mut def __init__(self, vpn_id: str, customer_name: ?str, vpn_service_topology: ?Identityref=None, cloud_accesses: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses=None, multicast: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast=None, carrierscarrier: ?bool=None, extranet_vpns: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_id = vpn_id
        self.customer_name = customer_name
        _default_vpn_service_topology, error = complete_and_validate_identityref(Identityref.from_adata('any-to-any'), _identities, ['l3vpn-svc:vpn-topology'], 'ietf-l3vpn-svc')
        if _default_vpn_service_topology is not None:
            self.vpn_service_topology = vpn_service_topology if vpn_service_topology is not None else _default_vpn_service_topology
        else:
            raise ValueError('Invalid default value for identityref leaf vpn-service: {error}')
        self.cloud_accesses = cloud_accesses if cloud_accesses is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses()
        self.multicast = multicast if multicast is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast()
        self.carrierscarrier = carrierscarrier if carrierscarrier is not None else False
        self.extranet_vpns = extranet_vpns if extranet_vpns is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('string', _vpn_id)
        _customer_name = self.customer_name
        if _customer_name is not None:
            children['customer-name'] = yang.gdata.Leaf('string', _customer_name)
        _vpn_service_topology = self.vpn_service_topology
        if _vpn_service_topology is not None:
            _identityref_vpn_service_topology, error = complete_and_validate_identityref(_vpn_service_topology, _identities, ['l3vpn-svc:vpn-topology'], 'ietf-l3vpn-svc')
            if _identityref_vpn_service_topology is not None:
                _vpn_service_topology = _identityref_vpn_service_topology
            else:
                raise ValueError('Invalid value for identityref leaf vpn-service-topology: {error}')
            children['vpn-service-topology'] = yang.gdata.Leaf('identityref', _vpn_service_topology)
        _cloud_accesses = self.cloud_accesses
        if _cloud_accesses is not None:
            children['cloud-accesses'] = _cloud_accesses.to_gdata()
        _multicast = self.multicast
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        _carrierscarrier = self.carrierscarrier
        if _carrierscarrier is not None:
            children['carrierscarrier'] = yang.gdata.Leaf('boolean', _carrierscarrier)
        _extranet_vpns = self.extranet_vpns
        if _extranet_vpns is not None:
            children['extranet-vpns'] = _extranet_vpns.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry:
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(vpn_id=n.get_str('vpn-id'), customer_name=n.get_opt_str('customer-name'), vpn_service_topology=n.get_opt_Identityref('vpn-service-topology'), cloud_accesses=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses.from_gdata(n.get_opt_cnt('cloud-accesses')), multicast=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast.from_gdata(n.get_opt_cnt('multicast')), carrierscarrier=n.get_opt_bool('carrierscarrier'), extranet_vpns=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns.from_gdata(n.get_opt_cnt('extranet-vpns')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services/vpn-service')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service({repr(self.vpn_id)})')
        leaves = []
        _customer_name = self.customer_name
        if _customer_name is not None:
            leaves.append('{self_name}.customer_name = {repr(_customer_name)}')
        _vpn_service_topology = self.vpn_service_topology
        if _vpn_service_topology is not None:
            leaves.append('{self_name}.vpn_service_topology = {repr(_vpn_service_topology)}')
        _cloud_accesses = self.cloud_accesses
        if _cloud_accesses is not None:
            res.extend(_cloud_accesses.prsrc('{self_name}.cloud_accesses', False).splitlines())
        _multicast = self.multicast
        if _multicast is not None:
            res.extend(_multicast.prsrc('{self_name}.multicast', False).splitlines())
        _carrierscarrier = self.carrierscarrier
        if _carrierscarrier is not None:
            leaves.append('{self_name}.carrierscarrier = {repr(_carrierscarrier)}')
        _extranet_vpns = self.extranet_vpns
        if _extranet_vpns is not None:
            res.extend(_extranet_vpns.prsrc('{self_name}.extranet_vpns', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services/vpn-service'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'vpn-service'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self.elements:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry(vpn_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.from_xml_str(node, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_id, child_vpn_id)
    child_customer_name = yang.gdata.from_xml_opt_str(node, 'customer-name')
    yang.gdata.maybe_add(children, 'customer-name', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__customer_name, child_customer_name)
    child_vpn_service_topology = yang.gdata.from_xml_opt_Identityref(node, 'vpn-service-topology')
    yang.gdata.maybe_add(children, 'vpn-service-topology', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_service_topology, child_vpn_service_topology)
    child_cloud_accesses = yang.gdata.from_xml_opt_cnt(node, 'cloud-accesses')
    yang.gdata.maybe_add(children, 'cloud-accesses', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses, child_cloud_accesses)
    child_multicast = yang.gdata.from_xml_opt_cnt(node, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast, child_multicast)
    child_carrierscarrier = yang.gdata.from_xml_opt_bool(node, 'carrierscarrier')
    yang.gdata.maybe_add(children, 'carrierscarrier', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__carrierscarrier, child_carrierscarrier)
    child_extranet_vpns = yang.gdata.from_xml_opt_cnt(node, 'extranet-vpns')
    yang.gdata.maybe_add(children, 'extranet-vpns', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns, child_extranet_vpns)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(e) for e in nodes]
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['vpn-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['vpn-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_id(keys[0])
        if point == 'customer-name':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'vpn-service-topology':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'cloud-accesses':
            children['cloud-accesses'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses(jd, rest_path, op)
        if point == 'multicast':
            children['multicast'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast(jd, rest_path, op)
        if point == 'carrierscarrier':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'extranet-vpns':
            children['extranet-vpns'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['vpn-id'])))
        return yang.gdata.List(['vpn-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.take_json_str(jd, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_id, child_vpn_id)
    child_customer_name = yang.gdata.take_json_opt_str(jd, 'customer-name')
    yang.gdata.maybe_add(children, 'customer-name', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__customer_name, child_customer_name)
    child_vpn_service_topology = yang.gdata.take_json_opt_Identityref(jd, 'vpn-service-topology')
    yang.gdata.maybe_add(children, 'vpn-service-topology', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__vpn_service_topology, child_vpn_service_topology)
    child_cloud_accesses = yang.gdata.take_json_opt_cnt(jd, 'cloud-accesses')
    yang.gdata.maybe_add(children, 'cloud-accesses', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__cloud_accesses, child_cloud_accesses)
    child_multicast = yang.gdata.take_json_opt_cnt(jd, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__multicast, child_multicast)
    child_carrierscarrier = yang.gdata.take_json_opt_bool(jd, 'carrierscarrier')
    yang.gdata.maybe_add(children, 'carrierscarrier', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__carrierscarrier, child_carrierscarrier)
    child_extranet_vpns = yang.gdata.take_json_opt_cnt(jd, 'extranet-vpns')
    yang.gdata.maybe_add(children, 'extranet-vpns', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service__extranet_vpns, child_extranet_vpns)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__vpn_services(yang.adata.MNode):
    vpn_service: ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service

    mut def __init__(self, vpn_service: list[ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_service = ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(elements=vpn_service)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_service = self.vpn_service
        if _vpn_service is not None:
            children['vpn-service'] = _vpn_service.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__vpn_services:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__vpn_services(vpn_service=ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service.from_gdata(n.get_opt_list('vpn-service')))
        return ietf_l3vpn_svc__l3vpn_svc__vpn_services()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/vpn-services')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__vpn_services()')
        leaves = []
        _vpn_service = self.vpn_service
        for _element in _vpn_service.elements:
            res.append('')
            res.append("# List /l3vpn-svc/vpn-services/vpn-service element: {_element.to_gdata().key_str(['vpn-id'])}")
            list_elem = 'vpn_service_element = {self_name}.vpn_service.create({repr(_element.vpn_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('vpn_service_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/vpn-services'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_vpn_service = yang.gdata.from_xml_opt_list(node, 'vpn-service')
    yang.gdata.maybe_add(children, 'vpn-service', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service, child_vpn_service)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'vpn-service':
            child = {'vpn-service': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_service = yang.gdata.take_json_opt_list(jd, 'vpn-service')
    yang.gdata.maybe_add(children, 'vpn-service', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services__vpn_service, child_vpn_service)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_start(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_start(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_stop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_stop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__location_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__location_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__postal_code(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__postal_code(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__city(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__city(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__country_code(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__country_code(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(yang.adata.MNode):
    location_id: str
    address: ?str
    postal_code: ?str
    state: ?str
    city: ?str
    country_code: ?str

    mut def __init__(self, location_id: str, address: ?str, postal_code: ?str, state: ?str, city: ?str, country_code: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.location_id = location_id
        self.address = address
        self.postal_code = postal_code
        self.state = state
        self.city = city
        self.country_code = country_code

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _location_id = self.location_id
        if _location_id is not None:
            children['location-id'] = yang.gdata.Leaf('string', _location_id)
        _address = self.address
        if _address is not None:
            children['address'] = yang.gdata.Leaf('string', _address)
        _postal_code = self.postal_code
        if _postal_code is not None:
            children['postal-code'] = yang.gdata.Leaf('string', _postal_code)
        _state = self.state
        if _state is not None:
            children['state'] = yang.gdata.Leaf('string', _state)
        _city = self.city
        if _city is not None:
            children['city'] = yang.gdata.Leaf('string', _city)
        _country_code = self.country_code
        if _country_code is not None:
            children['country-code'] = yang.gdata.Leaf('string', _country_code)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(location_id=n.get_str('location-id'), address=n.get_opt_str('address'), postal_code=n.get_opt_str('postal-code'), state=n.get_opt_str('state'), city=n.get_opt_str('city'), country_code=n.get_opt_str('country-code'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/locations/location')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location({repr(self.location_id)})')
        leaves = []
        _address = self.address
        if _address is not None:
            leaves.append('{self_name}.address = {repr(_address)}')
        _postal_code = self.postal_code
        if _postal_code is not None:
            leaves.append('{self_name}.postal_code = {repr(_postal_code)}')
        _state = self.state
        if _state is not None:
            leaves.append('{self_name}.state = {repr(_state)}')
        _city = self.city
        if _city is not None:
            leaves.append('{self_name}.city = {repr(_city)}')
        _country_code = self.country_code
        if _country_code is not None:
            leaves.append('{self_name}.country_code = {repr(_country_code)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/locations/location'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'location'
        self.elements = elements

    mut def create(self, location_id):
        for e in self.elements:
            match = True
            if e.location_id != location_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry(location_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['location-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_location_id = yang.gdata.from_xml_str(node, 'location-id')
    yang.gdata.maybe_add(children, 'location-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__location_id, child_location_id)
    child_address = yang.gdata.from_xml_opt_str(node, 'address')
    yang.gdata.maybe_add(children, 'address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__address, child_address)
    child_postal_code = yang.gdata.from_xml_opt_str(node, 'postal-code')
    yang.gdata.maybe_add(children, 'postal-code', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__postal_code, child_postal_code)
    child_state = yang.gdata.from_xml_opt_str(node, 'state')
    yang.gdata.maybe_add(children, 'state', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__state, child_state)
    child_city = yang.gdata.from_xml_opt_str(node, 'city')
    yang.gdata.maybe_add(children, 'city', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__city, child_city)
    child_country_code = yang.gdata.from_xml_opt_str(node, 'country-code')
    yang.gdata.maybe_add(children, 'country-code', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__country_code, child_country_code)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(e) for e in nodes]
    return yang.gdata.List(keys=['location-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['location-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['location-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__location_id(keys[0])
        if point == 'address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'postal-code':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'state':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'city':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'country-code':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['location-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['location-id'])))
        return yang.gdata.List(['location-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['location-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_location_id = yang.gdata.take_json_str(jd, 'location-id')
    yang.gdata.maybe_add(children, 'location-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__location_id, child_location_id)
    child_address = yang.gdata.take_json_opt_str(jd, 'address')
    yang.gdata.maybe_add(children, 'address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__address, child_address)
    child_postal_code = yang.gdata.take_json_opt_str(jd, 'postal-code')
    yang.gdata.maybe_add(children, 'postal-code', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__postal_code, child_postal_code)
    child_state = yang.gdata.take_json_opt_str(jd, 'state')
    yang.gdata.maybe_add(children, 'state', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__state, child_state)
    child_city = yang.gdata.take_json_opt_str(jd, 'city')
    yang.gdata.maybe_add(children, 'city', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__city, child_city)
    child_country_code = yang.gdata.take_json_opt_str(jd, 'country-code')
    yang.gdata.maybe_add(children, 'country-code', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location__country_code, child_country_code)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['location-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(yang.adata.MNode):
    location: ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location

    mut def __init__(self, location: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.location = ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(elements=location)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _location = self.location
        if _location is not None:
            children['location'] = _location.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__locations:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(location=ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location.from_gdata(n.get_opt_list('location')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__locations()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/locations')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__locations()')
        leaves = []
        _location = self.location
        for _element in _location.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/locations/location element: {_element.to_gdata().key_str(['location-id'])}")
            list_elem = 'location_element = {self_name}.location.create({repr(_element.location_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('location_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/locations'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_location = yang.gdata.from_xml_opt_list(node, 'location')
    yang.gdata.maybe_add(children, 'location', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location, child_location)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'location':
            child = {'location': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_location = yang.gdata.take_json_opt_list(jd, 'location')
    yang.gdata.maybe_add(children, 'location', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations__location, child_location)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__device_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__device_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__location(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__location(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address_family(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address_family(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(yang.adata.MNode):
    address_family: ?str
    address: str

    mut def __init__(self, address: str, address_family: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family
        self.address = address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.Leaf('enumeration', _address_family)
        _address = self.address
        if _address is not None:
            children['address'] = yang.gdata.Leaf('union', _address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(address_family=n.get_opt_str('address-family'), address=n.get_str('address'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/devices/device/management')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management({repr(self.address)})')
        leaves = []
        _address_family = self.address_family
        if _address_family is not None:
            leaves.append('{self_name}.address_family = {repr(_address_family)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/devices/device/management'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_opt_str(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address_family, child_address_family)
    child_address = yang.gdata.from_xml_str(node, 'address')
    yang.gdata.maybe_add(children, 'address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address, child_address)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_opt_str(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address_family, child_address_family)
    child_address = yang.gdata.take_json_str(jd, 'address')
    yang.gdata.maybe_add(children, 'address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management__address, child_address)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(yang.adata.MNode):
    device_id: str
    location: str
    management: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management

    mut def __init__(self, device_id: str, location: str, management: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.device_id = device_id
        self.location = location
        self.management = management

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _device_id = self.device_id
        if _device_id is not None:
            children['device-id'] = yang.gdata.Leaf('string', _device_id)
        _location = self.location
        if _location is not None:
            children['location'] = yang.gdata.Leaf('leafref', _location)
        _management = self.management
        if _management is not None:
            children['management'] = _management.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(device_id=n.get_str('device-id'), location=n.get_str('location'), management=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management.from_gdata(n.get_cnt('management')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/devices/device')
            res.append('self_management = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management({repr(self.management.address)})')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device({repr(self.device_id)}, {repr(self.location)}, self_management)')
        leaves = []
        _management = self.management
        if _management is not None:
            res.extend(_management.prsrc('{self_name}.management', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/devices/device'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'device'
        self.elements = elements

    mut def create(self, device_id, location, management):
        for e in self.elements:
            match = True
            if e.device_id != device_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry(device_id, location, management)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['device-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_device_id = yang.gdata.from_xml_str(node, 'device-id')
    yang.gdata.maybe_add(children, 'device-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__device_id, child_device_id)
    child_location = yang.gdata.from_xml_str(node, 'location')
    yang.gdata.maybe_add(children, 'location', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__location, child_location)
    child_management = yang.gdata.from_xml_cnt(node, 'management')
    yang.gdata.maybe_add(children, 'management', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management, child_management)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(e) for e in nodes]
    return yang.gdata.List(keys=['device-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['device-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['device-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__device_id(keys[0])
        if point == 'location':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'management':
            children['management'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['device-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['device-id'])))
        return yang.gdata.List(['device-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['device-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_device_id = yang.gdata.take_json_str(jd, 'device-id')
    yang.gdata.maybe_add(children, 'device-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__device_id, child_device_id)
    child_location = yang.gdata.take_json_str(jd, 'location')
    yang.gdata.maybe_add(children, 'location', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__location, child_location)
    child_management = yang.gdata.take_json_cnt(jd, 'management')
    yang.gdata.maybe_add(children, 'management', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management, child_management)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['device-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(yang.adata.MNode):
    device: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device

    mut def __init__(self, device: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.device = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(elements=device)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _device = self.device
        if _device is not None:
            children['device'] = _device.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__devices:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(device=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device.from_gdata(n.get_opt_list('device')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__devices()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/devices')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices()')
        leaves = []
        _device = self.device
        for _element in _device.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/devices/device element: {_element.to_gdata().key_str(['device-id'])}")
            res.append('element_management = ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device__management({repr(_element.management.address)})')
            list_elem = 'device_element = {self_name}.device.create({repr(_element.device_id)}, {repr(_element.location)}, element_management)'
            res.append(list_elem)
            res.extend(_element.prsrc('device_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/devices'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_device = yang.gdata.from_xml_opt_list(node, 'device')
    yang.gdata.maybe_add(children, 'device', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device, child_device)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'device':
            child = {'device': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_device = yang.gdata.take_json_opt_list(jd, 'device')
    yang.gdata.maybe_add(children, 'device', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices__device, child_device)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(yang.adata.MNode):
    group_id: str

    mut def __init__(self, group_id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(group_id=n.get_str('group-id'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-diversity/groups/group')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group({repr(self.group_id)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-diversity/groups/group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self.elements:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.from_xml_str(node, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group__group_id, child_group_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(e) for e in nodes]
    return yang.gdata.List(keys=['group-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['group-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group__group_id(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['group-id'])))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.take_json_str(jd, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group__group_id, child_group_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['group-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(elements=group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group.from_gdata(n.get_opt_list('group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-diversity/groups')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups()')
        leaves = []
        _group = self.group
        for _element in _group.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-diversity/groups/group element: {_element.to_gdata().key_str(['group-id'])}")
            list_elem = 'group_element = {self_name}.group.create({repr(_element.group_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('group_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-diversity/groups'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.from_xml_opt_list(node, 'group')
    yang.gdata.maybe_add(children, 'group', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group, child_group)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.take_json_opt_list(jd, 'group')
    yang.gdata.maybe_add(children, 'group', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups__group, child_group)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(yang.adata.MNode):
    groups: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups

    mut def __init__(self, groups: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.groups = groups if groups is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _groups = self.groups
        if _groups is not None:
            children['groups'] = _groups.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(groups=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups.from_gdata(n.get_opt_cnt('groups')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-diversity')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity()')
        leaves = []
        _groups = self.groups
        if _groups is not None:
            res.extend(_groups.prsrc('{self_name}.groups', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-diversity'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_groups = yang.gdata.from_xml_opt_cnt(node, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups, child_groups)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'groups':
            child = {'groups': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_groups = yang.gdata.take_json_opt_cnt(jd, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity__groups, child_groups)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:management'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__management__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:management'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

class ietf_l3vpn_svc__l3vpn_svc__sites__site__management(yang.adata.MNode):
    type: Identityref

    mut def __init__(self, type: Identityref):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        if _type is not None:
            _identityref_type, error = complete_and_validate_identityref(_type, _identities, ['l3vpn-svc:management'], 'ietf-l3vpn-svc')
            if _identityref_type is not None:
                _type = _identityref_type
            else:
                raise ValueError('Invalid value for identityref leaf type: {error}')
            children['type'] = yang.gdata.Leaf('identityref', _type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__management:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__management(type=n.get_Identityref('type'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__management')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/management')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__management({repr(self.type)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/management'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_type = yang.gdata.from_xml_Identityref(node, 'type')
    yang.gdata.maybe_add(children, 'type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__management__type, child_type)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_type = yang.gdata.take_json_Identityref(jd, 'type')
    yang.gdata.maybe_add(children, 'type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management__type, child_type)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__vpn_policy_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__vpn_policy_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:vpn-policy-filter-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:vpn-policy-filter-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__lan_tag(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__lan_tag(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv4_lan_prefix(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv4_lan_prefix(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv6_lan_prefix(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv6_lan_prefix(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(yang.adata.MNode):
    type: Identityref
    lan_tag: list[str]
    ipv4_lan_prefix: list[str]
    ipv6_lan_prefix: list[str]

    mut def __init__(self, type: Identityref, lan_tag: ?list[str]=None, ipv4_lan_prefix: ?list[str]=None, ipv6_lan_prefix: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type
        self.lan_tag = lan_tag if lan_tag is not None else []
        self.ipv4_lan_prefix = ipv4_lan_prefix if ipv4_lan_prefix is not None else []
        self.ipv6_lan_prefix = ipv6_lan_prefix if ipv6_lan_prefix is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        if _type is not None:
            _identityref_type, error = complete_and_validate_identityref(_type, _identities, ['l3vpn-svc:vpn-policy-filter-type'], 'ietf-l3vpn-svc')
            if _identityref_type is not None:
                _type = _identityref_type
            else:
                raise ValueError('Invalid value for identityref leaf type: {error}')
            children['type'] = yang.gdata.Leaf('identityref', _type)
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.LeafList('string', _lan_tag)
        _ipv4_lan_prefix = self.ipv4_lan_prefix
        if _ipv4_lan_prefix is not None:
            children['ipv4-lan-prefix'] = yang.gdata.LeafList('string', _ipv4_lan_prefix)
        _ipv6_lan_prefix = self.ipv6_lan_prefix
        if _ipv6_lan_prefix is not None:
            children['ipv6-lan-prefix'] = yang.gdata.LeafList('string', _ipv6_lan_prefix)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(type=n.get_Identityref('type'), lan_tag=n.get_opt_strs('lan-tag'), ipv4_lan_prefix=n.get_opt_strs('ipv4-lan-prefix'), ipv6_lan_prefix=n.get_opt_strs('ipv6-lan-prefix'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/filters/filter')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter({repr(self.type)})')
        leaves = []
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            leaves.append('{self_name}.lan_tag = {repr(_lan_tag)}')
        _ipv4_lan_prefix = self.ipv4_lan_prefix
        if _ipv4_lan_prefix is not None:
            leaves.append('{self_name}.ipv4_lan_prefix = {repr(_ipv4_lan_prefix)}')
        _ipv6_lan_prefix = self.ipv6_lan_prefix
        if _ipv6_lan_prefix is not None:
            leaves.append('{self_name}.ipv6_lan_prefix = {repr(_ipv6_lan_prefix)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/filters/filter'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'filter'
        self.elements = elements

    mut def create(self, type):
        for e in self.elements:
            match = True
            if e.type != type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry(type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['type'], elements, user_order=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_type = yang.gdata.from_xml_Identityref(node, 'type')
    yang.gdata.maybe_add(children, 'type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__type, child_type)
    child_lan_tag = yang.gdata.from_xml_opt_strs(node, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__lan_tag, child_lan_tag)
    child_ipv4_lan_prefix = yang.gdata.from_xml_opt_strs(node, 'ipv4-lan-prefix')
    yang.gdata.maybe_add(children, 'ipv4-lan-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv4_lan_prefix, child_ipv4_lan_prefix)
    child_ipv6_lan_prefix = yang.gdata.from_xml_opt_strs(node, 'ipv6-lan-prefix')
    yang.gdata.maybe_add(children, 'ipv6-lan-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv6_lan_prefix, child_ipv6_lan_prefix)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(e) for e in nodes]
    return yang.gdata.List(keys=['type'], elements=elements, user_order=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['type']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__type(Identityref.from_json(keys[0]))
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-lan-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-lan-prefix':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['type'])))
        return yang.gdata.List(['type'], elements, user_order=True)
    elif len(path) > 1:
        return yang.gdata.List(['type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd, path, op)], user_order=True)
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_type = yang.gdata.take_json_Identityref(jd, 'type')
    yang.gdata.maybe_add(children, 'type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__type, child_type)
    child_lan_tag = yang.gdata.take_json_opt_strs(jd, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__lan_tag, child_lan_tag)
    child_ipv4_lan_prefix = yang.gdata.take_json_opt_strs(jd, 'ipv4-lan-prefix')
    yang.gdata.maybe_add(children, 'ipv4-lan-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv4_lan_prefix, child_ipv4_lan_prefix)
    child_ipv6_lan_prefix = yang.gdata.take_json_opt_strs(jd, 'ipv6-lan-prefix')
    yang.gdata.maybe_add(children, 'ipv6-lan-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter__ipv6_lan_prefix, child_ipv6_lan_prefix)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['type'], elements=elements, user_order=True)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(yang.adata.MNode):
    filter: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter

    mut def __init__(self, filter: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.filter = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(elements=filter)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _filter = self.filter
        if _filter is not None:
            children['filter'] = _filter.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(filter=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter.from_gdata(n.get_opt_list('filter')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/filters')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters()')
        leaves = []
        _filter = self.filter
        for _element in _filter.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/filters/filter element: {_element.to_gdata().key_str(['type'])}")
            list_elem = 'filter_element = {self_name}.filter.create({repr(_element.type)})'
            res.append(list_elem)
            res.extend(_element.prsrc('filter_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/filters'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_filter = yang.gdata.from_xml_opt_list(node, 'filter')
    yang.gdata.maybe_add(children, 'filter', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter, child_filter)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'filter':
            child = {'filter': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_filter = yang.gdata.take_json_opt_list(jd, 'filter')
    yang.gdata.maybe_add(children, 'filter', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters__filter, child_filter)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__site_role(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-role: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__site_role(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-role: {error}')

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(yang.adata.MNode):
    vpn_id: str
    site_role: Identityref

    mut def __init__(self, vpn_id: str, site_role: ?Identityref=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_id = vpn_id
        _default_site_role, error = complete_and_validate_identityref(Identityref.from_adata('any-to-any-role'), _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
        if _default_site_role is not None:
            self.site_role = site_role if site_role is not None else _default_site_role
        else:
            raise ValueError('Invalid default value for identityref leaf vpn: {error}')

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('leafref', _vpn_id)
        _site_role = self.site_role
        if _site_role is not None:
            _identityref_site_role, error = complete_and_validate_identityref(_site_role, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
            if _identityref_site_role is not None:
                _site_role = _identityref_site_role
            else:
                raise ValueError('Invalid value for identityref leaf site-role: {error}')
            children['site-role'] = yang.gdata.Leaf('identityref', _site_role)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(vpn_id=n.get_str('vpn-id'), site_role=n.get_opt_Identityref('site-role'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/vpn')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn({repr(self.vpn_id)})')
        leaves = []
        _site_role = self.site_role
        if _site_role is not None:
            leaves.append('{self_name}.site_role = {repr(_site_role)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/vpn'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'vpn'
        self.elements = elements

    mut def create(self, vpn_id):
        for e in self.elements:
            match = True
            if e.vpn_id != vpn_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry(vpn_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.from_xml_str(node, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__vpn_id, child_vpn_id)
    child_site_role = yang.gdata.from_xml_opt_Identityref(node, 'site-role')
    yang.gdata.maybe_add(children, 'site-role', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__site_role, child_site_role)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(e) for e in nodes]
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['vpn-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['vpn-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__vpn_id(keys[0])
        if point == 'site-role':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['vpn-id'])))
        return yang.gdata.List(['vpn-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_vpn_id = yang.gdata.take_json_str(jd, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__vpn_id, child_vpn_id)
    child_site_role = yang.gdata.take_json_opt_Identityref(jd, 'site-role')
    yang.gdata.maybe_add(children, 'site-role', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn__site_role, child_site_role)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['vpn-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(yang.adata.MNode):
    id: str
    filters: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters
    vpn: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn

    mut def __init__(self, id: str, filters: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters=None, vpn: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.filters = filters if filters is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters()
        self.vpn = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(elements=vpn)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        _filters = self.filters
        if _filters is not None:
            children['filters'] = _filters.to_gdata()
        _vpn = self.vpn
        if _vpn is not None:
            children['vpn'] = _vpn.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(id=n.get_str('id'), filters=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters.from_gdata(n.get_opt_cnt('filters')), vpn=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn.from_gdata(n.get_opt_list('vpn')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries({repr(self.id)})')
        leaves = []
        _filters = self.filters
        if _filters is not None:
            res.extend(_filters.prsrc('{self_name}.filters', False).splitlines())
        _vpn = self.vpn
        for _element in _vpn.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries/vpn element: {_element.to_gdata().key_str(['vpn-id'])}")
            list_elem = 'vpn_element = {self_name}.vpn.create({repr(_element.vpn_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('vpn_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'entries'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_str(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__id, child_id)
    child_filters = yang.gdata.from_xml_opt_cnt(node, 'filters')
    yang.gdata.maybe_add(children, 'filters', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters, child_filters)
    child_vpn = yang.gdata.from_xml_opt_list(node, 'vpn')
    yang.gdata.maybe_add(children, 'vpn', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn, child_vpn)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__id(keys[0])
        if point == 'filters':
            children['filters'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters(jd, rest_path, op)
        if point == 'vpn':
            children['vpn'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__id, child_id)
    child_filters = yang.gdata.take_json_opt_cnt(jd, 'filters')
    yang.gdata.maybe_add(children, 'filters', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__filters, child_filters)
    child_vpn = yang.gdata.take_json_opt_list(jd, 'vpn')
    yang.gdata.maybe_add(children, 'vpn', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries__vpn, child_vpn)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(yang.adata.MNode):
    vpn_policy_id: str
    entries: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries

    mut def __init__(self, vpn_policy_id: str, entries: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_policy_id = vpn_policy_id
        self.entries = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(elements=entries)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_policy_id = self.vpn_policy_id
        if _vpn_policy_id is not None:
            children['vpn-policy-id'] = yang.gdata.Leaf('string', _vpn_policy_id)
        _entries = self.entries
        if _entries is not None:
            children['entries'] = _entries.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(vpn_policy_id=n.get_str('vpn-policy-id'), entries=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries.from_gdata(n.get_opt_list('entries')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/vpn-policies/vpn-policy')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy({repr(self.vpn_policy_id)})')
        leaves = []
        _entries = self.entries
        for _element in _entries.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/vpn-policies/vpn-policy/entries element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'entries_element = {self_name}.entries.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('entries_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/vpn-policies/vpn-policy'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'vpn-policy'
        self.elements = elements

    mut def create(self, vpn_policy_id):
        for e in self.elements:
            match = True
            if e.vpn_policy_id != vpn_policy_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry(vpn_policy_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vpn-policy-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_vpn_policy_id = yang.gdata.from_xml_str(node, 'vpn-policy-id')
    yang.gdata.maybe_add(children, 'vpn-policy-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__vpn_policy_id, child_vpn_policy_id)
    child_entries = yang.gdata.from_xml_opt_list(node, 'entries')
    yang.gdata.maybe_add(children, 'entries', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries, child_entries)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(e) for e in nodes]
    return yang.gdata.List(keys=['vpn-policy-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['vpn-policy-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['vpn-policy-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__vpn_policy_id(keys[0])
        if point == 'entries':
            children['entries'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vpn-policy-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['vpn-policy-id'])))
        return yang.gdata.List(['vpn-policy-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vpn-policy-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_vpn_policy_id = yang.gdata.take_json_str(jd, 'vpn-policy-id')
    yang.gdata.maybe_add(children, 'vpn-policy-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__vpn_policy_id, child_vpn_policy_id)
    child_entries = yang.gdata.take_json_opt_list(jd, 'entries')
    yang.gdata.maybe_add(children, 'entries', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy__entries, child_entries)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['vpn-policy-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(yang.adata.MNode):
    vpn_policy: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy

    mut def __init__(self, vpn_policy: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_policy = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(elements=vpn_policy)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_policy = self.vpn_policy
        if _vpn_policy is not None:
            children['vpn-policy'] = _vpn_policy.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(vpn_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy.from_gdata(n.get_opt_list('vpn-policy')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/vpn-policies')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies()')
        leaves = []
        _vpn_policy = self.vpn_policy
        for _element in _vpn_policy.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/vpn-policies/vpn-policy element: {_element.to_gdata().key_str(['vpn-policy-id'])}")
            list_elem = 'vpn_policy_element = {self_name}.vpn_policy.create({repr(_element.vpn_policy_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('vpn_policy_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/vpn-policies'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_vpn_policy = yang.gdata.from_xml_opt_list(node, 'vpn-policy')
    yang.gdata.maybe_add(children, 'vpn-policy', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy, child_vpn_policy)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'vpn-policy':
            child = {'vpn-policy': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_policy = yang.gdata.take_json_opt_list(jd, 'vpn-policy')
    yang.gdata.maybe_add(children, 'vpn-policy', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies__vpn_policy, child_vpn_policy)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_vpn_flavor(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-vpn-flavor'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-vpn-flavor: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_vpn_flavor(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-vpn-flavor'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-vpn-flavor: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__af(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__af(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__maximum_routes(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__maximum_routes(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(yang.adata.MNode):
    af: str
    maximum_routes: ?int

    mut def __init__(self, af: str, maximum_routes: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.af = af
        self.maximum_routes = maximum_routes

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _af = self.af
        if _af is not None:
            children['af'] = yang.gdata.Leaf('enumeration', _af)
        _maximum_routes = self.maximum_routes
        if _maximum_routes is not None:
            children['maximum-routes'] = yang.gdata.Leaf('uint32', _maximum_routes)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(af=n.get_str('af'), maximum_routes=n.get_opt_int('maximum-routes'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/maximum-routes/address-family')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family({repr(self.af)})')
        leaves = []
        _maximum_routes = self.maximum_routes
        if _maximum_routes is not None:
            leaves.append('{self_name}.maximum_routes = {repr(_maximum_routes)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/maximum-routes/address-family'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af):
        for e in self.elements:
            match = True
            if e.af != af:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry(af)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['af'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_af = yang.gdata.from_xml_str(node, 'af')
    yang.gdata.maybe_add(children, 'af', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__af, child_af)
    child_maximum_routes = yang.gdata.from_xml_opt_int(node, 'maximum-routes')
    yang.gdata.maybe_add(children, 'maximum-routes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__maximum_routes, child_maximum_routes)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(e) for e in nodes]
    return yang.gdata.List(keys=['af'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['af']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['af'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__af(keys[0])
        if point == 'maximum-routes':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['af']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['af'])))
        return yang.gdata.List(['af'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['af'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_af = yang.gdata.take_json_str(jd, 'af')
    yang.gdata.maybe_add(children, 'af', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__af, child_af)
    child_maximum_routes = yang.gdata.take_json_opt_int(jd, 'maximum-routes')
    yang.gdata.maybe_add(children, 'maximum-routes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family__maximum_routes, child_maximum_routes)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['af'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(yang.adata.MNode):
    address_family: ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family

    mut def __init__(self, address_family: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(elements=address_family)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = _address_family.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family.from_gdata(n.get_opt_list('address-family')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/maximum-routes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes()')
        leaves = []
        _address_family = self.address_family
        for _element in _address_family.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/maximum-routes/address-family element: {_element.to_gdata().key_str(['af'])}")
            list_elem = 'address_family_element = {self_name}.address_family.create({repr(_element.af)})'
            res.append(list_elem)
            res.extend(_element.prsrc('address_family_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/maximum-routes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_opt_list(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family, child_address_family)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            child = {'address-family': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_opt_list(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes__address_family, child_address_family)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/security/authentication')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/security/authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__layer(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__layer(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__preshared_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__preshared_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(yang.adata.MNode):
    profile_name: ?str
    algorithm: ?str
    preshared_key: ?str

    mut def __init__(self, profile_name: ?str, algorithm: ?str, preshared_key: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile_name = profile_name
        self.algorithm = algorithm
        self.preshared_key = preshared_key

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile_name = self.profile_name
        if _profile_name is not None:
            children['profile-name'] = yang.gdata.Leaf('leafref', _profile_name)
        _algorithm = self.algorithm
        if _algorithm is not None:
            children['algorithm'] = yang.gdata.Leaf('string', _algorithm)
        _preshared_key = self.preshared_key
        if _preshared_key is not None:
            children['preshared-key'] = yang.gdata.Leaf('string', _preshared_key)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(profile_name=n.get_opt_str('profile-name'), algorithm=n.get_opt_str('algorithm'), preshared_key=n.get_opt_str('preshared-key'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/security/encryption/encryption-profile')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile()')
        leaves = []
        _profile_name = self.profile_name
        if _profile_name is not None:
            leaves.append('{self_name}.profile_name = {repr(_profile_name)}')
        _algorithm = self.algorithm
        if _algorithm is not None:
            leaves.append('{self_name}.algorithm = {repr(_algorithm)}')
        _preshared_key = self.preshared_key
        if _preshared_key is not None:
            leaves.append('{self_name}.preshared_key = {repr(_preshared_key)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/security/encryption/encryption-profile'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_profile_name = yang.gdata.from_xml_opt_str(node, 'profile-name')
    yang.gdata.maybe_add(children, 'profile-name', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__profile_name, child_profile_name)
    child_algorithm = yang.gdata.from_xml_opt_str(node, 'algorithm')
    yang.gdata.maybe_add(children, 'algorithm', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__algorithm, child_algorithm)
    child_preshared_key = yang.gdata.from_xml_opt_str(node, 'preshared-key')
    yang.gdata.maybe_add(children, 'preshared-key', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__preshared_key, child_preshared_key)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'profile-name':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'algorithm':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'preshared-key':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile_name = yang.gdata.take_json_opt_str(jd, 'profile-name')
    yang.gdata.maybe_add(children, 'profile-name', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__profile_name, child_profile_name)
    child_algorithm = yang.gdata.take_json_opt_str(jd, 'algorithm')
    yang.gdata.maybe_add(children, 'algorithm', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__algorithm, child_algorithm)
    child_preshared_key = yang.gdata.take_json_opt_str(jd, 'preshared-key')
    yang.gdata.maybe_add(children, 'preshared-key', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile__preshared_key, child_preshared_key)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(yang.adata.MNode):
    enabled: bool
    layer: ?str
    encryption_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile

    mut def __init__(self, enabled: ?bool=None, layer: ?str, encryption_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.layer = layer
        self.encryption_profile = encryption_profile if encryption_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _layer = self.layer
        if _layer is not None:
            children['layer'] = yang.gdata.Leaf('enumeration', _layer)
        _encryption_profile = self.encryption_profile
        if _encryption_profile is not None:
            children['encryption-profile'] = _encryption_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(enabled=n.get_opt_bool('enabled'), layer=n.get_opt_str('layer'), encryption_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile.from_gdata(n.get_opt_cnt('encryption-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/security/encryption')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption()')
        leaves = []
        _enabled = self.enabled
        if _enabled is not None:
            leaves.append('{self_name}.enabled = {repr(_enabled)}')
        _layer = self.layer
        if _layer is not None:
            leaves.append('{self_name}.layer = {repr(_layer)}')
        _encryption_profile = self.encryption_profile
        if _encryption_profile is not None:
            res.extend(_encryption_profile.prsrc('{self_name}.encryption_profile', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/security/encryption'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.from_xml_opt_bool(node, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__enabled, child_enabled)
    child_layer = yang.gdata.from_xml_opt_str(node, 'layer')
    yang.gdata.maybe_add(children, 'layer', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__layer, child_layer)
    child_encryption_profile = yang.gdata.from_xml_opt_cnt(node, 'encryption-profile')
    yang.gdata.maybe_add(children, 'encryption-profile', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile, child_encryption_profile)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'layer':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'encryption-profile':
            child = {'encryption-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__enabled, child_enabled)
    child_layer = yang.gdata.take_json_opt_str(jd, 'layer')
    yang.gdata.maybe_add(children, 'layer', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__layer, child_layer)
    child_encryption_profile = yang.gdata.take_json_opt_cnt(jd, 'encryption-profile')
    yang.gdata.maybe_add(children, 'encryption-profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption__encryption_profile, child_encryption_profile)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__security(yang.adata.MNode):
    authentication: ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication
    encryption: ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption

    mut def __init__(self, authentication: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication=None, encryption: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.authentication = authentication if authentication is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication()
        self.encryption = encryption if encryption is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _authentication = self.authentication
        if _authentication is not None:
            children['authentication'] = _authentication.to_gdata()
        _encryption = self.encryption
        if _encryption is not None:
            children['encryption'] = _encryption.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__security:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__security(authentication=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication.from_gdata(n.get_opt_cnt('authentication')), encryption=ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption.from_gdata(n.get_opt_cnt('encryption')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__security()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/security')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__security()')
        leaves = []
        _authentication = self.authentication
        if _authentication is not None:
            res.extend(_authentication.prsrc('{self_name}.authentication', False).splitlines())
        _encryption = self.encryption
        if _encryption is not None:
            res.extend(_encryption.prsrc('{self_name}.encryption', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/security'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_authentication = yang.gdata.from_xml_opt_cnt(node, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication, child_authentication)
    child_encryption = yang.gdata.from_xml_opt_cnt(node, 'encryption')
    yang.gdata.maybe_add(children, 'encryption', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption, child_encryption)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'authentication':
            child = {'authentication': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'encryption':
            child = {'encryption': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_authentication = yang.gdata.take_json_opt_cnt(jd, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__authentication, child_authentication)
    child_encryption = yang.gdata.take_json_opt_cnt(jd, 'encryption')
    yang.gdata.maybe_add(children, 'encryption', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security__encryption, child_encryption)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dscp(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dscp(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dot1p(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dot1p(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__target_sites(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__target_sites(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        _upper_port = self.upper_port
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(lower_port=n.get_opt_int('lower-port'), upper_port=n.get_opt_int('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule/match-flow/l4-src-port-range')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()')
        leaves = []
        _lower_port = self.lower_port
        if _lower_port is not None:
            leaves.append('{self_name}.lower_port = {repr(_lower_port)}')
        _upper_port = self.upper_port
        if _upper_port is not None:
            leaves.append('{self_name}.upper_port = {repr(_upper_port)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule/match-flow/l4-src-port-range'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.from_xml_opt_int(node, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.from_xml_opt_int(node, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.take_json_opt_int(jd, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.take_json_opt_int(jd, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        _upper_port = self.upper_port
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(lower_port=n.get_opt_int('lower-port'), upper_port=n.get_opt_int('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule/match-flow/l4-dst-port-range')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()')
        leaves = []
        _lower_port = self.lower_port
        if _lower_port is not None:
            leaves.append('{self_name}.lower_port = {repr(_lower_port)}')
        _upper_port = self.upper_port
        if _upper_port is not None:
            leaves.append('{self_name}.upper_port = {repr(_upper_port)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule/match-flow/l4-dst-port-range'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.from_xml_opt_int(node, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.from_xml_opt_int(node, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.take_json_opt_int(jd, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.take_json_opt_int(jd, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__protocol_field(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__protocol_field(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(yang.adata.MNode):
    dscp: ?int
    dot1p: ?int
    ipv4_src_prefix: ?str
    ipv6_src_prefix: ?str
    ipv4_dst_prefix: ?str
    ipv6_dst_prefix: ?str
    l4_src_port: ?int
    target_sites: list[str]
    l4_src_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range
    l4_dst_port: ?int
    l4_dst_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range
    protocol_field: ?value

    mut def __init__(self, dscp: ?int, dot1p: ?int, ipv4_src_prefix: ?str, ipv6_src_prefix: ?str, ipv4_dst_prefix: ?str, ipv6_dst_prefix: ?str, l4_src_port: ?int, target_sites: ?list[str]=None, l4_src_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range=None, l4_dst_port: ?int, l4_dst_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range=None, protocol_field: ?value):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.dscp = dscp
        self.dot1p = dot1p
        self.ipv4_src_prefix = ipv4_src_prefix
        self.ipv6_src_prefix = ipv6_src_prefix
        self.ipv4_dst_prefix = ipv4_dst_prefix
        self.ipv6_dst_prefix = ipv6_dst_prefix
        self.l4_src_port = l4_src_port
        self.target_sites = target_sites if target_sites is not None else []
        self.l4_src_port_range = l4_src_port_range if l4_src_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()
        self.l4_dst_port = l4_dst_port
        self.l4_dst_port_range = l4_dst_port_range if l4_dst_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()
        self.protocol_field = protocol_field

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _dscp = self.dscp
        if _dscp is not None:
            children['dscp'] = yang.gdata.Leaf('uint8', _dscp)
        _dot1p = self.dot1p
        if _dot1p is not None:
            children['dot1p'] = yang.gdata.Leaf('uint8', _dot1p)
        _ipv4_src_prefix = self.ipv4_src_prefix
        if _ipv4_src_prefix is not None:
            children['ipv4-src-prefix'] = yang.gdata.Leaf('string', _ipv4_src_prefix)
        _ipv6_src_prefix = self.ipv6_src_prefix
        if _ipv6_src_prefix is not None:
            children['ipv6-src-prefix'] = yang.gdata.Leaf('string', _ipv6_src_prefix)
        _ipv4_dst_prefix = self.ipv4_dst_prefix
        if _ipv4_dst_prefix is not None:
            children['ipv4-dst-prefix'] = yang.gdata.Leaf('string', _ipv4_dst_prefix)
        _ipv6_dst_prefix = self.ipv6_dst_prefix
        if _ipv6_dst_prefix is not None:
            children['ipv6-dst-prefix'] = yang.gdata.Leaf('string', _ipv6_dst_prefix)
        _l4_src_port = self.l4_src_port
        if _l4_src_port is not None:
            children['l4-src-port'] = yang.gdata.Leaf('uint16', _l4_src_port)
        _target_sites = self.target_sites
        if _target_sites is not None:
            children['target-sites'] = yang.gdata.LeafList('string', _target_sites)
        _l4_src_port_range = self.l4_src_port_range
        if _l4_src_port_range is not None:
            children['l4-src-port-range'] = _l4_src_port_range.to_gdata()
        _l4_dst_port = self.l4_dst_port
        if _l4_dst_port is not None:
            children['l4-dst-port'] = yang.gdata.Leaf('uint16', _l4_dst_port)
        _l4_dst_port_range = self.l4_dst_port_range
        if _l4_dst_port_range is not None:
            children['l4-dst-port-range'] = _l4_dst_port_range.to_gdata()
        _protocol_field = self.protocol_field
        if _protocol_field is not None:
            children['protocol-field'] = yang.gdata.Leaf('union', _protocol_field)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(dscp=n.get_opt_int('dscp'), dot1p=n.get_opt_int('dot1p'), ipv4_src_prefix=n.get_opt_str('ipv4-src-prefix'), ipv6_src_prefix=n.get_opt_str('ipv6-src-prefix'), ipv4_dst_prefix=n.get_opt_str('ipv4-dst-prefix'), ipv6_dst_prefix=n.get_opt_str('ipv6-dst-prefix'), l4_src_port=n.get_opt_int('l4-src-port'), target_sites=n.get_opt_strs('target-sites'), l4_src_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_gdata(n.get_opt_cnt('l4-src-port-range')), l4_dst_port=n.get_opt_int('l4-dst-port'), l4_dst_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_gdata(n.get_opt_cnt('l4-dst-port-range')), protocol_field=n.get_opt_value('protocol-field'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule/match-flow')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow()')
        leaves = []
        _dscp = self.dscp
        if _dscp is not None:
            leaves.append('{self_name}.dscp = {repr(_dscp)}')
        _dot1p = self.dot1p
        if _dot1p is not None:
            leaves.append('{self_name}.dot1p = {repr(_dot1p)}')
        _ipv4_src_prefix = self.ipv4_src_prefix
        if _ipv4_src_prefix is not None:
            leaves.append('{self_name}.ipv4_src_prefix = {repr(_ipv4_src_prefix)}')
        _ipv6_src_prefix = self.ipv6_src_prefix
        if _ipv6_src_prefix is not None:
            leaves.append('{self_name}.ipv6_src_prefix = {repr(_ipv6_src_prefix)}')
        _ipv4_dst_prefix = self.ipv4_dst_prefix
        if _ipv4_dst_prefix is not None:
            leaves.append('{self_name}.ipv4_dst_prefix = {repr(_ipv4_dst_prefix)}')
        _ipv6_dst_prefix = self.ipv6_dst_prefix
        if _ipv6_dst_prefix is not None:
            leaves.append('{self_name}.ipv6_dst_prefix = {repr(_ipv6_dst_prefix)}')
        _l4_src_port = self.l4_src_port
        if _l4_src_port is not None:
            leaves.append('{self_name}.l4_src_port = {repr(_l4_src_port)}')
        _target_sites = self.target_sites
        if _target_sites is not None:
            leaves.append('{self_name}.target_sites = {repr(_target_sites)}')
        _l4_src_port_range = self.l4_src_port_range
        if _l4_src_port_range is not None:
            res.extend(_l4_src_port_range.prsrc('{self_name}.l4_src_port_range', False).splitlines())
        _l4_dst_port = self.l4_dst_port
        if _l4_dst_port is not None:
            leaves.append('{self_name}.l4_dst_port = {repr(_l4_dst_port)}')
        _l4_dst_port_range = self.l4_dst_port_range
        if _l4_dst_port_range is not None:
            res.extend(_l4_dst_port_range.prsrc('{self_name}.l4_dst_port_range', False).splitlines())
        _protocol_field = self.protocol_field
        if _protocol_field is not None:
            leaves.append('{self_name}.protocol_field = {repr(_protocol_field)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule/match-flow'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_dscp = yang.gdata.from_xml_opt_int(node, 'dscp')
    yang.gdata.maybe_add(children, 'dscp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dscp, child_dscp)
    child_dot1p = yang.gdata.from_xml_opt_int(node, 'dot1p')
    yang.gdata.maybe_add(children, 'dot1p', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dot1p, child_dot1p)
    child_ipv4_src_prefix = yang.gdata.from_xml_opt_str(node, 'ipv4-src-prefix')
    yang.gdata.maybe_add(children, 'ipv4-src-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix, child_ipv4_src_prefix)
    child_ipv6_src_prefix = yang.gdata.from_xml_opt_str(node, 'ipv6-src-prefix')
    yang.gdata.maybe_add(children, 'ipv6-src-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix, child_ipv6_src_prefix)
    child_ipv4_dst_prefix = yang.gdata.from_xml_opt_str(node, 'ipv4-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv4-dst-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix, child_ipv4_dst_prefix)
    child_ipv6_dst_prefix = yang.gdata.from_xml_opt_str(node, 'ipv6-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv6-dst-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix, child_ipv6_dst_prefix)
    child_l4_src_port = yang.gdata.from_xml_opt_int(node, 'l4-src-port')
    yang.gdata.maybe_add(children, 'l4-src-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port, child_l4_src_port)
    child_target_sites = yang.gdata.from_xml_opt_strs(node, 'target-sites')
    yang.gdata.maybe_add(children, 'target-sites', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__target_sites, child_target_sites)
    child_l4_src_port_range = yang.gdata.from_xml_opt_cnt(node, 'l4-src-port-range')
    yang.gdata.maybe_add(children, 'l4-src-port-range', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range, child_l4_src_port_range)
    child_l4_dst_port = yang.gdata.from_xml_opt_int(node, 'l4-dst-port')
    yang.gdata.maybe_add(children, 'l4-dst-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port, child_l4_dst_port)
    child_l4_dst_port_range = yang.gdata.from_xml_opt_cnt(node, 'l4-dst-port-range')
    yang.gdata.maybe_add(children, 'l4-dst-port-range', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range, child_l4_dst_port_range)
    child_protocol_field = yang.gdata.from_xml_opt_value(node, 'protocol-field')
    yang.gdata.maybe_add(children, 'protocol-field', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__protocol_field, child_protocol_field)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'dscp':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'dot1p':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-src-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'target-sites':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-src-port-range':
            child = {'l4-src-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l4-dst-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-dst-port-range':
            child = {'l4-dst-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'protocol-field':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_dscp = yang.gdata.take_json_opt_int(jd, 'dscp')
    yang.gdata.maybe_add(children, 'dscp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dscp, child_dscp)
    child_dot1p = yang.gdata.take_json_opt_int(jd, 'dot1p')
    yang.gdata.maybe_add(children, 'dot1p', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__dot1p, child_dot1p)
    child_ipv4_src_prefix = yang.gdata.take_json_opt_str(jd, 'ipv4-src-prefix')
    yang.gdata.maybe_add(children, 'ipv4-src-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix, child_ipv4_src_prefix)
    child_ipv6_src_prefix = yang.gdata.take_json_opt_str(jd, 'ipv6-src-prefix')
    yang.gdata.maybe_add(children, 'ipv6-src-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix, child_ipv6_src_prefix)
    child_ipv4_dst_prefix = yang.gdata.take_json_opt_str(jd, 'ipv4-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv4-dst-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix, child_ipv4_dst_prefix)
    child_ipv6_dst_prefix = yang.gdata.take_json_opt_str(jd, 'ipv6-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv6-dst-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix, child_ipv6_dst_prefix)
    child_l4_src_port = yang.gdata.take_json_opt_int(jd, 'l4-src-port')
    yang.gdata.maybe_add(children, 'l4-src-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port, child_l4_src_port)
    child_target_sites = yang.gdata.take_json_opt_strs(jd, 'target-sites')
    yang.gdata.maybe_add(children, 'target-sites', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__target_sites, child_target_sites)
    child_l4_src_port_range = yang.gdata.take_json_opt_cnt(jd, 'l4-src-port-range')
    yang.gdata.maybe_add(children, 'l4-src-port-range', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range, child_l4_src_port_range)
    child_l4_dst_port = yang.gdata.take_json_opt_int(jd, 'l4-dst-port')
    yang.gdata.maybe_add(children, 'l4-dst-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port, child_l4_dst_port)
    child_l4_dst_port_range = yang.gdata.take_json_opt_cnt(jd, 'l4-dst-port-range')
    yang.gdata.maybe_add(children, 'l4-dst-port-range', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range, child_l4_dst_port_range)
    child_protocol_field = yang.gdata.take_json_opt_value(jd, 'protocol-field')
    yang.gdata.maybe_add(children, 'protocol-field', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow__protocol_field, child_protocol_field)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_application(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:customer-application'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf match-application: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_application(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:customer-application'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf match-application: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__target_class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__target_class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(yang.adata.MNode):
    id: str
    match_flow: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow
    match_application: ?Identityref
    target_class_id: ?str

    mut def __init__(self, id: str, match_flow: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow=None, match_application: ?Identityref, target_class_id: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.match_flow = match_flow if match_flow is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow()
        self.match_application = match_application
        self.target_class_id = target_class_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        _match_flow = self.match_flow
        if _match_flow is not None:
            children['match-flow'] = _match_flow.to_gdata()
        _match_application = self.match_application
        if _match_application is not None:
            _identityref_match_application, error = complete_and_validate_identityref(_match_application, _identities, ['l3vpn-svc:customer-application'], 'ietf-l3vpn-svc')
            if _identityref_match_application is not None:
                _match_application = _identityref_match_application
            else:
                raise ValueError('Invalid value for identityref leaf match-application: {error}')
            children['match-application'] = yang.gdata.Leaf('identityref', _match_application)
        _target_class_id = self.target_class_id
        if _target_class_id is not None:
            children['target-class-id'] = yang.gdata.Leaf('string', _target_class_id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(id=n.get_str('id'), match_flow=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow.from_gdata(n.get_opt_cnt('match-flow')), match_application=n.get_opt_Identityref('match-application'), target_class_id=n.get_opt_str('target-class-id'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule({repr(self.id)})')
        leaves = []
        _match_flow = self.match_flow
        if _match_flow is not None:
            res.extend(_match_flow.prsrc('{self_name}.match_flow', False).splitlines())
        _match_application = self.match_application
        if _match_application is not None:
            leaves.append('{self_name}.match_application = {repr(_match_application)}')
        _target_class_id = self.target_class_id
        if _target_class_id is not None:
            leaves.append('{self_name}.target_class_id = {repr(_target_class_id)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'rule'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements, user_order=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_str(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__id, child_id)
    child_match_flow = yang.gdata.from_xml_opt_cnt(node, 'match-flow')
    yang.gdata.maybe_add(children, 'match-flow', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow, child_match_flow)
    child_match_application = yang.gdata.from_xml_opt_Identityref(node, 'match-application')
    yang.gdata.maybe_add(children, 'match-application', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_application, child_match_application)
    child_target_class_id = yang.gdata.from_xml_opt_str(node, 'target-class-id')
    yang.gdata.maybe_add(children, 'target-class-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__target_class_id, child_target_class_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements, user_order=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__id(keys[0])
        if point == 'match-flow':
            children['match-flow'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow(jd, rest_path, op)
        if point == 'match-application':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'target-class-id':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements, user_order=True)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd, path, op)], user_order=True)
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__id, child_id)
    child_match_flow = yang.gdata.take_json_opt_cnt(jd, 'match-flow')
    yang.gdata.maybe_add(children, 'match-flow', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_flow, child_match_flow)
    child_match_application = yang.gdata.take_json_opt_Identityref(jd, 'match-application')
    yang.gdata.maybe_add(children, 'match-application', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__match_application, child_match_application)
    child_target_class_id = yang.gdata.take_json_opt_str(jd, 'target-class-id')
    yang.gdata.maybe_add(children, 'target-class-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule__target_class_id, child_target_class_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements, user_order=True)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(yang.adata.MNode):
    rule: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule

    mut def __init__(self, rule: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rule = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(elements=rule)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rule = self.rule
        if _rule is not None:
            children['rule'] = _rule.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(rule=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule.from_gdata(n.get_opt_list('rule')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-classification-policy')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy()')
        leaves = []
        _rule = self.rule
        for _element in _rule.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/service/qos/qos-classification-policy/rule element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'rule_element = {self_name}.rule.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('rule_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-classification-policy'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_rule = yang.gdata.from_xml_opt_list(node, 'rule')
    yang.gdata.maybe_add(children, 'rule', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule, child_rule)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'rule':
            child = {'rule': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rule = yang.gdata.take_json_opt_list(jd, 'rule')
    yang.gdata.maybe_add(children, 'rule', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy__rule, child_rule)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__profile(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__profile(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__direction(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf direction: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__direction(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf direction: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__rate_limit(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__rate_limit(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__use_lowest_latency(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__use_lowest_latency(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(yang.adata.MNode):
    use_lowest_latency: ?bool
    latency_boundary: int

    mut def __init__(self, use_lowest_latency: ?bool, latency_boundary: ?int=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_latency = use_lowest_latency
        self.latency_boundary = latency_boundary if latency_boundary is not None else 400

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_latency = self.use_lowest_latency
        if _use_lowest_latency is not None:
            children['use-lowest-latency'] = yang.gdata.Leaf('empty', _use_lowest_latency)
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint16', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(use_lowest_latency=n.get_opt_empty('use-lowest-latency'), latency_boundary=n.get_opt_int('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class/latency')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency()')
        leaves = []
        _use_lowest_latency = self.use_lowest_latency
        if _use_lowest_latency is not None:
            leaves.append('{self_name}.use_lowest_latency = {repr(_use_lowest_latency)}')
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            leaves.append('{self_name}.latency_boundary = {repr(_latency_boundary)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class/latency'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_use_lowest_latency = yang.gdata.from_xml_opt_empty(node, 'use-lowest-latency')
    yang.gdata.maybe_add(children, 'use-lowest-latency', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__use_lowest_latency, child_use_lowest_latency)
    child_latency_boundary = yang.gdata.from_xml_opt_int(node, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'use-lowest-latency':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_latency = yang.gdata.take_json_opt_empty(jd, 'use-lowest-latency')
    yang.gdata.maybe_add(children, 'use-lowest-latency', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__use_lowest_latency, child_use_lowest_latency)
    child_latency_boundary = yang.gdata.take_json_opt_int(jd, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(yang.adata.MNode):
    use_lowest_jitter: ?bool
    latency_boundary: int

    mut def __init__(self, use_lowest_jitter: ?bool, latency_boundary: ?int=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_jitter = use_lowest_jitter
        self.latency_boundary = latency_boundary if latency_boundary is not None else 40000

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_jitter = self.use_lowest_jitter
        if _use_lowest_jitter is not None:
            children['use-lowest-jitter'] = yang.gdata.Leaf('empty', _use_lowest_jitter)
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint32', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(use_lowest_jitter=n.get_opt_empty('use-lowest-jitter'), latency_boundary=n.get_opt_int('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class/jitter')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter()')
        leaves = []
        _use_lowest_jitter = self.use_lowest_jitter
        if _use_lowest_jitter is not None:
            leaves.append('{self_name}.use_lowest_jitter = {repr(_use_lowest_jitter)}')
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            leaves.append('{self_name}.latency_boundary = {repr(_latency_boundary)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class/jitter'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_use_lowest_jitter = yang.gdata.from_xml_opt_empty(node, 'use-lowest-jitter')
    yang.gdata.maybe_add(children, 'use-lowest-jitter', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter, child_use_lowest_jitter)
    child_latency_boundary = yang.gdata.from_xml_opt_int(node, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'use-lowest-jitter':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_jitter = yang.gdata.take_json_opt_empty(jd, 'use-lowest-jitter')
    yang.gdata.maybe_add(children, 'use-lowest-jitter', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter, child_use_lowest_jitter)
    child_latency_boundary = yang.gdata.take_json_opt_int(jd, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__end_to_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__end_to_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(yang.adata.MNode):
    guaranteed_bw_percent: float
    end_to_end: ?bool

    mut def __init__(self, guaranteed_bw_percent: float, end_to_end: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.guaranteed_bw_percent = guaranteed_bw_percent
        self.end_to_end = end_to_end

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _guaranteed_bw_percent = self.guaranteed_bw_percent
        if _guaranteed_bw_percent is not None:
            children['guaranteed-bw-percent'] = yang.gdata.Leaf('decimal64', _guaranteed_bw_percent)
        _end_to_end = self.end_to_end
        if _end_to_end is not None:
            children['end-to-end'] = yang.gdata.Leaf('empty', _end_to_end)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(guaranteed_bw_percent=n.get_float('guaranteed-bw-percent'), end_to_end=n.get_opt_empty('end-to-end'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class/bandwidth')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth({repr(self.guaranteed_bw_percent)})')
        leaves = []
        _end_to_end = self.end_to_end
        if _end_to_end is not None:
            leaves.append('{self_name}.end_to_end = {repr(_end_to_end)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class/bandwidth'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_guaranteed_bw_percent = yang.gdata.from_xml_float(node, 'guaranteed-bw-percent')
    yang.gdata.maybe_add(children, 'guaranteed-bw-percent', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent, child_guaranteed_bw_percent)
    child_end_to_end = yang.gdata.from_xml_opt_empty(node, 'end-to-end')
    yang.gdata.maybe_add(children, 'end-to-end', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__end_to_end, child_end_to_end)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'guaranteed-bw-percent':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'end-to-end':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_guaranteed_bw_percent = yang.gdata.take_json_float(jd, 'guaranteed-bw-percent')
    yang.gdata.maybe_add(children, 'guaranteed-bw-percent', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent, child_guaranteed_bw_percent)
    child_end_to_end = yang.gdata.take_json_opt_empty(jd, 'end-to-end')
    yang.gdata.maybe_add(children, 'end-to-end', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth__end_to_end, child_end_to_end)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(yang.adata.MNode):
    class_id: str
    direction: Identityref
    rate_limit: ?float
    latency: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency
    jitter: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter
    bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth

    mut def __init__(self, class_id: str, bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth, direction: ?Identityref=None, rate_limit: ?float, latency: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency=None, jitter: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_id = class_id
        _default_direction, error = complete_and_validate_identityref(Identityref.from_adata('both'), _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
        if _default_direction is not None:
            self.direction = direction if direction is not None else _default_direction
        else:
            raise ValueError('Invalid default value for identityref leaf class: {error}')
        self.rate_limit = rate_limit
        self.latency = latency if latency is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency()
        self.jitter = jitter if jitter is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter()
        self.bandwidth = bandwidth

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_id = self.class_id
        if _class_id is not None:
            children['class-id'] = yang.gdata.Leaf('string', _class_id)
        _direction = self.direction
        if _direction is not None:
            _identityref_direction, error = complete_and_validate_identityref(_direction, _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
            if _identityref_direction is not None:
                _direction = _identityref_direction
            else:
                raise ValueError('Invalid value for identityref leaf direction: {error}')
            children['direction'] = yang.gdata.Leaf('identityref', _direction)
        _rate_limit = self.rate_limit
        if _rate_limit is not None:
            children['rate-limit'] = yang.gdata.Leaf('decimal64', _rate_limit)
        _latency = self.latency
        if _latency is not None:
            children['latency'] = _latency.to_gdata()
        _jitter = self.jitter
        if _jitter is not None:
            children['jitter'] = _jitter.to_gdata()
        _bandwidth = self.bandwidth
        if _bandwidth is not None:
            children['bandwidth'] = _bandwidth.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(class_id=n.get_str('class-id'), direction=n.get_opt_Identityref('direction'), rate_limit=n.get_opt_float('rate-limit'), latency=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency.from_gdata(n.get_opt_cnt('latency')), jitter=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter.from_gdata(n.get_opt_cnt('jitter')), bandwidth=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth.from_gdata(n.get_cnt('bandwidth')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class')
            res.append('self_bandwidth = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth({repr(self.bandwidth.guaranteed_bw_percent)})')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class({repr(self.class_id)}, self_bandwidth)')
        leaves = []
        _direction = self.direction
        if _direction is not None:
            leaves.append('{self_name}.direction = {repr(_direction)}')
        _rate_limit = self.rate_limit
        if _rate_limit is not None:
            leaves.append('{self_name}.rate_limit = {repr(_rate_limit)}')
        _latency = self.latency
        if _latency is not None:
            res.extend(_latency.prsrc('{self_name}.latency', False).splitlines())
        _jitter = self.jitter
        if _jitter is not None:
            res.extend(_jitter.prsrc('{self_name}.jitter', False).splitlines())
        _bandwidth = self.bandwidth
        if _bandwidth is not None:
            res.extend(_bandwidth.prsrc('{self_name}.bandwidth', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'class'
        self.elements = elements

    mut def create(self, class_id, bandwidth):
        for e in self.elements:
            match = True
            if e.class_id != class_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry(class_id, bandwidth)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['class-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_class_id = yang.gdata.from_xml_str(node, 'class-id')
    yang.gdata.maybe_add(children, 'class-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__class_id, child_class_id)
    child_direction = yang.gdata.from_xml_opt_Identityref(node, 'direction')
    yang.gdata.maybe_add(children, 'direction', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__direction, child_direction)
    child_rate_limit = yang.gdata.from_xml_opt_float(node, 'rate-limit')
    yang.gdata.maybe_add(children, 'rate-limit', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__rate_limit, child_rate_limit)
    child_latency = yang.gdata.from_xml_opt_cnt(node, 'latency')
    yang.gdata.maybe_add(children, 'latency', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency, child_latency)
    child_jitter = yang.gdata.from_xml_opt_cnt(node, 'jitter')
    yang.gdata.maybe_add(children, 'jitter', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter, child_jitter)
    child_bandwidth = yang.gdata.from_xml_cnt(node, 'bandwidth')
    yang.gdata.maybe_add(children, 'bandwidth', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth, child_bandwidth)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(e) for e in nodes]
    return yang.gdata.List(keys=['class-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['class-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['class-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__class_id(keys[0])
        if point == 'direction':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'rate-limit':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency':
            children['latency'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency(jd, rest_path, op)
        if point == 'jitter':
            children['jitter'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter(jd, rest_path, op)
        if point == 'bandwidth':
            children['bandwidth'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['class-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['class-id'])))
        return yang.gdata.List(['class-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['class-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_class_id = yang.gdata.take_json_str(jd, 'class-id')
    yang.gdata.maybe_add(children, 'class-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__class_id, child_class_id)
    child_direction = yang.gdata.take_json_opt_Identityref(jd, 'direction')
    yang.gdata.maybe_add(children, 'direction', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__direction, child_direction)
    child_rate_limit = yang.gdata.take_json_opt_float(jd, 'rate-limit')
    yang.gdata.maybe_add(children, 'rate-limit', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__rate_limit, child_rate_limit)
    child_latency = yang.gdata.take_json_opt_cnt(jd, 'latency')
    yang.gdata.maybe_add(children, 'latency', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__latency, child_latency)
    child_jitter = yang.gdata.take_json_opt_cnt(jd, 'jitter')
    yang.gdata.maybe_add(children, 'jitter', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__jitter, child_jitter)
    child_bandwidth = yang.gdata.take_json_cnt(jd, 'bandwidth')
    yang.gdata.maybe_add(children, 'bandwidth', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth, child_bandwidth)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['class-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(yang.adata.MNode):
    class_: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class

    mut def __init__(self, class_: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_ = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(elements=class_)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_ = self.class_
        if _class_ is not None:
            children['class'] = _class_.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(class_=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class.from_gdata(n.get_opt_list('class')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-profile/classes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes()')
        leaves = []
        _class_ = self.class_
        for _element in _class_.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/service/qos/qos-profile/classes/class element: {_element.to_gdata().key_str(['class-id'])}")
            res.append('element_bandwidth = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class__bandwidth({repr(_element.bandwidth.guaranteed_bw_percent)})')
            list_elem = 'class__element = {self_name}.class_.create({repr(_element.class_id)}, element_bandwidth)'
            res.append(list_elem)
            res.extend(_element.prsrc('class__element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-profile/classes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_class_ = yang.gdata.from_xml_opt_list(node, 'class')
    yang.gdata.maybe_add(children, 'class', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class, child_class_)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'class':
            child = {'class': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_class_ = yang.gdata.take_json_opt_list(jd, 'class')
    yang.gdata.maybe_add(children, 'class', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes__class, child_class_)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(yang.adata.MNode):
    profile: ?str
    classes: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes

    mut def __init__(self, profile: ?str, classes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile = profile
        self.classes = classes if classes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile = self.profile
        if _profile is not None:
            children['profile'] = yang.gdata.Leaf('leafref', _profile)
        _classes = self.classes
        if _classes is not None:
            children['classes'] = _classes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(profile=n.get_opt_str('profile'), classes=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes.from_gdata(n.get_opt_cnt('classes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos/qos-profile')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile()')
        leaves = []
        _profile = self.profile
        if _profile is not None:
            leaves.append('{self_name}.profile = {repr(_profile)}')
        _classes = self.classes
        if _classes is not None:
            res.extend(_classes.prsrc('{self_name}.classes', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos/qos-profile'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_profile = yang.gdata.from_xml_opt_str(node, 'profile')
    yang.gdata.maybe_add(children, 'profile', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__profile, child_profile)
    child_classes = yang.gdata.from_xml_opt_cnt(node, 'classes')
    yang.gdata.maybe_add(children, 'classes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes, child_classes)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'profile':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'classes':
            child = {'classes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile = yang.gdata.take_json_opt_str(jd, 'profile')
    yang.gdata.maybe_add(children, 'profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__profile, child_profile)
    child_classes = yang.gdata.take_json_opt_cnt(jd, 'classes')
    yang.gdata.maybe_add(children, 'classes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile__classes, child_classes)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(yang.adata.MNode):
    qos_classification_policy: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy
    qos_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile

    mut def __init__(self, qos_classification_policy: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy=None, qos_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.qos_classification_policy = qos_classification_policy if qos_classification_policy is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy()
        self.qos_profile = qos_profile if qos_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _qos_classification_policy = self.qos_classification_policy
        if _qos_classification_policy is not None:
            children['qos-classification-policy'] = _qos_classification_policy.to_gdata()
        _qos_profile = self.qos_profile
        if _qos_profile is not None:
            children['qos-profile'] = _qos_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(qos_classification_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy.from_gdata(n.get_opt_cnt('qos-classification-policy')), qos_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile.from_gdata(n.get_opt_cnt('qos-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/qos')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos()')
        leaves = []
        _qos_classification_policy = self.qos_classification_policy
        if _qos_classification_policy is not None:
            res.extend(_qos_classification_policy.prsrc('{self_name}.qos_classification_policy', False).splitlines())
        _qos_profile = self.qos_profile
        if _qos_profile is not None:
            res.extend(_qos_profile.prsrc('{self_name}.qos_profile', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/qos'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_qos_classification_policy = yang.gdata.from_xml_opt_cnt(node, 'qos-classification-policy')
    yang.gdata.maybe_add(children, 'qos-classification-policy', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy, child_qos_classification_policy)
    child_qos_profile = yang.gdata.from_xml_opt_cnt(node, 'qos-profile')
    yang.gdata.maybe_add(children, 'qos-profile', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile, child_qos_profile)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'qos-classification-policy':
            child = {'qos-classification-policy': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'qos-profile':
            child = {'qos-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_qos_classification_policy = yang.gdata.take_json_opt_cnt(jd, 'qos-classification-policy')
    yang.gdata.maybe_add(children, 'qos-classification-policy', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_classification_policy, child_qos_classification_policy)
    child_qos_profile = yang.gdata.take_json_opt_cnt(jd, 'qos-profile')
    yang.gdata.maybe_add(children, 'qos-profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos__qos_profile, child_qos_profile)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier__signalling_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier__signalling_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(yang.adata.MNode):
    signalling_type: str

    mut def __init__(self, signalling_type: ?str=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.signalling_type = signalling_type if signalling_type is not None else "bgp"

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _signalling_type = self.signalling_type
        if _signalling_type is not None:
            children['signalling-type'] = yang.gdata.Leaf('enumeration', _signalling_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(signalling_type=n.get_opt_str('signalling-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/carrierscarrier')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier()')
        leaves = []
        _signalling_type = self.signalling_type
        if _signalling_type is not None:
            leaves.append('{self_name}.signalling_type = {repr(_signalling_type)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/carrierscarrier'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_signalling_type = yang.gdata.from_xml_opt_str(node, 'signalling-type')
    yang.gdata.maybe_add(children, 'signalling-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier__signalling_type, child_signalling_type)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'signalling-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_signalling_type = yang.gdata.take_json_opt_str(jd, 'signalling-type')
    yang.gdata.maybe_add(children, 'signalling-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier__signalling_type, child_signalling_type)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_site_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_site_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv4(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv4(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv6(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv6(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(yang.adata.MNode):
    ipv4: bool
    ipv6: bool

    mut def __init__(self, ipv4: ?bool=None, ipv6: ?bool=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4 = ipv4 if ipv4 is not None else False
        self.ipv6 = ipv6 if ipv6 is not None else False

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            children['ipv4'] = yang.gdata.Leaf('boolean', _ipv4)
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            children['ipv6'] = yang.gdata.Leaf('boolean', _ipv6)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(ipv4=n.get_opt_bool('ipv4'), ipv6=n.get_opt_bool('ipv6'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/multicast/multicast-address-family')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family()')
        leaves = []
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            leaves.append('{self_name}.ipv4 = {repr(_ipv4)}')
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            leaves.append('{self_name}.ipv6 = {repr(_ipv6)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/multicast/multicast-address-family'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.from_xml_opt_bool(node, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.from_xml_opt_bool(node, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv6, child_ipv6)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'ipv4':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.take_json_opt_bool(jd, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.take_json_opt_bool(jd, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family__ipv6, child_ipv6)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__protocol_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__protocol_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(yang.adata.MNode):
    multicast_site_type: str
    multicast_address_family: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family
    protocol_type: str

    mut def __init__(self, multicast_site_type: ?str=None, multicast_address_family: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family=None, protocol_type: ?str=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.multicast_site_type = multicast_site_type if multicast_site_type is not None else "source-receiver"
        self.multicast_address_family = multicast_address_family if multicast_address_family is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family()
        self.protocol_type = protocol_type if protocol_type is not None else "both"

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _multicast_site_type = self.multicast_site_type
        if _multicast_site_type is not None:
            children['multicast-site-type'] = yang.gdata.Leaf('enumeration', _multicast_site_type)
        _multicast_address_family = self.multicast_address_family
        if _multicast_address_family is not None:
            children['multicast-address-family'] = _multicast_address_family.to_gdata()
        _protocol_type = self.protocol_type
        if _protocol_type is not None:
            children['protocol-type'] = yang.gdata.Leaf('enumeration', _protocol_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(multicast_site_type=n.get_opt_str('multicast-site-type'), multicast_address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family.from_gdata(n.get_opt_cnt('multicast-address-family')), protocol_type=n.get_opt_str('protocol-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service/multicast')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast()')
        leaves = []
        _multicast_site_type = self.multicast_site_type
        if _multicast_site_type is not None:
            leaves.append('{self_name}.multicast_site_type = {repr(_multicast_site_type)}')
        _multicast_address_family = self.multicast_address_family
        if _multicast_address_family is not None:
            res.extend(_multicast_address_family.prsrc('{self_name}.multicast_address_family', False).splitlines())
        _protocol_type = self.protocol_type
        if _protocol_type is not None:
            leaves.append('{self_name}.protocol_type = {repr(_protocol_type)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service/multicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_multicast_site_type = yang.gdata.from_xml_opt_str(node, 'multicast-site-type')
    yang.gdata.maybe_add(children, 'multicast-site-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_site_type, child_multicast_site_type)
    child_multicast_address_family = yang.gdata.from_xml_opt_cnt(node, 'multicast-address-family')
    yang.gdata.maybe_add(children, 'multicast-address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family, child_multicast_address_family)
    child_protocol_type = yang.gdata.from_xml_opt_str(node, 'protocol-type')
    yang.gdata.maybe_add(children, 'protocol-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__protocol_type, child_protocol_type)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'multicast-site-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'multicast-address-family':
            child = {'multicast-address-family': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'protocol-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_multicast_site_type = yang.gdata.take_json_opt_str(jd, 'multicast-site-type')
    yang.gdata.maybe_add(children, 'multicast-site-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_site_type, child_multicast_site_type)
    child_multicast_address_family = yang.gdata.take_json_opt_cnt(jd, 'multicast-address-family')
    yang.gdata.maybe_add(children, 'multicast-address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__multicast_address_family, child_multicast_address_family)
    child_protocol_type = yang.gdata.take_json_opt_str(jd, 'protocol-type')
    yang.gdata.maybe_add(children, 'protocol-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast__protocol_type, child_protocol_type)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__service(yang.adata.MNode):
    qos: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos
    carrierscarrier: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier
    multicast: ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast

    mut def __init__(self, qos: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos=None, carrierscarrier: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier=None, multicast: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.qos = qos if qos is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos()
        self.carrierscarrier = carrierscarrier if carrierscarrier is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier()
        self.multicast = multicast if multicast is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _qos = self.qos
        if _qos is not None:
            children['qos'] = _qos.to_gdata()
        _carrierscarrier = self.carrierscarrier
        if _carrierscarrier is not None:
            children['carrierscarrier'] = _carrierscarrier.to_gdata()
        _multicast = self.multicast
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__service:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__service(qos=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos.from_gdata(n.get_opt_cnt('qos')), carrierscarrier=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier.from_gdata(n.get_opt_cnt('carrierscarrier')), multicast=ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast.from_gdata(n.get_opt_cnt('multicast')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__service()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/service')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__service()')
        leaves = []
        _qos = self.qos
        if _qos is not None:
            res.extend(_qos.prsrc('{self_name}.qos', False).splitlines())
        _carrierscarrier = self.carrierscarrier
        if _carrierscarrier is not None:
            res.extend(_carrierscarrier.prsrc('{self_name}.carrierscarrier', False).splitlines())
        _multicast = self.multicast
        if _multicast is not None:
            res.extend(_multicast.prsrc('{self_name}.multicast', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/service'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_qos = yang.gdata.from_xml_opt_cnt(node, 'qos')
    yang.gdata.maybe_add(children, 'qos', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos, child_qos)
    child_carrierscarrier = yang.gdata.from_xml_opt_cnt(node, 'carrierscarrier')
    yang.gdata.maybe_add(children, 'carrierscarrier', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier, child_carrierscarrier)
    child_multicast = yang.gdata.from_xml_opt_cnt(node, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast, child_multicast)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'qos':
            child = {'qos': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'carrierscarrier':
            child = {'carrierscarrier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'multicast':
            child = {'multicast': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_qos = yang.gdata.take_json_opt_cnt(jd, 'qos')
    yang.gdata.maybe_add(children, 'qos', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__qos, child_qos)
    child_carrierscarrier = yang.gdata.take_json_opt_cnt(jd, 'carrierscarrier')
    yang.gdata.maybe_add(children, 'carrierscarrier', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__carrierscarrier, child_carrierscarrier)
    child_multicast = yang.gdata.take_json_opt_cnt(jd, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service__multicast, child_multicast)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(yang.adata.MNode):
    enabled: bool

    mut def __init__(self, enabled: ?bool=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(enabled=n.get_opt_bool('enabled'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/traffic-protection')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection()')
        leaves = []
        _enabled = self.enabled
        if _enabled is not None:
            leaves.append('{self_name}.enabled = {repr(_enabled)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/traffic-protection'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.from_xml_opt_bool(node, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection__enabled, child_enabled)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection__enabled, child_enabled)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:routing-protocol-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:routing-protocol-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__area_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__area_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(yang.adata.MNode):
    target_site: str
    metric: int

    mut def __init__(self, target_site: str, metric: ?int=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.target_site = target_site
        self.metric = metric if metric is not None else 1

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _target_site = self.target_site
        if _target_site is not None:
            children['target-site'] = yang.gdata.Leaf('string', _target_site)
        _metric = self.metric
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site=n.get_str('target-site'), metric=n.get_opt_int('metric'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf/sham-links/sham-link')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link({repr(self.target_site)})')
        leaves = []
        _metric = self.metric
        if _metric is not None:
            leaves.append('{self_name}.metric = {repr(_metric)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf/sham-links/sham-link'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'sham-link'
        self.elements = elements

    mut def create(self, target_site):
        for e in self.elements:
            match = True
            if e.target_site != target_site:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['target-site'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_target_site = yang.gdata.from_xml_str(node, 'target-site')
    yang.gdata.maybe_add(children, 'target-site', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site, child_target_site)
    child_metric = yang.gdata.from_xml_opt_int(node, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric, child_metric)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(e) for e in nodes]
    return yang.gdata.List(keys=['target-site'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['target-site']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['target-site'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(keys[0])
        if point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['target-site']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['target-site'])))
        return yang.gdata.List(['target-site'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['target-site'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_target_site = yang.gdata.take_json_str(jd, 'target-site')
    yang.gdata.maybe_add(children, 'target-site', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site, child_target_site)
    child_metric = yang.gdata.take_json_opt_int(jd, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric, child_metric)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['target-site'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(yang.adata.MNode):
    sham_link: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link

    mut def __init__(self, sham_link: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.sham_link = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(elements=sham_link)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _sham_link = self.sham_link
        if _sham_link is not None:
            children['sham-link'] = _sham_link.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(sham_link=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link.from_gdata(n.get_opt_list('sham-link')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf/sham-links')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links()')
        leaves = []
        _sham_link = self.sham_link
        for _element in _sham_link.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf/sham-links/sham-link element: {_element.to_gdata().key_str(['target-site'])}")
            list_elem = 'sham_link_element = {self_name}.sham_link.create({repr(_element.target_site)})'
            res.append(list_elem)
            res.extend(_element.prsrc('sham_link_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf/sham-links'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_sham_link = yang.gdata.from_xml_opt_list(node, 'sham-link')
    yang.gdata.maybe_add(children, 'sham-link', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link, child_sham_link)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'sham-link':
            child = {'sham-link': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_sham_link = yang.gdata.take_json_opt_list(jd, 'sham-link')
    yang.gdata.maybe_add(children, 'sham-link', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links__sham_link, child_sham_link)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(yang.adata.MNode):
    address_family: list[str]
    area_address: str
    metric: int
    sham_links: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links

    mut def __init__(self, area_address: str, address_family: ?list[str]=None, metric: ?int=None, sham_links: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []
        self.area_address = area_address
        self.metric = metric if metric is not None else 1
        self.sham_links = sham_links if sham_links is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        _area_address = self.area_address
        if _area_address is not None:
            children['area-address'] = yang.gdata.Leaf('string', _area_address)
        _metric = self.metric
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        _sham_links = self.sham_links
        if _sham_links is not None:
            children['sham-links'] = _sham_links.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(address_family=n.get_strs('address-family'), area_address=n.get_str('area-address'), metric=n.get_opt_int('metric'), sham_links=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links.from_gdata(n.get_opt_cnt('sham-links')))
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf({repr(self.area_address)})')
        leaves = []
        _metric = self.metric
        if _metric is not None:
            leaves.append('{self_name}.metric = {repr(_metric)}')
        _sham_links = self.sham_links
        if _sham_links is not None:
            res.extend(_sham_links.prsrc('{self_name}.sham_links', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__address_family, child_address_family)
    child_area_address = yang.gdata.from_xml_str(node, 'area-address')
    yang.gdata.maybe_add(children, 'area-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__area_address, child_area_address)
    child_metric = yang.gdata.from_xml_opt_int(node, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__metric, child_metric)
    child_sham_links = yang.gdata.from_xml_opt_cnt(node, 'sham-links')
    yang.gdata.maybe_add(children, 'sham-links', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links, child_sham_links)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'area-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'sham-links':
            child = {'sham-links': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__address_family, child_address_family)
    child_area_address = yang.gdata.take_json_str(jd, 'area-address')
    yang.gdata.maybe_add(children, 'area-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__area_address, child_area_address)
    child_metric = yang.gdata.take_json_opt_int(jd, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__metric, child_metric)
    child_sham_links = yang.gdata.take_json_opt_cnt(jd, 'sham-links')
    yang.gdata.maybe_add(children, 'sham-links', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf__sham_links, child_sham_links)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__autonomous_system(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__autonomous_system(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(yang.adata.MNode):
    autonomous_system: int
    address_family: list[str]

    mut def __init__(self, autonomous_system: int, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.autonomous_system = autonomous_system
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _autonomous_system = self.autonomous_system
        if _autonomous_system is not None:
            children['autonomous-system'] = yang.gdata.Leaf('uint32', _autonomous_system)
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(autonomous_system=n.get_int('autonomous-system'), address_family=n.get_strs('address-family'))
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/bgp')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp({repr(self.autonomous_system)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/bgp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_autonomous_system = yang.gdata.from_xml_int(node, 'autonomous-system')
    yang.gdata.maybe_add(children, 'autonomous-system', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__autonomous_system, child_autonomous_system)
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'autonomous-system':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_autonomous_system = yang.gdata.take_json_int(jd, 'autonomous-system')
    yang.gdata.maybe_add(children, 'autonomous-system', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__autonomous_system, child_autonomous_system)
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        _next_hop = self.next_hop
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv4-lan-prefixes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes({repr(self.lan)}, {repr(self.next_hop)})')
        leaves = []
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            leaves.append('{self_name}.lan_tag = {repr(_lan_tag)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv4-lan-prefixes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv4-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self.elements:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.from_xml_str(node, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.from_xml_str(node, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.from_xml_opt_str(node, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(e) for e in nodes]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['lan', 'next-hop']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(keys[0])
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(keys[1])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['lan', 'next-hop'])))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.take_json_str(jd, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.take_json_str(jd, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.take_json_opt_str(jd, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        _next_hop = self.next_hop
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv6-lan-prefixes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes({repr(self.lan)}, {repr(self.next_hop)})')
        leaves = []
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            leaves.append('{self_name}.lan_tag = {repr(_lan_tag)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv6-lan-prefixes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv6-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self.elements:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.from_xml_str(node, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.from_xml_str(node, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.from_xml_opt_str(node, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(e) for e in nodes]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['lan', 'next-hop']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(keys[0])
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(keys[1])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['lan', 'next-hop'])))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.take_json_str(jd, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.take_json_str(jd, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.take_json_opt_str(jd, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.adata.MNode):
    ipv4_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes
    ipv6_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes

    mut def __init__(self, ipv4_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]=[], ipv6_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(elements=ipv4_lan_prefixes)
        self.ipv6_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(elements=ipv6_lan_prefixes)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4_lan_prefixes = self.ipv4_lan_prefixes
        if _ipv4_lan_prefixes is not None:
            children['ipv4-lan-prefixes'] = _ipv4_lan_prefixes.to_gdata()
        _ipv6_lan_prefixes = self.ipv6_lan_prefixes
        if _ipv6_lan_prefixes is not None:
            children['ipv6-lan-prefixes'] = _ipv6_lan_prefixes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(ipv4_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes.from_gdata(n.get_opt_list('ipv4-lan-prefixes')), ipv6_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes.from_gdata(n.get_opt_list('ipv6-lan-prefixes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()')
        leaves = []
        _ipv4_lan_prefixes = self.ipv4_lan_prefixes
        for _element in _ipv4_lan_prefixes.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv4-lan-prefixes element: {_element.to_gdata().key_str(['lan', 'next-hop'])}")
            list_elem = 'ipv4_lan_prefixes_element = {self_name}.ipv4_lan_prefixes.create({repr(_element.lan)}, {repr(_element.next_hop)})'
            res.append(list_elem)
            res.extend(_element.prsrc('ipv4_lan_prefixes_element', False, list_element=True).splitlines())
        _ipv6_lan_prefixes = self.ipv6_lan_prefixes
        for _element in _ipv6_lan_prefixes.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv6-lan-prefixes element: {_element.to_gdata().key_str(['lan', 'next-hop'])}")
            list_elem = 'ipv6_lan_prefixes_element = {self_name}.ipv6_lan_prefixes.create({repr(_element.lan)}, {repr(_element.next_hop)})'
            res.append(list_elem)
            res.extend(_element.prsrc('ipv6_lan_prefixes_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static/cascaded-lan-prefixes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4_lan_prefixes = yang.gdata.from_xml_opt_list(node, 'ipv4-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv4-lan-prefixes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes, child_ipv4_lan_prefixes)
    child_ipv6_lan_prefixes = yang.gdata.from_xml_opt_list(node, 'ipv6-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv6-lan-prefixes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes, child_ipv6_lan_prefixes)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'ipv4-lan-prefixes':
            child = {'ipv4-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'ipv6-lan-prefixes':
            child = {'ipv6-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4_lan_prefixes = yang.gdata.take_json_opt_list(jd, 'ipv4-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv4-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes, child_ipv4_lan_prefixes)
    child_ipv6_lan_prefixes = yang.gdata.take_json_opt_list(jd, 'ipv6-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv6-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes, child_ipv6_lan_prefixes)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(yang.adata.MNode):
    cascaded_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes

    mut def __init__(self, cascaded_lan_prefixes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cascaded_lan_prefixes = cascaded_lan_prefixes if cascaded_lan_prefixes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cascaded_lan_prefixes = self.cascaded_lan_prefixes
        if _cascaded_lan_prefixes is not None:
            children['cascaded-lan-prefixes'] = _cascaded_lan_prefixes.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(cascaded_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_gdata(n.get_opt_cnt('cascaded-lan-prefixes')))
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static()')
        leaves = []
        _cascaded_lan_prefixes = self.cascaded_lan_prefixes
        if _cascaded_lan_prefixes is not None:
            res.extend(_cascaded_lan_prefixes.prsrc('{self_name}.cascaded_lan_prefixes', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_cascaded_lan_prefixes = yang.gdata.from_xml_opt_cnt(node, 'cascaded-lan-prefixes')
    yang.gdata.maybe_add(children, 'cascaded-lan-prefixes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes, child_cascaded_lan_prefixes)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'cascaded-lan-prefixes':
            child = {'cascaded-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cascaded_lan_prefixes = yang.gdata.take_json_opt_cnt(jd, 'cascaded-lan-prefixes')
    yang.gdata.maybe_add(children, 'cascaded-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static__cascaded_lan_prefixes, child_cascaded_lan_prefixes)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(address_family=n.get_strs('address-family'))
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/rip')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/rip'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(address_family=n.get_strs('address-family'))
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/vrrp')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/vrrp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(yang.adata.MNode):
    type: Identityref
    ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf
    bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp
    static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static
    rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip
    vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp

    mut def __init__(self, type: Identityref, ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf=None, bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp=None, static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static=None, rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip=None, vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type
        self.ospf = ospf
        self.bgp = bgp
        self.static = static
        self.rip = rip
        self.vrrp = vrrp

    mut def create_ospf(self, area_address):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(area_address)
        self.ospf = res
        return res

    mut def create_bgp(self, autonomous_system):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(autonomous_system)
        self.bgp = res
        return res

    mut def create_static(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static()
        self.static = res
        return res

    mut def create_rip(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip()
        self.rip = res
        return res

    mut def create_vrrp(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp()
        self.vrrp = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        if _type is not None:
            _identityref_type, error = complete_and_validate_identityref(_type, _identities, ['l3vpn-svc:routing-protocol-type'], 'ietf-l3vpn-svc')
            if _identityref_type is not None:
                _type = _identityref_type
            else:
                raise ValueError('Invalid value for identityref leaf type: {error}')
            children['type'] = yang.gdata.Leaf('identityref', _type)
        _ospf = self.ospf
        if _ospf is not None:
            children['ospf'] = _ospf.to_gdata()
        _bgp = self.bgp
        if _bgp is not None:
            children['bgp'] = _bgp.to_gdata()
        _static = self.static
        if _static is not None:
            children['static'] = _static.to_gdata()
        _rip = self.rip
        if _rip is not None:
            children['rip'] = _rip.to_gdata()
        _vrrp = self.vrrp
        if _vrrp is not None:
            children['vrrp'] = _vrrp.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(type=n.get_Identityref('type'), ospf=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf.from_gdata(n.get_opt_cnt('ospf')), bgp=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp.from_gdata(n.get_opt_cnt('bgp')), static=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static.from_gdata(n.get_opt_cnt('static')), rip=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip.from_gdata(n.get_opt_cnt('rip')), vrrp=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp.from_gdata(n.get_opt_cnt('vrrp')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols/routing-protocol')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol({repr(self.type)})')
        leaves = []
        _ospf = self.ospf
        if _ospf is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/ospf')
            res.append('ospf = {self_name}.create_ospf({repr(_ospf.area_address)})')
            res.extend(_ospf.prsrc('ospf', False).splitlines())
        _bgp = self.bgp
        if _bgp is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/bgp')
            res.append('bgp = {self_name}.create_bgp({repr(_bgp.autonomous_system)})')
            res.extend(_bgp.prsrc('bgp', False).splitlines())
        _static = self.static
        if _static is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/static')
            res.append('static = {self_name}.create_static()')
            res.extend(_static.prsrc('static', False).splitlines())
        _rip = self.rip
        if _rip is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/rip')
            res.append('rip = {self_name}.create_rip()')
            res.extend(_rip.prsrc('rip', False).splitlines())
        _vrrp = self.vrrp
        if _vrrp is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol/vrrp')
            res.append('vrrp = {self_name}.create_vrrp()')
            res.extend(_vrrp.prsrc('vrrp', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols/routing-protocol'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'routing-protocol'
        self.elements = elements

    mut def create(self, type):
        for e in self.elements:
            match = True
            if e.type != type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry(type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['type'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_type = yang.gdata.from_xml_Identityref(node, 'type')
    yang.gdata.maybe_add(children, 'type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__type, child_type)
    child_ospf = yang.gdata.from_xml_opt_cnt(node, 'ospf')
    yang.gdata.maybe_add(children, 'ospf', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf, child_ospf)
    child_bgp = yang.gdata.from_xml_opt_cnt(node, 'bgp')
    yang.gdata.maybe_add(children, 'bgp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp, child_bgp)
    child_static = yang.gdata.from_xml_opt_cnt(node, 'static')
    yang.gdata.maybe_add(children, 'static', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static, child_static)
    child_rip = yang.gdata.from_xml_opt_cnt(node, 'rip')
    yang.gdata.maybe_add(children, 'rip', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip, child_rip)
    child_vrrp = yang.gdata.from_xml_opt_cnt(node, 'vrrp')
    yang.gdata.maybe_add(children, 'vrrp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp, child_vrrp)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(e) for e in nodes]
    return yang.gdata.List(keys=['type'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['type']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__type(Identityref.from_json(keys[0]))
        if point == 'ospf':
            children['ospf'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf(jd, rest_path, op)
        if point == 'bgp':
            children['bgp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp(jd, rest_path, op)
        if point == 'static':
            children['static'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static(jd, rest_path, op)
        if point == 'rip':
            children['rip'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip(jd, rest_path, op)
        if point == 'vrrp':
            children['vrrp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['type'])))
        return yang.gdata.List(['type'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_type = yang.gdata.take_json_Identityref(jd, 'type')
    yang.gdata.maybe_add(children, 'type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__type, child_type)
    child_ospf = yang.gdata.take_json_opt_cnt(jd, 'ospf')
    yang.gdata.maybe_add(children, 'ospf', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__ospf, child_ospf)
    child_bgp = yang.gdata.take_json_opt_cnt(jd, 'bgp')
    yang.gdata.maybe_add(children, 'bgp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__bgp, child_bgp)
    child_static = yang.gdata.take_json_opt_cnt(jd, 'static')
    yang.gdata.maybe_add(children, 'static', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__static, child_static)
    child_rip = yang.gdata.take_json_opt_cnt(jd, 'rip')
    yang.gdata.maybe_add(children, 'rip', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__rip, child_rip)
    child_vrrp = yang.gdata.take_json_opt_cnt(jd, 'vrrp')
    yang.gdata.maybe_add(children, 'vrrp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol__vrrp, child_vrrp)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['type'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(yang.adata.MNode):
    routing_protocol: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol

    mut def __init__(self, routing_protocol: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.routing_protocol = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(elements=routing_protocol)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _routing_protocol = self.routing_protocol
        if _routing_protocol is not None:
            children['routing-protocol'] = _routing_protocol.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(routing_protocol=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol.from_gdata(n.get_opt_list('routing-protocol')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/routing-protocols')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols()')
        leaves = []
        _routing_protocol = self.routing_protocol
        for _element in _routing_protocol.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/routing-protocols/routing-protocol element: {_element.to_gdata().key_str(['type'])}")
            list_elem = 'routing_protocol_element = {self_name}.routing_protocol.create({repr(_element.type)})'
            res.append(list_elem)
            res.extend(_element.prsrc('routing_protocol_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/routing-protocols'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_routing_protocol = yang.gdata.from_xml_opt_list(node, 'routing-protocol')
    yang.gdata.maybe_add(children, 'routing-protocol', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol, child_routing_protocol)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'routing-protocol':
            child = {'routing-protocol': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_routing_protocol = yang.gdata.take_json_opt_list(jd, 'routing-protocol')
    yang.gdata.maybe_add(children, 'routing-protocol', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols__routing_protocol, child_routing_protocol)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-network-access-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-network-access-type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-network-access-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-network-access-type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__location_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__location_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__device_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__device_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(yang.adata.MNode):
    group_id: str

    mut def __init__(self, group_id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(group_id=n.get_str('group-id'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/groups/group')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group({repr(self.group_id)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/groups/group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self.elements:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.from_xml_str(node, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group__group_id, child_group_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(e) for e in nodes]
    return yang.gdata.List(keys=['group-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['group-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group__group_id(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['group-id'])))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.take_json_str(jd, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group__group_id, child_group_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['group-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(elements=group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group.from_gdata(n.get_opt_list('group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/groups')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups()')
        leaves = []
        _group = self.group
        for _element in _group.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/groups/group element: {_element.to_gdata().key_str(['group-id'])}")
            list_elem = 'group_element = {self_name}.group.create({repr(_element.group_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('group_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/groups'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.from_xml_opt_list(node, 'group')
    yang.gdata.maybe_add(children, 'group', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group, child_group)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.take_json_opt_list(jd, 'group')
    yang.gdata.maybe_add(children, 'group', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups__group, child_group)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__constraint_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:placement-diversity'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf constraint-type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__constraint_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:placement-diversity'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf constraint-type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(yang.adata.MNode):
    group_id: str

    mut def __init__(self, group_id: str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(group_id=n.get_str('group-id'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint/target/group')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group({repr(self.group_id)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint/target/group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self.elements:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.from_xml_str(node, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group__group_id, child_group_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(e) for e in nodes]
    return yang.gdata.List(keys=['group-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['group-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group__group_id(keys[0])
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['group-id'])))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.take_json_str(jd, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group__group_id, child_group_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['group-id'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_accesses(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_accesses(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_groups(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_groups(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(yang.adata.MNode):
    group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group
    all_other_accesses: ?bool
    all_other_groups: ?bool

    mut def __init__(self, group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group_entry]=[], all_other_accesses: ?bool, all_other_groups: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(elements=group)
        self.all_other_accesses = all_other_accesses
        self.all_other_groups = all_other_groups

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        _all_other_accesses = self.all_other_accesses
        if _all_other_accesses is not None:
            children['all-other-accesses'] = yang.gdata.Leaf('empty', _all_other_accesses)
        _all_other_groups = self.all_other_groups
        if _all_other_groups is not None:
            children['all-other-groups'] = yang.gdata.Leaf('empty', _all_other_groups)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group.from_gdata(n.get_opt_list('group')), all_other_accesses=n.get_opt_empty('all-other-accesses'), all_other_groups=n.get_opt_empty('all-other-groups'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint/target')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target()')
        leaves = []
        _group = self.group
        for _element in _group.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint/target/group element: {_element.to_gdata().key_str(['group-id'])}")
            list_elem = 'group_element = {self_name}.group.create({repr(_element.group_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('group_element', False, list_element=True).splitlines())
        _all_other_accesses = self.all_other_accesses
        if _all_other_accesses is not None:
            leaves.append('{self_name}.all_other_accesses = {repr(_all_other_accesses)}')
        _all_other_groups = self.all_other_groups
        if _all_other_groups is not None:
            leaves.append('{self_name}.all_other_groups = {repr(_all_other_groups)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint/target'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.from_xml_opt_list(node, 'group')
    yang.gdata.maybe_add(children, 'group', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group, child_group)
    child_all_other_accesses = yang.gdata.from_xml_opt_empty(node, 'all-other-accesses')
    yang.gdata.maybe_add(children, 'all-other-accesses', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_accesses, child_all_other_accesses)
    child_all_other_groups = yang.gdata.from_xml_opt_empty(node, 'all-other-groups')
    yang.gdata.maybe_add(children, 'all-other-groups', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_groups, child_all_other_groups)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'group':
            child = {'group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'all-other-accesses':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'all-other-groups':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.take_json_opt_list(jd, 'group')
    yang.gdata.maybe_add(children, 'group', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__group, child_group)
    child_all_other_accesses = yang.gdata.take_json_opt_empty(jd, 'all-other-accesses')
    yang.gdata.maybe_add(children, 'all-other-accesses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_accesses, child_all_other_accesses)
    child_all_other_groups = yang.gdata.take_json_opt_empty(jd, 'all-other-groups')
    yang.gdata.maybe_add(children, 'all-other-groups', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target__all_other_groups, child_all_other_groups)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(yang.adata.MNode):
    constraint_type: Identityref
    target: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target

    mut def __init__(self, constraint_type: Identityref, target: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.constraint_type = constraint_type
        self.target = target if target is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _constraint_type = self.constraint_type
        if _constraint_type is not None:
            _identityref_constraint_type, error = complete_and_validate_identityref(_constraint_type, _identities, ['l3vpn-svc:placement-diversity'], 'ietf-l3vpn-svc')
            if _identityref_constraint_type is not None:
                _constraint_type = _identityref_constraint_type
            else:
                raise ValueError('Invalid value for identityref leaf constraint-type: {error}')
            children['constraint-type'] = yang.gdata.Leaf('identityref', _constraint_type)
        _target = self.target
        if _target is not None:
            children['target'] = _target.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(constraint_type=n.get_Identityref('constraint-type'), target=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target.from_gdata(n.get_opt_cnt('target')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint({repr(self.constraint_type)})')
        leaves = []
        _target = self.target
        if _target is not None:
            res.extend(_target.prsrc('{self_name}.target', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'constraint'
        self.elements = elements

    mut def create(self, constraint_type):
        for e in self.elements:
            match = True
            if e.constraint_type != constraint_type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry(constraint_type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['constraint-type'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_constraint_type = yang.gdata.from_xml_Identityref(node, 'constraint-type')
    yang.gdata.maybe_add(children, 'constraint-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__constraint_type, child_constraint_type)
    child_target = yang.gdata.from_xml_opt_cnt(node, 'target')
    yang.gdata.maybe_add(children, 'target', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target, child_target)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(e) for e in nodes]
    return yang.gdata.List(keys=['constraint-type'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['constraint-type']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['constraint-type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__constraint_type(Identityref.from_json(keys[0]))
        if point == 'target':
            children['target'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['constraint-type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['constraint-type'])))
        return yang.gdata.List(['constraint-type'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['constraint-type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_constraint_type = yang.gdata.take_json_Identityref(jd, 'constraint-type')
    yang.gdata.maybe_add(children, 'constraint-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__constraint_type, child_constraint_type)
    child_target = yang.gdata.take_json_opt_cnt(jd, 'target')
    yang.gdata.maybe_add(children, 'target', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint__target, child_target)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['constraint-type'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(yang.adata.MNode):
    constraint: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint

    mut def __init__(self, constraint: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.constraint = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(elements=constraint)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _constraint = self.constraint
        if _constraint is not None:
            children['constraint'] = _constraint.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(constraint=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint.from_gdata(n.get_opt_list('constraint')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints()')
        leaves = []
        _constraint = self.constraint
        for _element in _constraint.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints/constraint element: {_element.to_gdata().key_str(['constraint-type'])}")
            list_elem = 'constraint_element = {self_name}.constraint.create({repr(_element.constraint_type)})'
            res.append(list_elem)
            res.extend(_element.prsrc('constraint_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity/constraints'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_constraint = yang.gdata.from_xml_opt_list(node, 'constraint')
    yang.gdata.maybe_add(children, 'constraint', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint, child_constraint)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'constraint':
            child = {'constraint': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_constraint = yang.gdata.take_json_opt_list(jd, 'constraint')
    yang.gdata.maybe_add(children, 'constraint', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints__constraint, child_constraint)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(yang.adata.MNode):
    groups: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups
    constraints: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints

    mut def __init__(self, groups: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups=None, constraints: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.groups = groups if groups is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups()
        self.constraints = constraints if constraints is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _groups = self.groups
        if _groups is not None:
            children['groups'] = _groups.to_gdata()
        _constraints = self.constraints
        if _constraints is not None:
            children['constraints'] = _constraints.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(groups=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups.from_gdata(n.get_opt_cnt('groups')), constraints=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints.from_gdata(n.get_opt_cnt('constraints')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity()')
        leaves = []
        _groups = self.groups
        if _groups is not None:
            res.extend(_groups.prsrc('{self_name}.groups', False).splitlines())
        _constraints = self.constraints
        if _constraints is not None:
            res.extend(_constraints.prsrc('{self_name}.constraints', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/access-diversity'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_groups = yang.gdata.from_xml_opt_cnt(node, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups, child_groups)
    child_constraints = yang.gdata.from_xml_opt_cnt(node, 'constraints')
    yang.gdata.maybe_add(children, 'constraints', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints, child_constraints)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'groups':
            child = {'groups': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'constraints':
            child = {'constraints': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_groups = yang.gdata.take_json_opt_cnt(jd, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__groups, child_groups)
    child_constraints = yang.gdata.take_json_opt_cnt(jd, 'constraints')
    yang.gdata.maybe_add(children, 'constraints', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity__constraints, child_constraints)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__requested_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__requested_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__strict(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__strict(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(yang.adata.MNode):
    requested_type: ?str
    strict: bool

    mut def __init__(self, requested_type: ?str, strict: ?bool=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.requested_type = requested_type
        self.strict = strict if strict is not None else False

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _requested_type = self.requested_type
        if _requested_type is not None:
            children['requested-type'] = yang.gdata.Leaf('string', _requested_type)
        _strict = self.strict
        if _strict is not None:
            children['strict'] = yang.gdata.Leaf('boolean', _strict)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(requested_type=n.get_opt_str('requested-type'), strict=n.get_opt_bool('strict'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/bearer/requested-type')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type()')
        leaves = []
        _requested_type = self.requested_type
        if _requested_type is not None:
            leaves.append('{self_name}.requested_type = {repr(_requested_type)}')
        _strict = self.strict
        if _strict is not None:
            leaves.append('{self_name}.strict = {repr(_strict)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/bearer/requested-type'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_requested_type = yang.gdata.from_xml_opt_str(node, 'requested-type')
    yang.gdata.maybe_add(children, 'requested-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__requested_type, child_requested_type)
    child_strict = yang.gdata.from_xml_opt_bool(node, 'strict')
    yang.gdata.maybe_add(children, 'strict', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__strict, child_strict)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'requested-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'strict':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_requested_type = yang.gdata.take_json_opt_str(jd, 'requested-type')
    yang.gdata.maybe_add(children, 'requested-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__requested_type, child_requested_type)
    child_strict = yang.gdata.take_json_opt_bool(jd, 'strict')
    yang.gdata.maybe_add(children, 'strict', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type__strict, child_strict)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__always_on(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__always_on(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__bearer_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__bearer_reference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(yang.adata.MNode):
    requested_type: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type
    always_on: bool
    bearer_reference: ?str

    mut def __init__(self, requested_type: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type=None, always_on: ?bool=None, bearer_reference: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.requested_type = requested_type if requested_type is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type()
        self.always_on = always_on if always_on is not None else True
        self.bearer_reference = bearer_reference

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _requested_type = self.requested_type
        if _requested_type is not None:
            children['requested-type'] = _requested_type.to_gdata()
        _always_on = self.always_on
        if _always_on is not None:
            children['always-on'] = yang.gdata.Leaf('boolean', _always_on)
        _bearer_reference = self.bearer_reference
        if _bearer_reference is not None:
            children['bearer-reference'] = yang.gdata.Leaf('string', _bearer_reference)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(requested_type=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type.from_gdata(n.get_opt_cnt('requested-type')), always_on=n.get_opt_bool('always-on'), bearer_reference=n.get_opt_str('bearer-reference'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/bearer')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer()')
        leaves = []
        _requested_type = self.requested_type
        if _requested_type is not None:
            res.extend(_requested_type.prsrc('{self_name}.requested_type', False).splitlines())
        _always_on = self.always_on
        if _always_on is not None:
            leaves.append('{self_name}.always_on = {repr(_always_on)}')
        _bearer_reference = self.bearer_reference
        if _bearer_reference is not None:
            leaves.append('{self_name}.bearer_reference = {repr(_bearer_reference)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/bearer'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_requested_type = yang.gdata.from_xml_opt_cnt(node, 'requested-type')
    yang.gdata.maybe_add(children, 'requested-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type, child_requested_type)
    child_always_on = yang.gdata.from_xml_opt_bool(node, 'always-on')
    yang.gdata.maybe_add(children, 'always-on', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__always_on, child_always_on)
    child_bearer_reference = yang.gdata.from_xml_opt_str(node, 'bearer-reference')
    yang.gdata.maybe_add(children, 'bearer-reference', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__bearer_reference, child_bearer_reference)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'requested-type':
            child = {'requested-type': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'always-on':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'bearer-reference':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_requested_type = yang.gdata.take_json_opt_cnt(jd, 'requested-type')
    yang.gdata.maybe_add(children, 'requested-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__requested_type, child_requested_type)
    child_always_on = yang.gdata.take_json_opt_bool(jd, 'always-on')
    yang.gdata.maybe_add(children, 'always-on', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__always_on, child_always_on)
    child_bearer_reference = yang.gdata.take_json_opt_str(jd, 'bearer-reference')
    yang.gdata.maybe_add(children, 'bearer-reference', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer__bearer_reference, child_bearer_reference)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__address_allocation_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:address-allocation-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf address-allocation-type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__address_allocation_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:address-allocation-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf address-allocation-type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__number_of_dynamic_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__number_of_dynamic_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__start_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__start_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__end_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__end_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(yang.adata.MNode):
    group_id: str
    start_address: ?str
    end_address: ?str

    mut def __init__(self, group_id: str, start_address: ?str, end_address: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id
        self.start_address = start_address
        self.end_address = end_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        _start_address = self.start_address
        if _start_address is not None:
            children['start-address'] = yang.gdata.Leaf('string', _start_address)
        _end_address = self.end_address
        if _end_address is not None:
            children['end-address'] = yang.gdata.Leaf('string', _end_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(group_id=n.get_str('group-id'), start_address=n.get_opt_str('start-address'), end_address=n.get_opt_str('end-address'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/provider-dhcp/customer-addresses/address-group')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group({repr(self.group_id)})')
        leaves = []
        _start_address = self.start_address
        if _start_address is not None:
            leaves.append('{self_name}.start_address = {repr(_start_address)}')
        _end_address = self.end_address
        if _end_address is not None:
            leaves.append('{self_name}.end_address = {repr(_end_address)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/provider-dhcp/customer-addresses/address-group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'address-group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self.elements:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.from_xml_str(node, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__group_id, child_group_id)
    child_start_address = yang.gdata.from_xml_opt_str(node, 'start-address')
    yang.gdata.maybe_add(children, 'start-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__start_address, child_start_address)
    child_end_address = yang.gdata.from_xml_opt_str(node, 'end-address')
    yang.gdata.maybe_add(children, 'end-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__end_address, child_end_address)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(e) for e in nodes]
    return yang.gdata.List(keys=['group-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['group-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__group_id(keys[0])
        if point == 'start-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'end-address':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['group-id'])))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.take_json_str(jd, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__group_id, child_group_id)
    child_start_address = yang.gdata.take_json_opt_str(jd, 'start-address')
    yang.gdata.maybe_add(children, 'start-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__start_address, child_start_address)
    child_end_address = yang.gdata.take_json_opt_str(jd, 'end-address')
    yang.gdata.maybe_add(children, 'end-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group__end_address, child_end_address)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['group-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(yang.adata.MNode):
    address_group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group

    mut def __init__(self, address_group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(elements=address_group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_group = self.address_group
        if _address_group is not None:
            children['address-group'] = _address_group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(address_group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group.from_gdata(n.get_opt_list('address-group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/provider-dhcp/customer-addresses')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses()')
        leaves = []
        _address_group = self.address_group
        for _element in _address_group.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/provider-dhcp/customer-addresses/address-group element: {_element.to_gdata().key_str(['group-id'])}")
            list_elem = 'address_group_element = {self_name}.address_group.create({repr(_element.group_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('address_group_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/provider-dhcp/customer-addresses'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_group = yang.gdata.from_xml_opt_list(node, 'address-group')
    yang.gdata.maybe_add(children, 'address-group', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group, child_address_group)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-group':
            child = {'address-group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_group = yang.gdata.take_json_opt_list(jd, 'address-group')
    yang.gdata.maybe_add(children, 'address-group', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses__address_group, child_address_group)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    number_of_dynamic_address: int
    customer_addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, number_of_dynamic_address: ?int=None, customer_addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.number_of_dynamic_address = number_of_dynamic_address if number_of_dynamic_address is not None else 1
        self.customer_addresses = customer_addresses if customer_addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        _number_of_dynamic_address = self.number_of_dynamic_address
        if _number_of_dynamic_address is not None:
            children['number-of-dynamic-address'] = yang.gdata.Leaf('uint16', _number_of_dynamic_address)
        _customer_addresses = self.customer_addresses
        if _customer_addresses is not None:
            children['customer-addresses'] = _customer_addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_int('prefix-length'), number_of_dynamic_address=n.get_opt_int('number-of-dynamic-address'), customer_addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses.from_gdata(n.get_opt_cnt('customer-addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/provider-dhcp')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp()')
        leaves = []
        _provider_address = self.provider_address
        if _provider_address is not None:
            leaves.append('{self_name}.provider_address = {repr(_provider_address)}')
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            leaves.append('{self_name}.prefix_length = {repr(_prefix_length)}')
        _number_of_dynamic_address = self.number_of_dynamic_address
        if _number_of_dynamic_address is not None:
            leaves.append('{self_name}.number_of_dynamic_address = {repr(_number_of_dynamic_address)}')
        _customer_addresses = self.customer_addresses
        if _customer_addresses is not None:
            res.extend(_customer_addresses.prsrc('{self_name}.customer_addresses', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/provider-dhcp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.from_xml_opt_str(node, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.from_xml_opt_int(node, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__prefix_length, child_prefix_length)
    child_number_of_dynamic_address = yang.gdata.from_xml_opt_int(node, 'number-of-dynamic-address')
    yang.gdata.maybe_add(children, 'number-of-dynamic-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__number_of_dynamic_address, child_number_of_dynamic_address)
    child_customer_addresses = yang.gdata.from_xml_opt_cnt(node, 'customer-addresses')
    yang.gdata.maybe_add(children, 'customer-addresses', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses, child_customer_addresses)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'number-of-dynamic-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-addresses':
            child = {'customer-addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__prefix_length, child_prefix_length)
    child_number_of_dynamic_address = yang.gdata.take_json_opt_int(jd, 'number-of-dynamic-address')
    yang.gdata.maybe_add(children, 'number-of-dynamic-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__number_of_dynamic_address, child_number_of_dynamic_address)
    child_customer_addresses = yang.gdata.take_json_opt_cnt(jd, 'customer-addresses')
    yang.gdata.maybe_add(children, 'customer-addresses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp__customer_addresses, child_customer_addresses)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers__server_ip_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers__server_ip_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(yang.adata.MNode):
    server_ip_address: list[str]

    mut def __init__(self, server_ip_address: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.server_ip_address = server_ip_address if server_ip_address is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _server_ip_address = self.server_ip_address
        if _server_ip_address is not None:
            children['server-ip-address'] = yang.gdata.LeafList('string', _server_ip_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(server_ip_address=n.get_opt_strs('server-ip-address'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/dhcp-relay/customer-dhcp-servers')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers()')
        leaves = []
        _server_ip_address = self.server_ip_address
        if _server_ip_address is not None:
            leaves.append('{self_name}.server_ip_address = {repr(_server_ip_address)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/dhcp-relay/customer-dhcp-servers'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_server_ip_address = yang.gdata.from_xml_opt_strs(node, 'server-ip-address')
    yang.gdata.maybe_add(children, 'server-ip-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers__server_ip_address, child_server_ip_address)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'server-ip-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_server_ip_address = yang.gdata.take_json_opt_strs(jd, 'server-ip-address')
    yang.gdata.maybe_add(children, 'server-ip-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers__server_ip_address, child_server_ip_address)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    customer_dhcp_servers: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, customer_dhcp_servers: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.customer_dhcp_servers = customer_dhcp_servers if customer_dhcp_servers is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        _customer_dhcp_servers = self.customer_dhcp_servers
        if _customer_dhcp_servers is not None:
            children['customer-dhcp-servers'] = _customer_dhcp_servers.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_int('prefix-length'), customer_dhcp_servers=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers.from_gdata(n.get_opt_cnt('customer-dhcp-servers')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/dhcp-relay')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay()')
        leaves = []
        _provider_address = self.provider_address
        if _provider_address is not None:
            leaves.append('{self_name}.provider_address = {repr(_provider_address)}')
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            leaves.append('{self_name}.prefix_length = {repr(_prefix_length)}')
        _customer_dhcp_servers = self.customer_dhcp_servers
        if _customer_dhcp_servers is not None:
            res.extend(_customer_dhcp_servers.prsrc('{self_name}.customer_dhcp_servers', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/dhcp-relay'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.from_xml_opt_str(node, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.from_xml_opt_int(node, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__prefix_length, child_prefix_length)
    child_customer_dhcp_servers = yang.gdata.from_xml_opt_cnt(node, 'customer-dhcp-servers')
    yang.gdata.maybe_add(children, 'customer-dhcp-servers', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers, child_customer_dhcp_servers)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-dhcp-servers':
            child = {'customer-dhcp-servers': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__prefix_length, child_prefix_length)
    child_customer_dhcp_servers = yang.gdata.take_json_opt_cnt(jd, 'customer-dhcp-servers')
    yang.gdata.maybe_add(children, 'customer-dhcp-servers', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay__customer_dhcp_servers, child_customer_dhcp_servers)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(yang.adata.MNode):
    provider_address: ?str
    customer_address: ?str
    prefix_length: ?int

    mut def __init__(self, provider_address: ?str, customer_address: ?str, prefix_length: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.customer_address = customer_address
        self.prefix_length = prefix_length

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _customer_address = self.customer_address
        if _customer_address is not None:
            children['customer-address'] = yang.gdata.Leaf('string', _customer_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(provider_address=n.get_opt_str('provider-address'), customer_address=n.get_opt_str('customer-address'), prefix_length=n.get_opt_int('prefix-length'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/addresses')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses()')
        leaves = []
        _provider_address = self.provider_address
        if _provider_address is not None:
            leaves.append('{self_name}.provider_address = {repr(_provider_address)}')
        _customer_address = self.customer_address
        if _customer_address is not None:
            leaves.append('{self_name}.customer_address = {repr(_customer_address)}')
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            leaves.append('{self_name}.prefix_length = {repr(_prefix_length)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4/addresses'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.from_xml_opt_str(node, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__provider_address, child_provider_address)
    child_customer_address = yang.gdata.from_xml_opt_str(node, 'customer-address')
    yang.gdata.maybe_add(children, 'customer-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__customer_address, child_customer_address)
    child_prefix_length = yang.gdata.from_xml_opt_int(node, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__prefix_length, child_prefix_length)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__provider_address, child_provider_address)
    child_customer_address = yang.gdata.take_json_opt_str(jd, 'customer-address')
    yang.gdata.maybe_add(children, 'customer-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__customer_address, child_customer_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses__prefix_length, child_prefix_length)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(yang.adata.MNode):
    address_allocation_type: ?Identityref
    provider_dhcp: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp
    dhcp_relay: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay
    addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses

    mut def __init__(self, address_allocation_type: ?Identityref, provider_dhcp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp=None, dhcp_relay: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay=None, addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_allocation_type = address_allocation_type
        self.provider_dhcp = provider_dhcp if provider_dhcp is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp()
        self.dhcp_relay = dhcp_relay if dhcp_relay is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay()
        self.addresses = addresses if addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_allocation_type = self.address_allocation_type
        if _address_allocation_type is not None:
            _identityref_address_allocation_type, error = complete_and_validate_identityref(_address_allocation_type, _identities, ['l3vpn-svc:address-allocation-type'], 'ietf-l3vpn-svc')
            if _identityref_address_allocation_type is not None:
                _address_allocation_type = _identityref_address_allocation_type
            else:
                raise ValueError('Invalid value for identityref leaf address-allocation-type: {error}')
            children['address-allocation-type'] = yang.gdata.Leaf('identityref', _address_allocation_type)
        _provider_dhcp = self.provider_dhcp
        if _provider_dhcp is not None:
            children['provider-dhcp'] = _provider_dhcp.to_gdata()
        _dhcp_relay = self.dhcp_relay
        if _dhcp_relay is not None:
            children['dhcp-relay'] = _dhcp_relay.to_gdata()
        _addresses = self.addresses
        if _addresses is not None:
            children['addresses'] = _addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(address_allocation_type=n.get_opt_Identityref('address-allocation-type'), provider_dhcp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp.from_gdata(n.get_opt_cnt('provider-dhcp')), dhcp_relay=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay.from_gdata(n.get_opt_cnt('dhcp-relay')), addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses.from_gdata(n.get_opt_cnt('addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4()')
        leaves = []
        _address_allocation_type = self.address_allocation_type
        if _address_allocation_type is not None:
            leaves.append('{self_name}.address_allocation_type = {repr(_address_allocation_type)}')
        _provider_dhcp = self.provider_dhcp
        if _provider_dhcp is not None:
            res.extend(_provider_dhcp.prsrc('{self_name}.provider_dhcp', False).splitlines())
        _dhcp_relay = self.dhcp_relay
        if _dhcp_relay is not None:
            res.extend(_dhcp_relay.prsrc('{self_name}.dhcp_relay', False).splitlines())
        _addresses = self.addresses
        if _addresses is not None:
            res.extend(_addresses.prsrc('{self_name}.addresses', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv4'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_allocation_type = yang.gdata.from_xml_opt_Identityref(node, 'address-allocation-type')
    yang.gdata.maybe_add(children, 'address-allocation-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__address_allocation_type, child_address_allocation_type)
    child_provider_dhcp = yang.gdata.from_xml_opt_cnt(node, 'provider-dhcp')
    yang.gdata.maybe_add(children, 'provider-dhcp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp, child_provider_dhcp)
    child_dhcp_relay = yang.gdata.from_xml_opt_cnt(node, 'dhcp-relay')
    yang.gdata.maybe_add(children, 'dhcp-relay', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay, child_dhcp_relay)
    child_addresses = yang.gdata.from_xml_opt_cnt(node, 'addresses')
    yang.gdata.maybe_add(children, 'addresses', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses, child_addresses)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-allocation-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'provider-dhcp':
            child = {'provider-dhcp': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'dhcp-relay':
            child = {'dhcp-relay': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'addresses':
            child = {'addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_allocation_type = yang.gdata.take_json_opt_Identityref(jd, 'address-allocation-type')
    yang.gdata.maybe_add(children, 'address-allocation-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__address_allocation_type, child_address_allocation_type)
    child_provider_dhcp = yang.gdata.take_json_opt_cnt(jd, 'provider-dhcp')
    yang.gdata.maybe_add(children, 'provider-dhcp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__provider_dhcp, child_provider_dhcp)
    child_dhcp_relay = yang.gdata.take_json_opt_cnt(jd, 'dhcp-relay')
    yang.gdata.maybe_add(children, 'dhcp-relay', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__dhcp_relay, child_dhcp_relay)
    child_addresses = yang.gdata.take_json_opt_cnt(jd, 'addresses')
    yang.gdata.maybe_add(children, 'addresses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4__addresses, child_addresses)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__address_allocation_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:address-allocation-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf address-allocation-type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__address_allocation_type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:address-allocation-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf address-allocation-type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__number_of_dynamic_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__number_of_dynamic_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__group_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__start_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__start_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__end_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__end_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(yang.adata.MNode):
    group_id: str
    start_address: ?str
    end_address: ?str

    mut def __init__(self, group_id: str, start_address: ?str, end_address: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.group_id = group_id
        self.start_address = start_address
        self.end_address = end_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_id = self.group_id
        if _group_id is not None:
            children['group-id'] = yang.gdata.Leaf('string', _group_id)
        _start_address = self.start_address
        if _start_address is not None:
            children['start-address'] = yang.gdata.Leaf('string', _start_address)
        _end_address = self.end_address
        if _end_address is not None:
            children['end-address'] = yang.gdata.Leaf('string', _end_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(group_id=n.get_str('group-id'), start_address=n.get_opt_str('start-address'), end_address=n.get_opt_str('end-address'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/provider-dhcp/customer-addresses/address-group')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group({repr(self.group_id)})')
        leaves = []
        _start_address = self.start_address
        if _start_address is not None:
            leaves.append('{self_name}.start_address = {repr(_start_address)}')
        _end_address = self.end_address
        if _end_address is not None:
            leaves.append('{self_name}.end_address = {repr(_end_address)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/provider-dhcp/customer-addresses/address-group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'address-group'
        self.elements = elements

    mut def create(self, group_id):
        for e in self.elements:
            match = True
            if e.group_id != group_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry(group_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.from_xml_str(node, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__group_id, child_group_id)
    child_start_address = yang.gdata.from_xml_opt_str(node, 'start-address')
    yang.gdata.maybe_add(children, 'start-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__start_address, child_start_address)
    child_end_address = yang.gdata.from_xml_opt_str(node, 'end-address')
    yang.gdata.maybe_add(children, 'end-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__end_address, child_end_address)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(e) for e in nodes]
    return yang.gdata.List(keys=['group-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['group-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['group-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__group_id(keys[0])
        if point == 'start-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'end-address':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['group-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['group-id'])))
        return yang.gdata.List(['group-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['group-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_group_id = yang.gdata.take_json_str(jd, 'group-id')
    yang.gdata.maybe_add(children, 'group-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__group_id, child_group_id)
    child_start_address = yang.gdata.take_json_opt_str(jd, 'start-address')
    yang.gdata.maybe_add(children, 'start-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__start_address, child_start_address)
    child_end_address = yang.gdata.take_json_opt_str(jd, 'end-address')
    yang.gdata.maybe_add(children, 'end-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group__end_address, child_end_address)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['group-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(yang.adata.MNode):
    address_group: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group

    mut def __init__(self, address_group: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_group = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(elements=address_group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_group = self.address_group
        if _address_group is not None:
            children['address-group'] = _address_group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(address_group=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group.from_gdata(n.get_opt_list('address-group')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/provider-dhcp/customer-addresses')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses()')
        leaves = []
        _address_group = self.address_group
        for _element in _address_group.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/provider-dhcp/customer-addresses/address-group element: {_element.to_gdata().key_str(['group-id'])}")
            list_elem = 'address_group_element = {self_name}.address_group.create({repr(_element.group_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('address_group_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/provider-dhcp/customer-addresses'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_group = yang.gdata.from_xml_opt_list(node, 'address-group')
    yang.gdata.maybe_add(children, 'address-group', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group, child_address_group)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-group':
            child = {'address-group': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_group = yang.gdata.take_json_opt_list(jd, 'address-group')
    yang.gdata.maybe_add(children, 'address-group', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses__address_group, child_address_group)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    number_of_dynamic_address: int
    customer_addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, number_of_dynamic_address: ?int=None, customer_addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.number_of_dynamic_address = number_of_dynamic_address if number_of_dynamic_address is not None else 1
        self.customer_addresses = customer_addresses if customer_addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        _number_of_dynamic_address = self.number_of_dynamic_address
        if _number_of_dynamic_address is not None:
            children['number-of-dynamic-address'] = yang.gdata.Leaf('uint16', _number_of_dynamic_address)
        _customer_addresses = self.customer_addresses
        if _customer_addresses is not None:
            children['customer-addresses'] = _customer_addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_int('prefix-length'), number_of_dynamic_address=n.get_opt_int('number-of-dynamic-address'), customer_addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses.from_gdata(n.get_opt_cnt('customer-addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/provider-dhcp')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp()')
        leaves = []
        _provider_address = self.provider_address
        if _provider_address is not None:
            leaves.append('{self_name}.provider_address = {repr(_provider_address)}')
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            leaves.append('{self_name}.prefix_length = {repr(_prefix_length)}')
        _number_of_dynamic_address = self.number_of_dynamic_address
        if _number_of_dynamic_address is not None:
            leaves.append('{self_name}.number_of_dynamic_address = {repr(_number_of_dynamic_address)}')
        _customer_addresses = self.customer_addresses
        if _customer_addresses is not None:
            res.extend(_customer_addresses.prsrc('{self_name}.customer_addresses', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/provider-dhcp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.from_xml_opt_str(node, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.from_xml_opt_int(node, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__prefix_length, child_prefix_length)
    child_number_of_dynamic_address = yang.gdata.from_xml_opt_int(node, 'number-of-dynamic-address')
    yang.gdata.maybe_add(children, 'number-of-dynamic-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__number_of_dynamic_address, child_number_of_dynamic_address)
    child_customer_addresses = yang.gdata.from_xml_opt_cnt(node, 'customer-addresses')
    yang.gdata.maybe_add(children, 'customer-addresses', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses, child_customer_addresses)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'number-of-dynamic-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-addresses':
            child = {'customer-addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__prefix_length, child_prefix_length)
    child_number_of_dynamic_address = yang.gdata.take_json_opt_int(jd, 'number-of-dynamic-address')
    yang.gdata.maybe_add(children, 'number-of-dynamic-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__number_of_dynamic_address, child_number_of_dynamic_address)
    child_customer_addresses = yang.gdata.take_json_opt_cnt(jd, 'customer-addresses')
    yang.gdata.maybe_add(children, 'customer-addresses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp__customer_addresses, child_customer_addresses)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers__server_ip_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers__server_ip_address(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(yang.adata.MNode):
    server_ip_address: list[str]

    mut def __init__(self, server_ip_address: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.server_ip_address = server_ip_address if server_ip_address is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _server_ip_address = self.server_ip_address
        if _server_ip_address is not None:
            children['server-ip-address'] = yang.gdata.LeafList('string', _server_ip_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(server_ip_address=n.get_opt_strs('server-ip-address'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/dhcp-relay/customer-dhcp-servers')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers()')
        leaves = []
        _server_ip_address = self.server_ip_address
        if _server_ip_address is not None:
            leaves.append('{self_name}.server_ip_address = {repr(_server_ip_address)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/dhcp-relay/customer-dhcp-servers'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_server_ip_address = yang.gdata.from_xml_opt_strs(node, 'server-ip-address')
    yang.gdata.maybe_add(children, 'server-ip-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers__server_ip_address, child_server_ip_address)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'server-ip-address':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_server_ip_address = yang.gdata.take_json_opt_strs(jd, 'server-ip-address')
    yang.gdata.maybe_add(children, 'server-ip-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers__server_ip_address, child_server_ip_address)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(yang.adata.MNode):
    provider_address: ?str
    prefix_length: ?int
    customer_dhcp_servers: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers

    mut def __init__(self, provider_address: ?str, prefix_length: ?int, customer_dhcp_servers: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.prefix_length = prefix_length
        self.customer_dhcp_servers = customer_dhcp_servers if customer_dhcp_servers is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        _customer_dhcp_servers = self.customer_dhcp_servers
        if _customer_dhcp_servers is not None:
            children['customer-dhcp-servers'] = _customer_dhcp_servers.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(provider_address=n.get_opt_str('provider-address'), prefix_length=n.get_opt_int('prefix-length'), customer_dhcp_servers=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers.from_gdata(n.get_opt_cnt('customer-dhcp-servers')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/dhcp-relay')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay()')
        leaves = []
        _provider_address = self.provider_address
        if _provider_address is not None:
            leaves.append('{self_name}.provider_address = {repr(_provider_address)}')
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            leaves.append('{self_name}.prefix_length = {repr(_prefix_length)}')
        _customer_dhcp_servers = self.customer_dhcp_servers
        if _customer_dhcp_servers is not None:
            res.extend(_customer_dhcp_servers.prsrc('{self_name}.customer_dhcp_servers', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/dhcp-relay'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.from_xml_opt_str(node, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.from_xml_opt_int(node, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__prefix_length, child_prefix_length)
    child_customer_dhcp_servers = yang.gdata.from_xml_opt_cnt(node, 'customer-dhcp-servers')
    yang.gdata.maybe_add(children, 'customer-dhcp-servers', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers, child_customer_dhcp_servers)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-dhcp-servers':
            child = {'customer-dhcp-servers': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__provider_address, child_provider_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__prefix_length, child_prefix_length)
    child_customer_dhcp_servers = yang.gdata.take_json_opt_cnt(jd, 'customer-dhcp-servers')
    yang.gdata.maybe_add(children, 'customer-dhcp-servers', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay__customer_dhcp_servers, child_customer_dhcp_servers)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__provider_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__customer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(yang.adata.MNode):
    provider_address: ?str
    customer_address: ?str
    prefix_length: ?int

    mut def __init__(self, provider_address: ?str, customer_address: ?str, prefix_length: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.provider_address = provider_address
        self.customer_address = customer_address
        self.prefix_length = prefix_length

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _provider_address = self.provider_address
        if _provider_address is not None:
            children['provider-address'] = yang.gdata.Leaf('string', _provider_address)
        _customer_address = self.customer_address
        if _customer_address is not None:
            children['customer-address'] = yang.gdata.Leaf('string', _customer_address)
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            children['prefix-length'] = yang.gdata.Leaf('uint8', _prefix_length)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(provider_address=n.get_opt_str('provider-address'), customer_address=n.get_opt_str('customer-address'), prefix_length=n.get_opt_int('prefix-length'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/addresses')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses()')
        leaves = []
        _provider_address = self.provider_address
        if _provider_address is not None:
            leaves.append('{self_name}.provider_address = {repr(_provider_address)}')
        _customer_address = self.customer_address
        if _customer_address is not None:
            leaves.append('{self_name}.customer_address = {repr(_customer_address)}')
        _prefix_length = self.prefix_length
        if _prefix_length is not None:
            leaves.append('{self_name}.prefix_length = {repr(_prefix_length)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6/addresses'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.from_xml_opt_str(node, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__provider_address, child_provider_address)
    child_customer_address = yang.gdata.from_xml_opt_str(node, 'customer-address')
    yang.gdata.maybe_add(children, 'customer-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__customer_address, child_customer_address)
    child_prefix_length = yang.gdata.from_xml_opt_int(node, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__prefix_length, child_prefix_length)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'provider-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'customer-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'prefix-length':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_provider_address = yang.gdata.take_json_opt_str(jd, 'provider-address')
    yang.gdata.maybe_add(children, 'provider-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__provider_address, child_provider_address)
    child_customer_address = yang.gdata.take_json_opt_str(jd, 'customer-address')
    yang.gdata.maybe_add(children, 'customer-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__customer_address, child_customer_address)
    child_prefix_length = yang.gdata.take_json_opt_int(jd, 'prefix-length')
    yang.gdata.maybe_add(children, 'prefix-length', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses__prefix_length, child_prefix_length)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(yang.adata.MNode):
    address_allocation_type: ?Identityref
    provider_dhcp: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp
    dhcp_relay: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay
    addresses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses

    mut def __init__(self, address_allocation_type: ?Identityref, provider_dhcp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp=None, dhcp_relay: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay=None, addresses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_allocation_type = address_allocation_type
        self.provider_dhcp = provider_dhcp if provider_dhcp is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp()
        self.dhcp_relay = dhcp_relay if dhcp_relay is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay()
        self.addresses = addresses if addresses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_allocation_type = self.address_allocation_type
        if _address_allocation_type is not None:
            _identityref_address_allocation_type, error = complete_and_validate_identityref(_address_allocation_type, _identities, ['l3vpn-svc:address-allocation-type'], 'ietf-l3vpn-svc')
            if _identityref_address_allocation_type is not None:
                _address_allocation_type = _identityref_address_allocation_type
            else:
                raise ValueError('Invalid value for identityref leaf address-allocation-type: {error}')
            children['address-allocation-type'] = yang.gdata.Leaf('identityref', _address_allocation_type)
        _provider_dhcp = self.provider_dhcp
        if _provider_dhcp is not None:
            children['provider-dhcp'] = _provider_dhcp.to_gdata()
        _dhcp_relay = self.dhcp_relay
        if _dhcp_relay is not None:
            children['dhcp-relay'] = _dhcp_relay.to_gdata()
        _addresses = self.addresses
        if _addresses is not None:
            children['addresses'] = _addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(address_allocation_type=n.get_opt_Identityref('address-allocation-type'), provider_dhcp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp.from_gdata(n.get_opt_cnt('provider-dhcp')), dhcp_relay=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay.from_gdata(n.get_opt_cnt('dhcp-relay')), addresses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses.from_gdata(n.get_opt_cnt('addresses')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6()')
        leaves = []
        _address_allocation_type = self.address_allocation_type
        if _address_allocation_type is not None:
            leaves.append('{self_name}.address_allocation_type = {repr(_address_allocation_type)}')
        _provider_dhcp = self.provider_dhcp
        if _provider_dhcp is not None:
            res.extend(_provider_dhcp.prsrc('{self_name}.provider_dhcp', False).splitlines())
        _dhcp_relay = self.dhcp_relay
        if _dhcp_relay is not None:
            res.extend(_dhcp_relay.prsrc('{self_name}.dhcp_relay', False).splitlines())
        _addresses = self.addresses
        if _addresses is not None:
            res.extend(_addresses.prsrc('{self_name}.addresses', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/ipv6'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_allocation_type = yang.gdata.from_xml_opt_Identityref(node, 'address-allocation-type')
    yang.gdata.maybe_add(children, 'address-allocation-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__address_allocation_type, child_address_allocation_type)
    child_provider_dhcp = yang.gdata.from_xml_opt_cnt(node, 'provider-dhcp')
    yang.gdata.maybe_add(children, 'provider-dhcp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp, child_provider_dhcp)
    child_dhcp_relay = yang.gdata.from_xml_opt_cnt(node, 'dhcp-relay')
    yang.gdata.maybe_add(children, 'dhcp-relay', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay, child_dhcp_relay)
    child_addresses = yang.gdata.from_xml_opt_cnt(node, 'addresses')
    yang.gdata.maybe_add(children, 'addresses', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses, child_addresses)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-allocation-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'provider-dhcp':
            child = {'provider-dhcp': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'dhcp-relay':
            child = {'dhcp-relay': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'addresses':
            child = {'addresses': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_allocation_type = yang.gdata.take_json_opt_Identityref(jd, 'address-allocation-type')
    yang.gdata.maybe_add(children, 'address-allocation-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__address_allocation_type, child_address_allocation_type)
    child_provider_dhcp = yang.gdata.take_json_opt_cnt(jd, 'provider-dhcp')
    yang.gdata.maybe_add(children, 'provider-dhcp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__provider_dhcp, child_provider_dhcp)
    child_dhcp_relay = yang.gdata.take_json_opt_cnt(jd, 'dhcp-relay')
    yang.gdata.maybe_add(children, 'dhcp-relay', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__dhcp_relay, child_dhcp_relay)
    child_addresses = yang.gdata.take_json_opt_cnt(jd, 'addresses')
    yang.gdata.maybe_add(children, 'addresses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6__addresses, child_addresses)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__fixed_value(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__fixed_value(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(yang.adata.MNode):
    enabled: bool
    fixed_value: ?int
    profile_name: ?str

    mut def __init__(self, enabled: ?bool=None, fixed_value: ?int, profile_name: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.fixed_value = fixed_value
        self.profile_name = profile_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _fixed_value = self.fixed_value
        if _fixed_value is not None:
            children['fixed-value'] = yang.gdata.Leaf('uint32', _fixed_value)
        _profile_name = self.profile_name
        if _profile_name is not None:
            children['profile-name'] = yang.gdata.Leaf('leafref', _profile_name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(enabled=n.get_opt_bool('enabled'), fixed_value=n.get_opt_int('fixed-value'), profile_name=n.get_opt_str('profile-name'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/oam/bfd')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd()')
        leaves = []
        _enabled = self.enabled
        if _enabled is not None:
            leaves.append('{self_name}.enabled = {repr(_enabled)}')
        _fixed_value = self.fixed_value
        if _fixed_value is not None:
            leaves.append('{self_name}.fixed_value = {repr(_fixed_value)}')
        _profile_name = self.profile_name
        if _profile_name is not None:
            leaves.append('{self_name}.profile_name = {repr(_profile_name)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/oam/bfd'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.from_xml_opt_bool(node, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__enabled, child_enabled)
    child_fixed_value = yang.gdata.from_xml_opt_int(node, 'fixed-value')
    yang.gdata.maybe_add(children, 'fixed-value', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__fixed_value, child_fixed_value)
    child_profile_name = yang.gdata.from_xml_opt_str(node, 'profile-name')
    yang.gdata.maybe_add(children, 'profile-name', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__profile_name, child_profile_name)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'fixed-value':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'profile-name':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__enabled, child_enabled)
    child_fixed_value = yang.gdata.take_json_opt_int(jd, 'fixed-value')
    yang.gdata.maybe_add(children, 'fixed-value', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__fixed_value, child_fixed_value)
    child_profile_name = yang.gdata.take_json_opt_str(jd, 'profile-name')
    yang.gdata.maybe_add(children, 'profile-name', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd__profile_name, child_profile_name)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(yang.adata.MNode):
    bfd: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd

    mut def __init__(self, bfd: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.bfd = bfd if bfd is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _bfd = self.bfd
        if _bfd is not None:
            children['bfd'] = _bfd.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(bfd=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd.from_gdata(n.get_opt_cnt('bfd')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/oam')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam()')
        leaves = []
        _bfd = self.bfd
        if _bfd is not None:
            res.extend(_bfd.prsrc('{self_name}.bfd', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection/oam'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_bfd = yang.gdata.from_xml_opt_cnt(node, 'bfd')
    yang.gdata.maybe_add(children, 'bfd', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd, child_bfd)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'bfd':
            child = {'bfd': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_bfd = yang.gdata.take_json_opt_cnt(jd, 'bfd')
    yang.gdata.maybe_add(children, 'bfd', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam__bfd, child_bfd)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(yang.adata.MNode):
    ipv4: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4
    ipv6: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6
    oam: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam

    mut def __init__(self, ipv4: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4=None, ipv6: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6=None, oam: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4 = ipv4 if ipv4 is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4()
        self.ipv6 = ipv6 if ipv6 is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6()
        self.oam = oam if oam is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            children['ipv4'] = _ipv4.to_gdata()
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            children['ipv6'] = _ipv6.to_gdata()
        _oam = self.oam
        if _oam is not None:
            children['oam'] = _oam.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(ipv4=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4.from_gdata(n.get_opt_cnt('ipv4')), ipv6=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6.from_gdata(n.get_opt_cnt('ipv6')), oam=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam.from_gdata(n.get_opt_cnt('oam')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection()')
        leaves = []
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            res.extend(_ipv4.prsrc('{self_name}.ipv4', False).splitlines())
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            res.extend(_ipv6.prsrc('{self_name}.ipv6', False).splitlines())
        _oam = self.oam
        if _oam is not None:
            res.extend(_oam.prsrc('{self_name}.oam', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/ip-connection'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.from_xml_opt_cnt(node, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.from_xml_opt_cnt(node, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6, child_ipv6)
    child_oam = yang.gdata.from_xml_opt_cnt(node, 'oam')
    yang.gdata.maybe_add(children, 'oam', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam, child_oam)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'ipv4':
            child = {'ipv4': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'ipv6':
            child = {'ipv6': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'oam':
            child = {'oam': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.take_json_opt_cnt(jd, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.take_json_opt_cnt(jd, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__ipv6, child_ipv6)
    child_oam = yang.gdata.take_json_opt_cnt(jd, 'oam')
    yang.gdata.maybe_add(children, 'oam', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection__oam, child_oam)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security/authentication')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security/authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__enabled(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__layer(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__layer(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__profile_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__preshared_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__preshared_key(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(yang.adata.MNode):
    profile_name: ?str
    algorithm: ?str
    preshared_key: ?str

    mut def __init__(self, profile_name: ?str, algorithm: ?str, preshared_key: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile_name = profile_name
        self.algorithm = algorithm
        self.preshared_key = preshared_key

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile_name = self.profile_name
        if _profile_name is not None:
            children['profile-name'] = yang.gdata.Leaf('leafref', _profile_name)
        _algorithm = self.algorithm
        if _algorithm is not None:
            children['algorithm'] = yang.gdata.Leaf('string', _algorithm)
        _preshared_key = self.preshared_key
        if _preshared_key is not None:
            children['preshared-key'] = yang.gdata.Leaf('string', _preshared_key)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(profile_name=n.get_opt_str('profile-name'), algorithm=n.get_opt_str('algorithm'), preshared_key=n.get_opt_str('preshared-key'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security/encryption/encryption-profile')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile()')
        leaves = []
        _profile_name = self.profile_name
        if _profile_name is not None:
            leaves.append('{self_name}.profile_name = {repr(_profile_name)}')
        _algorithm = self.algorithm
        if _algorithm is not None:
            leaves.append('{self_name}.algorithm = {repr(_algorithm)}')
        _preshared_key = self.preshared_key
        if _preshared_key is not None:
            leaves.append('{self_name}.preshared_key = {repr(_preshared_key)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security/encryption/encryption-profile'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_profile_name = yang.gdata.from_xml_opt_str(node, 'profile-name')
    yang.gdata.maybe_add(children, 'profile-name', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__profile_name, child_profile_name)
    child_algorithm = yang.gdata.from_xml_opt_str(node, 'algorithm')
    yang.gdata.maybe_add(children, 'algorithm', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__algorithm, child_algorithm)
    child_preshared_key = yang.gdata.from_xml_opt_str(node, 'preshared-key')
    yang.gdata.maybe_add(children, 'preshared-key', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__preshared_key, child_preshared_key)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'profile-name':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'algorithm':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'preshared-key':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile_name = yang.gdata.take_json_opt_str(jd, 'profile-name')
    yang.gdata.maybe_add(children, 'profile-name', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__profile_name, child_profile_name)
    child_algorithm = yang.gdata.take_json_opt_str(jd, 'algorithm')
    yang.gdata.maybe_add(children, 'algorithm', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__algorithm, child_algorithm)
    child_preshared_key = yang.gdata.take_json_opt_str(jd, 'preshared-key')
    yang.gdata.maybe_add(children, 'preshared-key', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile__preshared_key, child_preshared_key)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(yang.adata.MNode):
    enabled: bool
    layer: ?str
    encryption_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile

    mut def __init__(self, enabled: ?bool=None, layer: ?str, encryption_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.enabled = enabled if enabled is not None else False
        self.layer = layer
        self.encryption_profile = encryption_profile if encryption_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enabled = self.enabled
        if _enabled is not None:
            children['enabled'] = yang.gdata.Leaf('boolean', _enabled)
        _layer = self.layer
        if _layer is not None:
            children['layer'] = yang.gdata.Leaf('enumeration', _layer)
        _encryption_profile = self.encryption_profile
        if _encryption_profile is not None:
            children['encryption-profile'] = _encryption_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(enabled=n.get_opt_bool('enabled'), layer=n.get_opt_str('layer'), encryption_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile.from_gdata(n.get_opt_cnt('encryption-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security/encryption')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption()')
        leaves = []
        _enabled = self.enabled
        if _enabled is not None:
            leaves.append('{self_name}.enabled = {repr(_enabled)}')
        _layer = self.layer
        if _layer is not None:
            leaves.append('{self_name}.layer = {repr(_layer)}')
        _encryption_profile = self.encryption_profile
        if _encryption_profile is not None:
            res.extend(_encryption_profile.prsrc('{self_name}.encryption_profile', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security/encryption'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.from_xml_opt_bool(node, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__enabled, child_enabled)
    child_layer = yang.gdata.from_xml_opt_str(node, 'layer')
    yang.gdata.maybe_add(children, 'layer', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__layer, child_layer)
    child_encryption_profile = yang.gdata.from_xml_opt_cnt(node, 'encryption-profile')
    yang.gdata.maybe_add(children, 'encryption-profile', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile, child_encryption_profile)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'enabled':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'layer':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'encryption-profile':
            child = {'encryption-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_enabled = yang.gdata.take_json_opt_bool(jd, 'enabled')
    yang.gdata.maybe_add(children, 'enabled', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__enabled, child_enabled)
    child_layer = yang.gdata.take_json_opt_str(jd, 'layer')
    yang.gdata.maybe_add(children, 'layer', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__layer, child_layer)
    child_encryption_profile = yang.gdata.take_json_opt_cnt(jd, 'encryption-profile')
    yang.gdata.maybe_add(children, 'encryption-profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption__encryption_profile, child_encryption_profile)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(yang.adata.MNode):
    authentication: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication
    encryption: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption

    mut def __init__(self, authentication: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication=None, encryption: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.authentication = authentication if authentication is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication()
        self.encryption = encryption if encryption is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _authentication = self.authentication
        if _authentication is not None:
            children['authentication'] = _authentication.to_gdata()
        _encryption = self.encryption
        if _encryption is not None:
            children['encryption'] = _encryption.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(authentication=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication.from_gdata(n.get_opt_cnt('authentication')), encryption=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption.from_gdata(n.get_opt_cnt('encryption')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security()')
        leaves = []
        _authentication = self.authentication
        if _authentication is not None:
            res.extend(_authentication.prsrc('{self_name}.authentication', False).splitlines())
        _encryption = self.encryption
        if _encryption is not None:
            res.extend(_encryption.prsrc('{self_name}.encryption', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/security'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_authentication = yang.gdata.from_xml_opt_cnt(node, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication, child_authentication)
    child_encryption = yang.gdata.from_xml_opt_cnt(node, 'encryption')
    yang.gdata.maybe_add(children, 'encryption', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption, child_encryption)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'authentication':
            child = {'authentication': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'encryption':
            child = {'encryption': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_authentication = yang.gdata.take_json_opt_cnt(jd, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__authentication, child_authentication)
    child_encryption = yang.gdata.take_json_opt_cnt(jd, 'encryption')
    yang.gdata.maybe_add(children, 'encryption', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security__encryption, child_encryption)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_input_bandwidth(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint64', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_input_bandwidth(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_output_bandwidth(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint64', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_output_bandwidth(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_mtu(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_mtu(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dscp(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dscp(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dot1p(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dot1p(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__target_sites(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__target_sites(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        _upper_port = self.upper_port
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(lower_port=n.get_opt_int('lower-port'), upper_port=n.get_opt_int('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule/match-flow/l4-src-port-range')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()')
        leaves = []
        _lower_port = self.lower_port
        if _lower_port is not None:
            leaves.append('{self_name}.lower_port = {repr(_lower_port)}')
        _upper_port = self.upper_port
        if _upper_port is not None:
            leaves.append('{self_name}.upper_port = {repr(_upper_port)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule/match-flow/l4-src-port-range'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.from_xml_opt_int(node, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.from_xml_opt_int(node, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.take_json_opt_int(jd, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.take_json_opt_int(jd, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.adata.MNode):
    lower_port: ?int
    upper_port: ?int

    mut def __init__(self, lower_port: ?int, upper_port: ?int):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lower_port = lower_port
        self.upper_port = upper_port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lower_port = self.lower_port
        if _lower_port is not None:
            children['lower-port'] = yang.gdata.Leaf('uint16', _lower_port)
        _upper_port = self.upper_port
        if _upper_port is not None:
            children['upper-port'] = yang.gdata.Leaf('uint16', _upper_port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(lower_port=n.get_opt_int('lower-port'), upper_port=n.get_opt_int('upper-port'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule/match-flow/l4-dst-port-range')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()')
        leaves = []
        _lower_port = self.lower_port
        if _lower_port is not None:
            leaves.append('{self_name}.lower_port = {repr(_lower_port)}')
        _upper_port = self.upper_port
        if _upper_port is not None:
            leaves.append('{self_name}.upper_port = {repr(_upper_port)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule/match-flow/l4-dst-port-range'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.from_xml_opt_int(node, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.from_xml_opt_int(node, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'lower-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'upper-port':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_lower_port = yang.gdata.take_json_opt_int(jd, 'lower-port')
    yang.gdata.maybe_add(children, 'lower-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__lower_port, child_lower_port)
    child_upper_port = yang.gdata.take_json_opt_int(jd, 'upper-port')
    yang.gdata.maybe_add(children, 'upper-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range__upper_port, child_upper_port)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__protocol_field(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__protocol_field(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(yang.adata.MNode):
    dscp: ?int
    dot1p: ?int
    ipv4_src_prefix: ?str
    ipv6_src_prefix: ?str
    ipv4_dst_prefix: ?str
    ipv6_dst_prefix: ?str
    l4_src_port: ?int
    target_sites: list[str]
    l4_src_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range
    l4_dst_port: ?int
    l4_dst_port_range: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range
    protocol_field: ?value

    mut def __init__(self, dscp: ?int, dot1p: ?int, ipv4_src_prefix: ?str, ipv6_src_prefix: ?str, ipv4_dst_prefix: ?str, ipv6_dst_prefix: ?str, l4_src_port: ?int, target_sites: ?list[str]=None, l4_src_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range=None, l4_dst_port: ?int, l4_dst_port_range: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range=None, protocol_field: ?value):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.dscp = dscp
        self.dot1p = dot1p
        self.ipv4_src_prefix = ipv4_src_prefix
        self.ipv6_src_prefix = ipv6_src_prefix
        self.ipv4_dst_prefix = ipv4_dst_prefix
        self.ipv6_dst_prefix = ipv6_dst_prefix
        self.l4_src_port = l4_src_port
        self.target_sites = target_sites if target_sites is not None else []
        self.l4_src_port_range = l4_src_port_range if l4_src_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range()
        self.l4_dst_port = l4_dst_port
        self.l4_dst_port_range = l4_dst_port_range if l4_dst_port_range is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range()
        self.protocol_field = protocol_field

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _dscp = self.dscp
        if _dscp is not None:
            children['dscp'] = yang.gdata.Leaf('uint8', _dscp)
        _dot1p = self.dot1p
        if _dot1p is not None:
            children['dot1p'] = yang.gdata.Leaf('uint8', _dot1p)
        _ipv4_src_prefix = self.ipv4_src_prefix
        if _ipv4_src_prefix is not None:
            children['ipv4-src-prefix'] = yang.gdata.Leaf('string', _ipv4_src_prefix)
        _ipv6_src_prefix = self.ipv6_src_prefix
        if _ipv6_src_prefix is not None:
            children['ipv6-src-prefix'] = yang.gdata.Leaf('string', _ipv6_src_prefix)
        _ipv4_dst_prefix = self.ipv4_dst_prefix
        if _ipv4_dst_prefix is not None:
            children['ipv4-dst-prefix'] = yang.gdata.Leaf('string', _ipv4_dst_prefix)
        _ipv6_dst_prefix = self.ipv6_dst_prefix
        if _ipv6_dst_prefix is not None:
            children['ipv6-dst-prefix'] = yang.gdata.Leaf('string', _ipv6_dst_prefix)
        _l4_src_port = self.l4_src_port
        if _l4_src_port is not None:
            children['l4-src-port'] = yang.gdata.Leaf('uint16', _l4_src_port)
        _target_sites = self.target_sites
        if _target_sites is not None:
            children['target-sites'] = yang.gdata.LeafList('string', _target_sites)
        _l4_src_port_range = self.l4_src_port_range
        if _l4_src_port_range is not None:
            children['l4-src-port-range'] = _l4_src_port_range.to_gdata()
        _l4_dst_port = self.l4_dst_port
        if _l4_dst_port is not None:
            children['l4-dst-port'] = yang.gdata.Leaf('uint16', _l4_dst_port)
        _l4_dst_port_range = self.l4_dst_port_range
        if _l4_dst_port_range is not None:
            children['l4-dst-port-range'] = _l4_dst_port_range.to_gdata()
        _protocol_field = self.protocol_field
        if _protocol_field is not None:
            children['protocol-field'] = yang.gdata.Leaf('union', _protocol_field)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(dscp=n.get_opt_int('dscp'), dot1p=n.get_opt_int('dot1p'), ipv4_src_prefix=n.get_opt_str('ipv4-src-prefix'), ipv6_src_prefix=n.get_opt_str('ipv6-src-prefix'), ipv4_dst_prefix=n.get_opt_str('ipv4-dst-prefix'), ipv6_dst_prefix=n.get_opt_str('ipv6-dst-prefix'), l4_src_port=n.get_opt_int('l4-src-port'), target_sites=n.get_opt_strs('target-sites'), l4_src_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range.from_gdata(n.get_opt_cnt('l4-src-port-range')), l4_dst_port=n.get_opt_int('l4-dst-port'), l4_dst_port_range=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range.from_gdata(n.get_opt_cnt('l4-dst-port-range')), protocol_field=n.get_opt_value('protocol-field'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule/match-flow')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow()')
        leaves = []
        _dscp = self.dscp
        if _dscp is not None:
            leaves.append('{self_name}.dscp = {repr(_dscp)}')
        _dot1p = self.dot1p
        if _dot1p is not None:
            leaves.append('{self_name}.dot1p = {repr(_dot1p)}')
        _ipv4_src_prefix = self.ipv4_src_prefix
        if _ipv4_src_prefix is not None:
            leaves.append('{self_name}.ipv4_src_prefix = {repr(_ipv4_src_prefix)}')
        _ipv6_src_prefix = self.ipv6_src_prefix
        if _ipv6_src_prefix is not None:
            leaves.append('{self_name}.ipv6_src_prefix = {repr(_ipv6_src_prefix)}')
        _ipv4_dst_prefix = self.ipv4_dst_prefix
        if _ipv4_dst_prefix is not None:
            leaves.append('{self_name}.ipv4_dst_prefix = {repr(_ipv4_dst_prefix)}')
        _ipv6_dst_prefix = self.ipv6_dst_prefix
        if _ipv6_dst_prefix is not None:
            leaves.append('{self_name}.ipv6_dst_prefix = {repr(_ipv6_dst_prefix)}')
        _l4_src_port = self.l4_src_port
        if _l4_src_port is not None:
            leaves.append('{self_name}.l4_src_port = {repr(_l4_src_port)}')
        _target_sites = self.target_sites
        if _target_sites is not None:
            leaves.append('{self_name}.target_sites = {repr(_target_sites)}')
        _l4_src_port_range = self.l4_src_port_range
        if _l4_src_port_range is not None:
            res.extend(_l4_src_port_range.prsrc('{self_name}.l4_src_port_range', False).splitlines())
        _l4_dst_port = self.l4_dst_port
        if _l4_dst_port is not None:
            leaves.append('{self_name}.l4_dst_port = {repr(_l4_dst_port)}')
        _l4_dst_port_range = self.l4_dst_port_range
        if _l4_dst_port_range is not None:
            res.extend(_l4_dst_port_range.prsrc('{self_name}.l4_dst_port_range', False).splitlines())
        _protocol_field = self.protocol_field
        if _protocol_field is not None:
            leaves.append('{self_name}.protocol_field = {repr(_protocol_field)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule/match-flow'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_dscp = yang.gdata.from_xml_opt_int(node, 'dscp')
    yang.gdata.maybe_add(children, 'dscp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dscp, child_dscp)
    child_dot1p = yang.gdata.from_xml_opt_int(node, 'dot1p')
    yang.gdata.maybe_add(children, 'dot1p', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dot1p, child_dot1p)
    child_ipv4_src_prefix = yang.gdata.from_xml_opt_str(node, 'ipv4-src-prefix')
    yang.gdata.maybe_add(children, 'ipv4-src-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix, child_ipv4_src_prefix)
    child_ipv6_src_prefix = yang.gdata.from_xml_opt_str(node, 'ipv6-src-prefix')
    yang.gdata.maybe_add(children, 'ipv6-src-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix, child_ipv6_src_prefix)
    child_ipv4_dst_prefix = yang.gdata.from_xml_opt_str(node, 'ipv4-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv4-dst-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix, child_ipv4_dst_prefix)
    child_ipv6_dst_prefix = yang.gdata.from_xml_opt_str(node, 'ipv6-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv6-dst-prefix', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix, child_ipv6_dst_prefix)
    child_l4_src_port = yang.gdata.from_xml_opt_int(node, 'l4-src-port')
    yang.gdata.maybe_add(children, 'l4-src-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port, child_l4_src_port)
    child_target_sites = yang.gdata.from_xml_opt_strs(node, 'target-sites')
    yang.gdata.maybe_add(children, 'target-sites', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__target_sites, child_target_sites)
    child_l4_src_port_range = yang.gdata.from_xml_opt_cnt(node, 'l4-src-port-range')
    yang.gdata.maybe_add(children, 'l4-src-port-range', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range, child_l4_src_port_range)
    child_l4_dst_port = yang.gdata.from_xml_opt_int(node, 'l4-dst-port')
    yang.gdata.maybe_add(children, 'l4-dst-port', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port, child_l4_dst_port)
    child_l4_dst_port_range = yang.gdata.from_xml_opt_cnt(node, 'l4-dst-port-range')
    yang.gdata.maybe_add(children, 'l4-dst-port-range', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range, child_l4_dst_port_range)
    child_protocol_field = yang.gdata.from_xml_opt_value(node, 'protocol-field')
    yang.gdata.maybe_add(children, 'protocol-field', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__protocol_field, child_protocol_field)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'dscp':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'dot1p':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-src-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv4-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6-dst-prefix':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-src-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'target-sites':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-src-port-range':
            child = {'l4-src-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'l4-dst-port':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'l4-dst-port-range':
            child = {'l4-dst-port-range': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'protocol-field':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_dscp = yang.gdata.take_json_opt_int(jd, 'dscp')
    yang.gdata.maybe_add(children, 'dscp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dscp, child_dscp)
    child_dot1p = yang.gdata.take_json_opt_int(jd, 'dot1p')
    yang.gdata.maybe_add(children, 'dot1p', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__dot1p, child_dot1p)
    child_ipv4_src_prefix = yang.gdata.take_json_opt_str(jd, 'ipv4-src-prefix')
    yang.gdata.maybe_add(children, 'ipv4-src-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_src_prefix, child_ipv4_src_prefix)
    child_ipv6_src_prefix = yang.gdata.take_json_opt_str(jd, 'ipv6-src-prefix')
    yang.gdata.maybe_add(children, 'ipv6-src-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_src_prefix, child_ipv6_src_prefix)
    child_ipv4_dst_prefix = yang.gdata.take_json_opt_str(jd, 'ipv4-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv4-dst-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv4_dst_prefix, child_ipv4_dst_prefix)
    child_ipv6_dst_prefix = yang.gdata.take_json_opt_str(jd, 'ipv6-dst-prefix')
    yang.gdata.maybe_add(children, 'ipv6-dst-prefix', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__ipv6_dst_prefix, child_ipv6_dst_prefix)
    child_l4_src_port = yang.gdata.take_json_opt_int(jd, 'l4-src-port')
    yang.gdata.maybe_add(children, 'l4-src-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port, child_l4_src_port)
    child_target_sites = yang.gdata.take_json_opt_strs(jd, 'target-sites')
    yang.gdata.maybe_add(children, 'target-sites', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__target_sites, child_target_sites)
    child_l4_src_port_range = yang.gdata.take_json_opt_cnt(jd, 'l4-src-port-range')
    yang.gdata.maybe_add(children, 'l4-src-port-range', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_src_port_range, child_l4_src_port_range)
    child_l4_dst_port = yang.gdata.take_json_opt_int(jd, 'l4-dst-port')
    yang.gdata.maybe_add(children, 'l4-dst-port', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port, child_l4_dst_port)
    child_l4_dst_port_range = yang.gdata.take_json_opt_cnt(jd, 'l4-dst-port-range')
    yang.gdata.maybe_add(children, 'l4-dst-port-range', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__l4_dst_port_range, child_l4_dst_port_range)
    child_protocol_field = yang.gdata.take_json_opt_value(jd, 'protocol-field')
    yang.gdata.maybe_add(children, 'protocol-field', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow__protocol_field, child_protocol_field)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_application(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:customer-application'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf match-application: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_application(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:customer-application'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf match-application: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__target_class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__target_class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(yang.adata.MNode):
    id: str
    match_flow: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow
    match_application: ?Identityref
    target_class_id: ?str

    mut def __init__(self, id: str, match_flow: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow=None, match_application: ?Identityref, target_class_id: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.id = id
        self.match_flow = match_flow if match_flow is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow()
        self.match_application = match_application
        self.target_class_id = target_class_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        _match_flow = self.match_flow
        if _match_flow is not None:
            children['match-flow'] = _match_flow.to_gdata()
        _match_application = self.match_application
        if _match_application is not None:
            _identityref_match_application, error = complete_and_validate_identityref(_match_application, _identities, ['l3vpn-svc:customer-application'], 'ietf-l3vpn-svc')
            if _identityref_match_application is not None:
                _match_application = _identityref_match_application
            else:
                raise ValueError('Invalid value for identityref leaf match-application: {error}')
            children['match-application'] = yang.gdata.Leaf('identityref', _match_application)
        _target_class_id = self.target_class_id
        if _target_class_id is not None:
            children['target-class-id'] = yang.gdata.Leaf('string', _target_class_id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(id=n.get_str('id'), match_flow=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow.from_gdata(n.get_opt_cnt('match-flow')), match_application=n.get_opt_Identityref('match-application'), target_class_id=n.get_opt_str('target-class-id'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule({repr(self.id)})')
        leaves = []
        _match_flow = self.match_flow
        if _match_flow is not None:
            res.extend(_match_flow.prsrc('{self_name}.match_flow', False).splitlines())
        _match_application = self.match_application
        if _match_application is not None:
            leaves.append('{self_name}.match_application = {repr(_match_application)}')
        _target_class_id = self.target_class_id
        if _target_class_id is not None:
            leaves.append('{self_name}.target_class_id = {repr(_target_class_id)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'rule'
        self.elements = elements

    mut def create(self, id):
        for e in self.elements:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements, user_order=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_str(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__id, child_id)
    child_match_flow = yang.gdata.from_xml_opt_cnt(node, 'match-flow')
    yang.gdata.maybe_add(children, 'match-flow', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow, child_match_flow)
    child_match_application = yang.gdata.from_xml_opt_Identityref(node, 'match-application')
    yang.gdata.maybe_add(children, 'match-application', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_application, child_match_application)
    child_target_class_id = yang.gdata.from_xml_opt_str(node, 'target-class-id')
    yang.gdata.maybe_add(children, 'target-class-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__target_class_id, child_target_class_id)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements, user_order=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__id(keys[0])
        if point == 'match-flow':
            children['match-flow'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow(jd, rest_path, op)
        if point == 'match-application':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'target-class-id':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['id'])))
        return yang.gdata.List(['id'], elements, user_order=True)
    elif len(path) > 1:
        return yang.gdata.List(['id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd, path, op)], user_order=True)
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.take_json_str(jd, 'id')
    yang.gdata.maybe_add(children, 'id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__id, child_id)
    child_match_flow = yang.gdata.take_json_opt_cnt(jd, 'match-flow')
    yang.gdata.maybe_add(children, 'match-flow', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_flow, child_match_flow)
    child_match_application = yang.gdata.take_json_opt_Identityref(jd, 'match-application')
    yang.gdata.maybe_add(children, 'match-application', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__match_application, child_match_application)
    child_target_class_id = yang.gdata.take_json_opt_str(jd, 'target-class-id')
    yang.gdata.maybe_add(children, 'target-class-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule__target_class_id, child_target_class_id)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['id'], elements=elements, user_order=True)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(yang.adata.MNode):
    rule: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule

    mut def __init__(self, rule: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.rule = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(elements=rule)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rule = self.rule
        if _rule is not None:
            children['rule'] = _rule.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(rule=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule.from_gdata(n.get_opt_list('rule')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy()')
        leaves = []
        _rule = self.rule
        for _element in _rule.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy/rule element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'rule_element = {self_name}.rule.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('rule_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-classification-policy'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_rule = yang.gdata.from_xml_opt_list(node, 'rule')
    yang.gdata.maybe_add(children, 'rule', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule, child_rule)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'rule':
            child = {'rule': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_rule = yang.gdata.take_json_opt_list(jd, 'rule')
    yang.gdata.maybe_add(children, 'rule', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy__rule, child_rule)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__profile(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__profile(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__class_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__direction(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf direction: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__direction(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf direction: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__rate_limit(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__rate_limit(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__use_lowest_latency(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__use_lowest_latency(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(yang.adata.MNode):
    use_lowest_latency: ?bool
    latency_boundary: int

    mut def __init__(self, use_lowest_latency: ?bool, latency_boundary: ?int=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_latency = use_lowest_latency
        self.latency_boundary = latency_boundary if latency_boundary is not None else 400

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_latency = self.use_lowest_latency
        if _use_lowest_latency is not None:
            children['use-lowest-latency'] = yang.gdata.Leaf('empty', _use_lowest_latency)
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint16', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(use_lowest_latency=n.get_opt_empty('use-lowest-latency'), latency_boundary=n.get_opt_int('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class/latency')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency()')
        leaves = []
        _use_lowest_latency = self.use_lowest_latency
        if _use_lowest_latency is not None:
            leaves.append('{self_name}.use_lowest_latency = {repr(_use_lowest_latency)}')
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            leaves.append('{self_name}.latency_boundary = {repr(_latency_boundary)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class/latency'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_use_lowest_latency = yang.gdata.from_xml_opt_empty(node, 'use-lowest-latency')
    yang.gdata.maybe_add(children, 'use-lowest-latency', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__use_lowest_latency, child_use_lowest_latency)
    child_latency_boundary = yang.gdata.from_xml_opt_int(node, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'use-lowest-latency':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_latency = yang.gdata.take_json_opt_empty(jd, 'use-lowest-latency')
    yang.gdata.maybe_add(children, 'use-lowest-latency', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__use_lowest_latency, child_use_lowest_latency)
    child_latency_boundary = yang.gdata.take_json_opt_int(jd, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__latency_boundary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(yang.adata.MNode):
    use_lowest_jitter: ?bool
    latency_boundary: int

    mut def __init__(self, use_lowest_jitter: ?bool, latency_boundary: ?int=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.use_lowest_jitter = use_lowest_jitter
        self.latency_boundary = latency_boundary if latency_boundary is not None else 40000

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _use_lowest_jitter = self.use_lowest_jitter
        if _use_lowest_jitter is not None:
            children['use-lowest-jitter'] = yang.gdata.Leaf('empty', _use_lowest_jitter)
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            children['latency-boundary'] = yang.gdata.Leaf('uint32', _latency_boundary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(use_lowest_jitter=n.get_opt_empty('use-lowest-jitter'), latency_boundary=n.get_opt_int('latency-boundary'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class/jitter')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter()')
        leaves = []
        _use_lowest_jitter = self.use_lowest_jitter
        if _use_lowest_jitter is not None:
            leaves.append('{self_name}.use_lowest_jitter = {repr(_use_lowest_jitter)}')
        _latency_boundary = self.latency_boundary
        if _latency_boundary is not None:
            leaves.append('{self_name}.latency_boundary = {repr(_latency_boundary)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class/jitter'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_use_lowest_jitter = yang.gdata.from_xml_opt_empty(node, 'use-lowest-jitter')
    yang.gdata.maybe_add(children, 'use-lowest-jitter', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter, child_use_lowest_jitter)
    child_latency_boundary = yang.gdata.from_xml_opt_int(node, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'use-lowest-jitter':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency-boundary':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_use_lowest_jitter = yang.gdata.take_json_opt_empty(jd, 'use-lowest-jitter')
    yang.gdata.maybe_add(children, 'use-lowest-jitter', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__use_lowest_jitter, child_use_lowest_jitter)
    child_latency_boundary = yang.gdata.take_json_opt_int(jd, 'latency-boundary')
    yang.gdata.maybe_add(children, 'latency-boundary', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter__latency_boundary, child_latency_boundary)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('decimal64', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__end_to_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__end_to_end(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(yang.adata.MNode):
    guaranteed_bw_percent: float
    end_to_end: ?bool

    mut def __init__(self, guaranteed_bw_percent: float, end_to_end: ?bool):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.guaranteed_bw_percent = guaranteed_bw_percent
        self.end_to_end = end_to_end

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _guaranteed_bw_percent = self.guaranteed_bw_percent
        if _guaranteed_bw_percent is not None:
            children['guaranteed-bw-percent'] = yang.gdata.Leaf('decimal64', _guaranteed_bw_percent)
        _end_to_end = self.end_to_end
        if _end_to_end is not None:
            children['end-to-end'] = yang.gdata.Leaf('empty', _end_to_end)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(guaranteed_bw_percent=n.get_float('guaranteed-bw-percent'), end_to_end=n.get_opt_empty('end-to-end'))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class/bandwidth')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth({repr(self.guaranteed_bw_percent)})')
        leaves = []
        _end_to_end = self.end_to_end
        if _end_to_end is not None:
            leaves.append('{self_name}.end_to_end = {repr(_end_to_end)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class/bandwidth'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_guaranteed_bw_percent = yang.gdata.from_xml_float(node, 'guaranteed-bw-percent')
    yang.gdata.maybe_add(children, 'guaranteed-bw-percent', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent, child_guaranteed_bw_percent)
    child_end_to_end = yang.gdata.from_xml_opt_empty(node, 'end-to-end')
    yang.gdata.maybe_add(children, 'end-to-end', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__end_to_end, child_end_to_end)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'guaranteed-bw-percent':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'end-to-end':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_guaranteed_bw_percent = yang.gdata.take_json_float(jd, 'guaranteed-bw-percent')
    yang.gdata.maybe_add(children, 'guaranteed-bw-percent', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__guaranteed_bw_percent, child_guaranteed_bw_percent)
    child_end_to_end = yang.gdata.take_json_opt_empty(jd, 'end-to-end')
    yang.gdata.maybe_add(children, 'end-to-end', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth__end_to_end, child_end_to_end)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(yang.adata.MNode):
    class_id: str
    direction: Identityref
    rate_limit: ?float
    latency: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency
    jitter: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter
    bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth

    mut def __init__(self, class_id: str, bandwidth: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth, direction: ?Identityref=None, rate_limit: ?float, latency: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency=None, jitter: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_id = class_id
        _default_direction, error = complete_and_validate_identityref(Identityref.from_adata('both'), _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
        if _default_direction is not None:
            self.direction = direction if direction is not None else _default_direction
        else:
            raise ValueError('Invalid default value for identityref leaf class: {error}')
        self.rate_limit = rate_limit
        self.latency = latency if latency is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency()
        self.jitter = jitter if jitter is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter()
        self.bandwidth = bandwidth

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_id = self.class_id
        if _class_id is not None:
            children['class-id'] = yang.gdata.Leaf('string', _class_id)
        _direction = self.direction
        if _direction is not None:
            _identityref_direction, error = complete_and_validate_identityref(_direction, _identities, ['l3vpn-svc:qos-profile-direction'], 'ietf-l3vpn-svc')
            if _identityref_direction is not None:
                _direction = _identityref_direction
            else:
                raise ValueError('Invalid value for identityref leaf direction: {error}')
            children['direction'] = yang.gdata.Leaf('identityref', _direction)
        _rate_limit = self.rate_limit
        if _rate_limit is not None:
            children['rate-limit'] = yang.gdata.Leaf('decimal64', _rate_limit)
        _latency = self.latency
        if _latency is not None:
            children['latency'] = _latency.to_gdata()
        _jitter = self.jitter
        if _jitter is not None:
            children['jitter'] = _jitter.to_gdata()
        _bandwidth = self.bandwidth
        if _bandwidth is not None:
            children['bandwidth'] = _bandwidth.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(class_id=n.get_str('class-id'), direction=n.get_opt_Identityref('direction'), rate_limit=n.get_opt_float('rate-limit'), latency=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency.from_gdata(n.get_opt_cnt('latency')), jitter=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter.from_gdata(n.get_opt_cnt('jitter')), bandwidth=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth.from_gdata(n.get_cnt('bandwidth')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class')
            res.append('self_bandwidth = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth({repr(self.bandwidth.guaranteed_bw_percent)})')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class({repr(self.class_id)}, self_bandwidth)')
        leaves = []
        _direction = self.direction
        if _direction is not None:
            leaves.append('{self_name}.direction = {repr(_direction)}')
        _rate_limit = self.rate_limit
        if _rate_limit is not None:
            leaves.append('{self_name}.rate_limit = {repr(_rate_limit)}')
        _latency = self.latency
        if _latency is not None:
            res.extend(_latency.prsrc('{self_name}.latency', False).splitlines())
        _jitter = self.jitter
        if _jitter is not None:
            res.extend(_jitter.prsrc('{self_name}.jitter', False).splitlines())
        _bandwidth = self.bandwidth
        if _bandwidth is not None:
            res.extend(_bandwidth.prsrc('{self_name}.bandwidth', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'class'
        self.elements = elements

    mut def create(self, class_id, bandwidth):
        for e in self.elements:
            match = True
            if e.class_id != class_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry(class_id, bandwidth)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['class-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_class_id = yang.gdata.from_xml_str(node, 'class-id')
    yang.gdata.maybe_add(children, 'class-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__class_id, child_class_id)
    child_direction = yang.gdata.from_xml_opt_Identityref(node, 'direction')
    yang.gdata.maybe_add(children, 'direction', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__direction, child_direction)
    child_rate_limit = yang.gdata.from_xml_opt_float(node, 'rate-limit')
    yang.gdata.maybe_add(children, 'rate-limit', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__rate_limit, child_rate_limit)
    child_latency = yang.gdata.from_xml_opt_cnt(node, 'latency')
    yang.gdata.maybe_add(children, 'latency', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency, child_latency)
    child_jitter = yang.gdata.from_xml_opt_cnt(node, 'jitter')
    yang.gdata.maybe_add(children, 'jitter', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter, child_jitter)
    child_bandwidth = yang.gdata.from_xml_cnt(node, 'bandwidth')
    yang.gdata.maybe_add(children, 'bandwidth', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth, child_bandwidth)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(e) for e in nodes]
    return yang.gdata.List(keys=['class-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['class-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['class-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__class_id(keys[0])
        if point == 'direction':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'rate-limit':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'latency':
            children['latency'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency(jd, rest_path, op)
        if point == 'jitter':
            children['jitter'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter(jd, rest_path, op)
        if point == 'bandwidth':
            children['bandwidth'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['class-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['class-id'])))
        return yang.gdata.List(['class-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['class-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_class_id = yang.gdata.take_json_str(jd, 'class-id')
    yang.gdata.maybe_add(children, 'class-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__class_id, child_class_id)
    child_direction = yang.gdata.take_json_opt_Identityref(jd, 'direction')
    yang.gdata.maybe_add(children, 'direction', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__direction, child_direction)
    child_rate_limit = yang.gdata.take_json_opt_float(jd, 'rate-limit')
    yang.gdata.maybe_add(children, 'rate-limit', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__rate_limit, child_rate_limit)
    child_latency = yang.gdata.take_json_opt_cnt(jd, 'latency')
    yang.gdata.maybe_add(children, 'latency', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__latency, child_latency)
    child_jitter = yang.gdata.take_json_opt_cnt(jd, 'jitter')
    yang.gdata.maybe_add(children, 'jitter', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__jitter, child_jitter)
    child_bandwidth = yang.gdata.take_json_cnt(jd, 'bandwidth')
    yang.gdata.maybe_add(children, 'bandwidth', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth, child_bandwidth)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['class-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(yang.adata.MNode):
    class_: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class

    mut def __init__(self, class_: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.class_ = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(elements=class_)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _class_ = self.class_
        if _class_ is not None:
            children['class'] = _class_.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(class_=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class.from_gdata(n.get_opt_list('class')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes()')
        leaves = []
        _class_ = self.class_
        for _element in _class_.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes/class element: {_element.to_gdata().key_str(['class-id'])}")
            res.append('element_bandwidth = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class__bandwidth({repr(_element.bandwidth.guaranteed_bw_percent)})')
            list_elem = 'class__element = {self_name}.class_.create({repr(_element.class_id)}, element_bandwidth)'
            res.append(list_elem)
            res.extend(_element.prsrc('class__element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile/classes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_class_ = yang.gdata.from_xml_opt_list(node, 'class')
    yang.gdata.maybe_add(children, 'class', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class, child_class_)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'class':
            child = {'class': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_class_ = yang.gdata.take_json_opt_list(jd, 'class')
    yang.gdata.maybe_add(children, 'class', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes__class, child_class_)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(yang.adata.MNode):
    profile: ?str
    classes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes

    mut def __init__(self, profile: ?str, classes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.profile = profile
        self.classes = classes if classes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _profile = self.profile
        if _profile is not None:
            children['profile'] = yang.gdata.Leaf('leafref', _profile)
        _classes = self.classes
        if _classes is not None:
            children['classes'] = _classes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(profile=n.get_opt_str('profile'), classes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes.from_gdata(n.get_opt_cnt('classes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile()')
        leaves = []
        _profile = self.profile
        if _profile is not None:
            leaves.append('{self_name}.profile = {repr(_profile)}')
        _classes = self.classes
        if _classes is not None:
            res.extend(_classes.prsrc('{self_name}.classes', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos/qos-profile'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_profile = yang.gdata.from_xml_opt_str(node, 'profile')
    yang.gdata.maybe_add(children, 'profile', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__profile, child_profile)
    child_classes = yang.gdata.from_xml_opt_cnt(node, 'classes')
    yang.gdata.maybe_add(children, 'classes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes, child_classes)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'profile':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'classes':
            child = {'classes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_profile = yang.gdata.take_json_opt_str(jd, 'profile')
    yang.gdata.maybe_add(children, 'profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__profile, child_profile)
    child_classes = yang.gdata.take_json_opt_cnt(jd, 'classes')
    yang.gdata.maybe_add(children, 'classes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile__classes, child_classes)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(yang.adata.MNode):
    qos_classification_policy: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy
    qos_profile: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile

    mut def __init__(self, qos_classification_policy: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy=None, qos_profile: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.qos_classification_policy = qos_classification_policy if qos_classification_policy is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy()
        self.qos_profile = qos_profile if qos_profile is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _qos_classification_policy = self.qos_classification_policy
        if _qos_classification_policy is not None:
            children['qos-classification-policy'] = _qos_classification_policy.to_gdata()
        _qos_profile = self.qos_profile
        if _qos_profile is not None:
            children['qos-profile'] = _qos_profile.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(qos_classification_policy=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy.from_gdata(n.get_opt_cnt('qos-classification-policy')), qos_profile=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile.from_gdata(n.get_opt_cnt('qos-profile')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos()')
        leaves = []
        _qos_classification_policy = self.qos_classification_policy
        if _qos_classification_policy is not None:
            res.extend(_qos_classification_policy.prsrc('{self_name}.qos_classification_policy', False).splitlines())
        _qos_profile = self.qos_profile
        if _qos_profile is not None:
            res.extend(_qos_profile.prsrc('{self_name}.qos_profile', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/qos'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_qos_classification_policy = yang.gdata.from_xml_opt_cnt(node, 'qos-classification-policy')
    yang.gdata.maybe_add(children, 'qos-classification-policy', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy, child_qos_classification_policy)
    child_qos_profile = yang.gdata.from_xml_opt_cnt(node, 'qos-profile')
    yang.gdata.maybe_add(children, 'qos-profile', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile, child_qos_profile)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'qos-classification-policy':
            child = {'qos-classification-policy': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'qos-profile':
            child = {'qos-profile': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_qos_classification_policy = yang.gdata.take_json_opt_cnt(jd, 'qos-classification-policy')
    yang.gdata.maybe_add(children, 'qos-classification-policy', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_classification_policy, child_qos_classification_policy)
    child_qos_profile = yang.gdata.take_json_opt_cnt(jd, 'qos-profile')
    yang.gdata.maybe_add(children, 'qos-profile', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos__qos_profile, child_qos_profile)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier__signalling_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier__signalling_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(yang.adata.MNode):
    signalling_type: str

    mut def __init__(self, signalling_type: ?str=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.signalling_type = signalling_type if signalling_type is not None else "bgp"

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _signalling_type = self.signalling_type
        if _signalling_type is not None:
            children['signalling-type'] = yang.gdata.Leaf('enumeration', _signalling_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(signalling_type=n.get_opt_str('signalling-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/carrierscarrier')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier()')
        leaves = []
        _signalling_type = self.signalling_type
        if _signalling_type is not None:
            leaves.append('{self_name}.signalling_type = {repr(_signalling_type)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/carrierscarrier'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_signalling_type = yang.gdata.from_xml_opt_str(node, 'signalling-type')
    yang.gdata.maybe_add(children, 'signalling-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier__signalling_type, child_signalling_type)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'signalling-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_signalling_type = yang.gdata.take_json_opt_str(jd, 'signalling-type')
    yang.gdata.maybe_add(children, 'signalling-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier__signalling_type, child_signalling_type)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_site_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_site_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv4(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv4(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv6(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv6(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(yang.adata.MNode):
    ipv4: bool
    ipv6: bool

    mut def __init__(self, ipv4: ?bool=None, ipv6: ?bool=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4 = ipv4 if ipv4 is not None else False
        self.ipv6 = ipv6 if ipv6 is not None else False

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            children['ipv4'] = yang.gdata.Leaf('boolean', _ipv4)
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            children['ipv6'] = yang.gdata.Leaf('boolean', _ipv6)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(ipv4=n.get_opt_bool('ipv4'), ipv6=n.get_opt_bool('ipv6'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/multicast/multicast-address-family')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family()')
        leaves = []
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            leaves.append('{self_name}.ipv4 = {repr(_ipv4)}')
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            leaves.append('{self_name}.ipv6 = {repr(_ipv6)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/multicast/multicast-address-family'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.from_xml_opt_bool(node, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.from_xml_opt_bool(node, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv6, child_ipv6)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'ipv4':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'ipv6':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.take_json_opt_bool(jd, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.take_json_opt_bool(jd, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family__ipv6, child_ipv6)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__protocol_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__protocol_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(yang.adata.MNode):
    multicast_site_type: str
    multicast_address_family: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family
    protocol_type: str

    mut def __init__(self, multicast_site_type: ?str=None, multicast_address_family: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family=None, protocol_type: ?str=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.multicast_site_type = multicast_site_type if multicast_site_type is not None else "source-receiver"
        self.multicast_address_family = multicast_address_family if multicast_address_family is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family()
        self.protocol_type = protocol_type if protocol_type is not None else "both"

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _multicast_site_type = self.multicast_site_type
        if _multicast_site_type is not None:
            children['multicast-site-type'] = yang.gdata.Leaf('enumeration', _multicast_site_type)
        _multicast_address_family = self.multicast_address_family
        if _multicast_address_family is not None:
            children['multicast-address-family'] = _multicast_address_family.to_gdata()
        _protocol_type = self.protocol_type
        if _protocol_type is not None:
            children['protocol-type'] = yang.gdata.Leaf('enumeration', _protocol_type)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(multicast_site_type=n.get_opt_str('multicast-site-type'), multicast_address_family=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family.from_gdata(n.get_opt_cnt('multicast-address-family')), protocol_type=n.get_opt_str('protocol-type'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/multicast')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast()')
        leaves = []
        _multicast_site_type = self.multicast_site_type
        if _multicast_site_type is not None:
            leaves.append('{self_name}.multicast_site_type = {repr(_multicast_site_type)}')
        _multicast_address_family = self.multicast_address_family
        if _multicast_address_family is not None:
            res.extend(_multicast_address_family.prsrc('{self_name}.multicast_address_family', False).splitlines())
        _protocol_type = self.protocol_type
        if _protocol_type is not None:
            leaves.append('{self_name}.protocol_type = {repr(_protocol_type)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service/multicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_multicast_site_type = yang.gdata.from_xml_opt_str(node, 'multicast-site-type')
    yang.gdata.maybe_add(children, 'multicast-site-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_site_type, child_multicast_site_type)
    child_multicast_address_family = yang.gdata.from_xml_opt_cnt(node, 'multicast-address-family')
    yang.gdata.maybe_add(children, 'multicast-address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family, child_multicast_address_family)
    child_protocol_type = yang.gdata.from_xml_opt_str(node, 'protocol-type')
    yang.gdata.maybe_add(children, 'protocol-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__protocol_type, child_protocol_type)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'multicast-site-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'multicast-address-family':
            child = {'multicast-address-family': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'protocol-type':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_multicast_site_type = yang.gdata.take_json_opt_str(jd, 'multicast-site-type')
    yang.gdata.maybe_add(children, 'multicast-site-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_site_type, child_multicast_site_type)
    child_multicast_address_family = yang.gdata.take_json_opt_cnt(jd, 'multicast-address-family')
    yang.gdata.maybe_add(children, 'multicast-address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__multicast_address_family, child_multicast_address_family)
    child_protocol_type = yang.gdata.take_json_opt_str(jd, 'protocol-type')
    yang.gdata.maybe_add(children, 'protocol-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast__protocol_type, child_protocol_type)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(yang.adata.MNode):
    svc_input_bandwidth: int
    svc_output_bandwidth: int
    svc_mtu: int
    qos: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos
    carrierscarrier: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier
    multicast: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast

    mut def __init__(self, svc_input_bandwidth: int, svc_output_bandwidth: int, svc_mtu: int, qos: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos=None, carrierscarrier: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier=None, multicast: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.svc_input_bandwidth = svc_input_bandwidth
        self.svc_output_bandwidth = svc_output_bandwidth
        self.svc_mtu = svc_mtu
        self.qos = qos if qos is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos()
        self.carrierscarrier = carrierscarrier if carrierscarrier is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier()
        self.multicast = multicast if multicast is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _svc_input_bandwidth = self.svc_input_bandwidth
        if _svc_input_bandwidth is not None:
            children['svc-input-bandwidth'] = yang.gdata.Leaf('uint64', _svc_input_bandwidth)
        _svc_output_bandwidth = self.svc_output_bandwidth
        if _svc_output_bandwidth is not None:
            children['svc-output-bandwidth'] = yang.gdata.Leaf('uint64', _svc_output_bandwidth)
        _svc_mtu = self.svc_mtu
        if _svc_mtu is not None:
            children['svc-mtu'] = yang.gdata.Leaf('uint16', _svc_mtu)
        _qos = self.qos
        if _qos is not None:
            children['qos'] = _qos.to_gdata()
        _carrierscarrier = self.carrierscarrier
        if _carrierscarrier is not None:
            children['carrierscarrier'] = _carrierscarrier.to_gdata()
        _multicast = self.multicast
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(svc_input_bandwidth=n.get_int('svc-input-bandwidth'), svc_output_bandwidth=n.get_int('svc-output-bandwidth'), svc_mtu=n.get_int('svc-mtu'), qos=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos.from_gdata(n.get_opt_cnt('qos')), carrierscarrier=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier.from_gdata(n.get_opt_cnt('carrierscarrier')), multicast=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast.from_gdata(n.get_opt_cnt('multicast')))
        raise ValueError('Missing required subtree ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service({repr(self.svc_input_bandwidth)}, {repr(self.svc_output_bandwidth)}, {repr(self.svc_mtu)})')
        leaves = []
        _qos = self.qos
        if _qos is not None:
            res.extend(_qos.prsrc('{self_name}.qos', False).splitlines())
        _carrierscarrier = self.carrierscarrier
        if _carrierscarrier is not None:
            res.extend(_carrierscarrier.prsrc('{self_name}.carrierscarrier', False).splitlines())
        _multicast = self.multicast
        if _multicast is not None:
            res.extend(_multicast.prsrc('{self_name}.multicast', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/service'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_svc_input_bandwidth = yang.gdata.from_xml_int(node, 'svc-input-bandwidth')
    yang.gdata.maybe_add(children, 'svc-input-bandwidth', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_input_bandwidth, child_svc_input_bandwidth)
    child_svc_output_bandwidth = yang.gdata.from_xml_int(node, 'svc-output-bandwidth')
    yang.gdata.maybe_add(children, 'svc-output-bandwidth', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_output_bandwidth, child_svc_output_bandwidth)
    child_svc_mtu = yang.gdata.from_xml_int(node, 'svc-mtu')
    yang.gdata.maybe_add(children, 'svc-mtu', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_mtu, child_svc_mtu)
    child_qos = yang.gdata.from_xml_opt_cnt(node, 'qos')
    yang.gdata.maybe_add(children, 'qos', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos, child_qos)
    child_carrierscarrier = yang.gdata.from_xml_opt_cnt(node, 'carrierscarrier')
    yang.gdata.maybe_add(children, 'carrierscarrier', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier, child_carrierscarrier)
    child_multicast = yang.gdata.from_xml_opt_cnt(node, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast, child_multicast)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'svc-input-bandwidth':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'svc-output-bandwidth':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'svc-mtu':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'qos':
            child = {'qos': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'carrierscarrier':
            child = {'carrierscarrier': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'multicast':
            child = {'multicast': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_svc_input_bandwidth = yang.gdata.take_json_int64(jd, 'svc-input-bandwidth')
    yang.gdata.maybe_add(children, 'svc-input-bandwidth', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_input_bandwidth, child_svc_input_bandwidth)
    child_svc_output_bandwidth = yang.gdata.take_json_int64(jd, 'svc-output-bandwidth')
    yang.gdata.maybe_add(children, 'svc-output-bandwidth', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_output_bandwidth, child_svc_output_bandwidth)
    child_svc_mtu = yang.gdata.take_json_int(jd, 'svc-mtu')
    yang.gdata.maybe_add(children, 'svc-mtu', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__svc_mtu, child_svc_mtu)
    child_qos = yang.gdata.take_json_opt_cnt(jd, 'qos')
    yang.gdata.maybe_add(children, 'qos', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__qos, child_qos)
    child_carrierscarrier = yang.gdata.take_json_opt_cnt(jd, 'carrierscarrier')
    yang.gdata.maybe_add(children, 'carrierscarrier', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__carrierscarrier, child_carrierscarrier)
    child_multicast = yang.gdata.take_json_opt_cnt(jd, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service__multicast, child_multicast)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:routing-protocol-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__type(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:routing-protocol-type'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__area_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__area_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(yang.adata.MNode):
    target_site: str
    metric: int

    mut def __init__(self, target_site: str, metric: ?int=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.target_site = target_site
        self.metric = metric if metric is not None else 1

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _target_site = self.target_site
        if _target_site is not None:
            children['target-site'] = yang.gdata.Leaf('string', _target_site)
        _metric = self.metric
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site=n.get_str('target-site'), metric=n.get_opt_int('metric'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf/sham-links/sham-link')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link({repr(self.target_site)})')
        leaves = []
        _metric = self.metric
        if _metric is not None:
            leaves.append('{self_name}.metric = {repr(_metric)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf/sham-links/sham-link'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'sham-link'
        self.elements = elements

    mut def create(self, target_site):
        for e in self.elements:
            match = True
            if e.target_site != target_site:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry(target_site)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['target-site'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_target_site = yang.gdata.from_xml_str(node, 'target-site')
    yang.gdata.maybe_add(children, 'target-site', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site, child_target_site)
    child_metric = yang.gdata.from_xml_opt_int(node, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric, child_metric)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(e) for e in nodes]
    return yang.gdata.List(keys=['target-site'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['target-site']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['target-site'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site(keys[0])
        if point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['target-site']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['target-site'])))
        return yang.gdata.List(['target-site'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['target-site'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_target_site = yang.gdata.take_json_str(jd, 'target-site')
    yang.gdata.maybe_add(children, 'target-site', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__target_site, child_target_site)
    child_metric = yang.gdata.take_json_opt_int(jd, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link__metric, child_metric)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['target-site'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(yang.adata.MNode):
    sham_link: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link

    mut def __init__(self, sham_link: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.sham_link = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(elements=sham_link)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _sham_link = self.sham_link
        if _sham_link is not None:
            children['sham-link'] = _sham_link.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(sham_link=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link.from_gdata(n.get_opt_list('sham-link')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf/sham-links')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links()')
        leaves = []
        _sham_link = self.sham_link
        for _element in _sham_link.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf/sham-links/sham-link element: {_element.to_gdata().key_str(['target-site'])}")
            list_elem = 'sham_link_element = {self_name}.sham_link.create({repr(_element.target_site)})'
            res.append(list_elem)
            res.extend(_element.prsrc('sham_link_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf/sham-links'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_sham_link = yang.gdata.from_xml_opt_list(node, 'sham-link')
    yang.gdata.maybe_add(children, 'sham-link', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link, child_sham_link)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'sham-link':
            child = {'sham-link': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_sham_link = yang.gdata.take_json_opt_list(jd, 'sham-link')
    yang.gdata.maybe_add(children, 'sham-link', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links__sham_link, child_sham_link)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(yang.adata.MNode):
    address_family: list[str]
    area_address: str
    metric: int
    sham_links: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links

    mut def __init__(self, area_address: str, address_family: ?list[str]=None, metric: ?int=None, sham_links: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []
        self.area_address = area_address
        self.metric = metric if metric is not None else 1
        self.sham_links = sham_links if sham_links is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        _area_address = self.area_address
        if _area_address is not None:
            children['area-address'] = yang.gdata.Leaf('string', _area_address)
        _metric = self.metric
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint16', _metric)
        _sham_links = self.sham_links
        if _sham_links is not None:
            children['sham-links'] = _sham_links.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(address_family=n.get_strs('address-family'), area_address=n.get_str('area-address'), metric=n.get_opt_int('metric'), sham_links=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links.from_gdata(n.get_opt_cnt('sham-links')))
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf({repr(self.area_address)})')
        leaves = []
        _metric = self.metric
        if _metric is not None:
            leaves.append('{self_name}.metric = {repr(_metric)}')
        _sham_links = self.sham_links
        if _sham_links is not None:
            res.extend(_sham_links.prsrc('{self_name}.sham_links', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__address_family, child_address_family)
    child_area_address = yang.gdata.from_xml_str(node, 'area-address')
    yang.gdata.maybe_add(children, 'area-address', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__area_address, child_area_address)
    child_metric = yang.gdata.from_xml_opt_int(node, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__metric, child_metric)
    child_sham_links = yang.gdata.from_xml_opt_cnt(node, 'sham-links')
    yang.gdata.maybe_add(children, 'sham-links', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links, child_sham_links)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'area-address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'metric':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'sham-links':
            child = {'sham-links': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__address_family, child_address_family)
    child_area_address = yang.gdata.take_json_str(jd, 'area-address')
    yang.gdata.maybe_add(children, 'area-address', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__area_address, child_area_address)
    child_metric = yang.gdata.take_json_opt_int(jd, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__metric, child_metric)
    child_sham_links = yang.gdata.take_json_opt_cnt(jd, 'sham-links')
    yang.gdata.maybe_add(children, 'sham-links', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf__sham_links, child_sham_links)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__autonomous_system(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__autonomous_system(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(yang.adata.MNode):
    autonomous_system: int
    address_family: list[str]

    mut def __init__(self, autonomous_system: int, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.autonomous_system = autonomous_system
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _autonomous_system = self.autonomous_system
        if _autonomous_system is not None:
            children['autonomous-system'] = yang.gdata.Leaf('uint32', _autonomous_system)
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(autonomous_system=n.get_int('autonomous-system'), address_family=n.get_strs('address-family'))
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/bgp')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp({repr(self.autonomous_system)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/bgp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_autonomous_system = yang.gdata.from_xml_int(node, 'autonomous-system')
    yang.gdata.maybe_add(children, 'autonomous-system', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__autonomous_system, child_autonomous_system)
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'autonomous-system':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_autonomous_system = yang.gdata.take_json_int(jd, 'autonomous-system')
    yang.gdata.maybe_add(children, 'autonomous-system', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__autonomous_system, child_autonomous_system)
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        _next_hop = self.next_hop
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv4-lan-prefixes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes({repr(self.lan)}, {repr(self.next_hop)})')
        leaves = []
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            leaves.append('{self_name}.lan_tag = {repr(_lan_tag)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv4-lan-prefixes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv4-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self.elements:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.from_xml_str(node, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.from_xml_str(node, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.from_xml_opt_str(node, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(e) for e in nodes]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['lan', 'next-hop']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan(keys[0])
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop(keys[1])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['lan', 'next-hop'])))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.take_json_str(jd, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.take_json_str(jd, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.take_json_opt_str(jd, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(yang.adata.MNode):
    lan: str
    next_hop: str
    lan_tag: ?str

    mut def __init__(self, lan: str, next_hop: str, lan_tag: ?str):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.lan = lan
        self.next_hop = next_hop
        self.lan_tag = lan_tag

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lan = self.lan
        if _lan is not None:
            children['lan'] = yang.gdata.Leaf('string', _lan)
        _next_hop = self.next_hop
        if _next_hop is not None:
            children['next-hop'] = yang.gdata.Leaf('string', _next_hop)
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            children['lan-tag'] = yang.gdata.Leaf('string', _lan_tag)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan=n.get_str('lan'), next_hop=n.get_str('next-hop'), lan_tag=n.get_opt_str('lan-tag'))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv6-lan-prefixes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes({repr(self.lan)}, {repr(self.next_hop)})')
        leaves = []
        _lan_tag = self.lan_tag
        if _lan_tag is not None:
            leaves.append('{self_name}.lan_tag = {repr(_lan_tag)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv6-lan-prefixes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'ipv6-lan-prefixes'
        self.elements = elements

    mut def create(self, lan, next_hop):
        for e in self.elements:
            match = True
            if e.lan != lan:
                match = False
                continue
            if e.next_hop != next_hop:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry(lan, next_hop)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['lan', 'next-hop'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.from_xml_str(node, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.from_xml_str(node, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.from_xml_opt_str(node, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(e) for e in nodes]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['lan', 'next-hop']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['lan'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan(keys[0])
        children['next-hop'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop(keys[1])
        if point == 'lan-tag':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['lan', 'next-hop']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['lan', 'next-hop'])))
        return yang.gdata.List(['lan', 'next-hop'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['lan', 'next-hop'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_lan = yang.gdata.take_json_str(jd, 'lan')
    yang.gdata.maybe_add(children, 'lan', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan, child_lan)
    child_next_hop = yang.gdata.take_json_str(jd, 'next-hop')
    yang.gdata.maybe_add(children, 'next-hop', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__next_hop, child_next_hop)
    child_lan_tag = yang.gdata.take_json_opt_str(jd, 'lan-tag')
    yang.gdata.maybe_add(children, 'lan-tag', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes__lan_tag, child_lan_tag)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['lan', 'next-hop'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.adata.MNode):
    ipv4_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes
    ipv6_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes

    mut def __init__(self, ipv4_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes_entry]=[], ipv6_lan_prefixes: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.ipv4_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(elements=ipv4_lan_prefixes)
        self.ipv6_lan_prefixes = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(elements=ipv6_lan_prefixes)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4_lan_prefixes = self.ipv4_lan_prefixes
        if _ipv4_lan_prefixes is not None:
            children['ipv4-lan-prefixes'] = _ipv4_lan_prefixes.to_gdata()
        _ipv6_lan_prefixes = self.ipv6_lan_prefixes
        if _ipv6_lan_prefixes is not None:
            children['ipv6-lan-prefixes'] = _ipv6_lan_prefixes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(ipv4_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes.from_gdata(n.get_opt_list('ipv4-lan-prefixes')), ipv6_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes.from_gdata(n.get_opt_list('ipv6-lan-prefixes')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()')
        leaves = []
        _ipv4_lan_prefixes = self.ipv4_lan_prefixes
        for _element in _ipv4_lan_prefixes.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv4-lan-prefixes element: {_element.to_gdata().key_str(['lan', 'next-hop'])}")
            list_elem = 'ipv4_lan_prefixes_element = {self_name}.ipv4_lan_prefixes.create({repr(_element.lan)}, {repr(_element.next_hop)})'
            res.append(list_elem)
            res.extend(_element.prsrc('ipv4_lan_prefixes_element', False, list_element=True).splitlines())
        _ipv6_lan_prefixes = self.ipv6_lan_prefixes
        for _element in _ipv6_lan_prefixes.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv6-lan-prefixes element: {_element.to_gdata().key_str(['lan', 'next-hop'])}")
            list_elem = 'ipv6_lan_prefixes_element = {self_name}.ipv6_lan_prefixes.create({repr(_element.lan)}, {repr(_element.next_hop)})'
            res.append(list_elem)
            res.extend(_element.prsrc('ipv6_lan_prefixes_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4_lan_prefixes = yang.gdata.from_xml_opt_list(node, 'ipv4-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv4-lan-prefixes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes, child_ipv4_lan_prefixes)
    child_ipv6_lan_prefixes = yang.gdata.from_xml_opt_list(node, 'ipv6-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv6-lan-prefixes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes, child_ipv6_lan_prefixes)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'ipv4-lan-prefixes':
            child = {'ipv4-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'ipv6-lan-prefixes':
            child = {'ipv6-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4_lan_prefixes = yang.gdata.take_json_opt_list(jd, 'ipv4-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv4-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv4_lan_prefixes, child_ipv4_lan_prefixes)
    child_ipv6_lan_prefixes = yang.gdata.take_json_opt_list(jd, 'ipv6-lan-prefixes')
    yang.gdata.maybe_add(children, 'ipv6-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes__ipv6_lan_prefixes, child_ipv6_lan_prefixes)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(yang.adata.MNode):
    cascaded_lan_prefixes: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes

    mut def __init__(self, cascaded_lan_prefixes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.cascaded_lan_prefixes = cascaded_lan_prefixes if cascaded_lan_prefixes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _cascaded_lan_prefixes = self.cascaded_lan_prefixes
        if _cascaded_lan_prefixes is not None:
            children['cascaded-lan-prefixes'] = _cascaded_lan_prefixes.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(cascaded_lan_prefixes=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes.from_gdata(n.get_opt_cnt('cascaded-lan-prefixes')))
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static()')
        leaves = []
        _cascaded_lan_prefixes = self.cascaded_lan_prefixes
        if _cascaded_lan_prefixes is not None:
            res.extend(_cascaded_lan_prefixes.prsrc('{self_name}.cascaded_lan_prefixes', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_cascaded_lan_prefixes = yang.gdata.from_xml_opt_cnt(node, 'cascaded-lan-prefixes')
    yang.gdata.maybe_add(children, 'cascaded-lan-prefixes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes, child_cascaded_lan_prefixes)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'cascaded-lan-prefixes':
            child = {'cascaded-lan-prefixes': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_cascaded_lan_prefixes = yang.gdata.take_json_opt_cnt(jd, 'cascaded-lan-prefixes')
    yang.gdata.maybe_add(children, 'cascaded-lan-prefixes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static__cascaded_lan_prefixes, child_cascaded_lan_prefixes)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(address_family=n.get_strs('address-family'))
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/rip')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/rip'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp__address_family(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(yang.adata.MNode):
    address_family: list[str]

    mut def __init__(self, address_family: ?list[str]=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.address_family = address_family if address_family is not None else []

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = yang.gdata.LeafList('enumeration', _address_family)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(address_family=n.get_strs('address-family'))
        return None

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/vrrp')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/vrrp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_strs(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'address-family':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.take_json_strs(jd, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp__address_family, child_address_family)
    return yang.gdata.Container(children, presence=True)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(yang.adata.MNode):
    type: Identityref
    ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf
    bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp
    static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static
    rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip
    vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp

    mut def __init__(self, type: Identityref, ospf: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf=None, bgp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp=None, static: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static=None, rip: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip=None, vrrp: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.type = type
        self.ospf = ospf
        self.bgp = bgp
        self.static = static
        self.rip = rip
        self.vrrp = vrrp

    mut def create_ospf(self, area_address):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(area_address)
        self.ospf = res
        return res

    mut def create_bgp(self, autonomous_system):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(autonomous_system)
        self.bgp = res
        return res

    mut def create_static(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static()
        self.static = res
        return res

    mut def create_rip(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip()
        self.rip = res
        return res

    mut def create_vrrp(self):
        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp()
        self.vrrp = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _type = self.type
        if _type is not None:
            _identityref_type, error = complete_and_validate_identityref(_type, _identities, ['l3vpn-svc:routing-protocol-type'], 'ietf-l3vpn-svc')
            if _identityref_type is not None:
                _type = _identityref_type
            else:
                raise ValueError('Invalid value for identityref leaf type: {error}')
            children['type'] = yang.gdata.Leaf('identityref', _type)
        _ospf = self.ospf
        if _ospf is not None:
            children['ospf'] = _ospf.to_gdata()
        _bgp = self.bgp
        if _bgp is not None:
            children['bgp'] = _bgp.to_gdata()
        _static = self.static
        if _static is not None:
            children['static'] = _static.to_gdata()
        _rip = self.rip
        if _rip is not None:
            children['rip'] = _rip.to_gdata()
        _vrrp = self.vrrp
        if _vrrp is not None:
            children['vrrp'] = _vrrp.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(type=n.get_Identityref('type'), ospf=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf.from_gdata(n.get_opt_cnt('ospf')), bgp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp.from_gdata(n.get_opt_cnt('bgp')), static=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static.from_gdata(n.get_opt_cnt('static')), rip=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip.from_gdata(n.get_opt_cnt('rip')), vrrp=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp.from_gdata(n.get_opt_cnt('vrrp')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol({repr(self.type)})')
        leaves = []
        _ospf = self.ospf
        if _ospf is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/ospf')
            res.append('ospf = {self_name}.create_ospf({repr(_ospf.area_address)})')
            res.extend(_ospf.prsrc('ospf', False).splitlines())
        _bgp = self.bgp
        if _bgp is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/bgp')
            res.append('bgp = {self_name}.create_bgp({repr(_bgp.autonomous_system)})')
            res.extend(_bgp.prsrc('bgp', False).splitlines())
        _static = self.static
        if _static is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/static')
            res.append('static = {self_name}.create_static()')
            res.extend(_static.prsrc('static', False).splitlines())
        _rip = self.rip
        if _rip is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/rip')
            res.append('rip = {self_name}.create_rip()')
            res.extend(_rip.prsrc('rip', False).splitlines())
        _vrrp = self.vrrp
        if _vrrp is not None:
            res.append('')
            res.append('# P-container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol/vrrp')
            res.append('vrrp = {self_name}.create_vrrp()')
            res.extend(_vrrp.prsrc('vrrp', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'routing-protocol'
        self.elements = elements

    mut def create(self, type):
        for e in self.elements:
            match = True
            if e.type != type:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry(type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['type'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_type = yang.gdata.from_xml_Identityref(node, 'type')
    yang.gdata.maybe_add(children, 'type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__type, child_type)
    child_ospf = yang.gdata.from_xml_opt_cnt(node, 'ospf')
    yang.gdata.maybe_add(children, 'ospf', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf, child_ospf)
    child_bgp = yang.gdata.from_xml_opt_cnt(node, 'bgp')
    yang.gdata.maybe_add(children, 'bgp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp, child_bgp)
    child_static = yang.gdata.from_xml_opt_cnt(node, 'static')
    yang.gdata.maybe_add(children, 'static', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static, child_static)
    child_rip = yang.gdata.from_xml_opt_cnt(node, 'rip')
    yang.gdata.maybe_add(children, 'rip', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip, child_rip)
    child_vrrp = yang.gdata.from_xml_opt_cnt(node, 'vrrp')
    yang.gdata.maybe_add(children, 'vrrp', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp, child_vrrp)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(e) for e in nodes]
    return yang.gdata.List(keys=['type'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['type']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['type'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__type(Identityref.from_json(keys[0]))
        if point == 'ospf':
            children['ospf'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf(jd, rest_path, op)
        if point == 'bgp':
            children['bgp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp(jd, rest_path, op)
        if point == 'static':
            children['static'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static(jd, rest_path, op)
        if point == 'rip':
            children['rip'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip(jd, rest_path, op)
        if point == 'vrrp':
            children['vrrp'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['type']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['type'])))
        return yang.gdata.List(['type'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['type'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_type = yang.gdata.take_json_Identityref(jd, 'type')
    yang.gdata.maybe_add(children, 'type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__type, child_type)
    child_ospf = yang.gdata.take_json_opt_cnt(jd, 'ospf')
    yang.gdata.maybe_add(children, 'ospf', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__ospf, child_ospf)
    child_bgp = yang.gdata.take_json_opt_cnt(jd, 'bgp')
    yang.gdata.maybe_add(children, 'bgp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__bgp, child_bgp)
    child_static = yang.gdata.take_json_opt_cnt(jd, 'static')
    yang.gdata.maybe_add(children, 'static', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__static, child_static)
    child_rip = yang.gdata.take_json_opt_cnt(jd, 'rip')
    yang.gdata.maybe_add(children, 'rip', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__rip, child_rip)
    child_vrrp = yang.gdata.take_json_opt_cnt(jd, 'vrrp')
    yang.gdata.maybe_add(children, 'vrrp', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol__vrrp, child_vrrp)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['type'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(yang.adata.MNode):
    routing_protocol: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol

    mut def __init__(self, routing_protocol: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.routing_protocol = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(elements=routing_protocol)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _routing_protocol = self.routing_protocol
        if _routing_protocol is not None:
            children['routing-protocol'] = _routing_protocol.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(routing_protocol=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol.from_gdata(n.get_opt_list('routing-protocol')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols()')
        leaves = []
        _routing_protocol = self.routing_protocol
        for _element in _routing_protocol.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols/routing-protocol element: {_element.to_gdata().key_str(['type'])}")
            list_elem = 'routing_protocol_element = {self_name}.routing_protocol.create({repr(_element.type)})'
            res.append(list_elem)
            res.extend(_element.prsrc('routing_protocol_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/routing-protocols'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_routing_protocol = yang.gdata.from_xml_opt_list(node, 'routing-protocol')
    yang.gdata.maybe_add(children, 'routing-protocol', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol, child_routing_protocol)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'routing-protocol':
            child = {'routing-protocol': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_routing_protocol = yang.gdata.take_json_opt_list(jd, 'routing-protocol')
    yang.gdata.maybe_add(children, 'routing-protocol', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols__routing_protocol, child_routing_protocol)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability__access_priority(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability__access_priority(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(yang.adata.MNode):
    access_priority: int

    mut def __init__(self, access_priority: ?int=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.access_priority = access_priority if access_priority is not None else 100

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _access_priority = self.access_priority
        if _access_priority is not None:
            children['access-priority'] = yang.gdata.Leaf('uint32', _access_priority)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(access_priority=n.get_opt_int('access-priority'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/availability')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability()')
        leaves = []
        _access_priority = self.access_priority
        if _access_priority is not None:
            leaves.append('{self_name}.access_priority = {repr(_access_priority)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/availability'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_access_priority = yang.gdata.from_xml_opt_int(node, 'access-priority')
    yang.gdata.maybe_add(children, 'access-priority', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability__access_priority, child_access_priority)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'access-priority':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_access_priority = yang.gdata.take_json_opt_int(jd, 'access-priority')
    yang.gdata.maybe_add(children, 'access-priority', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability__access_priority, child_access_priority)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_policy_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_policy_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__site_role(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-role: {error}')

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__site_role(val: PartialIdentityref) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf site-role: {error}')

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(yang.adata.MNode):
    vpn_policy_id: ?str
    vpn_id: ?str
    site_role: Identityref

    mut def __init__(self, vpn_policy_id: ?str, vpn_id: ?str, site_role: ?Identityref=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_policy_id = vpn_policy_id
        self.vpn_id = vpn_id
        _default_site_role, error = complete_and_validate_identityref(Identityref.from_adata('any-to-any-role'), _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
        if _default_site_role is not None:
            self.site_role = site_role if site_role is not None else _default_site_role
        else:
            raise ValueError('Invalid default value for identityref leaf vpn-attachment: {error}')

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_policy_id = self.vpn_policy_id
        if _vpn_policy_id is not None:
            children['vpn-policy-id'] = yang.gdata.Leaf('leafref', _vpn_policy_id)
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            children['vpn-id'] = yang.gdata.Leaf('leafref', _vpn_id)
        _site_role = self.site_role
        if _site_role is not None:
            _identityref_site_role, error = complete_and_validate_identityref(_site_role, _identities, ['l3vpn-svc:site-role'], 'ietf-l3vpn-svc')
            if _identityref_site_role is not None:
                _site_role = _identityref_site_role
            else:
                raise ValueError('Invalid value for identityref leaf site-role: {error}')
            children['site-role'] = yang.gdata.Leaf('identityref', _site_role)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(vpn_policy_id=n.get_opt_str('vpn-policy-id'), vpn_id=n.get_opt_str('vpn-id'), site_role=n.get_opt_Identityref('site-role'))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/vpn-attachment')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment()')
        leaves = []
        _vpn_policy_id = self.vpn_policy_id
        if _vpn_policy_id is not None:
            leaves.append('{self_name}.vpn_policy_id = {repr(_vpn_policy_id)}')
        _vpn_id = self.vpn_id
        if _vpn_id is not None:
            leaves.append('{self_name}.vpn_id = {repr(_vpn_id)}')
        _site_role = self.site_role
        if _site_role is not None:
            leaves.append('{self_name}.site_role = {repr(_site_role)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access/vpn-attachment'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_vpn_policy_id = yang.gdata.from_xml_opt_str(node, 'vpn-policy-id')
    yang.gdata.maybe_add(children, 'vpn-policy-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_policy_id, child_vpn_policy_id)
    child_vpn_id = yang.gdata.from_xml_opt_str(node, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_id, child_vpn_id)
    child_site_role = yang.gdata.from_xml_opt_Identityref(node, 'site-role')
    yang.gdata.maybe_add(children, 'site-role', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__site_role, child_site_role)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'vpn-policy-id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'vpn-id':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'site-role':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_policy_id = yang.gdata.take_json_opt_str(jd, 'vpn-policy-id')
    yang.gdata.maybe_add(children, 'vpn-policy-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_policy_id, child_vpn_policy_id)
    child_vpn_id = yang.gdata.take_json_opt_str(jd, 'vpn-id')
    yang.gdata.maybe_add(children, 'vpn-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__vpn_id, child_vpn_id)
    child_site_role = yang.gdata.take_json_opt_Identityref(jd, 'site-role')
    yang.gdata.maybe_add(children, 'site-role', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment__site_role, child_site_role)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(yang.adata.MNode):
    site_network_access_id: str
    site_network_access_type: Identityref
    location_reference: ?str
    device_reference: ?str
    access_diversity: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity
    bearer: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer
    ip_connection: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection
    security: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security
    service: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service
    routing_protocols: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols
    availability: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability
    vpn_attachment: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment

    mut def __init__(self, site_network_access_id: str, service: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service, site_network_access_type: ?Identityref=None, location_reference: ?str, device_reference: ?str, access_diversity: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity=None, bearer: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer=None, ip_connection: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection=None, security: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security=None, routing_protocols: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols=None, availability: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability=None, vpn_attachment: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site_network_access_id = site_network_access_id
        _default_site_network_access_type, error = complete_and_validate_identityref(Identityref.from_adata('point-to-point'), _identities, ['l3vpn-svc:site-network-access-type'], 'ietf-l3vpn-svc')
        if _default_site_network_access_type is not None:
            self.site_network_access_type = site_network_access_type if site_network_access_type is not None else _default_site_network_access_type
        else:
            raise ValueError('Invalid default value for identityref leaf site-network-access: {error}')
        self.location_reference = location_reference
        self.device_reference = device_reference
        self.access_diversity = access_diversity if access_diversity is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity()
        self.bearer = bearer if bearer is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer()
        self.ip_connection = ip_connection if ip_connection is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection()
        self.security = security if security is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security()
        self.service = service
        self.routing_protocols = routing_protocols if routing_protocols is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols()
        self.availability = availability if availability is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability()
        self.vpn_attachment = vpn_attachment if vpn_attachment is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site_network_access_id = self.site_network_access_id
        if _site_network_access_id is not None:
            children['site-network-access-id'] = yang.gdata.Leaf('string', _site_network_access_id)
        _site_network_access_type = self.site_network_access_type
        if _site_network_access_type is not None:
            _identityref_site_network_access_type, error = complete_and_validate_identityref(_site_network_access_type, _identities, ['l3vpn-svc:site-network-access-type'], 'ietf-l3vpn-svc')
            if _identityref_site_network_access_type is not None:
                _site_network_access_type = _identityref_site_network_access_type
            else:
                raise ValueError('Invalid value for identityref leaf site-network-access-type: {error}')
            children['site-network-access-type'] = yang.gdata.Leaf('identityref', _site_network_access_type)
        _location_reference = self.location_reference
        if _location_reference is not None:
            children['location-reference'] = yang.gdata.Leaf('leafref', _location_reference)
        _device_reference = self.device_reference
        if _device_reference is not None:
            children['device-reference'] = yang.gdata.Leaf('leafref', _device_reference)
        _access_diversity = self.access_diversity
        if _access_diversity is not None:
            children['access-diversity'] = _access_diversity.to_gdata()
        _bearer = self.bearer
        if _bearer is not None:
            children['bearer'] = _bearer.to_gdata()
        _ip_connection = self.ip_connection
        if _ip_connection is not None:
            children['ip-connection'] = _ip_connection.to_gdata()
        _security = self.security
        if _security is not None:
            children['security'] = _security.to_gdata()
        _service = self.service
        if _service is not None:
            children['service'] = _service.to_gdata()
        _routing_protocols = self.routing_protocols
        if _routing_protocols is not None:
            children['routing-protocols'] = _routing_protocols.to_gdata()
        _availability = self.availability
        if _availability is not None:
            children['availability'] = _availability.to_gdata()
        _vpn_attachment = self.vpn_attachment
        if _vpn_attachment is not None:
            children['vpn-attachment'] = _vpn_attachment.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(site_network_access_id=n.get_str('site-network-access-id'), site_network_access_type=n.get_opt_Identityref('site-network-access-type'), location_reference=n.get_opt_str('location-reference'), device_reference=n.get_opt_str('device-reference'), access_diversity=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity.from_gdata(n.get_opt_cnt('access-diversity')), bearer=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer.from_gdata(n.get_opt_cnt('bearer')), ip_connection=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection.from_gdata(n.get_opt_cnt('ip-connection')), security=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security.from_gdata(n.get_opt_cnt('security')), service=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service.from_gdata(n.get_cnt('service')), routing_protocols=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols.from_gdata(n.get_opt_cnt('routing-protocols')), availability=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability.from_gdata(n.get_opt_cnt('availability')), vpn_attachment=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment.from_gdata(n.get_opt_cnt('vpn-attachment')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses/site-network-access')
            res.append('self_service = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service({repr(self.service.svc_input_bandwidth)}, {repr(self.service.svc_output_bandwidth)}, {repr(self.service.svc_mtu)})')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access({repr(self.site_network_access_id)}, self_service)')
        leaves = []
        _site_network_access_type = self.site_network_access_type
        if _site_network_access_type is not None:
            leaves.append('{self_name}.site_network_access_type = {repr(_site_network_access_type)}')
        _location_reference = self.location_reference
        if _location_reference is not None:
            leaves.append('{self_name}.location_reference = {repr(_location_reference)}')
        _device_reference = self.device_reference
        if _device_reference is not None:
            leaves.append('{self_name}.device_reference = {repr(_device_reference)}')
        _access_diversity = self.access_diversity
        if _access_diversity is not None:
            res.extend(_access_diversity.prsrc('{self_name}.access_diversity', False).splitlines())
        _bearer = self.bearer
        if _bearer is not None:
            res.extend(_bearer.prsrc('{self_name}.bearer', False).splitlines())
        _ip_connection = self.ip_connection
        if _ip_connection is not None:
            res.extend(_ip_connection.prsrc('{self_name}.ip_connection', False).splitlines())
        _security = self.security
        if _security is not None:
            res.extend(_security.prsrc('{self_name}.security', False).splitlines())
        _service = self.service
        if _service is not None:
            res.extend(_service.prsrc('{self_name}.service', False).splitlines())
        _routing_protocols = self.routing_protocols
        if _routing_protocols is not None:
            res.extend(_routing_protocols.prsrc('{self_name}.routing_protocols', False).splitlines())
        _availability = self.availability
        if _availability is not None:
            res.extend(_availability.prsrc('{self_name}.availability', False).splitlines())
        _vpn_attachment = self.vpn_attachment
        if _vpn_attachment is not None:
            res.extend(_vpn_attachment.prsrc('{self_name}.vpn_attachment', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses/site-network-access'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'site-network-access'
        self.elements = elements

    mut def create(self, site_network_access_id, service):
        for e in self.elements:
            match = True
            if e.site_network_access_id != site_network_access_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry(site_network_access_id, service)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['site-network-access-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_site_network_access_id = yang.gdata.from_xml_str(node, 'site-network-access-id')
    yang.gdata.maybe_add(children, 'site-network-access-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_id, child_site_network_access_id)
    child_site_network_access_type = yang.gdata.from_xml_opt_Identityref(node, 'site-network-access-type')
    yang.gdata.maybe_add(children, 'site-network-access-type', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_type, child_site_network_access_type)
    child_location_reference = yang.gdata.from_xml_opt_str(node, 'location-reference')
    yang.gdata.maybe_add(children, 'location-reference', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__location_reference, child_location_reference)
    child_device_reference = yang.gdata.from_xml_opt_str(node, 'device-reference')
    yang.gdata.maybe_add(children, 'device-reference', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__device_reference, child_device_reference)
    child_access_diversity = yang.gdata.from_xml_opt_cnt(node, 'access-diversity')
    yang.gdata.maybe_add(children, 'access-diversity', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity, child_access_diversity)
    child_bearer = yang.gdata.from_xml_opt_cnt(node, 'bearer')
    yang.gdata.maybe_add(children, 'bearer', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer, child_bearer)
    child_ip_connection = yang.gdata.from_xml_opt_cnt(node, 'ip-connection')
    yang.gdata.maybe_add(children, 'ip-connection', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection, child_ip_connection)
    child_security = yang.gdata.from_xml_opt_cnt(node, 'security')
    yang.gdata.maybe_add(children, 'security', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security, child_security)
    child_service = yang.gdata.from_xml_cnt(node, 'service')
    yang.gdata.maybe_add(children, 'service', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service, child_service)
    child_routing_protocols = yang.gdata.from_xml_opt_cnt(node, 'routing-protocols')
    yang.gdata.maybe_add(children, 'routing-protocols', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols, child_routing_protocols)
    child_availability = yang.gdata.from_xml_opt_cnt(node, 'availability')
    yang.gdata.maybe_add(children, 'availability', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability, child_availability)
    child_vpn_attachment = yang.gdata.from_xml_opt_cnt(node, 'vpn-attachment')
    yang.gdata.maybe_add(children, 'vpn-attachment', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment, child_vpn_attachment)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(e) for e in nodes]
    return yang.gdata.List(keys=['site-network-access-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['site-network-access-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['site-network-access-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_id(keys[0])
        if point == 'site-network-access-type':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'location-reference':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'device-reference':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'access-diversity':
            children['access-diversity'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity(jd, rest_path, op)
        if point == 'bearer':
            children['bearer'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer(jd, rest_path, op)
        if point == 'ip-connection':
            children['ip-connection'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection(jd, rest_path, op)
        if point == 'security':
            children['security'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security(jd, rest_path, op)
        if point == 'service':
            children['service'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service(jd, rest_path, op)
        if point == 'routing-protocols':
            children['routing-protocols'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols(jd, rest_path, op)
        if point == 'availability':
            children['availability'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability(jd, rest_path, op)
        if point == 'vpn-attachment':
            children['vpn-attachment'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['site-network-access-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['site-network-access-id'])))
        return yang.gdata.List(['site-network-access-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['site-network-access-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_site_network_access_id = yang.gdata.take_json_str(jd, 'site-network-access-id')
    yang.gdata.maybe_add(children, 'site-network-access-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_id, child_site_network_access_id)
    child_site_network_access_type = yang.gdata.take_json_opt_Identityref(jd, 'site-network-access-type')
    yang.gdata.maybe_add(children, 'site-network-access-type', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__site_network_access_type, child_site_network_access_type)
    child_location_reference = yang.gdata.take_json_opt_str(jd, 'location-reference')
    yang.gdata.maybe_add(children, 'location-reference', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__location_reference, child_location_reference)
    child_device_reference = yang.gdata.take_json_opt_str(jd, 'device-reference')
    yang.gdata.maybe_add(children, 'device-reference', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__device_reference, child_device_reference)
    child_access_diversity = yang.gdata.take_json_opt_cnt(jd, 'access-diversity')
    yang.gdata.maybe_add(children, 'access-diversity', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__access_diversity, child_access_diversity)
    child_bearer = yang.gdata.take_json_opt_cnt(jd, 'bearer')
    yang.gdata.maybe_add(children, 'bearer', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__bearer, child_bearer)
    child_ip_connection = yang.gdata.take_json_opt_cnt(jd, 'ip-connection')
    yang.gdata.maybe_add(children, 'ip-connection', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__ip_connection, child_ip_connection)
    child_security = yang.gdata.take_json_opt_cnt(jd, 'security')
    yang.gdata.maybe_add(children, 'security', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__security, child_security)
    child_service = yang.gdata.take_json_cnt(jd, 'service')
    yang.gdata.maybe_add(children, 'service', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service, child_service)
    child_routing_protocols = yang.gdata.take_json_opt_cnt(jd, 'routing-protocols')
    yang.gdata.maybe_add(children, 'routing-protocols', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__routing_protocols, child_routing_protocols)
    child_availability = yang.gdata.take_json_opt_cnt(jd, 'availability')
    yang.gdata.maybe_add(children, 'availability', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__availability, child_availability)
    child_vpn_attachment = yang.gdata.take_json_opt_cnt(jd, 'vpn-attachment')
    yang.gdata.maybe_add(children, 'vpn-attachment', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__vpn_attachment, child_vpn_attachment)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['site-network-access-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(yang.adata.MNode):
    site_network_access: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access

    mut def __init__(self, site_network_access: list[ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site_network_access = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(elements=site_network_access)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site_network_access = self.site_network_access
        if _site_network_access is not None:
            children['site-network-access'] = _site_network_access.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(site_network_access=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access.from_gdata(n.get_opt_list('site-network-access')))
        return ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site/site-network-accesses')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses()')
        leaves = []
        _site_network_access = self.site_network_access
        for _element in _site_network_access.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site/site-network-accesses/site-network-access element: {_element.to_gdata().key_str(['site-network-access-id'])}")
            res.append('element_service = ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access__service({repr(_element.service.svc_input_bandwidth)}, {repr(_element.service.svc_output_bandwidth)}, {repr(_element.service.svc_mtu)})')
            list_elem = 'site_network_access_element = {self_name}.site_network_access.create({repr(_element.site_network_access_id)}, element_service)'
            res.append(list_elem)
            res.extend(_element.prsrc('site_network_access_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site/site-network-accesses'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_site_network_access = yang.gdata.from_xml_opt_list(node, 'site-network-access')
    yang.gdata.maybe_add(children, 'site-network-access', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access, child_site_network_access)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'site-network-access':
            child = {'site-network-access': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_site_network_access = yang.gdata.take_json_opt_list(jd, 'site-network-access')
    yang.gdata.maybe_add(children, 'site-network-access', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses__site_network_access, child_site_network_access)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(yang.adata.MNode):
    site_id: str
    requested_site_start: ?str
    requested_site_stop: ?str
    locations: ietf_l3vpn_svc__l3vpn_svc__sites__site__locations
    devices: ietf_l3vpn_svc__l3vpn_svc__sites__site__devices
    site_diversity: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity
    management: ietf_l3vpn_svc__l3vpn_svc__sites__site__management
    vpn_policies: ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies
    site_vpn_flavor: Identityref
    maximum_routes: ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes
    security: ietf_l3vpn_svc__l3vpn_svc__sites__site__security
    service: ietf_l3vpn_svc__l3vpn_svc__sites__site__service
    traffic_protection: ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection
    routing_protocols: ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols
    site_network_accesses: ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses

    mut def __init__(self, site_id: str, management: ietf_l3vpn_svc__l3vpn_svc__sites__site__management, requested_site_start: ?str, requested_site_stop: ?str, locations: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__locations=None, devices: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__devices=None, site_diversity: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity=None, vpn_policies: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies=None, site_vpn_flavor: ?Identityref=None, maximum_routes: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes=None, security: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__security=None, service: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__service=None, traffic_protection: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection=None, routing_protocols: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols=None, site_network_accesses: ?ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site_id = site_id
        self.requested_site_start = requested_site_start
        self.requested_site_stop = requested_site_stop
        self.locations = locations if locations is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__locations()
        self.devices = devices if devices is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__devices()
        self.site_diversity = site_diversity if site_diversity is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity()
        self.management = management
        self.vpn_policies = vpn_policies if vpn_policies is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies()
        _default_site_vpn_flavor, error = complete_and_validate_identityref(Identityref.from_adata('site-vpn-flavor-single'), _identities, ['l3vpn-svc:site-vpn-flavor'], 'ietf-l3vpn-svc')
        if _default_site_vpn_flavor is not None:
            self.site_vpn_flavor = site_vpn_flavor if site_vpn_flavor is not None else _default_site_vpn_flavor
        else:
            raise ValueError('Invalid default value for identityref leaf site: {error}')
        self.maximum_routes = maximum_routes if maximum_routes is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes()
        self.security = security if security is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__security()
        self.service = service if service is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__service()
        self.traffic_protection = traffic_protection if traffic_protection is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection()
        self.routing_protocols = routing_protocols if routing_protocols is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols()
        self.site_network_accesses = site_network_accesses if site_network_accesses is not None else ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site_id = self.site_id
        if _site_id is not None:
            children['site-id'] = yang.gdata.Leaf('string', _site_id)
        _requested_site_start = self.requested_site_start
        if _requested_site_start is not None:
            children['requested-site-start'] = yang.gdata.Leaf('string', _requested_site_start)
        _requested_site_stop = self.requested_site_stop
        if _requested_site_stop is not None:
            children['requested-site-stop'] = yang.gdata.Leaf('string', _requested_site_stop)
        _locations = self.locations
        if _locations is not None:
            children['locations'] = _locations.to_gdata()
        _devices = self.devices
        if _devices is not None:
            children['devices'] = _devices.to_gdata()
        _site_diversity = self.site_diversity
        if _site_diversity is not None:
            children['site-diversity'] = _site_diversity.to_gdata()
        _management = self.management
        if _management is not None:
            children['management'] = _management.to_gdata()
        _vpn_policies = self.vpn_policies
        if _vpn_policies is not None:
            children['vpn-policies'] = _vpn_policies.to_gdata()
        _site_vpn_flavor = self.site_vpn_flavor
        if _site_vpn_flavor is not None:
            _identityref_site_vpn_flavor, error = complete_and_validate_identityref(_site_vpn_flavor, _identities, ['l3vpn-svc:site-vpn-flavor'], 'ietf-l3vpn-svc')
            if _identityref_site_vpn_flavor is not None:
                _site_vpn_flavor = _identityref_site_vpn_flavor
            else:
                raise ValueError('Invalid value for identityref leaf site-vpn-flavor: {error}')
            children['site-vpn-flavor'] = yang.gdata.Leaf('identityref', _site_vpn_flavor)
        _maximum_routes = self.maximum_routes
        if _maximum_routes is not None:
            children['maximum-routes'] = _maximum_routes.to_gdata()
        _security = self.security
        if _security is not None:
            children['security'] = _security.to_gdata()
        _service = self.service
        if _service is not None:
            children['service'] = _service.to_gdata()
        _traffic_protection = self.traffic_protection
        if _traffic_protection is not None:
            children['traffic-protection'] = _traffic_protection.to_gdata()
        _routing_protocols = self.routing_protocols
        if _routing_protocols is not None:
            children['routing-protocols'] = _routing_protocols.to_gdata()
        _site_network_accesses = self.site_network_accesses
        if _site_network_accesses is not None:
            children['site-network-accesses'] = _site_network_accesses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites__site_entry:
        return ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(site_id=n.get_str('site-id'), requested_site_start=n.get_opt_str('requested-site-start'), requested_site_stop=n.get_opt_str('requested-site-stop'), locations=ietf_l3vpn_svc__l3vpn_svc__sites__site__locations.from_gdata(n.get_opt_cnt('locations')), devices=ietf_l3vpn_svc__l3vpn_svc__sites__site__devices.from_gdata(n.get_opt_cnt('devices')), site_diversity=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity.from_gdata(n.get_opt_cnt('site-diversity')), management=ietf_l3vpn_svc__l3vpn_svc__sites__site__management.from_gdata(n.get_cnt('management')), vpn_policies=ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies.from_gdata(n.get_opt_cnt('vpn-policies')), site_vpn_flavor=n.get_opt_Identityref('site-vpn-flavor'), maximum_routes=ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes.from_gdata(n.get_opt_cnt('maximum-routes')), security=ietf_l3vpn_svc__l3vpn_svc__sites__site__security.from_gdata(n.get_opt_cnt('security')), service=ietf_l3vpn_svc__l3vpn_svc__sites__site__service.from_gdata(n.get_opt_cnt('service')), traffic_protection=ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection.from_gdata(n.get_opt_cnt('traffic-protection')), routing_protocols=ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols.from_gdata(n.get_opt_cnt('routing-protocols')), site_network_accesses=ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses.from_gdata(n.get_opt_cnt('site-network-accesses')))

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites/site')
            res.append('self_management = ietf_l3vpn_svc__l3vpn_svc__sites__site__management({repr(self.management.type)})')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites__site({repr(self.site_id)}, self_management)')
        leaves = []
        _requested_site_start = self.requested_site_start
        if _requested_site_start is not None:
            leaves.append('{self_name}.requested_site_start = {repr(_requested_site_start)}')
        _requested_site_stop = self.requested_site_stop
        if _requested_site_stop is not None:
            leaves.append('{self_name}.requested_site_stop = {repr(_requested_site_stop)}')
        _locations = self.locations
        if _locations is not None:
            res.extend(_locations.prsrc('{self_name}.locations', False).splitlines())
        _devices = self.devices
        if _devices is not None:
            res.extend(_devices.prsrc('{self_name}.devices', False).splitlines())
        _site_diversity = self.site_diversity
        if _site_diversity is not None:
            res.extend(_site_diversity.prsrc('{self_name}.site_diversity', False).splitlines())
        _management = self.management
        if _management is not None:
            res.extend(_management.prsrc('{self_name}.management', False).splitlines())
        _vpn_policies = self.vpn_policies
        if _vpn_policies is not None:
            res.extend(_vpn_policies.prsrc('{self_name}.vpn_policies', False).splitlines())
        _site_vpn_flavor = self.site_vpn_flavor
        if _site_vpn_flavor is not None:
            leaves.append('{self_name}.site_vpn_flavor = {repr(_site_vpn_flavor)}')
        _maximum_routes = self.maximum_routes
        if _maximum_routes is not None:
            res.extend(_maximum_routes.prsrc('{self_name}.maximum_routes', False).splitlines())
        _security = self.security
        if _security is not None:
            res.extend(_security.prsrc('{self_name}.security', False).splitlines())
        _service = self.service
        if _service is not None:
            res.extend(_service.prsrc('{self_name}.service', False).splitlines())
        _traffic_protection = self.traffic_protection
        if _traffic_protection is not None:
            res.extend(_traffic_protection.prsrc('{self_name}.traffic_protection', False).splitlines())
        _routing_protocols = self.routing_protocols
        if _routing_protocols is not None:
            res.extend(_routing_protocols.prsrc('{self_name}.routing_protocols', False).splitlines())
        _site_network_accesses = self.site_network_accesses
        if _site_network_accesses is not None:
            res.extend(_site_network_accesses.prsrc('{self_name}.site_network_accesses', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites/site'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

class ietf_l3vpn_svc__l3vpn_svc__sites__site(yang.adata.MNode):
    elements: list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self._name = 'site'
        self.elements = elements

    mut def create(self, site_id, management):
        for e in self.elements:
            match = True
            if e.site_id != site_id:
                match = False
                continue
            if match:
                return e

        res = ietf_l3vpn_svc__l3vpn_svc__sites__site_entry(site_id, management)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['site-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]:
        if n is not None:
            return [ietf_l3vpn_svc__l3vpn_svc__sites__site_entry.from_gdata(e) for e in n.elements]
        return []


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_site_id = yang.gdata.from_xml_str(node, 'site-id')
    yang.gdata.maybe_add(children, 'site-id', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_id, child_site_id)
    child_requested_site_start = yang.gdata.from_xml_opt_str(node, 'requested-site-start')
    yang.gdata.maybe_add(children, 'requested-site-start', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_start, child_requested_site_start)
    child_requested_site_stop = yang.gdata.from_xml_opt_str(node, 'requested-site-stop')
    yang.gdata.maybe_add(children, 'requested-site-stop', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_stop, child_requested_site_stop)
    child_locations = yang.gdata.from_xml_opt_cnt(node, 'locations')
    yang.gdata.maybe_add(children, 'locations', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations, child_locations)
    child_devices = yang.gdata.from_xml_opt_cnt(node, 'devices')
    yang.gdata.maybe_add(children, 'devices', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices, child_devices)
    child_site_diversity = yang.gdata.from_xml_opt_cnt(node, 'site-diversity')
    yang.gdata.maybe_add(children, 'site-diversity', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity, child_site_diversity)
    child_management = yang.gdata.from_xml_cnt(node, 'management')
    yang.gdata.maybe_add(children, 'management', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__management, child_management)
    child_vpn_policies = yang.gdata.from_xml_opt_cnt(node, 'vpn-policies')
    yang.gdata.maybe_add(children, 'vpn-policies', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies, child_vpn_policies)
    child_site_vpn_flavor = yang.gdata.from_xml_opt_Identityref(node, 'site-vpn-flavor')
    yang.gdata.maybe_add(children, 'site-vpn-flavor', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_vpn_flavor, child_site_vpn_flavor)
    child_maximum_routes = yang.gdata.from_xml_opt_cnt(node, 'maximum-routes')
    yang.gdata.maybe_add(children, 'maximum-routes', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes, child_maximum_routes)
    child_security = yang.gdata.from_xml_opt_cnt(node, 'security')
    yang.gdata.maybe_add(children, 'security', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__security, child_security)
    child_service = yang.gdata.from_xml_opt_cnt(node, 'service')
    yang.gdata.maybe_add(children, 'service', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__service, child_service)
    child_traffic_protection = yang.gdata.from_xml_opt_cnt(node, 'traffic-protection')
    yang.gdata.maybe_add(children, 'traffic-protection', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection, child_traffic_protection)
    child_routing_protocols = yang.gdata.from_xml_opt_cnt(node, 'routing-protocols')
    yang.gdata.maybe_add(children, 'routing-protocols', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols, child_routing_protocols)
    child_site_network_accesses = yang.gdata.from_xml_opt_cnt(node, 'site-network-accesses')
    yang.gdata.maybe_add(children, 'site-network-accesses', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses, child_site_network_accesses)
    return yang.gdata.Container(children)

mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(e) for e in nodes]
    return yang.gdata.List(keys=['site-id'], elements=elements)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.Absent(val.key_children(['site-id']))
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        children['site-id'] = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_id(keys[0])
        if point == 'requested-site-start':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'requested-site-stop':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'locations':
            children['locations'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations(jd, rest_path, op)
        if point == 'devices':
            children['devices'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices(jd, rest_path, op)
        if point == 'site-diversity':
            children['site-diversity'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity(jd, rest_path, op)
        if point == 'management':
            children['management'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__management(jd, rest_path, op)
        if point == 'vpn-policies':
            children['vpn-policies'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies(jd, rest_path, op)
        if point == 'site-vpn-flavor':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'maximum-routes':
            children['maximum-routes'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes(jd, rest_path, op)
        if point == 'security':
            children['security'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__security(jd, rest_path, op)
        if point == 'service':
            children['service'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__service(jd, rest_path, op)
        if point == 'traffic-protection':
            children['traffic-protection'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection(jd, rest_path, op)
        if point == 'routing-protocols':
            children['routing-protocols'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols(jd, rest_path, op)
        if point == 'site-network-accesses':
            children['site-network-accesses'] = from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses(jd, rest_path, op)
        return yang.gdata.Container(children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['site-id']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.Absent(element.key_children(['site-id'])))
        return yang.gdata.List(['site-id'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['site-id'], [from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(jd: dict[str, ?value]) -> yang.gdata.Node:
    children = {}
    child_site_id = yang.gdata.take_json_str(jd, 'site-id')
    yang.gdata.maybe_add(children, 'site-id', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_id, child_site_id)
    child_requested_site_start = yang.gdata.take_json_opt_str(jd, 'requested-site-start')
    yang.gdata.maybe_add(children, 'requested-site-start', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_start, child_requested_site_start)
    child_requested_site_stop = yang.gdata.take_json_opt_str(jd, 'requested-site-stop')
    yang.gdata.maybe_add(children, 'requested-site-stop', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__requested_site_stop, child_requested_site_stop)
    child_locations = yang.gdata.take_json_opt_cnt(jd, 'locations')
    yang.gdata.maybe_add(children, 'locations', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__locations, child_locations)
    child_devices = yang.gdata.take_json_opt_cnt(jd, 'devices')
    yang.gdata.maybe_add(children, 'devices', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__devices, child_devices)
    child_site_diversity = yang.gdata.take_json_opt_cnt(jd, 'site-diversity')
    yang.gdata.maybe_add(children, 'site-diversity', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_diversity, child_site_diversity)
    child_management = yang.gdata.take_json_cnt(jd, 'management')
    yang.gdata.maybe_add(children, 'management', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__management, child_management)
    child_vpn_policies = yang.gdata.take_json_opt_cnt(jd, 'vpn-policies')
    yang.gdata.maybe_add(children, 'vpn-policies', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__vpn_policies, child_vpn_policies)
    child_site_vpn_flavor = yang.gdata.take_json_opt_Identityref(jd, 'site-vpn-flavor')
    yang.gdata.maybe_add(children, 'site-vpn-flavor', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_vpn_flavor, child_site_vpn_flavor)
    child_maximum_routes = yang.gdata.take_json_opt_cnt(jd, 'maximum-routes')
    yang.gdata.maybe_add(children, 'maximum-routes', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__maximum_routes, child_maximum_routes)
    child_security = yang.gdata.take_json_opt_cnt(jd, 'security')
    yang.gdata.maybe_add(children, 'security', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__security, child_security)
    child_service = yang.gdata.take_json_opt_cnt(jd, 'service')
    yang.gdata.maybe_add(children, 'service', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__service, child_service)
    child_traffic_protection = yang.gdata.take_json_opt_cnt(jd, 'traffic-protection')
    yang.gdata.maybe_add(children, 'traffic-protection', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__traffic_protection, child_traffic_protection)
    child_routing_protocols = yang.gdata.take_json_opt_cnt(jd, 'routing-protocols')
    yang.gdata.maybe_add(children, 'routing-protocols', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__routing_protocols, child_routing_protocols)
    child_site_network_accesses = yang.gdata.take_json_opt_cnt(jd, 'site-network-accesses')
    yang.gdata.maybe_add(children, 'site-network-accesses', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site__site_network_accesses, child_site_network_accesses)
    return yang.gdata.Container(children)

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = [from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site_element(e) for e in jd if isinstance(e, dict)]
    return yang.gdata.List(keys=['site-id'], elements=elements)

class ietf_l3vpn_svc__l3vpn_svc__sites(yang.adata.MNode):
    site: ietf_l3vpn_svc__l3vpn_svc__sites__site

    mut def __init__(self, site: list[ietf_l3vpn_svc__l3vpn_svc__sites__site_entry]=[]):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.site = ietf_l3vpn_svc__l3vpn_svc__sites__site(elements=site)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _site = self.site
        if _site is not None:
            children['site'] = _site.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc__sites:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc__sites(site=ietf_l3vpn_svc__l3vpn_svc__sites__site.from_gdata(n.get_opt_list('site')))
        return ietf_l3vpn_svc__l3vpn_svc__sites()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc/sites')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc__sites()')
        leaves = []
        _site = self.site
        for _element in _site.elements:
            res.append('')
            res.append("# List /l3vpn-svc/sites/site element: {_element.to_gdata().key_str(['site-id'])}")
            res.append('element_management = ietf_l3vpn_svc__l3vpn_svc__sites__site__management({repr(_element.management.type)})')
            list_elem = 'site_element = {self_name}.site.create({repr(_element.site_id)}, element_management)'
            res.append(list_elem)
            res.extend(_element.prsrc('site_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc/sites'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc__sites(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_site = yang.gdata.from_xml_opt_list(node, 'site')
    yang.gdata.maybe_add(children, 'site', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites__site, child_site)
    return yang.gdata.Container(children)

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'site':
            child = {'site': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites__site(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc__sites(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc__sites(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_site = yang.gdata.take_json_opt_list(jd, 'site')
    yang.gdata.maybe_add(children, 'site', from_json_ietf_l3vpn_svc__l3vpn_svc__sites__site, child_site)
    return yang.gdata.Container(children)

class ietf_l3vpn_svc__l3vpn_svc(yang.adata.MNode):
    vpn_profiles: ietf_l3vpn_svc__l3vpn_svc__vpn_profiles
    vpn_services: ietf_l3vpn_svc__l3vpn_svc__vpn_services
    sites: ietf_l3vpn_svc__l3vpn_svc__sites

    mut def __init__(self, vpn_profiles: ?ietf_l3vpn_svc__l3vpn_svc__vpn_profiles=None, vpn_services: ?ietf_l3vpn_svc__l3vpn_svc__vpn_services=None, sites: ?ietf_l3vpn_svc__l3vpn_svc__sites=None):
        self._ns = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc'
        self.vpn_profiles = vpn_profiles if vpn_profiles is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_profiles()
        self.vpn_services = vpn_services if vpn_services is not None else ietf_l3vpn_svc__l3vpn_svc__vpn_services()
        self.sites = sites if sites is not None else ietf_l3vpn_svc__l3vpn_svc__sites()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vpn_profiles = self.vpn_profiles
        if _vpn_profiles is not None:
            children['vpn-profiles'] = _vpn_profiles.to_gdata()
        _vpn_services = self.vpn_services
        if _vpn_services is not None:
            children['vpn-services'] = _vpn_services.to_gdata()
        _sites = self.sites
        if _sites is not None:
            children['sites'] = _sites.to_gdata()
        return yang.gdata.Container(children, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ietf_l3vpn_svc__l3vpn_svc:
        if n is not None:
            return ietf_l3vpn_svc__l3vpn_svc(vpn_profiles=ietf_l3vpn_svc__l3vpn_svc__vpn_profiles.from_gdata(n.get_opt_cnt('vpn-profiles')), vpn_services=ietf_l3vpn_svc__l3vpn_svc__vpn_services.from_gdata(n.get_opt_cnt('vpn-services')), sites=ietf_l3vpn_svc__l3vpn_svc__sites.from_gdata(n.get_opt_cnt('sites')))
        return ietf_l3vpn_svc__l3vpn_svc()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /l3vpn-svc')
            res.append('{self_name} = ietf_l3vpn_svc__l3vpn_svc()')
        leaves = []
        _vpn_profiles = self.vpn_profiles
        if _vpn_profiles is not None:
            res.extend(_vpn_profiles.prsrc('{self_name}.vpn_profiles', False).splitlines())
        _vpn_services = self.vpn_services
        if _vpn_services is not None:
            res.extend(_vpn_services.prsrc('{self_name}.vpn_services', False).splitlines())
        _sites = self.sites
        if _sites is not None:
            res.extend(_sites.prsrc('{self_name}.sites', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /l3vpn-svc'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml_ietf_l3vpn_svc__l3vpn_svc(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_vpn_profiles = yang.gdata.from_xml_opt_cnt(node, 'vpn-profiles')
    yang.gdata.maybe_add(children, 'vpn-profiles', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles, child_vpn_profiles)
    child_vpn_services = yang.gdata.from_xml_opt_cnt(node, 'vpn-services')
    yang.gdata.maybe_add(children, 'vpn-services', from_xml_ietf_l3vpn_svc__l3vpn_svc__vpn_services, child_vpn_services)
    child_sites = yang.gdata.from_xml_opt_cnt(node, 'sites')
    yang.gdata.maybe_add(children, 'sites', from_xml_ietf_l3vpn_svc__l3vpn_svc__sites, child_sites)
    return yang.gdata.Container(children, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')

mut def from_json_path_ietf_l3vpn_svc__l3vpn_svc(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'vpn-profiles':
            child = {'vpn-profiles': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')
        if point == 'vpn-services':
            child = {'vpn-services': from_json_path_ietf_l3vpn_svc__l3vpn_svc__vpn_services(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')
        if point == 'sites':
            child = {'sites': from_json_path_ietf_l3vpn_svc__l3vpn_svc__sites(jd, rest_path, op) }
            return yang.gdata.Container(child, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_ietf_l3vpn_svc__l3vpn_svc(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_ietf_l3vpn_svc__l3vpn_svc(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vpn_profiles = yang.gdata.take_json_opt_cnt(jd, 'vpn-profiles')
    yang.gdata.maybe_add(children, 'vpn-profiles', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_profiles, child_vpn_profiles)
    child_vpn_services = yang.gdata.take_json_opt_cnt(jd, 'vpn-services')
    yang.gdata.maybe_add(children, 'vpn-services', from_json_ietf_l3vpn_svc__l3vpn_svc__vpn_services, child_vpn_services)
    child_sites = yang.gdata.take_json_opt_cnt(jd, 'sites')
    yang.gdata.maybe_add(children, 'sites', from_json_ietf_l3vpn_svc__l3vpn_svc__sites, child_sites)
    return yang.gdata.Container(children, ns='urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc', module='ietf-l3vpn-svc')

class root(yang.adata.MNode):
    netinfra: netinfra__netinfra
    l3vpn_svc: ietf_l3vpn_svc__l3vpn_svc

    mut def __init__(self, netinfra: ?netinfra__netinfra=None, l3vpn_svc: ?ietf_l3vpn_svc__l3vpn_svc=None):
        self._ns = ''
        self.netinfra = netinfra if netinfra is not None else netinfra__netinfra()
        self.l3vpn_svc = l3vpn_svc if l3vpn_svc is not None else ietf_l3vpn_svc__l3vpn_svc()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _netinfra = self.netinfra
        if _netinfra is not None:
            children['netinfra'] = _netinfra.to_gdata()
        _l3vpn_svc = self.l3vpn_svc
        if _l3vpn_svc is not None:
            children['l3vpn-svc'] = _l3vpn_svc.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> root:
        if n is not None:
            return root(netinfra=netinfra__netinfra.from_gdata(n.get_opt_cnt('netinfra')), l3vpn_svc=ietf_l3vpn_svc__l3vpn_svc.from_gdata(n.get_opt_cnt('l3vpn-svc')))
        return root()

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /root')
            res.append('{self_name} = root()')
        leaves = []
        _netinfra = self.netinfra
        if _netinfra is not None:
            res.extend(_netinfra.prsrc('{self_name}.netinfra', False).splitlines())
        _l3vpn_svc = self.l3vpn_svc
        if _l3vpn_svc is not None:
            res.extend(_l3vpn_svc.prsrc('{self_name}.l3vpn_svc', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /root'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)


mut def from_xml(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_netinfra = yang.gdata.from_xml_opt_cnt(node, 'netinfra', 'http://example.com/netinfra')
    yang.gdata.maybe_add(children, 'netinfra', from_xml_netinfra__netinfra, child_netinfra)
    child_l3vpn_svc = yang.gdata.from_xml_opt_cnt(node, 'l3vpn-svc', 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc')
    yang.gdata.maybe_add(children, 'l3vpn-svc', from_xml_ietf_l3vpn_svc__l3vpn_svc, child_l3vpn_svc)
    return yang.gdata.Container(children)

mut def from_json_path(jd: value, path: list[str]=[], op: ?str='merge') -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'netinfra:netinfra':
            child = {'netinfra': from_json_path_netinfra__netinfra(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'ietf-l3vpn-svc:l3vpn-svc':
            child = {'l3vpn-svc': from_json_path_ietf_l3vpn_svc__l3vpn_svc(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_netinfra = yang.gdata.take_json_opt_cnt(jd, 'netinfra', 'netinfra')
    yang.gdata.maybe_add(children, 'netinfra', from_json_netinfra__netinfra, child_netinfra)
    child_l3vpn_svc = yang.gdata.take_json_opt_cnt(jd, 'l3vpn-svc', 'ietf-l3vpn-svc')
    yang.gdata.maybe_add(children, 'l3vpn-svc', from_json_ietf_l3vpn_svc__l3vpn_svc, child_l3vpn_svc)
    return yang.gdata.Container(children)

schema_namespaces: set[str] = {
    'http://example.com/netinfra',
    'urn:ietf:params:xml:ns:yang:ietf-l3vpn-svc',
}
