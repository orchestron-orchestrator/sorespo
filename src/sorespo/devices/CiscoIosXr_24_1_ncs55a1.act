import base64
import json
import xml
import yang
import yang.adata
import yang.gdata
import yang.gen3
from yang.gdata import repr_yang
from yang.identity import complete_and_validate_identityref
from yang.identityref import Identityref, PartialIdentityref
from yang.schema import DIdentity

# == This file is generated ==




_identities: list[DIdentity] = []


def src_yang():
    res = []
    res.append(r"""module Cisco-IOS-XR-policy-repository-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg";
  prefix "policy-repository-cfg";
  import Cisco-IOS-XR-types {
    prefix "xr";
  }
  import cisco-semver {
    prefix "semver";
  }
  organization "Cisco Systems, Inc.";
  contact "Cisco Systems, Inc.
Customer Service

Postal: 170 West Tasman Drive
San Jose, CA 95134

Tel: +1 800 553-NETS

E-mail: cs-yang@cisco.com";
  description "This module contains a collection of YANG definitions
for Cisco IOS-XR policy-repository package configuration.

This module contains definitions
for the following management objects:
  routing-policy: Routing policy configuration

Copyright (c) 2013-2022 by Cisco Systems, Inc.
All rights reserved.";
  revision 2022-12-02 {
    description "Updated RPL knob operations to include extcomm evpn-link-bandwidth.
2022-06-22
  Updating RPL knob for set nexthop with allocate-vpn-label";
    semver:module-version 1.1.0;
  }
  revision 2019-04-05 {
    description "Establish semantic version baseline.";
    semver:module-version 1.0.1;
  }
  revision 2017-09-07 {
    description "Fixing prepend/append/remove containers.";
  }
  revision 2017-09-07 {
    description "Fixed type translation error.";
  }
  revision 2015-08-27 {
    description "IOS XR 5.3.2 revision.";
  }
  container routing-policy {
    description "Routing policy configuration";
    container route-policies {
      description "All configured policies";
      list route-policy {
        key route-policy-name;
        description "Information about an individual policy";
        leaf route-policy-name {
          type xr:Cisco-ios-xr-string;
          description "Route policy name";
        }
        leaf rpl-route-policy {
          type xr:Rpl-policy;
          mandatory true;
          description "policy statements";
        }
      }
    }
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-types {
  namespace "http://cisco.com/ns/yang/cisco-xr-types";
  prefix xr;

  import cisco-semver {
    prefix semver;
  }
  import ietf-inet-types {
    prefix inet;
  }

  organization
    "Cisco Systems, Inc.";
  contact
    "Cisco Systems, Inc.
     Customer Service
     
     Postal: 170 W Tasman Drive
     San Jose, CA 95134
     
     Tel: +1 1800 553-NETS
     
     E-mail: cs-yang@cisco.com";
  description
    "This module contains a collection of IOS-XR derived YANG data
     types.
     
     Copyright (c) 2013-2021 by Cisco Systems, Inc.
     All rights reserved.";

  revision 2023-12-06 {
    description
      "Modified string match pattern of Node-id
       2022-03-09
         Included space in Cisco-ios-xr-string pattern.
       2021-10-19
         Added a new type Hex-long-integer";
    semver:module-version "2.2.0";
  }
  revision 2020-11-18 {
    description
      "Added a new type Hex-integer-8";
    semver:module-version "2.1.0";
  }
  revision 2019-12-03 {
    description
      "Modified string match pattern of Interface-name";
    semver:module-version "2.0.0";
  }
  revision 2019-04-05 {
    description
      "Establish semantic version baseline.";
    semver:module-version "1.0.0";
  }
  revision 2019-01-18 {
    description
      "This revision adds the following new data types:
       - Type10-password";
  }
  revision 2018-06-29 {
    description
      "Modified string match pattern of Interface-name";
  }
  revision 2017-12-01 {
    description
      "Modified string match pattern of Tty-escape-char-num";
  }
  revision 2017-03-07 {
    description
      "This revision adds the following new data types:
       - Type8-password
       - Type9-password";
  }
  revision 2015-06-29 {
    description
      "This revision adds the following new data types:
       - Rpl-policy
       - Rpl-set";
  }
  revision 2015-05-18 {
    description
      "Updated Node-id string pattern to match also shorter ncs4k
         node names.";
  }
  revision 2015-01-19 {
    description
      "This revision adds the following new data types:
       - Bgp-ipv4-flowspec-address
       - Bgp-ipv6-flowspec-address";
  }
  revision 2013-07-22 {
    description
      "Initial revision.";
  }

  extension xr-cli-map {
    argument cli-command;
    description
      "The xr-cli-map statement takes as an argument
       relevant CLI configuration command.";
  }

  extension xr-xml-map {
    argument xr-xml-node;
    description
      "The xr-xml-map statement takes as an argument
       relevant Cisco XML Schema node name.";
  }

  extension cli-command {
    argument command;
    description
      "Corresponding CLI command for this RPC node";
  }

  extension cli-name {
    argument keyword;
    description
      "Corresponding CLI keyword for this node";
  }

  extension xr-task {
    argument task;
    description
      "XR task-id required for operating the yang node";
  }

  extension event-telemetry {
    argument description;
    description
      "Node eligible for telemetry event subscription";
  }

  typedef Route-dist {
    type string {
      pattern "[a-fA-F0-9]{16}";
    }
    description
      "Route distinguisher in hexadecimal notation.";
  }

  typedef Bgp-l2vpn-evpn-addrs {
    type string {
      pattern "[a-fA-F0-9]{58}";
    }
    description
      "L2VPN EVPN Address in hexadecimal notation.";
  }

  typedef Bgp-ls-addr {
    type string {
      pattern "[a-fA-F0-9]+";
    }
    description
      "BGP link state unicast address in hexadecimal
       notation.";
  }

  typedef Bgp-ipv6-mvpn-addr {
    type string {
      pattern "[a-fA-F0-9]{104}";
    }
    description
      "An IPV6 MVPN address in hexadecimal notation.";
  }

  typedef Bgp-ipv4-mvpn-addr {
    type string {
      pattern "[a-fA-F0-9]{56}";
    }
    description
      "An IPV4 MVPN address in hexadecimal notation.";
  }

  typedef Bgp-rt-constrt-addr {
    type string {
      pattern "[a-fA-F0-9]{24}";
    }
    description
      "An IPV4 RTConstraint address in hexadecimal notation.";
  }

  typedef Bgp-ipv4-mdt-addr {
    type string {
      pattern "(([a-f0-9]{16}-)(([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))";
    }
    description
      "An IPV4 MDT address in dotted decimal notation.
       An IPv4 MDT address should be of the form
       0000006400000065-129.29.83.45. This datatype
       restricts the value of each field 16 digits in
       hexadecimal for RD field and between 0 and 255
       for IPv4 address field, i.e.
       [0000000000000000-ffffffffffffffff]-
       [0-255].[0-255].[0-255].[0-255].";
  }

  typedef Bgp-ipv4-tunnel-addr {
    type string {
      pattern "((0:|[1-9][0-9]{0,4}:)(([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))";
    }
    description
      "An IPV4 tunnel address in dotted decimal notation.
       An IPv4 tunnel address should be of the form
       65535:129.29.83.45. This datatype restricts the
       value of each field between 0 and 65535 for prefix
       field and 0 and 255 for IPv4 address field, i.e.
       [0-65535]:[0-255].[0-255].[0-255].[0-255]";
  }

  typedef Cisco-ios-xr-port-number {
    type uint16 {
      range "1..65535";
    }
    description
      "Port number of range from 1 to 65535";
  }

  typedef Interface-name {
    type string {
      pattern "[a-zA-Z0-9.:_/-]+";
    }
    description
      "An interface name specifying an interface type and
       instance.
       Interface represents a string defining an interface
       type and instance, e.g. MgmtEth0/4/CPU1/0 or
       TenGigE0/2/0/0.2 or Bundle-Ether9 or
       Bundle-Ether9.98 or Serial0/0/0/0/3/1:1";
  }

  typedef Controller-name {
    type string {
      pattern "[a-zA-Z0-9.:_/-]+";
    }
    description
      "A controller name specifying a controller type and
       instance.
       Controller represents a string defining a controller
       type and instance, e.g. dwdm0/4/0/0 or
       GigabitEthCtrlr0/2/0/0 or T10/0/0/0";
  }

  typedef Cisco-ios-xr-string {
    type string {
      pattern "[\\w\\-\\.:,_@#%$\\+=\\| ;]+";
    }
    description
      "Special characters are not allowed.";
  }

  typedef Ipv4-prefix-length {
    type uint8 {
      range "0..32";
    }
    description
      "An IPv4 address prefix length.
       Must lie between 0 and 32 inclusive.";
  }

  typedef Ipv6-prefix-length {
    type uint8 {
      range "0..128";
    }
    description
      "An IPv6 address prefix length.
       Must lie between 0 and 32 inclusive.";
  }

  typedef Rack-id {
    type string {
      pattern "[a-zA-Z0-9_]*\\d+";
    }
    description
      "Names the rack portion of a NodeID
       Rack/Slot/Instance triple";
  }

  typedef Slot-id {
    type string {
      pattern "[a-zA-Z0-9_]*\\d+";
    }
    description
      "Names the slot portion of a NodeID
       Rack/Slot/Instance triple";
  }

  typedef Instance-id {
    type string {
      pattern "[a-zA-Z0-9_]*\\d+";
    }
    description
      "Names the instance portion of a NodeID
       Rack/Slot/Instance triple";
  }

  typedef Sub-instance-id {
    type string {
      pattern "[a-zA-Z0-9_]*\\d+";
    }
    description
      "Names the sub-instance portion of an extended
       NodeID Rack/Slot/Instance/SubInstance";
  }

  typedef Encryption-type {
    type enumeration {
      enum "none" {
        value 0;
        description
          "The password string is clear text.";
      }
      enum "md5" {
        value 1;
        description
          "The password is encrypted to an MD5 digest.";
      }
      enum "proprietary" {
        value 2;
        description
          "The password is encrypted using Cisco type 7
           password encryption.";
      }
      enum "type6" {
        value 3;
        description
          "The password is encrypted using Cisco type 6
           password encryption.";
      }
    }
    description
      "The type of encryption used on a password string.";
  }

  typedef Hex-long-integer {
    type string {
      pattern "[0-9a-fA-F]{1,16}";
    }
    description
      "An unsigned 64-bit integer represented in
       hexadecimal format.";
  }

  typedef Hex-integer {
    type string {
      pattern "[0-9a-fA-F]{1,8}";
    }
    description
      "An unsigned 32-bit integer represented in
       hexadecimal format.";
  }

  typedef Hex-integer-16 {
    type string {
      pattern "[0-9a-fA-F]{1,4}";
    }
    description
      "An unsigned 16-bit integer represented in
       hexadecimal format.";
  }

  typedef Hex-integer-8 {
    type string {
      pattern "[0-9a-fA-F]{1,2}";
    }
    description
      "An unsigned 8-bit integer represented in
       hexadecimal format.";
  }

  typedef Osi-system-id {
    type string {
      pattern "[a-fA-F0-9]{4}(\\.[a-fA-F0-9]{4}){2}";
    }
    description
      "An OSI system ID should be of the form
       0123.4567.89ab. This data type restricts each
       character to a hex character.";
  }

  typedef Osi-area-address {
    type string {
      pattern "[a-fA-F0-9]{2}(\\.[a-fA-F0-9]{4}){0,6}";
    }
    description
      "An OSI area address should consist of an odd number
       of octets, and be of the form 01 or 01.2345 etc up
       to 01.2345.6789.abcd.ef01.2345.6789. This data type
       restricts each character to a hex character.";
  }

  typedef Isis-node-id {
    type string {
      pattern "[a-fA-F0-9]{4}(\\.[a-fA-F0-9]{4}){2}\\.[a-fA-F0-9]{2}";
    }
    description
      "An ISIS node ID should be of the form
       0123.4567.89ab.cd. This data type restricts each
       character to a hex character.";
  }

  typedef Isis-snpa {
    type string {
      pattern "[a-fA-F0-9]{4}(\\.[a-fA-F0-9]{4}){2}";
    }
    description
      "String representation of a SNPA, 802.2 MAC address
       in canonical format, e.g. 0123.4567.89ab";
  }

  typedef Isis-lsp-id {
    type string {
      pattern "[a-fA-F0-9]{4}(\\.[a-fA-F0-9]{4}){2}\\.[a-fA-F0-9]{2}\\-[a-fA-F0-9]{2}";
    }
    description
      "An ISIS LSP ID should be of the form
       0123.4567.89ab.cd-ef. This data type restricts each
       character to a hex character.";
  }

  typedef Osi-net {
    type string {
      pattern "[a-fA-F0-9]{2}(\\.[a-fA-F0-9]{4}){3,9}\\.[a-fA-F0-9]{2}";
    }
    description
      "An OSI NET should consist of an even number of
       octets, and be of the form 01.2345.6789.abcd.ef etc
       up to
       01.2345.6789.abcd.ef01.2345.6789.abcd.ef01.2345.67.
       This data type restricts each character to a hex
       character.";
  }

  typedef String-identifier {
    type string {
      pattern "[a-zA-Z0-9_\\-]+";
    }
    description
      "A string for specifying identifier.";
  }

  typedef Char-num {
    type union {
      type string {
        pattern "(0x[0-9A-Fa-f]{1,2}|\\p{IsBasicLatin}|\\p{IsLatin-1Supplement})";
      }
      type uint8;
    }
    description
      "Takes a character or its ASCII decimal equivalent
       (0-255).";
  }

  typedef Tty-escape-char-num {
    type union {
      type string {
        pattern "(0x[0-9A-Fa-f]{1,2}|\\p{IsBasicLatin}|\\p{IsLatin-1Supplement}|DEFAULT|BREAK|NONE)";
      }
      type uint8;
    }
    description
      "Escape character or its ASCII decimal equivalent
       (0-255) or one of the three string DEFAULT, BREAK,
       NONE.";
  }

  typedef Extended-node-id {
    type string {
      pattern "([a-zA-Z0-9_]*\\d+/){3}([a-zA-Z0-9_]*\\d+)";
    }
    description
      "A location used as value information and specified
       as a Rack/Slot/Instance/SubInstance, e.g.
       0/1/CPU0/NPU0";
  }

  typedef Node-id {
    type string {
      pattern "([a-zA-Z0-9_]*\\d+/){1,2}([a-zA-Z0-9_]*\\d*)";
    }
    description
      "A location used as value information.";
  }

  typedef Pq-node-id {
    type string {
      pattern "((([a-zA-Z0-9_]*\\d+)|(\\*))/){2}(([a-zA-Z0-9_]*\\d+)|(\\*))";
    }
    description
      "Partially qualified location which is used for
       wildcarding location specifications, e.g. 1/*/*";
  }

  typedef Md5-password {
    type string {
      pattern "(!.+)|([^!].+)";
    }
    description
      "The Md5-password type is used to store password using the MD5
       hash function.
       When a clear text value is set to a leaf of this type, the
       server calculates a password hash and stores the result
       in the datastore. The password is never stored in clear text.
       
       When a leaf of this type is read, the stored password hash is
       returned.
       
       A value of this type matches one of the forms:
       
         !<clear text password>
         <password hash>
       
       The '!' prefix signals that the value is clear text. When
       such a value is received by the server, a hash value is
       calculated. This value is stored in the configuration data
       store.
       
       If a value starting without '!' is received, the server knows
       that the value already represents a hashed value, and stores
       it as is in the data store.";
  }

  typedef Type8-password {
    type string {
      pattern "(!.+)|([^!].+)";
    }
    description
      "The Type8-password type is used to store password using the
       SHA-256 encryption.
       When a clear text value is set to a leaf of this type, the
       server calculates a password hash and stores the result
       in the datastore. The password is never stored in clear text.
       
       When a leaf of this type is read, the stored password hash is
       returned.
       
       A value of this type matches one of the forms:
       
         !<clear text password>
         <password hash>
       
       The '!' prefix signals that the value is clear text. When
       such a value is received by the server, a hash value is
       calculated. This value is stored in the configuration data
       store.
       
       If a value starting without '!' is received, the server knows
       that the value already represents a hashed value, and stores
       it as is in the data store.";
  }

  typedef Type9-password {
    type string {
      pattern "(!.+)|([^!].+)";
    }
    description
      "The Type9-password type is used to store password using the
       Script algorithmic encryption.
       When a clear text value is set to a leaf of this type, the
       server calculates a password hash and stores the result
       in the datastore. The password is never stored in clear text.
       
       When a leaf of this type is read, the stored password hash is
       returned.
       
       A value of this type matches one of the forms:
       
         !<clear text password>
         <password hash>
       
       The '!' prefix signals that the value is clear text. When
       such a value is received by the server, a hash value is
       calculated. This value is stored in the configuration data
       store.
       
       If a value starting without '!' is received, the server knows
       that the value already represents a hashed value, and stores
       it as is in the data store.";
  }

  typedef Type10-password {
    type string {
      pattern "(!.+)|([^!].+)";
    }
    description
      "The Type10-password type is used to store password using the
       Script algorithmic encryption.
       When a clear text value is set to a leaf of this type, the
       server calculates a password hash and stores the result
       in the datastore. The password is never stored in clear text.
       
       When a leaf of this type is read, the stored password hash is
       returned.
       
       A value of this type matches one of the forms:
       
         !<clear text password>
         <password hash>
       
       The '!' prefix signals that the value is clear text. When
       such a value is received by the server, a hash value is
       calculated. This value is stored in the configuration data
       store.
       
       If a value starting without '!' is received, the server knows
       that the value already represents a hashed value, and stores
       it as is in the data store.";
  }

  typedef Proprietary-password {
    type string {
      pattern "(!.+)|([^!].+)";
    }
    description
      "The Proprietary-password type is used to store password
       using the Cisco proprietary hash function.
       When a clear text value is set to a leaf of this type, the
       server calculates a password hash and stores the result
       in the datastore. The password is never stored in clear text.
       
       When a leaf of this type is read, the stored password hash is
       returned.
       
       A value of this type matches one of the forms:
       
         !<clear text password>
         <password hash>
       
       The '!' prefix signals that the value is clear text. When
       such a value is received by the server, a hash value is
       calculated. This value is stored in the configuration data
       store.
       
       If a value starting without '!' is received, the server knows
       that the value already represents a hashed value, and stores
       it as is in the data store.";
  }

  typedef Type6-password {
    type string {
      pattern "(!.+)|([^!].+)";
    }
    description
      "The Type6-password type is used to store password
       using the Cisco type 6 hash function.
       When a clear text value is set to a leaf of this type, the
       server calculates a password hash and stores the result
       in the datastore. The password is never stored in clear text.
       
       When a leaf of this type is read, the stored password hash is
       returned.
       
       A value of this type matches one of the forms:
       
         !<clear text password>
         <password hash>
       
       The '!' prefix signals that the value is clear text. When
       such a value is received by the server, a hash value is
       calculated. This value is stored in the configuration data
       store.
       
       If a value starting without '!' is received, the server knows
       that the value already represents a hashed value, and stores
       it as is in the data store.";
  }

  typedef Bgp-ipv4-flowspec-address {
    type string {
      pattern "[a-fA-F0-9]{4096}";
    }
    description
      "An IPV4 Flowspec address in hexadecimal notation.";
  }

  typedef Bgp-ipv6-flowspec-address {
    type string {
      pattern "[a-fA-F0-9]{4096}";
    }
    description
      "An IPV6 Flowspec address in hexadecimal notation.";
  }

  typedef Rpl-policy {
    type string;
    description
      "RPL Policy info";
  }

  typedef Rpl-set {
    type string;
    description
      "RPL Set info";
  }

  typedef Physical-allowed-node-id {
    type uint32;
    description
      "A physical location encoded as a 32-bit value.";
  }

  typedef Physical-allowed-node-id-string {
    type string;
    description
      "A physical location which is represented internallyusing string format (eg: 0_6_CPU0).";
  }

  typedef Bgp-as-number {
    /* XXX
    type union {
      type uint32 {
        range "1..65535" {
          description
            "2-byte AS number";
        }
      }
      type string {
        pattern "([1-9][0-9]{0,4}).([0-9]{1,5})" {
          description
            "4-byte AS number in asdot (X.Y) format";
        }
      }
      type uint32 {
        range "65536..4294967295" {
          description
            "4-byte AS number in asplain format";
        }
      }
    }
    */
    type string;
    description
      "BGP AS number type";
  }

  typedef Route-policy-name {
    type string {
      length "1..255";
    }
    description
      "Datatype for route policy name";
  }

  typedef Ospf-area-id {
    type union {
      type uint32 {
        range "0..4294967295";
      }
      type inet:ip-address;
    }
    description
      "OSPF area ID. Either OSPF area ID as a decimal value or OSPF area ID in IP address format";
  }

  typedef Vpn-id {
    type string {
      pattern "([0-9a-f]{1,8}):([0-9a-f]{1,8})" {
        description
          "VPN ID format (OUI:VPN-Index in hex integer)";
      }
    }
    description
      "VPN ID format (OUI:VPN-Index in hex integer)";
  }

  typedef Mpls-label-space-id {
    type string {
      pattern "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]):0" {
        description
          "<IPv4 address>:0";
      }
    }
    description
      "MPLS-LDP labe-space ID format";
  }

  typedef Bgp-route-distinguisher {
    type union {
      type string {
        pattern "([0-9]{1,5}):([0-9]{1,10})" {
          description
            "2-byte AS number:nn (<1-65535>:<0-4294967295>)";
        }
      }
      type string {
        pattern "([0-9]{5,10}):([0-9]{1,10})" {
          description
            "4-byte AS number:nn (<65536-4294967295>:<0-4294967295>)";
        }
      }
      type string {
        pattern "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]):([0-9]{1,10})" {
          description
            "IP address:nn (A.B.C.D:<0-4294967295>)";
        }
      }
    }
    description
      "BGP route distinguisher number format";
  }

  typedef Evpn-esi-value {
    type string {
      pattern "[0-9a-f]{1,2}(\\.[0-9a-f]{1,2}){8}";
    }
    description
      "EVPN 9-octet ESI value";
  }

  typedef Docker-app-id {
    type string {
      pattern "[a-zA-Z0-9][a-zA-Z0-9_.-]+";
    }
    description
      "A Docker container name format.";
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-hostname-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg";
  prefix um-hostname-cfg;

  import Cisco-IOS-XR-types {
    prefix xr;
  }
  import cisco-semver {
    prefix semver;
  }

  organization
    "Cisco Systems, Inc.";
  contact
    "Cisco Systems, Inc.
     Customer Service
     
     Postal: 170 West Tasman Drive
     San Jose, CA 95134
     
     Tel: +1 800 553-NETS
     
     E-mail: cs-yang@cisco.com";
  description
    "This module contains a collection of YANG definitions
     for Cisco IOS-XR hostname package configuration.
     
     This YANG module augments the
     modules with configuration data.
     
     Copyright (c) 2021-2022 by Cisco Systems, Inc.
     All rights reserved.";

  revision 2021-04-21 {
    description
      "Initial release";
    semver:module-version "1.0.0";
  }

  container hostname {
    description
      "Set system's network name";
    leaf system-network-name {
      type xr:Cisco-ios-xr-string {
        length "1..253" {
          description
            "This system's network name";
        }
        pattern "[a-zA-Z0-9_.-]+";
      }
      description
        "Set system's network name";
    }
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-if-ip-address-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg";
  prefix um-if-ip-address-cfg;

  import cisco-semver {
    prefix semver;
  }
  import ietf-inet-types {
    prefix inet;
  }
  import Cisco-IOS-XR-types {
    prefix xr;
  }
  import Cisco-IOS-XR-um-interface-cfg {
    prefix a1;
  }

  organization
    "Cisco Systems, Inc.";
  contact
    "Cisco Systems, Inc.
     Customer Service
     
     Postal: 170 West Tasman Drive
     San Jose, CA 95134
     
     Tel: +1 800 553-NETS
     
     E-mail: cs-yang@cisco.com";
  description
    "This module contains a collection of YANG definitions
     for Cisco IOS-XR interface package configuration.
     
     This YANG module augments the
     modules with configuration data.
     
     Copyright (c) 2019-2022 by Cisco Systems, Inc.
     All rights reserved.";

  revision 2022-07-11 {
    description
      "Added missing description statement to nodes
       2021-09-14
         Added leaf algorithm under container address, secondaries and eui64-addresses";
    semver:module-version "3.1.0";
  }
  revision 2020-05-27 {
    description
      "- Included BVI interface under when statement for container dhcp
       - Added container dhcp and dhcp-client-options under ipv6 addresses";
    semver:module-version "3.0.0";
  }
  revision 2019-06-10 {
    description
      "Establish semantic version baseline.";
    semver:module-version "2.0.0";
  }
  revision 2019-03-29 {
    description
      "Initial version";
  }

  grouping GROUP-IPV4 {
    description
      "Interface IPv4 config commands";
    container addresses {
      description
        "Set the IPv4 address of an interface";
      container address {
        presence "Indicates a address node is configured.";
        description
          "IP address and Mask";
        leaf address {
          type inet:ipv4-address-no-zone;
          mandatory true;
          description
            "IP address";
        }
        leaf netmask {
          type inet:ipv4-address-no-zone;
          mandatory true;
          description
            "IP subnet mask";
        }
        leaf route-tag {
          type uint32 {
            range "1..4294967295";
          }
          description
            "Route-tag to be associated with this address";
        }
        leaf algorithm {
          type uint32 {
            range "128..255" {
              description
                "Algorithm value (default: no algo)";
            }
          }
          description
            "Algorithm to be associated with this address";
        }
      }
      container secondaries {
        description
          "Specify a secondary address";
        list secondary {
          key "address";
          description
            "IP address and Mask";
          leaf address {
            type inet:ipv4-address-no-zone;
            description
              "Secondary IP address";
          }
          leaf netmask {
            type inet:ipv4-address-no-zone;
            mandatory true;
            description
              "Netmask";
          }
          leaf route-tag {
            type uint32 {
              range "1..4294967295";
            }
            description
              "Route-tag to be associated with this address";
          }
          leaf algorithm {
            type uint32 {
              range "128..255" {
                description
                  "Algorithm value (default: no algo)";
              }
            }
            description
              "Algorithm to be associated with this address";
          }
        }
      }
      leaf unnumbered {
        when "../../../a1:interface-name[not(starts-with(text(),'pw-ether'))]" {
        }
        type xr:Interface-name;
        description
          "Enable IP processing without an explicit address";
      }
      container dhcp {
        when "../../../a1:interface-name[starts-with(text(),'MgmtEth')] or ../../../a1:interface-name[starts-with(text(),'BVI')]" {
        }
        presence "Indicates a dampening node is configured.";
        description
          "IPv4 address and Mask negotiated via DHCP";
      }
    }
  }

  augment "/a1:interfaces/a1:interface/a1:ipv4" {
    description
      "This augment extends active nodes configuration";
    uses GROUP-IPV4;
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-l2-ethernet-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg";
  prefix "um-l2-ethernet-cfg";
  import Cisco-IOS-XR-types {
    prefix "xr";
  }
  import ietf-yang-types {
    prefix "yang";
  }
  import Cisco-IOS-XR-um-interface-cfg {
    prefix "a1";
  }
  import tailf-common {
    prefix "tailf";
  }
  import cisco-semver {
    prefix "semver";
  }
  organization "Cisco Systems, Inc.";
  contact "Cisco Systems, Inc.
Customer Service

Postal: 170 West Tasman Drive
San Jose, CA 95134

Tel: +1 800 553-NETS

E-mail: cs-yang@cisco.com";
  description "This module contains a collection of YANG definitions
for Cisco IOS-XR l2-ethernet package configuration.

This YANG module augments the
modules with configuration data.

Copyright (c) 2020-2022 by Cisco Systems, Inc.
All rights reserved.";
  revision 2023-06-15 {
    description "Added ethernet conatiner with leaf UNI id in,
IF_BODY grouping.
2022-10-10
  Added must statement dot1q, dot1ad, untagged, and default
2022-07-11
  Added missing description statement to nodes
2022-06-18
  Added container list-extended to support 64 vlan ranges
2022-03-10
  1.Added leaf dot1q-end-vlan-id under l2transport-encapsulation/dot1ad
2.Added leaf second-dot1q-end-vlan-id under l2transport-encapsulation/dot1q";
    semver:module-version 4.0.0;
  }
  revision 2021-03-30 {
    description "Updated with statement for 800G interface";
    semver:module-version 3.0.0;
  }
  revision 2021-02-19 {
    description "Updated when/must statement under carrier-delay, l2transport-encapsulation,
  encapsulation, l2protocol container.
2020-08-01
    Added when/must statement under encapsulation container.
  Added feature/if-feature for global ethernet config.";
    semver:module-version 2.0.0;
  }
  revision 2020-03-05 {
    description "Initial draft";
    semver:module-version 1.0.0;
  }
  feature global-ethernet {
    description "Global ethernet configuration";
  }
  grouping IF-BODY {
    description "Grouping for interface";
    container encapsulation {
      when "(../a1:interface-name[starts-with(text(),'FastEthernet')] or ../a1:interface-name[starts-with(text(),'GigabitEthernet')] or ../a1:interface-name[starts-with(text(),'TenGigE')] or ../a1:interface-name[starts-with(text(),'FortyGigE')] or ../a1:interface-name[starts-with(text(),'HundredGigE')] or ../a1:interface-name[starts-with(text(),'TwoHundredGigE')] or ../a1:interface-name[starts-with(text(),'FourHundredGigE')] or ../a1:interface-name[starts-with(text(),'EightHundredGigE')] or ../a1:interface-name[starts-with(text(),'TwentyFiveGigE')] or ../a1:interface-name[starts-with(text(),'FiftyGigE')] or ../a1:interface-name[starts-with(text(),'Bundle-Ether')] or ../a1:interface-name[starts-with(text(),'PW-Ether')])and ../a1:interface-name[contains(text(),'.')]and not(../a1:sub-interface-type/a1:l2transport)" {
        tailf:dependency "../a1:interface-name";
      }
      description "Specify which packets will be matched by this sub-interface";
      container dot1q {
        description "IEEE 802.1Q VLAN-tagged packets";
        leaf vlan-id {
          type uint32 {
            range "1..4094" {
              description "Configure first (outer) VLAN ID on the subinterface";
            }
          }
          description "Configure first (outer) VLAN ID on the subinterface";
        }
        leaf second-dot1q {
          type uint32 {
            range "1..4094" {
              description "Configure second (inner 802.1Q) VLAN ID on the subinterface";
            }
          }
          must "../vlan-id";
          description "Configure second (inner 802.1Q) VLAN ID on the subinterface";
        }
      }
    }
  }
  grouping L2TRANS-BODY {
    description "Grouping for l2transport";
    container l2protocol {
      when "(../../a1:interface-name[starts-with(text(),'FastEthernet')] or ../../a1:interface-name[starts-with(text(),'GigabitEthernet')] or ../../a1:interface-name[starts-with(text(),'TenGigE')] or ../../a1:interface-name[starts-with(text(),'FortyGigE')] or ../../a1:interface-name[starts-with(text(),'HundredGigE')] or ../../a1:interface-name[starts-with(text(),'TwentyFiveGigE')] or ../../a1:interface-name[starts-with(text(),'Ethernet')] or ../../a1:interface-name[starts-with(text(),'Bundle-Ether')] or ../../a1:interface-name[starts-with(text(),'PW-Ether')] or ../../a1:interface-name[starts-with(text(),'Interflex')]) and (../../a1:interface-name[not(contains(text(),'.'))] or ../../a1:sub-interface-type/a1:l2transport)" {
        tailf:dependency "../../a1:interface-name";
      }
      description "Layer 2 protocol handling";
      container cpsv {
        description "CDP, PVST+, STP, and VTP protocols";
        container tunnel {
          must "not(../reverse-tunnel) and not(../drop)";
          presence "Indicates a tunnel node is configured.";
          description "Tunnel at ingress";
        }
        container reverse-tunnel {
          must "not(../tunnel) and not(../drop)";
          presence "Indicates a reverse-tunnel node is configured.";
          description "Tunnel at egress";
        }
        container drop {
          must "not(../tunnel) and not(../reverse-tunnel)";
          presence "Indicates a drop node is configured.";
          description "Drop these protocol packets";
        }
      }
      container cdp {
        description "Cisco Discovery Protocol";
        container drop {
          must "not(../tunnel) and not(../forward)";
          presence "Indicates a drop node is configured.";
          description "Drop this protocol's packets";
        }
        container forward {
          must "not(../drop) and not(../tunnel)";
          presence "Indicates a forward node is configured.";
          description "Forward this protocol's packets";
        }
        container tunnel {
          must "not(../drop) and not(../forward)";
          presence "Indicates a tunnel node is configured.";
          description "Tunnel this protocol's packets";
        }
        container experimental {
          description "Modify the MPLS Experimental bits";
          leaf mpls-experimental-bits {
            type uint32 {
              range "0..7" {
                description "Set the MPLS experimental bits for this interface";
              }
            }
            must "../../forward or ../../tunnel";
            description "Set the MPLS experimental bits for this interface";
          }
        }
      }
      container stp {
        description "Spanning Tree Protocol";
        container drop {
          must "not(../tunnel) and not(../forward)";
          presence "Indicates a drop node is configured.";
          description "Drop this protocol's packets";
        }
        container forward {
          must "not(../drop) and not(../tunnel)";
          presence "Indicates a forward node is configured.";
          description "Forward this protocol's packets";
        }
        container tunnel {
          must "not(../drop) and not(../forward)";
          presence "Indicates a tunnel node is configured.";
          description "Tunnel this protocol's packets";
        }
        container experimental {
          description "Modify the MPLS Experimental bits";
          leaf mpls-experimental-bits {
            type uint32 {
              range "0..7" {
                description "Set the MPLS experimental bits for this interface";
              }
            }
            must "../../forward or ../../tunnel";
            description "Set the MPLS experimental bits for this interface";
          }
        }
      }
      container vtp {
        description "VLAN Trunk Protocol";
        container drop {
          must "not(../tunnel) and not(../forward)";
          presence "Indicates a drop node is configured.";
          description "Drop this protocol's packets";
        }
        container forward {
          must "not(../drop) and not(../tunnel)";
          presence "Indicates a forward node is configured.";
          description "Forward this protocol's packets";
        }
        container tunnel {
          must "not(../drop) and not(../forward)";
          presence "Indicates a tunnel node is configured.";
          description "Tunnel this protocol's packets";
        }
        container experimental {
          description "Modify the MPLS Experimental bits";
          leaf mpls-experimental-bits {
            type uint32 {
              range "0..7" {
                description "Set the MPLS experimental bits for this interface";
              }
            }
            must "../../forward or ../../tunnel";
            description "Set the MPLS experimental bits for this interface";
          }
        }
      }
      container pvst {
        description "Per VLAN Spanning Tree";
        container drop {
          must "not(../tunnel) and not(../forward)";
          presence "Indicates a drop node is configured.";
          description "Drop this protocol's packets";
        }
        container forward {
          must "not(../drop) and not(../tunnel)";
          presence "Indicates a forward node is configured.";
          description "Forward this protocol's packets";
        }
        container tunnel {
          must "not(../drop) and not(../forward)";
          presence "Indicates a tunnel node is configured.";
          description "Tunnel this protocol's packets";
        }
        container experimental {
          description "Modify the MPLS Experimental bits";
          leaf mpls-experimental-bits {
            type uint32 {
              range "0..7" {
                description "Set the MPLS experimental bits for this interface";
              }
            }
            must "../../forward or ../../tunnel";
            description "Set the MPLS experimental bits for this interface";
          }
        }
      }
    }
    container propagate {
      description "Select events to propagate";
      container remote-status {
        presence "Indicates a remote-status node is configured.";
        description "Propagate remote link status changes";
      }
    }
  }
  augment "/a1:interfaces/a1:interface" {
    description "This augment extends active nodes configuration";
    uses IF-BODY;
  }
  container ethernet {
    description "Ethernet configuration";
    container egress-filter {
      description "Egress-filter commands";
      container strict {
        if-feature "global-ethernet";
        presence "Indicates a strict node is configured.";
        description "Strict egress-filtering on by default";
      }
    }
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-if-vrf-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-vrf-cfg";
  prefix um-if-vrf-cfg;

  import cisco-semver {
    prefix semver;
  }
  import Cisco-IOS-XR-types {
    prefix xr;
  }
  import Cisco-IOS-XR-um-interface-cfg {
    prefix a1;
  }

  organization
    "Cisco Systems, Inc.";
  contact
    "Cisco Systems, Inc.
     Customer Service
     
     Postal: 170 West Tasman Drive
     San Jose, CA 95134
     
     Tel: +1 800 553-NETS
     
     E-mail: cs-yang@cisco.com";
  description
    "This module contains a collection of YANG definitions
     for Cisco IOS-XR if vrf package configuration.
     
     This YANG module augments the
     modules with configuration data.
     
     Copyright (c) 2019-2022 by Cisco Systems, Inc.
     All rights reserved.";

  revision 2022-07-11 {
    description
      "Added missing description statement to nodes";
    semver:module-version "1.1.0";
  }
  revision 2019-10-10 {
    description
      "Initial version";
    semver:module-version "1.0.0";
  }

  grouping GROUP-IFSUB {
    description
      "Grouping for interface";
    leaf vrf {
      when "../a1:interface-name[not(starts-with(text(),'tunnel-'))] and ../a1:interface-name[not(starts-with(text(),'cem'))] and ../a1:interface-name[not(starts-with(text(),'nve'))]" {
      }
      type xr:Cisco-ios-xr-string {
        length "1..32" {
          description
            "VRF name";
        }
      }
      description
        "Set VRF in which the interface operates";
    }
  }

  augment "/a1:interfaces/a1:interface" {
    description
      "This augment extends active nodes configuration";
    uses GROUP-IFSUB;
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-interface-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg";
  prefix um-interface-cfg;

  import cisco-semver {
    prefix semver;
  }
  import Cisco-IOS-XR-types {
    prefix xr;
  }

  organization
    "Cisco Systems, Inc.";
  contact
    "Cisco Systems, Inc.
     Customer Service
     
     Postal: 170 West Tasman Drive
     San Jose, CA 95134
     
     Tel: +1 800 553-NETS
     
     E-mail: cs-yang@cisco.com";
  description
    "This module contains a collection of YANG definitions
     for Cisco IOS-XR interface package configuration.
     
     This YANG module augments the
     modules with configuration data.
     
     Copyright (c) 2019-2022 by Cisco Systems, Inc.
     All rights reserved.";

  revision 2022-07-11 {
    description
      "Added missing description statement to nodes
       2022-06-01
         Adjusted controller hierarchy";
    semver:module-version "3.0.0";
  }
  revision 2021-05-04 {
    description
      "Added sec-admin-state node under controller";
    semver:module-version "2.0.0";
  }
  revision 2019-06-10 {
    description
      "Establish semantic version baseline.";
    semver:module-version "1.0.1";
  }
  revision 2019-03-29 {
    description
      "Initial version";
  }

  grouping GROUP-BODY {
    description
      "Grouping for group-body";
    container sub-interface-type {
      description
        "Specify type of sub-interface";
      container l2transport {
        presence "Indicates a l2transport node is configured.";
        description
          "l2transport sub-interface";
      }
      container point-to-point {
        presence "Indicates a point-to-point node is configured.";
        description
          "point-to-point sub-interface";
      }
      container multipoint {
        presence "Indicates a multipoint node is configured.";
        description
          "multipoint sub-interface";
      }
    }
    container ipv4 {
      description
        "Interface IPv4 config commands";
    }
    container ipv6 {
      description
        "Interface IPv6 config commands";
    }
    container encapsulation {
      when "../interface-name[starts-with(text(),'POS')] or ../interface-name[starts-with(text(),'serial')] or ../interface-name[starts-with(text(),'multilink')]" {
      }
      description
        "Set the encapsulation on an interface";
      container ppp {
        presence "Indicates a ppp node is configured.";
        description
          "Point-to-Point protocol";
      }
      container hdlc {
        presence "Indicates a hdlc node is configured.";
        description
          "Serial HDLC synchronous";
      }
      container mfr {
        when "../../interface-name[starts-with(text(),'serial')]" {
        }
        presence "Indicates a mfr node is configured.";
        description
          "Multilink Frame Relay Member Link";
      }
      container frame-relay {
        when "../../interface-name[not(contains(text(),'.'))]" {
        }
        presence "Indicates a frame-relay node is configured.";
        description
          "Frame Relay networks";
        container IETF {
          presence "Indicates a IETF node is configured.";
          description
            "Use RFC1490/RFC2427 encapsulation";
        }
      }
    }
    leaf shutdown {
      type empty;
      description
        "shutdown the given interface";
    }
    leaf mtu {
      when "../interface-name[not(starts-with(text(),'SBC'))] and ../interface-name[not(starts-with(text(),'tunnel-te'))] and ../interface-name[not(starts-with(text(),'tunnel-mte'))] and ../interface-name[not(starts-with(text(),'VASILeft'))] and ../interface-name[not(starts-with(text(),'VASIRight'))] and ../interface-name[not(starts-with(text(),'service-gre'))] and ../interface-name[not(starts-with(text(),'service-ipsec'))] and ../interface-name[not(starts-with(text(),'InterflexLeft'))] and ../interface-name[not(starts-with(text(),'InterflexRight'))] and ../interface-name[not(starts-with(text(),'CEM'))]" {
      }
      type uint32 {
        range "64..65535" {
          description
            "MTU size in bytes";
        }
      }
      description
        "Set the MTU on an interface";
    }
    leaf description {
      type string {
        length "1..1024" {
          description
            "Description for this interface";
        }
      }
      description
        "Set description for this interface";
    }
  }

  grouping CONT-BODY {
    description
      "Grouping for controller-body";
    container shutdown {
      when "../controller-name[not(starts-with(text(),'MACSecCtrlr'))] and ../controller-name[not(starts-with(text(),'Odu-Group-'))] and ../controller-name[not(starts-with(text(),'dwdm'))]" {
      }
      presence "Indicates a shutdown node is configured.";
      description
        "shutdown the given controller";
    }
    leaf description {
      when "../controller-name[not(starts-with(text(),'CPRI'))] and ../controller-name[not(starts-with(text(),'MACSecCtrlr'))] and ../controller-name[not(starts-with(text(),'Odu-Group-'))] and ../controller-name[not(starts-with(text(),'STM'))] and ../controller-name[not(starts-with(text(),'STS'))] and ../controller-name[not(starts-with(text(),'VC'))] and ../controller-name[not(starts-with(text(),'dwdm'))]" {
      }
      type string {
        length "1..1024" {
          description
            "Description for this controller";
        }
      }
      description
        "Set description for this controller";
    }
    leaf sec-admin-state {
      when "../controller-name[not(starts-with(text(),'MACSecCtrlr'))] and ../controller-name[not(starts-with(text(),'Odu-Group-'))] and ../controller-name[not(starts-with(text(),'E1'))] and ../controller-name[not(starts-with(text(),'E3'))] and ../controller-name[not(starts-with(text(),'T1'))] and ../controller-name[not(starts-with(text(),'T3'))] and ../controller-name[not(starts-with(text(),'SONET'))] and ../controller-name[not(starts-with(text(),'ODU'))] and ../controller-name[not(starts-with(text(),'OTU'))] and ../controller-name[not(starts-with(text(),'dwdm'))]" {
      }
      type enumeration {
        enum "normal" {
          value 0;
          description
            "change the sec-admin-state to normal, only for optics";
        }
        enum "maintenance" {
          value 1;
          description
            "change the sec-admin-state to maintenance";
        }
      }
      description
        "Configure the secondary admin state, not available for all controllers";
    }
  }

  container interfaces {
    description
      "Interface configuration";
    list interface {
      key "interface-name";
      description
        "Interface configuration subcommands";
      leaf interface-name {
        type xr:Interface-name;
        description
          "Interface configuration subcommands";
      }
      uses GROUP-BODY;
    }
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-mpls-ldp-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg";
  prefix "um-mpls-ldp-cfg";
  import cisco-semver {
    prefix "semver";
  }
  import Cisco-IOS-XR-types {
    prefix "xr";
  }
  import ietf-inet-types {
    prefix "inet";
  }
  organization "Cisco Systems, Inc.";
  contact "Cisco Systems, Inc.
Customer Service

Postal: 170 West Tasman Drive
San Jose, CA 95134

Tel: +1 800 553-NETS

E-mail: cs-yang@cisco.com";
  description "This module contains a collection of YANG definitions
for Cisco IOS-XR mpls-ldp package configuration.

This YANG module augments the
modules with configuration data.

Copyright (c) 2019-2023 by Cisco Systems, Inc.
All rights reserved.";
  revision 2022-06-01 {
    description "added entropy-label-add-el and clone-tunnel support
2021-11-15
  added address-family ipv6 feature and rtr-id-arb-tlv ";
    semver:module-version 3.1.0;
  }
  revision 2021-07-09 {
    description "type correction for the ipv4/v6 address";
    semver:module-version 3.0.0;
  }
  revision 2021-01-29 {
    description "Add enable container under recursive-fec container
2021-01-28
    Added cisco-support task yang nodes
2020-12-08
    Removed cisco-support yang nodes
2020-07-10
    Added when statement to redistribute to show it's only for ipv4";
    semver:module-version 2.0.0;
  }
  revision 2020-05-29 {
    description "Changed description for sac";
  }
  revision 2019-12-10 {
    description "Corrected must statement definition for password/encrypted,disable";
  }
  revision 2019-10-10 {
    description "Moved trap augments into Cisco-IOS-XR-um-traps-mpls-ldp-cfg.";
  }
  revision 2019-09-25 {
    description "Changed the list node name access-list to access-lists.";
    semver:module-version 2.0.0;
  }
  revision 2019-06-10 {
    description "Establish semantic version baseline.";
  }
  revision 2019-03-30 {
    description "Initial version";
  }
  container mpls {
    description "Global MPLS configuration subcommands";
    container ldp {
      presence "Indicates a ldp node is configured.";
      description "Label Distribution Protocol";
      container address-families {
        description "Configure Address Family and its parameters";
        list address-family {
          key af-name;
          description "Configure Address Family and its parameters";
          leaf af-name {
            type enumeration {
              enum ipv4 {
                value 4;
                description "IPv4";
              }
              enum ipv6 {
                value 6;
                description "IPv6";
              }
            }
            description "Configure Address Family and its parameters";
          }
        }
      }
      container interfaces {
        description "Enable LDP on an interface and enter interface submode";
        list interface {
          key interface-name;
          description "Enable LDP on an interface and enter interface submode";
          leaf interface-name {
            type xr:Interface-name;
            description "Enable LDP on an interface and enter interface submode";
          }
        }
      }
    }
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-router-bgp-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg";
  prefix "um-router-bgp-cfg";
  import Cisco-IOS-XR-types {
    prefix "xr";
  }
  import ietf-inet-types {
    prefix "inet";
  }
  import Cisco-IOS-XR-um-vrf-cfg {
    prefix "a2";
  }
  import cisco-semver {
    prefix "semver";
  }
  organization "Cisco Systems, Inc.";
  contact "Cisco Systems, Inc.
Customer Service

Postal: 170 West Tasman Drive
San Jose, CA 95134

Tel: +1 800 553-NETS

E-mail: cs-yang@cisco.com";
  description "This module contains a collection of YANG definitions
for Cisco IOS-XR router-bgp package configuration.

This YANG module augments the
modules with configuration data.

Copyright (c) 2019-2024 by Cisco Systems, Inc.
All rights reserved.";
  revision 2024-01-31 {
    description "Removed deprecated policy container under route-monitoring
2024-01-23
  Updated containers for export to vrf allow-imported-vpn
disable-adv-source-vrf-vni allow backup best-external
2023-12-08
  Updated containers for import from vrf advertise-as-vpn allow backup best-external
2023-12-03
  Updated sch-pathnames for next-hop-self
2023-08-04
  Added MPLS-VPN label mode per-vrf-46 option
2023-07-12
  Support for allocate-secondary-label
2023-06-05
  Support for local aggregates OC
2023-05-01
  Added segment-routing srv6 alloc mode per-vrf-46 option
2023-04-18
  1. Added allowconfedas-in leaf
2. Added nexthop route-policy under vrf leafs
2023-03-15
  Added segment-routing SRv6 uSID allocate from
WLIB
2023-02-27
  Added maximum-paths route-policy and eibgp equal-cost leaf
2023-02-06
  Added LPTS secure binding leaf
2023-01-25
  Support for update in error-handling
2022-12-13
  Support for evpn-link-bandwidth
2022-12-09
  Added OC-BGP neighbor logging and addpath
2022-12-08
  1. Added OC-BGP restart timer
2. Added EVPN host import knobs under AF v4/v6 of
global VRF.
2022-11-05
  Updated slow-peer static and dynamic leafs
2022-10-04
  Added OC-BGP replace-private-as
2022-09-23
  Added BMP route-monitoring suport for L3VPN inbound post-policy
and Local RIB,
Deprecated container policy under route-monitoring
2022-09-19
  Added EVPN Gateway IP disable
2022-08-16
  Updated slow-peer feature
2022-07-14
  Added OC-BGP mtu-discovery
2022-07-11
  Added missing description statement to nodes
2022-06-20
  Added delay/startup support under wait-install
2022-03-03
  Added leaf percentage-threshold-high under bandwidth-aware
2022-02-18
  Updated maximum-paths ebgp/eibgp and ibgp to remove unused container 'order' and fix pack format
2021-10-20
  Added force node under sr-policy";
    semver:module-version 5.0.0;
  }
  revision 2021-10-19 {
    description "Added leaf flex-algo under container optimal-route-reflection
2021-09-21
   Added retention under route-policy
2021-08-27
   Increase maximum-paths ebgp range to 1024,
 Added preference  under rpki/server,
 Added datafile under rpki,
 Added unique-nexthop-check-disable under maximum-paths,
 Added table-version under address-family
2021-08-23
   Added epe-bgp/labeled-unicast under advertise and epe/backup/enable
 Added deterministic under unequal-cost of maximum-paths
 Added container export under address family
 Added leaf route-policy under srv6/alloc
 Added container bandwidth-aware
 Added leaf route-policy under srv6/alloc of vrfs
 Added node deterministic under unequal-cost of maximum-paths/address family
2021-07-29
   Removed duplicate enforce-first-as-disable which serve same as enforce-first-as/disable";
    semver:module-version 4.0.0;
  }
  revision 2021-05-31 {
    description "Added must statement under list instances router->bgp
2021-03-15
    Added sr-policy under router-bgp->bgp->bestpath and
  router-bgp->vrf->bgp->bestpath
2021-02-25
    Added multipath container under vrf->neighbors->address-family
2021-02-17
    Added must constraints in af-group list
2021-02-11
    Removed presence statement from match node under eigrp container
2021-02-10
    Added labeled-unicast under best-external
2021-02-04
    Added sr-policy under nexthop & igp-metric
2021-02-03
    Added container option-b-asbr-only
2020-11-16
    Added srte-metric and validation under nexthop
2020-11-10
    Added mask-length under local-address-subnet as needed
2020-10-22
    Added rpki-dropped-only/rpki-tested-only under
  soft-reconfiguration/inbound. Updated must statements accordingly
  to define proper constraints with new nodes.
2020-09-30
    Added multipath under neighbor address-family
2020-08-12
    Added route-target container under retain.
  Added per-nexthop-received-label under mode.
  Added appropriate when statements under retain/mode containers.
  Removed per-prefix under vrf as it's not supported.
2020-08-05
    Added some must statements as needed
2020-07-30
    Added when statement to local-labeled-route under address-family
  hierarchy and removed one presence statement as needed";
    semver:module-version 3.0.0;
  }
  revision 2020-07-24 {
    description "Added internal under remove-private-as. Also added must statements
  under remove-private-as as appropriate.
2020-06-05
  Removed unused nodes from vrf address-family
  Added constraint to nodes under as-format
2020-05-17
  (1) Added enable/label-mode under as
  (2) Added srv6 under encapsulation-type
  (3) Added vpnv4/vpnv6/l2vpn nodes under advertise
  (4) Added segment-routing node under neighbors/neighbor/address-family
  (5) Changed integer range of multipath, message-log-buffer-size, purge-time
  (6) Added minimum-ipv6 node under nexthop/resolution/prefix-length
  (7) Changed sysdb path of log node and its chilren
  (8) Changed sysdb path of suppress node and its children
  (9) Added extended-nexthop-encoding node under suppress
  (10) Added update node under neighbor-group/address-families/address-family
  (11) Added retain-nbr-routes under graceful-restart

2020-04-14
  Added rd augment to vrf model
2020-03-13
  Added corresponding nodes for peer-set-id, adjacencies,
  peer-set and peer-node-sid";
    semver:module-version 2.0.0;
  }
  revision 2019-06-10 {
    description "Establish semantic version baseline.";
    semver:module-version 1.0.0;
  }
  revision 2019-03-30 {
    description "Initial version";
  }
  typedef Bgp-address-family {
    type enumeration {
      enum ipv4-unicast {
        value 0;
        description "IPv4 unicast";
      }
      enum ipv4-multicast {
        value 1;
        description "IPv4 multicast";
      }
      enum ipv4-labeled-unicast {
        value 2;
        description "IPv4 labeled-unicast";
      }
      enum ipv4-tunnel {
        value 3;
        description "IPv4 tunnel";
      }
      enum vpnv4-unicast {
        value 4;
        description "VPNv4 unicast";
      }
      enum ipv6-unicast {
        value 5;
        description "IPv6 unicast";
      }
      enum ipv6-multicast {
        value 6;
        description "IPv6 multicast";
      }
      enum ipv6-labeled-unicast {
        value 7;
        description "IPv6 labeled-unicast";
      }
      enum vpnv6-unicast {
        value 8;
        description "VPNv6 unicast";
      }
      enum ipv4-mdt {
        value 9;
        description "IPv4 MDT";
      }
      enum l2vpn-vpls-vpws {
        value 10;
        description "L2VPN VPLS-VPWS";
      }
      enum ipv4-rt-filter {
        value 11;
        description "IPv4 rt-filter";
      }
      enum ipv4-mvpn {
        value 12;
        description "IPv4 MVPN";
      }
      enum ipv6-mvpn {
        value 13;
        description "IPv6 MVPN";
      }
      enum l2vpn-evpn {
        value 14;
        description "L2VPN EVPN";
      }
      enum link-state-link-state {
        value 15;
        description "Link-state link-state";
      }
      enum vpnv4-multicast {
        value 16;
        description "VPNv4 Multicast";
      }
      enum vpnv6-multicast {
        value 17;
        description "VPNv6 Multicast";
      }
      enum ipv4-flowspec {
        value 18;
        description "IPv4 flowspec";
      }
      enum ipv6-flowspec {
        value 19;
        description "IPv6 flowspec";
      }
      enum vpnv4-flowspec {
        value 20;
        description "VPNv4 flowspec";
      }
      enum vpnv6-flowspec {
        value 21;
        description "VPNv6 flowspec";
      }
      enum l2vpn-mspw {
        value 22;
        description "L2VPN MSPW";
      }
      enum ipv4-sr-policy {
        value 23;
        description "IPv4 SRPolicy";
      }
      enum ipv6-sr-policy {
        value 24;
        description "IPv6 SRPolicy";
      }
      enum all-address-family {
        value 25;
        description "All Address Families";
      }
    }
    description "Bgp address family";
  }
  typedef Bgp-attribute-code {
    type union {
      type uint32 {
        range "0 | 4..14";
      }
      type uint32 {
        range "6..255";
      }
      type enumeration {
        enum AGGREGATOR {
          value 7;
          description "Aggregator attribute (7)";
        }
        enum AIGP {
          value 26;
          description "AIGP attribute (26)";
        }
        enum AS4-AGGREGATOR {
          value 18;
          description "AS4_AGGREGATOR attribute (18)";
        }
        enum AS4-PATH {
          value 17;
          description "AS4_PATH attribute (17)";
        }
        enum ATOMIC-AGGREGATE {
          value 6;
          description "Atomic aggrgate attribute (6)";
        }
        enum ATTRSET {
          value 128;
          description "ATTR_SET attribute (128)";
        }
        enum CLUSTER-LIST {
          value 10;
          description "Cluster List attribute (10)";
        }
        enum COMMUNITY {
          value 8;
          description "Community attribute (8)";
        }
        enum CONNECTOR {
          value 20;
          description "Connector attribute (20)";
        }
        enum EXTENDED-COMMUNITIES {
          value 16;
          description "Extended community attribute (16)";
        }
        enum LARGE-COMMUNITY {
          value 32;
          description "Large Community attribute (32)";
        }
        enum LOCAL-PREF {
          value 5;
          description "Local Preference attribute (5)";
        }
        enum LSATTR {
          value 29;
          description "Link-state attribute (29)";
        }
        enum MULTI-EXIT-DISC {
          value 4;
          description "MED attribute (4)";
        }
        enum ORIGINATOR-ID {
          value 9;
          description "Originator attribute (9)";
        }
        enum PMSI-TUNNEL {
          value 22;
          description "PMSI Tunnel attribute (22)";
        }
        enum PPMP {
          value 70;
          description "PPMP attribute (70)";
        }
        enum PREFIX-SID {
          value 40;
          description "Prefix-SID attribute (40)";
        }
        enum SSA {
          value 19;
          description "SAFI specific attribute (19)";
        }
        enum TUNNEL-ENCAP {
          value 23;
          description "Tunnel-Encapsulation attribute (23)";
        }
      }
    }
    description "Bgp attribute code";
  }
  typedef Bmp-mode {
    type enumeration {
      enum inbound-pre-policy {
        value 0;
        description "Pickup routes at inbound direction from peer
before application of route-policy";
      }
      enum inbound-post-policy {
        value 1;
        description "Pickup routes at inbound direction from peer
after application of route-policy";
      }
      enum local-rib {
        value 4;
        description "Pickup routes that have been selected by the
local BGP speaker's decision process";
      }
    }
    description "Bmp route monitor mode";
  }
  grouping VRF-COMMON {
    description "Grouping for vrf";
    container import {
      description "VRF import";
      container route-target {
        description "Specify import route target extended communities";
        container two-byte-as-rts {
          description "Two Byte AS Number Route Target";
          list two-byte-as-rt {
            key "as-number index stitching";
            description "Two Byte AS Number Route Target";
            leaf as-number {
              type uint32 {
                range "1..65535";
              }
              description "Two Byte AS Number";
            }
            leaf index {
              type uint32 {
                range "0..4294967295" {
                  description "ASN2:index (hex or decimal format)";
                }
              }
              description "ASN2:index (hex or decimal format)";
            }
            leaf stitching {
              type boolean;
              description "These are stitching RTs";
            }
          }
        }
      }
    }
    container export {
      description "VRF export";
      container route-target {
        description "Specify export route target extended communities";
        container two-byte-as-rts {
          description "Two Byte AS Number Route Target";
          list two-byte-as-rt {
            key "as-number index stitching";
            description "Two Byte AS Number Route Target";
            leaf as-number {
              type uint32 {
                range "1..65535";
              }
              description "Two Byte AS Number";
            }
            leaf index {
              type uint32 {
                range "0..4294967295" {
                  description "ASN2:index (hex or decimal format)";
                }
              }
              description "ASN2:index (hex or decimal format)";
            }
            leaf stitching {
              type boolean;
              description "These are stitching RTs";
            }
          }
        }
      }
    }
  }
  grouping VRF-RD {
    description "Grouping for vrf-rd";
    container rd {
      description "route distinguisher";
      container two-byte-as {
        must "not(../four-byte-as or ../ip-address)";
        presence "Indicates a two-byte-as node is configured.";
        description " two-byte-as route distinguisher";
        leaf as-number {
          type xr:Bgp-as-number;
          mandatory true;
          description "bgp as-number";
        }
        leaf index {
          type uint32 {
            range "0..4294967295" {
              description "ASN2:index (hex or decimal format)";
            }
          }
          mandatory true;
          description "ASN2:index (hex or decimal format)";
        }
      }
      container four-byte-as {
        must "not(../two-byte-as or ../ip-address)";
        presence "Indicates a four-byte-as node is configured.";
        description "four-byte-as route distinguisher";
        leaf as-number {
          type xr:Bgp-as-number;
          mandatory true;
          description "4-byte AS number";
        }
        leaf index {
          type uint32 {
            range "0..4294967295" {
              description "ASN2:index (hex or decimal format)";
            }
          }
          mandatory true;
          description "ASN2:index (hex or decimal format)";
        }
      }
      container ip-address {
        must "not(../two-byte-as or ../four-byte-as)";
        presence "Indicates a ip-address node is configured.";
        description "configure this node";
        leaf ipv4-address {
          type inet:ipv4-address-no-zone;
          mandatory true;
          description "configure this node";
        }
        leaf index {
          type uint32 {
            range "0..65535" {
              description "IPv4Address:index (hex or decimal format)";
            }
          }
          mandatory true;
          description "IPv4Address:index (hex or decimal format)";
        }
      }
    }
  }
  grouping AS-COMMON {
    description "Grouping for as-common";
    container rpki {
      description "Configure RPKI";
      container servers {
        description "Configure RPKI cache-servers";
        list server {
          key server-id;
          description "Configure RPKI cache-servers";
          leaf server-id {
            type xr:Cisco-ios-xr-string {
              length "1..1024" {
                description "Hostname or IP address";
              }
            }
            description "Configure RPKI cache-servers";
          }
          container bind-source {
            description "Specify a bind source for RPKI cache-server";
            container interface {
              description "Specify a source interface to bind the cache-server transport";
              leaf interface-name {
                type xr:Interface-name;
                description "Interface Name";
              }
            }
          }
          leaf preference {
            type uint32 {
              range "1..10" {
                description "(Deprecated from 7.4.1) RPKI cache-server preference value (lower is better)";
              }
            }
            description "(Deprecated from 7.4.1) Specify a preference value for the RPKI cache";
          }
          container refresh-time {
            description "Time between sending serial-queries for the RPKI cache-server";
            leaf refresh-time-value {
              type uint32 {
                range "15..3600" {
                  description "Refresh time (in seconds)";
                }
              }
              description "Refresh time (in seconds)";
            }
            container off {
              presence "Indicates a off node is configured.";
              description "Do not send serial-queries periodically";
            }
          }
          container response-time {
            description "Time to wait for a response from the RPKI cache-server";
            leaf response-time-value {
              type uint32 {
                range "15..3600" {
                  description "Response time (in seconds)";
                }
              }
              description "Response time (in seconds)";
            }
            container off {
              presence "Indicates a off node is configured.";
              description "Wait indefinitely for a response";
            }
          }
          leaf purge-time {
            type uint32 {
              range "30..65535" {
                description "Purge time (in seconds)";
              }
            }
            description "Purge time (in seconds)";
          }
          leaf username {
            type string {
              length "1..1024" {
                description "RPKI cache (SSH) username";
              }
            }
            description "Specify a (SSH) username for the RPKI cache-server";
          }
          leaf password {
            type string {
              length "1..1024" {
                description "RPKI cache (SSH) password";
              }
            }
            description "Specify a (SSH) password for the RPKI cache-server";
          }
          container transport {
            description "Specify a transport method for the RPKI cache-server";
            container tcp {
              description "Connect to the RPKI cache-server using TCP (unencrypted)";
              leaf port {
                type uint32 {
                  range "1..65535" {
                    description "Specify a port number for the RPKI cache-server transport";
                  }
                }
                must "not(../../ssh/port)";
                description "Specify a port number for the RPKI cache-server transport";
              }
            }
            container ssh {
              description "Connect to the RPKI cache-server using SSH";
              leaf port {
                type uint32 {
                  range "1..65535" {
                    description "Specify a port number for the RPKI cache-server transport";
                  }
                }
                must "not(../../tcp/port)";
                description "Specify a port number for the RPKI cache-server transport";
              }
            }
          }
          container shutdown {
            presence "Indicates a shutdown node is configured.";
            description "Shutdown the RPKI cache-server";
          }
        }
      }
      container routes {
        description "Configure an RPKI route";
        list route {
          key "address minimum-prefix-length maximum-prefix-length origin-as-number";
          description "Configure an RPKI route";
          leaf address {
            type inet:ip-address-no-zone;
            description "Configure an RPKI route";
          }
          leaf minimum-prefix-length {
            type union {
              type uint32 {
                range "0..32" {
                  description "Minimum prefix length for ipv4 address";
                }
              }
              type uint32 {
                range "0..128" {
                  description "Minimum prefix length for ipv6 address";
                }
              }
            }
            description "Minimum prefix length";
          }
          leaf maximum-prefix-length {
            type union {
              type uint32 {
                range "1..32" {
                  description "Maximum prefix length for ipv4 address";
                }
              }
              type uint32 {
                range "1..128" {
                  description "Maximum prefix length for ipv6 addess";
                }
              }
            }
            description "Maximum prefix length (Default 32/128 for IPv4/IPv6)";
          }
          leaf origin-as-number {
            type uint32 {
              range "1..4294967295" {
                description "Origin Autonomous System number (in asplain format)";
              }
            }
            description "Origin Autonomous System number";
          }
        }
      }
      leaf datafile {
        type xr:Cisco-ios-xr-string {
          length "1..800" {
            description "(Deprecated from 7.4.1) File name containing RPKI data entries";
          }
        }
        description "(Deprecated from 7.4.1) Configure an RPKI data file";
      }
    }
    container address-families {
      description "Enter Address Family command mode";
      list address-family {
        key af-name;
        description "Enter Address Family command mode";
        leaf af-name {
          type Bgp-address-family;
          description "Enter Address Family command mode";
        }
      }
    }
    container neighbors {
      description "Specify a neighbor router";
      list neighbor {
        key neighbor-address;
        description "Neighbor address";
        leaf neighbor-address {
          type inet:ip-address-no-zone;
          description "Neighbor address";
        }
        container use {
          description "Inherit configuration from a group";
          leaf session-group {
            type string {
              length "1..1024" {
                description "Session group name";
              }
            }
            description "Inherit address-family independent config from a session-group";
          }
          leaf neighbor-group {
            type string {
              length "1..1024" {
                description "Neighbor-group name";
              }
            }
            description "Inherit configuration from a neighbor-group";
          }
        }
        leaf description {
          type string {
            length "1..1024" {
              description "Up to 80 characters describing this neighbor";
            }
          }
          description "Neighbor specific description";
        }
      }
    }
    container neighbor-groups {
      description "Specify a Neighbor-group";
      list neighbor-group {
        key neighbor-group-name;
        description "Specify a Neighbor-group";
        leaf neighbor-group-name {
          type xr:Cisco-ios-xr-string {
            length "1..900" {
              description "Neighbor-group name";
            }
          }
          description "Specify a Neighbor-group";
        }
        container address-families {
          description "Enter Address Family command mode";
          list address-family {
            key af-name;
            description "Enter Address Family command mode";
            leaf af-name {
              type Bgp-address-family;
              description "Enter Address Family command mode";
            }
          }
        }
        leaf remote-as {
          type xr:Bgp-as-number;
          description "bgp as-number";
        }
        leaf description {
          type string {
            length "1..1024" {
              description "Up to 80 characters describing this neighbor";
            }
          }
          description "Neighbor specific description";
        }
        container password {
          must "encrypted or inheritance-disable";
          presence "Indicates a password node is configured.";
          description "Set a password";
          leaf encrypted {
            type xr:Proprietary-password;
            description "Specifies an ENCRYPTED password will follow";
          }
          container inheritance-disable {
            presence "Indicates a inheritance-disable node is configured.";
            description "Prevent password from being inherited from parent";
          }
        }
        leaf update-source {
          type xr:Interface-name;
          description "Source of routing updates";
        }
      }
    }
    container bgp {
      description "BGP commands";
      leaf router-id {
        type inet:ipv4-address-no-zone;
        description "Configure Router-id";
      }
    }
    container vrfs {
      description "Specify a vrf name";
      list vrf {
        key vrf-name;
        description "Specify a vrf name";
        leaf vrf-name {
          type xr:Cisco-ios-xr-string {
            length "1..32" {
              description "VRF name - maximum length 32 characters";
            }
          }
          description "Specify a vrf name";
        }
        container address-families {
          description "Enter Address Family command mode";
          list address-family {
            key af-name;
            description "Enter Address Family command mode";
            leaf af-name {
              type Bgp-address-family;
              description "Enter Address Family command mode";
            }
          }
        }
        container neighbors {
          description "Specify a neighbor router";
          list neighbor {
            key neighbor-address;
            description "Neighbor address";
            leaf neighbor-address {
              type inet:ip-address-no-zone;
              description "Neighbor address";
            }
            container address-families {
              description "Enter Address Family command mode";
              list address-family {
                key af-name;
                description "Enter Address Family command mode";
                leaf af-name {
                  type Bgp-address-family;
                  description "Enter Address Family command mode";
                }
                container route-policy {
                  description "Apply route policy to neighbor";
                  leaf in {
                    type xr:Route-policy-name;
                    description "Apply route policy to inbound routes";
                  }
                  leaf out {
                    type xr:Route-policy-name;
                    description "Apply route policy to outbound routes";
                  }
                  container retention {
                    description "Apply retention policy to inbound routes";
                    leaf route-policy-name {
                      type xr:Route-policy-name;
                      must "../retention-time";
                      description "Apply retention policy to inbound routes";
                    }
                    leaf retention-time {
                      type uint32 {
                        range "0..4294967295" {
                          description "Max time (seconds)";
                        }
                      }
                      must "../route-policy-name";
                      description "Retention-time for this neighbor";
                    }
                  }
                }
                container as-override {
                  presence "Indicates a as-override node is configured.";
                  description "Override matching AS-number while sending update";
                  container inheritance-disable {
                    presence "Indicates a inheritance-disable node is configured.";
                    description "Prevent as-override from being inherited from the parent";
                  }
                }
              }
            }
            leaf remote-as {
              type xr:Bgp-as-number;
              description "bgp as-number";
            }
            leaf description {
              type string {
                length "1..1024" {
                  description "Up to 80 characters describing this neighbor";
                }
              }
              description "Neighbor specific description";
            }
            container password {
              must "encrypted or inheritance-disable";
              presence "Indicates a password node is configured.";
              description "Set a password";
              leaf encrypted {
                type xr:Proprietary-password;
                description "Specifies an ENCRYPTED password will follow";
              }
              container inheritance-disable {
                presence "Indicates a inheritance-disable node is configured.";
                description "Prevent password from being inherited from parent";
              }
            }
          }
        }
        container rd {
          must "auto or two-byte-as or four-byte-as or ip-address";
          presence "Indicates a rd node is configured.";
          description "route distinguisher";
          container auto {
            must "not(../two-byte-as or ../four-byte-as or ../ip-address)";
            presence "Indicates a auto node is configured.";
            description "Automatic route distinguisher";
          }
          container two-byte-as {
            must "not(../auto or ../four-byte-as or ../ip-address)";
            presence "Indicates a two-byte-as node is configured.";
            description "two-byte-as route distinguisher";
            leaf as-number {
              type xr:Bgp-as-number;
              mandatory true;
              description "bgp as-number";
            }
            leaf index {
              type uint32 {
                range "0..4294967295" {
                  description "ASN2:index (hex or decimal format)";
                }
              }
              mandatory true;
              description "ASN2:index (hex or decimal format)";
            }
          }
          container four-byte-as {
            must "not(../auto or ../two-byte-as or ../ip-address)";
            presence "Indicates a four-byte-as node is configured.";
            description "four-byte-as route distinguisher";
            leaf as-number {
              type xr:Bgp-as-number;
              mandatory true;
              description "4-byte AS number";
            }
            leaf index {
              type uint32 {
                range "0..4294967295" {
                  description "ASN2:index (hex or decimal format)";
                }
              }
              mandatory true;
              description "ASN2:index (hex or decimal format)";
            }
          }
          container ip-address {
            must "not(../auto or ../two-byte-as or ../four-byte-as)";
            presence "Indicates a ip-address node is configured.";
            description "configure this node";
            leaf ipv4-address {
              type inet:ipv4-address-no-zone;
              mandatory true;
              description "configure this node";
            }
            leaf index {
              type uint32 {
                range "0..65535" {
                  description "IPv4Address:index (hex or decimal format)";
                }
              }
              mandatory true;
              description "IPv4Address:index (hex or decimal format)";
            }
          }
        }
      }
    }
  }
  augment "/a2:vrfs/a2:vrf/a2:address-family/a2:ipv4/a2:unicast" {
    description "This augment extends vrf ipv4 unicast nodes
configuration";
    uses VRF-COMMON;
  }
  augment "/a2:vrfs/a2:vrf/a2:address-family/a2:ipv6/a2:unicast" {
    description "This augment extends vrf ipv6 unicast nodes
configuration";
    uses VRF-COMMON;
  }
  augment "/a2:vrfs/a2:vrf" {
    description "This augment extends vrf nodes
configuration";
    uses VRF-RD;
  }
  container as-format {
    description "Autonomous system number format";
    container asdot {
      must "not(../asplain)";
      presence "Indicates a asdot node is configured.";
      description "AS Dot format";
    }
    container asplain {
      must "not(../asdot)";
      presence "Indicates a asplain node is configured.";
      description "AS Plain format";
    }
  }
  container bmp {
    description "BGP Monitoring Protocol commands";
    container servers {
      description "BMP server configuration";
      list server {
        key bmp-server-id;
        description "BMP server ID to configure";
        leaf bmp-server-id {
          type uint32 {
            range "1..8" {
              description "BMP server ID to configure";
            }
          }
          description "BMP server ID to configure";
        }
        container shutdown {
          presence "Indicates a shutdown node is configured.";
          description "Shutdown connection to BMP server";
        }
        container host {
          presence "Indicates a host node is configured.";
          description "Hostname of BMP Server";
          leaf host-name {
            type string {
              length "1..1024" {
                description "Name of the BMP server(accepts IP Address format too)";
              }
            }
            mandatory true;
            description "Hostname of BMP Server";
          }
          leaf port {
            type uint32 {
              range "1..65535" {
                description "Port Number of listening BMP server";
              }
            }
            description "BMP Server Listen Port";
          }
        }
        leaf initial-delay {
          type uint32 {
            range "1..3600" {
              description "Initial connect delay in sending BMP server updates";
            }
          }
          description "Initial connect delay in sending BMP server updates. Default=0";
        }
        leaf flapping-delay {
          type uint32 {
            range "60..3600" {
              description "Range in seconds for the connection delay after flap";
            }
          }
          description "delay in connecting to BMP Server after a flap had been detected. Default=300";
        }
        leaf max-buffer-size {
          type uint32 {
            range "1..4294967295" {
              description "Range in MegaBytes for the maximum buffer size of BMP message queue.";
            }
          }
          description "Set BMP message buffer size";
        }
        container initial-refresh {
          description "Initial refresh to generate BGP updates. DEfault=1";
          container delay {
            presence "Indicates a delay node is configured.";
            description "Initial delay before sending route refresh request";
            leaf initial-delay {
              type uint32 {
                range "1..3600" {
                  description "Delay in sending Refresh request to Peers (default : 30 secs)";
                }
              }
              mandatory true;
              description "Initial delay before sending route refresh request";
            }
            leaf spread {
              type uint32 {
                range "1..3600" {
                  description "Maximum additional random delay (in secs)";
                }
              }
              description "Maximum additional random delay for initial Refresh Request";
            }
          }
          container skip {
            presence "Indicates a skip node is configured.";
            description "Skip sending Refresh request to Peers";
          }
        }
        leaf stats-reporting-period {
          type uint32 {
            range "1..3600" {
              description "Stats-report-period in seconds";
            }
          }
          description "Stats reporting period for BMP server. Default=0";
        }
        leaf description {
          type string {
            length "1..1024" {
              description "Up to 250 characters describing this BMP server";
            }
          }
          description "BMP server specific description";
        }
        leaf dscp {
          type enumeration {
            enum default {
              value 0;
              description "Set packets with default dscp (000000)";
            }
            enum cs1 {
              value 8;
              description "Set packets with CS1(precedence 1) dscp (001000)";
            }
            enum af11 {
              value 10;
              description "Set packets with AF11 dscp (001010)";
            }
            enum af12 {
              value 12;
              description "Set packets with AF12 dscp (001100)";
            }
            enum af13 {
              value 14;
              description "Set packets with AF13 dscp (001110)";
            }
            enum cs2 {
              value 16;
              description "Set packets with CS2(precedence 2) dscp (010000)";
            }
            enum af21 {
              value 18;
              description "Set packets with AF21 dscp (010010)";
            }
            enum af22 {
              value 20;
              description "Set packets with AF22 dscp (010100)";
            }
            enum af23 {
              value 22;
              description "Set packets with AF23 dscp (010110)";
            }
            enum cs3 {
              value 24;
              description "Set packets with CS3(precedence 3) dscp (011000)";
            }
            enum af31 {
              value 26;
              description "Set packets with AF31 dscp (011010)";
            }
            enum af32 {
              value 28;
              description "Set packets with AF32 dscp (011100)";
            }
            enum af33 {
              value 30;
              description "Set packets with AF33 dscp (011110)";
            }
            enum cs4 {
              value 32;
              description "Set packets with CS4(precedence 4) dscp (100000)";
            }
            enum af41 {
              value 34;
              description "Set packets with AF41 dscp (100010)";
            }
            enum af42 {
              value 36;
              description "Set packets with AF42 dscp (100100)";
            }
            enum af43 {
              value 38;
              description "Set packets with AF43 dscp (100110)";
            }
            enum cs5 {
              value 40;
              description "Set packets with CS5(precedence 5) dscp (101000)";
            }
            enum ef {
              value 46;
              description "Set packets with EF dscp (101110)";
            }
            enum cs6 {
              value 48;
              description "Set packets with CS6(precedence 6) dscp (110000)";
            }
            enum cs7 {
              value 56;
              description "Set packets with CS7(precedence 7) dscp (111000)";
            }
          }
          description "Set IP DSCP (DiffServ CodePoint)";
        }
        leaf precedence {
          type enumeration {
            enum routine {
              value 0;
              description "Set packets with routine precedence (0)";
            }
            enum priority {
              value 1;
              description "Set packets with priority precedence (1)";
            }
            enum immediate {
              value 2;
              description "Set packets with immediate precedence (2)";
            }
            enum flash {
              value 3;
              description "Set packets with flash precedence (3)";
            }
            enum flash-override {
              value 4;
              description "Set packets with flash override precedence (4)";
            }
            enum critical {
              value 5;
              description "Set packets with critical precedence (5)";
            }
            enum internet {
              value 6;
              description "Set packets with internetwork control precedence (6)";
            }
            enum network {
              value 7;
              description "Set packets with network control precedence (7)";
            }
          }
          description "Set precedence";
        }
        leaf update-source {
          type xr:Interface-name;
          description "Source to reach BMP server";
        }
        leaf vrf {
          type string {
            length "1..1024" {
              description "VRF Name";
            }
          }
          description "VRF for the BMP server";
        }
        container tcp {
          description "Configure TCP related parameters";
          leaf keep-alive {
            type uint32 {
              range "0..7200" {
                description "Keep Alive interval in seconds";
              }
            }
            description "configure TCP keep alives to be exchanged between client and server";
          }
          leaf mss {
            type uint32 {
              range "68..10000" {
                description "TCP segment size in bytes";
              }
            }
            description "configure TCP maximum segment size";
          }
        }
      }
      container all {
        description "Common commands for all BMP servers";
        leaf max-buffer-size {
          type uint32 {
            range "1..4294967295" {
              description "Range in MegaBytes for the maximum buffer size of BMP message queue.";
            }
          }
          description "Maximum buffer limit upto which BMP messages will be queued to TCP sockets.
If total size of BMP messages queued up for BMP sockets exceeds this set limit,
messages will be dropped. The maximum buf-size is 20% and default buf-size is 15%
of the platform virtual memory max-limit (aka rlimit). Please run
show bgp process performance-statistics
to see the individual values. Unit is in MegaBytes.";
        }
        container route-monitoring {
          description "Enable Route Monitoring capability for the BMP servers.
BGP update messages will be regenerated with a table walk
";
          container bmp-modes {
            description "Enter BMP route monitoring command mode";
            list bmp-mode {
              key mode-name;
              description "Enter BMP route monitoring command mode";
              leaf mode-name {
                type Bmp-mode;
                description "Enter BMP route monitoring command mode";
              }
              leaf advertisement-interval {
                when "../mode-name = 'inbound-post-policy' or ../mode-name = 'local-rib'";
                type uint32 {
                  range "2..600" {
                    description "Time in seconds";
                  }
                }
                description "Minimum interval between updates sent to BMP servers";
              }
              leaf scan-time {
                when "../mode-name = 'inbound-post-policy'";
                type uint32 {
                  range "5..3600" {
                    description "Time in seconds";
                  }
                }
                description "Configure scanner interval";
              }
            }
          }
        }
      }
    }
  }
  container router {
    description "Enable a routing process";
    container bgp {
      description "BGP configuration subcommands";
      list as {
        key as-number;
        description "bgp as-number";
        leaf as-number {
          type xr:Bgp-as-number;
          description "bgp as-number";
        }
        uses AS-COMMON;
      }
    }
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-router-isis-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg";
  prefix "um-router-isis-cfg";
  import Cisco-IOS-XR-types {
    prefix "xr";
  }
  import ietf-inet-types {
    prefix "inet";
  }
  import tailf-common {
    prefix "tailf";
  }
  import cisco-semver {
    prefix "semver";
  }
  organization "Cisco Systems, Inc.";
  contact "Cisco Systems, Inc.
Customer Service

Postal: 170 West Tasman Drive
San Jose, CA 95134

Tel: +1 800 553-NETS

E-mail: cs-yang@cisco.com";
  description "This module contains a collection of YANG definitions
for Cisco IOS-XR router-isis package configuration.

This YANG module augments the
modules with configuration data.

Copyright (c) 2019-2023 by Cisco Systems, Inc.
All rights reserved.";
  revision 2023-08-22 {
    description "Add nsr-restart-time
2023-07-12
  Add flex-algo UCMP
2023-06-28
  Change the must clause from ../../srv6-locator-xxx to srv6-locator-xxx
2023-04-09
  Add maximum paths per route-policy for standard and flex algo
2023-04-03
  Add flex-algo MinimumBandwidth and MaximumDelay constraints
2023-03-13
  Add Uloop filtering suport
2023-02-10
  Modify must statement for SPF interval per-level
2022-11-18
  Add distribute link-state prefix filtering
2022-10-14
  Added new nodes for partition-detect
2022-10-04
  Added support for ISIS Prefix-SID UHP
2022-10-02
  Added hello-padding under router-isis
2022-10-01
  Add support for flex-algo reverse link affinities.
2022-07-25
  Added new node anycast-prefer-igp-cost to traffic-eng tunnel
2022-07-18
  Added new node php-disable to the existing connected-prefix-sid-map, strict-spf and flex-algo.
2022-07-11
  Added missing description statement to nodes
2022-05-12
  Added new node adv-unreachable with sub-node unreachable-component-tag and tag value to an existing ISIS address-family sub-mode summary-prefix command.Added new node prefix-unreachable under ISIS address-family sub-mode.
2022-05-05
  Added new node anomaly to the existing ISIS affinity flex-algo
2022-04-22
  Added support for maximum-paths under flex-algo,
Added container algorithm
2022-04-05
  Added support for te and delay
2022-03-03
  Added container metric & tag under segment-routing/srv6/locators,
Added container format,
Added container lsp-fast-flood
2022-01-19
  Added ietf support for spf-interval
2022-01-04
  Added support for unhidden CLI commands
2021-12-14
  Added authentication-check feature";
    semver:module-version 5.0.0;
  }
  revision 2021-09-23 {
    description "Merged container levels under disable|interval/periodic/address-family-topology,
 Merged container levels under disable|interval/periodic/address-family,
 Merged disable & interval-time into one leaf interval
2021-07-27
   Re-ordered maximum-wait, initial-wait and secondary-wait nodes under
 level container/spf-interval
2021-06-15
   Added when statement to container prefix-attributes";
    semver:module-version 4.0.0;
  }
  revision 2021-05-18 {
    description "Added features, 1. flex-algo srlg exclude
2. advertise application flex-algo link-attributes srlg
2021-04-22
    Added te-metric flex-algo feature
2021-03-02
    Re-ordered maximum-wait, initial-wait and secondary-wait nodes under
  level container
2021-02-11
    Re-ordered per-link, per-prefix nodes under interface fast-reroute container
2021-01-28
    Added cisco-support task yang nodes
2021-01-27
    Re-ordered nodes under lsp-gen-interval, min-lsp-arrivaltime container
2021-01-20
    Moved presence containers as leafs under snmp-server traps
2021-01-18
    Added presence statement and re-ordered few nodes under container max-metric
2021-01-11
    Add support to metric and preferred container under tunnel
2021-01-07
    Updated range value in leaf multiplier under fallback container
2021-01-06
    Added presence statement under link-state container
2020-12-09
    Removed cisco-support yang nodes
2020-12-01
    Added container anomaly under metric/fallback
2020-11-20
    Added metric type te
2020-11-19
    Fixed a must statement under absolute, added presence statement to text
2020-11-13
    Added container receive and attestation under list process.
2020-11-02
    Moved levels container under lsp-password out of it and renamed as
  lsp-password-levels.
2020-08-20
    Added level option under srv6/locator
2020-08-13
    Remove presence container and constraints on the match container
2020-08-10
    Updated the fallback topology
2020-07-21
    Slight changes to prefix-priority nodes
2020-07-17
    Added must statements and moved rib-update-delay up one node
2020-07-15
    Added down-flag-clear node under redistribute isis
2020-07-14
    Added mandatory node to bit-position under affinity-map";
    semver:module-version 3.0.0;
  }
  revision 2020-05-19 {
    description "Added nodes for new ISIS features
2020-05-07
  Added a container anycast and its child nodes
2020-04-14
  Updated the constraints in the nodes under stagger to be less strict
2020-03-09
  Updated lsp-password and summary-prefix trees with proper constaraint
  statements";
    semver:module-version 2.0.0;
  }
  revision 2019-06-10 {
    description "Establish semantic version baseline.";
    semver:module-version 1.0.0;
  }
  revision 2019-03-30 {
    description "Initial draft";
  }
  typedef Isis-af-name {
    type enumeration {
      enum ipv4 {
        value 0;
        description "IPv4";
      }
      enum ipv6 {
        value 1;
        description "IPv6";
      }
    }
    description "Address-family names";
  }
  typedef Isis-saf-name {
    type enumeration {
      enum unicast {
        value 0;
        description "unicast";
      }
      enum multicast {
        value 1;
        description "multicast";
      }
    }
    description "Sub address-family names";
  }
  typedef Isis-saf-multicast {
    type enumeration {
      enum multicast {
        value 1;
        description "multicast";
      }
    }
    description "Sub address-family names (only multicast)";
  }
  container router {
    description "Enable a routing process";
    container isis {
      description "ISO IS-IS";
      container processes {
        description "Process ID";
        list process {
          key process-id;
          description "Process ID";
          leaf process-id {
            type string {
              length "1..36" {
                description "Process ID";
              }
            }
            description "Process ID";
          }
          leaf is-type {
            type enumeration {
              enum level-1 {
                value 1;
                description "Act as a station router only";
              }
              enum level-2-only {
                value 2;
                description "Act as an area router only";
              }
              enum level-1-2 {
                value 3;
                description "Act as both a station router and an area router";
              }
            }
            description "Area type (level)";
          }
          container nets {
            description "A Network Entity Title (NET) for this process";
            list net {
              key net-id;
              description "A Network Entity Title (NET) for this process";
              leaf net-id {
                type string {
                  length "1..1024" {
                    description "NET (XX.XXXX. ... .XXXX.XX)";
                  }
                }
                description "A Network Entity Title (NET) for this process";
              }
            }
          }
          container address-families {
            description "Enter the IS-IS address-family configuration submode";
            list address-family {
              key "af-name saf-name";
              description "IS-IS address family";
              leaf af-name {
                type Isis-af-name;
                description "Address family name";
              }
              leaf saf-name {
                type Isis-saf-name;
                description "Sub address family name";
              }
              container segment-routing {
                description "Enable Segment Routing";
                container mpls {
                  description "Enable Segment Routing using MPLS encapsulation";
                  leaf sr-prefer {
                    when "../../../saf-name = 'unicast'";
                    type boolean;
                    description "Prefer segment routing labels over LDP labels";
                  }
                }
              }
              container metric-style {
                description "Use old-style (ISO 10589) or new-style packet formats";
                container narrow {
                  must "not(../wide or ../transition)";
                  presence "Indicates a narrow node is configured.";
                  description "Use old style of TLVs with narrow metric";
                }
                container wide {
                  must "not(../narrow or ../transition)";
                  presence "Indicates a wide node is configured.";
                  description "Use new style of TLVs to carry wider metric";
                }
                container transition {
                  must "not(../narrow or ../wide)";
                  presence "Indicates a transition node is configured.";
                  description "Send and accept both styles of TLVs during transition";
                }
                container levels {
                  description "Set metric-style for one level only";
                  list level {
                    key level-id;
                    description "Set metric-style for one level only";
                    leaf level-id {
                      type uint32 {
                        range "1..2" {
                          description "Level";
                        }
                      }
                      description "Set metric-style for one level only";
                    }
                    container narrow {
                      must "not(../wide or ../transition)";
                      presence "Indicates a narrow node is configured.";
                      description "Use old style of TLVs with narrow metric";
                    }
                    container wide {
                      must "not(../narrow or ../transition)";
                      presence "Indicates a wide node is configured.";
                      description "Use new style of TLVs to carry wider metric";
                    }
                    container transition {
                      must "not(../narrow or ../wide)";
                      presence "Indicates a transition node is configured.";
                      description "Send and accept both styles of TLVs during transition";
                    }
                  }
                }
              }
            }
          }
          container interfaces {
            description "Enter the IS-IS interface configuration submode";
            list interface {
              key interface-name;
              description "Enter the IS-IS interface configuration submode";
              leaf interface-name {
                type xr:Interface-name;
                description "Enter the IS-IS interface configuration submode";
              }
              leaf circuit-type {
                type enumeration {
                  enum level-1 {
                    value 1;
                    description "Form level-1 adjacencies only";
                  }
                  enum level-2-only {
                    value 2;
                    description "Form level-2 adjacencies only";
                  }
                  enum level-1-2 {
                    value 3;
                    description "Form level-1 and level-2 adjacencies";
                  }
                }
                description "Configure circuit type for interface";
              }
              container point-to-point {
                presence "Indicates a point-to-point node is configured.";
                description "Treat active LAN interface as point-to-point";
              }
              container bfd {
                description "Configure BFD parameters";
                container fast-detect {
                  description "Enable Fast detection";
                  container ipv4 {
                    presence "Indicates a ipv4 node is configured.";
                    description "Address Family";
                  }
                  container ipv6 {
                    presence "Indicates a ipv6 node is configured.";
                    description "Address Family";
                  }
                }
                leaf minimum-interval {
                  type uint32 {
                    range "3..30000" {
                      description "hello interval in milli-seconds";
                    }
                  }
                  description "Hello interval";
                }
                leaf multiplier {
                  type uint32 {
                    range "2..50" {
                      description "Detect multiplier";
                    }
                  }
                  description "Detect multiplier";
                }
              }
              container passive {
                must "not(../suppressed or ../shutdown)";
                presence "Indicates a passive node is configured.";
                description "Do not establish adjacencies over this interface";
              }
              container address-families {
                description "Enter the IS-IS interface address-family configuration submode";
                list address-family {
                  key "af-name saf-name";
                  description "Address family";
                  leaf af-name {
                    type Isis-af-name;
                    description "Address family name";
                  }
                  leaf saf-name {
                    type Isis-saf-name;
                    description "Sub address family name";
                  }
                  container metric {
                    description "Configure the metric for interface";
                    leaf default-metric {
                      type uint32 {
                        range "1..16777214" {
                          description "Default metric: <1-63> for narrow, <1-16777214> for wide";
                        }
                      }
                      must "not(../maximum)";
                      description "Default metric";
                    }
                    container maximum {
                      must "not(../default-metric)";
                      presence "Indicates a maximum node is configured.";
                      description "Maximum wide metric. All routers will exclude this link from their SPF";
                    }
                    container levels {
                      description "Set metric for one level only";
                      list level {
                        key level-id;
                        description "Set metric for one level only";
                        leaf level-id {
                          type uint32 {
                            range "1..2" {
                              description "Set metric at this level only";
                            }
                          }
                          description "Set metric for one level only";
                        }
                        leaf default-metric {
                          type uint32 {
                            range "1..16777214" {
                              description "Default metric: <1-63> for narrow, <1-16777214> for wide";
                            }
                          }
                          must "not(../maximum)";
                          description "Default metric";
                        }
                        container maximum {
                          must "not(../default-metric)";
                          presence "Indicates a maximum node is configured.";
                          description "Maximum wide metric. All routers will exclude this link from their SPF";
                        }
                      }
                    }
                  }
                  container prefix-sid {
                    when "../saf-name = 'unicast' and ../../../interface-name[starts-with(text(),'Loopback')]" {
                      tailf:dependency "../../../interface-name";
                    }
                    description "Specify the Prefix Segment ID";
                    container sid {
                      must "index or absolute";
                      presence "Indicates a sid node is configured.";
                      description "Specify the Prefix Segment ID";
                      container index {
                        must "not(../absolute)";
                        presence "Indicates a index node is configured.";
                        description "Specify the index of Prefix Segement ID";
                        leaf sid-index {
                          type uint32 {
                            range "0..1048575" {
                              description "The Prefix Segment ID index";
                            }
                          }
                          mandatory true;
                          description "Specify the index of Prefix Segement ID";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-vrf-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg";
  prefix "um-vrf-cfg";
  import cisco-semver {
    prefix "semver";
  }
  import Cisco-IOS-XR-types {
    prefix "xr";
  }
  organization "Cisco Systems, Inc.";
  contact "Cisco Systems, Inc.
Customer Service

Postal: 170 West Tasman Drive
San Jose, CA 95134

Tel: +1 800 553-NETS

E-mail: cs-yang@cisco.com";
  description "This module contains a collection of YANG definitions
for Cisco IOS-XR vrf package configuration.

This YANG module augments the
modules with configuration data.

Copyright (c) 2019-2022 by Cisco Systems, Inc.
All rights reserved.";
  revision 2022-07-11 {
    description "Added missing description statement to nodes";
    semver:module-version 4.2.0;
  }
  revision 2021-07-13 {
    description "Removed imported native model Cisco-IOS-XR-config-mda-cfg and imported
 model Cisco-IOS-XR-um-location-cfg";
    semver:module-version 4.1.0;
  }
  revision 2021-01-11 {
    description "Added new leaf description under srlg->names->name
2020-07-23
    Removed unused tailf import";
    semver:module-version 4.0.0;
  }
  revision 2019-10-31 {
    description "Added mandatory nodes";
    semver:module-version 3.0.0;
  }
  revision 2019-10-10 {
    description "Moved interface augments into Cisco-IOS-XR-um-if-vrf-cfg
2019-09-23
  Moved 'selective-vrf-download-locations' and its child nodes to module 'Cisco-IOS-XR-config-mda-cfg' to resolve an issue with duplicated list entries being created between the two models.";
    semver:module-version 2.0.0;
  }
  revision 2019-06-10 {
    description "Establish semantic version baseline.";
    semver:module-version 1.0.0;
  }
  revision 2019-03-29 {
    description "Initial version";
  }
  feature svd-location {
    description "selective-vrf-download location feature";
  }
  grouping GROUP-SVD-LOCATION {
    description "Grouping for svd-location";
    container selective-vrf-download {
      if-feature "svd-location";
      must "role or vrf-groups/vrf-group";
      presence "Indicates a selective-vrf-download node is configured.";
      description "Location for Selective VRF Download configuration";
      container role {
        presence "Indicates a role node is configured.";
        description "Card Role configuration";
        container address-family {
          description "AFI/SAFI configuration";
          container ipv4 {
            description "IPv4 AFI SVD configuration";
            leaf unicast {
              type enumeration {
                enum standard {
                  value 1;
                  description "Standard Role";
                }
                enum core-facing {
                  value 2;
                  description "Core Facing Role";
                }
                enum customer-facing {
                  value 3;
                  description "Customer Facing Role";
                }
                enum not-interested {
                  value 4;
                  description "Not-Interested";
                }
                enum vpnonly-customer-facing {
                  value 5;
                  description "L3VPN Only Cutomer Facing Role";
                }
              }
              mandatory true;
              description "IPv4 Unicast AFI-SAFI SVD configuration";
            }
          }
          container ipv6 {
            description "IPv6 AFI SVD configuration";
            leaf unicast {
              type enumeration {
                enum standard {
                  value 1;
                  description "Standard Role";
                }
                enum core-facing {
                  value 2;
                  description "Core Facing Role";
                }
                enum customer-facing {
                  value 3;
                  description "Customer Facing Role";
                }
                enum not-interested {
                  value 4;
                  description "Not-Interested";
                }
                enum vpnonly-customer-facing {
                  value 5;
                  description "L3VPN Only Cutomer Facing Role";
                }
              }
              mandatory true;
              description "IPv6 Unicast AFI-SAFI SVD configuration";
            }
          }
        }
      }
      container vrf-groups {
        description "Enable this VRF-GROUP on this location";
        list vrf-group {
          key vrf-group-name;
          description "Enable this VRF-GROUP on this location";
          leaf vrf-group-name {
            type xr:Cisco-ios-xr-string {
              length "1..32" {
                description "Group name";
              }
            }
            description "Enable this VRF-GROUP on this location";
          }
        }
      }
    }
  }
  container address-family {
    description "AFI/SAFI configuration";
    container ipv4 {
      description "IPv4 address family";
      container unicast {
        presence "Indicates a unicast node is configured.";
        description "Unicast topology";
      }
      container multicast {
        description "Multicast topology";
        container topologies {
          description "Specify a non-default topology";
          list topology {
            key topology-name;
            description "Specify a non-default topology";
            leaf topology-name {
              type xr:Cisco-ios-xr-string {
                length "1..32" {
                  description "Topology name";
                }
              }
              description "Specify a non-default topology";
            }
          }
        }
      }
    }
    container ipv6 {
      description "IPv6 address family";
      container unicast {
        presence "Indicates a unicast node is configured.";
        description "Unicast topology";
      }
      container multicast {
        description "Multicast topology";
        container topologies {
          description "Specify a non-default topology";
          list topology {
            key topology-name;
            description "Specify a non-default topology";
            leaf topology-name {
              type string {
                length "1..32" {
                  description "Topology name";
                }
              }
              description "Specify a non-default topology";
            }
          }
        }
      }
    }
  }
  container vrfs {
    description "VRF configuration commands";
    list vrf {
      key vrf-name;
      description "VRF name";
      leaf vrf-name {
        type xr:Cisco-ios-xr-string {
          length "1..32" {
            description "VRF name";
          }
        }
        description "VRF name";
      }
      container address-family {
        description "AFI/SAFI configuration";
        container ipv4 {
          description "IPv4 address family";
          container unicast {
            presence "Indicates a unicast node is configured.";
            description "Unicast sub address family";
          }
          container multicast {
            presence "Indicates a multicast node is configured.";
            description "Multicast topology";
          }
          container flowspec {
            presence "Indicates a flowspec node is configured.";
            description "Flowspec sub address family";
          }
        }
        container ipv6 {
          description "IPv6 address family";
          container unicast {
            presence "Indicates a unicast node is configured.";
            description "Unicast sub address family";
          }
          container multicast {
            presence "Indicates a multicast node is configured.";
            description "Multicast topology";
          }
          container flowspec {
            presence "Indicates a flowspec node is configured.";
            description "Flowspec sub address family";
          }
        }
      }
      container mode {
        description "VRF mode which determines the max prefix scale";
        container big {
          presence "Indicates a big node is configured.";
          description "big to set max prefix scale more than 64 K";
        }
      }
      container vpn {
        description "VPN ID for the VRF";
        leaf id {
          type xr:Vpn-id;
          description "VPN ID, (OUI:VPN-Index) format(hex), 4 bytes VPN_Index Part";
        }
      }
      leaf description {
        type string {
          length "1..1024" {
            description "Description for this VRF";
          }
        }
        description "A description for the VRF";
      }
      container remote-route-filtering {
        description "Enable/Disable remote route filtering per VRF";
        container disable {
          presence "Indicates a disable node is configured.";
          description "Disable remote route filtering per VRF";
        }
      }
      leaf fallback-vrf {
        type xr:Cisco-ios-xr-string {
          length "1..32" {
            description "Fallback VRF name";
          }
        }
        description "Fallback vrf for this VRF";
      }
    }
  }
  container selective-vrf-download {
    description "Selective VRF Download config commands";
    container disable {
      presence "Indicates a disable node is configured.";
      description "Disable Selective VRF Download";
    }
  }
  container srlg {
    presence "Indicates a srlg node is configured.";
    description "SRLG configuration commands";
    container names {
      description "SRLG name to value mapping";
      list name {
        must "value or description";
        key srlg-name;
        description "SRLG name to value mapping";
        leaf srlg-name {
          type xr:Cisco-ios-xr-string {
            length "1..64" {
              description "SRLG Name";
            }
          }
          description "SRLG name to value mapping";
        }
        leaf value {
          type uint32 {
            range "0..4294967295" {
              description "Network SRLG value";
            }
          }
          description "Configure SRLG network value";
        }
        leaf description {
          type string {
            length "1..800" {
              description "SRLG description";
            }
          }
          description "Configure SRLG network value";
        }
      }
    }
    container interfaces {
      description "SRLG interface configuration submode";
      list interface {
        key interface-name;
        description "SRLG interface configuration submode";
        leaf interface-name {
          type xr:Interface-name;
          description "SRLG interface configuration submode";
        }
        container include-optical {
          presence "Indicates a include-optical node is configured.";
          description "Include srlg values from optical layer";
          leaf priority {
            type enumeration {
              enum critical {
                value 0;
                description "Critical priority";
              }
              enum high {
                value 1;
                description "High priority";
              }
              enum low {
                value 3;
                description "Low priority";
              }
              enum verylow {
                value 4;
                description "Very low priority";
              }
            }
            description "Set prority for the value";
          }
        }
        container indexes {
          description "Index number for this value";
          list index {
            key index-number;
            description "Index number for this value";
            leaf index-number {
              type uint32 {
                range "1..65535" {
                  description "Index number for this value";
                }
              }
              description "Index number for this value";
            }
            leaf value {
              type uint32 {
                range "0..4294967295" {
                  description "Network SRLG value";
                }
              }
              mandatory true;
              description "Configure SRLG network value";
            }
            leaf priority {
              type enumeration {
                enum critical {
                  value 0;
                  description "Critical priority";
                }
                enum high {
                  value 1;
                  description "High priority";
                }
                enum default {
                  value 2;
                  description "Default priority";
                }
                enum low {
                  value 3;
                  description "Low priority";
                }
                enum verylow {
                  value 4;
                  description "Very low priority";
                }
              }
              mandatory true;
              description "Set prority for the value";
            }
          }
        }
        container names {
          description "Bind this SRLG name to the interface";
          list name {
            key srlg-name;
            description "Bind this SRLG name to the interface";
            leaf srlg-name {
              type string {
                length "1..64" {
                  description "SRLG Name";
                }
              }
              description "Bind this SRLG name to the interface";
            }
          }
        }
        container groups {
          presence "Indicates a groups node is configured.";
          description "Configure group srlg values";
          list group {
            key index-number;
            description "Group index number for this entry";
            leaf index-number {
              type uint32 {
                range "1" {
                  description "Group index number for this entry";
                }
              }
              description "Group index number for this entry";
            }
            leaf group-name {
              type string {
                length "1..32" {
                  description "Group name";
                }
              }
              mandatory true;
              description "Group name";
            }
          }
        }
      }
    }
    container groups {
      description "SRLG group configuration submode";
      list group {
        key group-name;
        description "SRLG group configuration submode";
        leaf group-name {
          type xr:Cisco-ios-xr-string {
            length "1..32" {
              description "Group name";
            }
          }
          description "SRLG group configuration submode";
        }
        container indexes {
          description "Index number for this value";
          list index {
            key index-number;
            description "Index number for this value";
            leaf index-number {
              type uint32 {
                range "1..65535" {
                  description "Index number for this value";
                }
              }
              description "Index number for this value";
            }
            leaf value {
              type uint32 {
                range "0..4294967295" {
                  description "Network SRLG value";
                }
              }
              mandatory true;
              description "Configure SRLG network value";
            }
            leaf priority {
              type enumeration {
                enum critical {
                  value 0;
                  description "Critical priority";
                }
                enum high {
                  value 1;
                  description "High priority";
                }
                enum default {
                  value 2;
                  description "Default priority";
                }
                enum low {
                  value 3;
                  description "Low priority";
                }
                enum verylow {
                  value 4;
                  description "Very low priority";
                }
              }
              mandatory true;
              description "Set prority for the value";
            }
          }
        }
      }
    }
    container inherit-locations {
      description "SRLG inherit-location configuration submode";
      list inherit-location {
        key location-name;
        description "SRLG inherit-location configuration submode";
        leaf location-name {
          type xr:Pq-node-id;
          description "The inherit location name";
        }
        container indexes {
          description "Index number for this value";
          list index {
            key index-number;
            description "Index number for this value";
            leaf index-number {
              type uint32 {
                range "1..65535" {
                  description "Index number for this value";
                }
              }
              description "Index number for this value";
            }
            leaf value {
              type uint32 {
                range "0..4294967295" {
                  description "Network SRLG value";
                }
              }
              mandatory true;
              description "Configure SRLG network value";
            }
            leaf priority {
              type enumeration {
                enum critical {
                  value 0;
                  description "Critical priority";
                }
                enum high {
                  value 1;
                  description "High priority";
                }
                enum default {
                  value 2;
                  description "Default priority";
                }
                enum low {
                  value 3;
                  description "Low priority";
                }
                enum verylow {
                  value 4;
                  description "Very low priority";
                }
              }
              mandatory true;
              description "Set prority for the value";
            }
          }
        }
      }
    }
  }
  container vrf-groups {
    description "VRFGROUP configuration commands";
    list vrf-group {
      key group-name;
      description "Group name";
      leaf group-name {
        type xr:Cisco-ios-xr-string {
          length "1..32" {
            description "Group name";
          }
        }
        description "Group name";
      }
      container vrfs {
        description "Enable the vrf on this vrf-group";
        list vrf {
          key vrf-name;
          description "VRF name";
          leaf vrf-name {
            type xr:Cisco-ios-xr-string {
              length "1..32" {
                description "VRF name";
              }
            }
            description "VRF name";
          }
        }
      }
    }
  }
}
""")
    res.append(r"""module cisco-semver {
    namespace "http://cisco.com/ns/yang/cisco-semver";

    prefix cisco-semver;

    organization
        "Cisco Systems
     170 West Tasman Drive
     San Jose, CA 95134-1706
     USA";

    contact
        "Mailing list: <cs-yang@cisco.com>";

    description
        "This YANG module defines semantic version for Cisco defined YANG models. 
     Copyright (c) 2019 by Cisco Systems, Inc.
     All rights reserved.";

    revision 2019-03-13 {
        description
            "Initial Version.";

        reference "draft-verdt-netmod-yang-solutions-00"; 
    }

    extension module-version {
        argument "semver";
        description
            "The version number for the module. This is
      expressed as a semantic version number of the form:
      major.minor.patch(x)  
      where:
        * major corresponds to the major version. 
        * minor corresponds to a minor version. 
        * patch corresponds to a patch version. It is updated only for 
          'editorial' changes that do not change the API semantics in 
          any way. In addition to 'editorial' changes that do not 
          change the YANG module semantics, the patch field can
          also be used in a limited way to indicate major and minor 
          version changes as well. The patch version may be incremented for
          a major or minor change if that change is happening on a 
          non-HEAD or non-latest branch. If the patch field is incremented 
          for a minor version change then it is appended with the 
          suffix '(m)', if the patch field is incremented for a major 
          version change then it is appended with the suffix '(M)', 
          replacing '(m)', if present.

      This version number should be specified as a child of revision 
      statement to indicate that a specific revision had a specific 
      semantic version number. Where several modules are used to build 
      up a single block of functionality, the same module version is 
      specified across each file that makes up the module.

      Following a release of major version 1, all modules will
      update 'major.minor.patch' version number as follows:

      1.  if one or more non-backwards-compatible change is made then
          either the major version number MUST be updated (resetting the
          minor and patch version numbers to 0) or only the patch version
          number MUST be updated and appended with '(M)', replacing '(m)'
          if present.
   
      2.  if one or more backwards-compatible change is made then either
          the minor version number MUST be updated (resetting the patch
          version numbers to 0) or only the patch version number MUST be
          updated and appended with '(m)' unless the previous patch version
          number already had '(M)' appended, in which case the '(M)' suffix
          is retained for the new patch version.
   
      3.  if one or more editorial change is made then the patch version
          number MUST be updated. If the previous patch version number
          already had either an '(m') or '(M)' suffix then it is retained
          for the new patch version regardless of whether the subsequent
          changes are backwards-compatible, non-backwards-compatible, 
          or editorial changes. 

      When a field in the version number is incremented, all following
      fields are reset back to 0.  Major version number 0 indicates that
      the module is not yet stable and allows non-backwards-compatible
      changes without requiring the major version number to be incremented
   
      Where possible, the version number should be updated using the
      standard semantic versioning rules, relying on the '(m)' and '(M)'
      suffixes only used where strictly necessary.";
    }
}
""")
    res.append(r"""module ietf-inet-types {

  namespace "urn:ietf:params:xml:ns:yang:ietf-inet-types";
  prefix "inet";

  organization
   "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
   "WG Web:   <http://tools.ietf.org/wg/netmod/>
    WG List:  <mailto:netmod@ietf.org>

    WG Chair: David Kessens
              <mailto:david.kessens@nsn.com>

    WG Chair: Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>

    Editor:   Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>";

  description
   "This module contains a collection of generally useful derived
    YANG data types for Internet addresses and related things.

    Copyright (c) 2013 IETF Trust and the persons identified as
    authors of the code.  All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, is permitted pursuant to, and subject
    to the license terms contained in, the Simplified BSD License
    set forth in Section 4.c of the IETF Trust's Legal Provisions
    Relating to IETF Documents
    (http://trustee.ietf.org/license-info).

    This version of this YANG module is part of RFC 6991; see
    the RFC itself for full legal notices.";

  revision 2013-07-15 {
    description
     "This revision adds the following new data types:
      - ip-address-no-zone
      - ipv4-address-no-zone
      - ipv6-address-no-zone";
    reference
     "RFC 6991: Common YANG Data Types";
  }

  revision 2010-09-24 {
    description
     "Initial revision.";
    reference
     "RFC 6021: Common YANG Data Types";
  }

  /*** collection of types related to protocol fields ***/

  typedef ip-version {
    type enumeration {
      enum unknown {
        value "0";
        description
         "An unknown or unspecified version of the Internet
          protocol.";
      }
      enum ipv4 {
        value "1";
        description
         "The IPv4 protocol as defined in RFC 791.";
      }
      enum ipv6 {
        value "2";
        description
         "The IPv6 protocol as defined in RFC 2460.";
      }
    }
    description
     "This value represents the version of the IP protocol.

      In the value set and its semantics, this type is equivalent
      to the InetVersion textual convention of the SMIv2.";
    reference
     "RFC  791: Internet Protocol
      RFC 2460: Internet Protocol, Version 6 (IPv6) Specification
      RFC 4001: Textual Conventions for Internet Network Addresses";
  }

  typedef dscp {
    type uint8 {
      range "0..63";
    }
    description
     "The dscp type represents a Differentiated Services Code Point
      that may be used for marking packets in a traffic stream.
      In the value set and its semantics, this type is equivalent
      to the Dscp textual convention of the SMIv2.";
    reference
     "RFC 3289: Management Information Base for the Differentiated
                Services Architecture
      RFC 2474: Definition of the Differentiated Services Field
                (DS Field) in the IPv4 and IPv6 Headers
      RFC 2780: IANA Allocation Guidelines For Values In
                the Internet Protocol and Related Headers";
  }

  typedef ipv6-flow-label {
    type uint32 {
      range "0..1048575";
    }
    description
     "The ipv6-flow-label type represents the flow identifier or Flow
      Label in an IPv6 packet header that may be used to
      discriminate traffic flows.

      In the value set and its semantics, this type is equivalent
      to the IPv6FlowLabel textual convention of the SMIv2.";
    reference
     "RFC 3595: Textual Conventions for IPv6 Flow Label
      RFC 2460: Internet Protocol, Version 6 (IPv6) Specification";
  }

  typedef port-number {
    type uint16 {
      range "0..65535";
    }
    description
     "The port-number type represents a 16-bit port number of an
      Internet transport-layer protocol such as UDP, TCP, DCCP, or
      SCTP.  Port numbers are assigned by IANA.  A current list of
      all assignments is available from <http://www.iana.org/>.

      Note that the port number value zero is reserved by IANA.  In
      situations where the value zero does not make sense, it can
      be excluded by subtyping the port-number type.
      In the value set and its semantics, this type is equivalent
      to the InetPortNumber textual convention of the SMIv2.";
    reference
     "RFC  768: User Datagram Protocol
      RFC  793: Transmission Control Protocol
      RFC 4960: Stream Control Transmission Protocol
      RFC 4340: Datagram Congestion Control Protocol (DCCP)
      RFC 4001: Textual Conventions for Internet Network Addresses";
  }

  /*** collection of types related to autonomous systems ***/

  typedef as-number {
    type uint32;
    description
     "The as-number type represents autonomous system numbers
      which identify an Autonomous System (AS).  An AS is a set
      of routers under a single technical administration, using
      an interior gateway protocol and common metrics to route
      packets within the AS, and using an exterior gateway
      protocol to route packets to other ASes.  IANA maintains
      the AS number space and has delegated large parts to the
      regional registries.

      Autonomous system numbers were originally limited to 16
      bits.  BGP extensions have enlarged the autonomous system
      number space to 32 bits.  This type therefore uses an uint32
      base type without a range restriction in order to support
      a larger autonomous system number space.

      In the value set and its semantics, this type is equivalent
      to the InetAutonomousSystemNumber textual convention of
      the SMIv2.";
    reference
     "RFC 1930: Guidelines for creation, selection, and registration
                of an Autonomous System (AS)
      RFC 4271: A Border Gateway Protocol 4 (BGP-4)
      RFC 4001: Textual Conventions for Internet Network Addresses
      RFC 6793: BGP Support for Four-Octet Autonomous System (AS)
                Number Space";
  }

  /*** collection of types related to IP addresses and hostnames ***/

  typedef ip-address {
    type union {
      type inet:ipv4-address;
      type inet:ipv6-address;
    }
    description
     "The ip-address type represents an IP address and is IP
      version neutral.  The format of the textual representation
      implies the IP version.  This type supports scoped addresses
      by allowing zone identifiers in the address format.";
    reference
     "RFC 4007: IPv6 Scoped Address Architecture";
  }

  typedef ipv4-address {
    type string {
      pattern
        '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
      +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
      + '(%[\p{N}\p{L}]+)?';
    }
    description
      "The ipv4-address type represents an IPv4 address in
       dotted-quad notation.  The IPv4 address may include a zone
       index, separated by a % sign.

       The zone index is used to disambiguate identical address
       values.  For link-local addresses, the zone index will
       typically be the interface index number or the name of an
       interface.  If the zone index is not present, the default
       zone of the device will be used.

       The canonical format for the zone index is the numerical
       format";
  }

  typedef ipv6-address {
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
            + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
            + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
            + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
            + '(%[\p{N}\p{L}]+)?';
      pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
            + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
            + '(%.+)?';
    }
    description
     "The ipv6-address type represents an IPv6 address in full,
      mixed, shortened, and shortened-mixed notation.  The IPv6
      address may include a zone index, separated by a % sign.

      The zone index is used to disambiguate identical address
      values.  For link-local addresses, the zone index will
      typically be the interface index number or the name of an
      interface.  If the zone index is not present, the default
      zone of the device will be used.

      The canonical format of IPv6 addresses uses the textual
      representation defined in Section 4 of RFC 5952.  The
      canonical format for the zone index is the numerical
      format as described in Section 11.2 of RFC 4007.";
    reference
     "RFC 4291: IP Version 6 Addressing Architecture
      RFC 4007: IPv6 Scoped Address Architecture
      RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
  }

  typedef ip-address-no-zone {
    type union {
      type inet:ipv4-address-no-zone;
      type inet:ipv6-address-no-zone;
    }
    description
     "The ip-address-no-zone type represents an IP address and is
      IP version neutral.  The format of the textual representation
      implies the IP version.  This type does not support scoped
      addresses since it does not allow zone identifiers in the
      address format.";
    reference
     "RFC 4007: IPv6 Scoped Address Architecture";
  }

  typedef ipv4-address-no-zone {
    type inet:ipv4-address {
      pattern '[0-9\.]*';
    }
    description
      "An IPv4 address without a zone index.  This type, derived from
       ipv4-address, may be used in situations where the zone is
       known from the context and hence no zone index is needed.";
  }

  typedef ipv6-address-no-zone {
    type inet:ipv6-address {
      pattern '[0-9a-fA-F:\.]*';
    }
    description
      "An IPv6 address without a zone index.  This type, derived from
       ipv6-address, may be used in situations where the zone is
       known from the context and hence no zone index is needed.";
    reference
     "RFC 4291: IP Version 6 Addressing Architecture
      RFC 4007: IPv6 Scoped Address Architecture
      RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
  }

  typedef ip-prefix {
    type union {
      type inet:ipv4-prefix;
      type inet:ipv6-prefix;
    }
    description
     "The ip-prefix type represents an IP prefix and is IP
      version neutral.  The format of the textual representations
      implies the IP version.";
  }

  typedef ipv4-prefix {
    type string {
      pattern
         '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
       +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
       + '/(([0-9])|([1-2][0-9])|(3[0-2]))';
    }
    description
     "The ipv4-prefix type represents an IPv4 address prefix.
      The prefix length is given by the number following the
      slash character and must be less than or equal to 32.

      A prefix length value of n corresponds to an IP address
      mask that has n contiguous 1-bits from the most
      significant bit (MSB) and all other bits set to 0.

      The canonical format of an IPv4 prefix has all bits of
      the IPv4 address set to zero that are not part of the
      IPv4 prefix.";
  }

  typedef ipv6-prefix {
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
            + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
            + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
            + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
            + '(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))';
      pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
            + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
            + '(/.+)';
    }
    description
     "The ipv6-prefix type represents an IPv6 address prefix.
      The prefix length is given by the number following the
      slash character and must be less than or equal to 128.

      A prefix length value of n corresponds to an IP address
      mask that has n contiguous 1-bits from the most
      significant bit (MSB) and all other bits set to 0.

      The IPv6 address should have all bits that do not belong
      to the prefix set to zero.

      The canonical format of an IPv6 prefix has all bits of
      the IPv6 address set to zero that are not part of the
      IPv6 prefix.  Furthermore, the IPv6 address is represented
      as defined in Section 4 of RFC 5952.";
    reference
     "RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
  }

  /*** collection of domain name and URI types ***/

  typedef domain-name {
    type string {
      length "1..253";
      pattern
        '((([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.)*'
      + '([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.?)'
      + '|\.';
    }
    description
     "The domain-name type represents a DNS domain name.  The
      name SHOULD be fully qualified whenever possible.

      Internet domain names are only loosely specified.  Section
      3.5 of RFC 1034 recommends a syntax (modified in Section
      2.1 of RFC 1123).  The pattern above is intended to allow
      for current practice in domain name use, and some possible
      future expansion.  It is designed to hold various types of
      domain names, including names used for A or AAAA records
      (host names) and other records, such as SRV records.  Note
      that Internet host names have a stricter syntax (described
      in RFC 952) than the DNS recommendations in RFCs 1034 and
      1123, and that systems that want to store host names in
      schema nodes using the domain-name type are recommended to
      adhere to this stricter standard to ensure interoperability.

      The encoding of DNS names in the DNS protocol is limited
      to 255 characters.  Since the encoding consists of labels
      prefixed by a length bytes and there is a trailing NULL
      byte, only 253 characters can appear in the textual dotted
      notation.

      The description clause of schema nodes using the domain-name
      type MUST describe when and how these names are resolved to
      IP addresses.  Note that the resolution of a domain-name value
      may require to query multiple DNS records (e.g., A for IPv4
      and AAAA for IPv6).  The order of the resolution process and
      which DNS record takes precedence can either be defined
      explicitly or may depend on the configuration of the
      resolver.

      Domain-name values use the US-ASCII encoding.  Their canonical
      format uses lowercase US-ASCII characters.  Internationalized
      domain names MUST be A-labels as per RFC 5890.";
    reference
     "RFC  952: DoD Internet Host Table Specification
      RFC 1034: Domain Names - Concepts and Facilities
      RFC 1123: Requirements for Internet Hosts -- Application
                and Support
      RFC 2782: A DNS RR for specifying the location of services
                (DNS SRV)
      RFC 5890: Internationalized Domain Names in Applications
                (IDNA): Definitions and Document Framework";
  }

  typedef host {
    type union {
      type inet:ip-address;
      type inet:domain-name;
    }
    description
     "The host type represents either an IP address or a DNS
      domain name.";
  }

  typedef uri {
    type string;
    description
     "The uri type represents a Uniform Resource Identifier
      (URI) as defined by STD 66.

      Objects using the uri type MUST be in US-ASCII encoding,
      and MUST be normalized as described by RFC 3986 Sections
      6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary
      percent-encoding is removed, and all case-insensitive
      characters are set to lowercase except for hexadecimal
      digits, which are normalized to uppercase as described in
      Section 6.2.2.1.

      The purpose of this normalization is to help provide
      unique URIs.  Note that this normalization is not
      sufficient to provide uniqueness.  Two URIs that are
      textually distinct after this normalization may still be
      equivalent.

      Objects using the uri type may restrict the schemes that
      they permit.  For example, 'data:' and 'urn:' schemes
      might not be appropriate.

      A zero-length URI is not a valid URI.  This can be used to
      express 'URI absent' where required.

      In the value set and its semantics, this type is equivalent
      to the Uri SMIv2 textual convention defined in RFC 5017.";
    reference
     "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax
      RFC 3305: Report from the Joint W3C/IETF URI Planning Interest
                Group: Uniform Resource Identifiers (URIs), URLs,
                and Uniform Resource Names (URNs): Clarifications
                and Recommendations
      RFC 5017: MIB Textual Conventions for Uniform Resource
                Identifiers (URIs)";
  }

}
""")
    res.append(r"""module ietf-yang-types {

  namespace "urn:ietf:params:xml:ns:yang:ietf-yang-types";
  prefix "yang";

  organization
   "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
   "WG Web:   <http://tools.ietf.org/wg/netmod/>
    WG List:  <mailto:netmod@ietf.org>

    WG Chair: David Kessens
              <mailto:david.kessens@nsn.com>

    WG Chair: Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>

    Editor:   Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>";

  description
   "This module contains a collection of generally useful derived
    YANG data types.

    Copyright (c) 2013 IETF Trust and the persons identified as
    authors of the code.  All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, is permitted pursuant to, and subject
    to the license terms contained in, the Simplified BSD License
    set forth in Section 4.c of the IETF Trust's Legal Provisions
    Relating to IETF Documents
    (http://trustee.ietf.org/license-info).

    This version of this YANG module is part of RFC 6991; see
    the RFC itself for full legal notices.";

  revision 2013-07-15 {
    description
     "This revision adds the following new data types:
      - yang-identifier
      - hex-string
      - uuid
      - dotted-quad";
    reference
     "RFC 6991: Common YANG Data Types";
  }

  revision 2010-09-24 {
    description
     "Initial revision.";
    reference
     "RFC 6021: Common YANG Data Types";
  }

  /*** collection of counter and gauge types ***/

  typedef counter32 {
    type uint32;
    description
     "The counter32 type represents a non-negative integer
      that monotonically increases until it reaches a
      maximum value of 2^32-1 (4294967295 decimal), when it
      wraps around and starts increasing again from zero.

      Counters have no defined 'initial' value, and thus, a
      single value of a counter has (in general) no information
      content.  Discontinuities in the monotonically increasing
      value normally occur at re-initialization of the
      management system, and at other times as specified in the
      description of a schema node using this type.  If such
      other times can occur, for example, the creation of
      a schema node of type counter32 at times other than
      re-initialization, then a corresponding schema node
      should be defined, with an appropriate type, to indicate
      the last discontinuity.

      The counter32 type should not be used for configuration
      schema nodes.  A default statement SHOULD NOT be used in
      combination with the type counter32.

      In the value set and its semantics, this type is equivalent
      to the Counter32 type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef zero-based-counter32 {
    type yang:counter32;
    default "0";
    description
     "The zero-based-counter32 type represents a counter32
      that has the defined 'initial' value zero.

      A schema node of this type will be set to zero (0) on creation
      and will thereafter increase monotonically until it reaches
      a maximum value of 2^32-1 (4294967295 decimal), when it
      wraps around and starts increasing again from zero.

      Provided that an application discovers a new schema node
      of this type within the minimum time to wrap, it can use the
      'initial' value as a delta.  It is important for a management
      station to be aware of this minimum time and the actual time
      between polls, and to discard data if the actual time is too
      long or there is no defined minimum time.

      In the value set and its semantics, this type is equivalent
      to the ZeroBasedCounter32 textual convention of the SMIv2.";
    reference
      "RFC 4502: Remote Network Monitoring Management Information
                 Base Version 2";
  }

  typedef counter64 {
    type uint64;
    description
     "The counter64 type represents a non-negative integer
      that monotonically increases until it reaches a
      maximum value of 2^64-1 (18446744073709551615 decimal),
      when it wraps around and starts increasing again from zero.

      Counters have no defined 'initial' value, and thus, a
      single value of a counter has (in general) no information
      content.  Discontinuities in the monotonically increasing
      value normally occur at re-initialization of the
      management system, and at other times as specified in the
      description of a schema node using this type.  If such
      other times can occur, for example, the creation of
      a schema node of type counter64 at times other than
      re-initialization, then a corresponding schema node
      should be defined, with an appropriate type, to indicate
      the last discontinuity.

      The counter64 type should not be used for configuration
      schema nodes.  A default statement SHOULD NOT be used in
      combination with the type counter64.

      In the value set and its semantics, this type is equivalent
      to the Counter64 type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef zero-based-counter64 {
    type yang:counter64;
    default "0";
    description
     "The zero-based-counter64 type represents a counter64 that
      has the defined 'initial' value zero.

      A schema node of this type will be set to zero (0) on creation
      and will thereafter increase monotonically until it reaches
      a maximum value of 2^64-1 (18446744073709551615 decimal),
      when it wraps around and starts increasing again from zero.

      Provided that an application discovers a new schema node
      of this type within the minimum time to wrap, it can use the
      'initial' value as a delta.  It is important for a management
      station to be aware of this minimum time and the actual time
      between polls, and to discard data if the actual time is too
      long or there is no defined minimum time.

      In the value set and its semantics, this type is equivalent
      to the ZeroBasedCounter64 textual convention of the SMIv2.";
    reference
     "RFC 2856: Textual Conventions for Additional High Capacity
                Data Types";
  }

  typedef gauge32 {
    type uint32;
    description
     "The gauge32 type represents a non-negative integer, which
      may increase or decrease, but shall never exceed a maximum
      value, nor fall below a minimum value.  The maximum value
      cannot be greater than 2^32-1 (4294967295 decimal), and
      the minimum value cannot be smaller than 0.  The value of
      a gauge32 has its maximum value whenever the information
      being modeled is greater than or equal to its maximum
      value, and has its minimum value whenever the information
      being modeled is smaller than or equal to its minimum value.
      If the information being modeled subsequently decreases
      below (increases above) the maximum (minimum) value, the
      gauge32 also decreases (increases).

      In the value set and its semantics, this type is equivalent
      to the Gauge32 type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef gauge64 {
    type uint64;
    description
     "The gauge64 type represents a non-negative integer, which
      may increase or decrease, but shall never exceed a maximum
      value, nor fall below a minimum value.  The maximum value
      cannot be greater than 2^64-1 (18446744073709551615), and
      the minimum value cannot be smaller than 0.  The value of
      a gauge64 has its maximum value whenever the information
      being modeled is greater than or equal to its maximum
      value, and has its minimum value whenever the information
      being modeled is smaller than or equal to its minimum value.
      If the information being modeled subsequently decreases
      below (increases above) the maximum (minimum) value, the
      gauge64 also decreases (increases).

      In the value set and its semantics, this type is equivalent
      to the CounterBasedGauge64 SMIv2 textual convention defined
      in RFC 2856";
    reference
     "RFC 2856: Textual Conventions for Additional High Capacity
                Data Types";
  }

  /*** collection of identifier-related types ***/

  typedef object-identifier {
    type string {
      pattern '(([0-1](\.[1-3]?[0-9]))|(2\.(0|([1-9]\d*))))'
            + '(\.(0|([1-9]\d*)))*';
    }
    description
     "The object-identifier type represents administratively
      assigned names in a registration-hierarchical-name tree.

      Values of this type are denoted as a sequence of numerical
      non-negative sub-identifier values.  Each sub-identifier
      value MUST NOT exceed 2^32-1 (4294967295).  Sub-identifiers
      are separated by single dots and without any intermediate
      whitespace.

      The ASN.1 standard restricts the value space of the first
      sub-identifier to 0, 1, or 2.  Furthermore, the value space
      of the second sub-identifier is restricted to the range
      0 to 39 if the first sub-identifier is 0 or 1.  Finally,
      the ASN.1 standard requires that an object identifier
      has always at least two sub-identifiers.  The pattern
      captures these restrictions.

      Although the number of sub-identifiers is not limited,
      module designers should realize that there may be
      implementations that stick with the SMIv2 limit of 128
      sub-identifiers.

      This type is a superset of the SMIv2 OBJECT IDENTIFIER type
      since it is not restricted to 128 sub-identifiers.  Hence,
      this type SHOULD NOT be used to represent the SMIv2 OBJECT
      IDENTIFIER type; the object-identifier-128 type SHOULD be
      used instead.";
    reference
     "ISO9834-1: Information technology -- Open Systems
      Interconnection -- Procedures for the operation of OSI
      Registration Authorities: General procedures and top
      arcs of the ASN.1 Object Identifier tree";
  }

  typedef object-identifier-128 {
    type object-identifier {
      pattern '\d*(\.\d*){1,127}';
    }
    description
     "This type represents object-identifiers restricted to 128
      sub-identifiers.

      In the value set and its semantics, this type is equivalent
      to the OBJECT IDENTIFIER type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef yang-identifier {
    type string {
      length "1..max";
      pattern '[a-zA-Z_][a-zA-Z0-9\-_.]*';
      pattern '.|..|[^xX].*|.[^mM].*|..[^lL].*';
    }
    description
      "A YANG identifier string as defined by the 'identifier'
       rule in Section 12 of RFC 6020.  An identifier must
       start with an alphabetic character or an underscore
       followed by an arbitrary sequence of alphabetic or
       numeric characters, underscores, hyphens, or dots.

       A YANG identifier MUST NOT start with any possible
       combination of the lowercase or uppercase character
       sequence 'xml'.";
    reference
      "RFC 6020: YANG - A Data Modeling Language for the Network
                 Configuration Protocol (NETCONF)";
  }

  /*** collection of types related to date and time***/

  typedef date-and-time {
    type string {
      pattern '\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?'
            + '(Z|[\+\-]\d{2}:\d{2})';
    }
    description
     "The date-and-time type is a profile of the ISO 8601
      standard for representation of dates and times using the
      Gregorian calendar.  The profile is defined by the
      date-time production in Section 5.6 of RFC 3339.

      The date-and-time type is compatible with the dateTime XML
      schema type with the following notable exceptions:

      (a) The date-and-time type does not allow negative years.

      (b) The date-and-time time-offset -00:00 indicates an unknown
          time zone (see RFC 3339) while -00:00 and +00:00 and Z
          all represent the same time zone in dateTime.

      (c) The canonical format (see below) of data-and-time values
          differs from the canonical format used by the dateTime XML
          schema type, which requires all times to be in UTC using
          the time-offset 'Z'.

      This type is not equivalent to the DateAndTime textual
      convention of the SMIv2 since RFC 3339 uses a different
      separator between full-date and full-time and provides
      higher resolution of time-secfrac.

      The canonical format for date-and-time values with a known time
      zone uses a numeric time zone offset that is calculated using
      the device's configured known offset to UTC time.  A change of
      the device's offset to UTC time will cause date-and-time values
      to change accordingly.  Such changes might happen periodically
      in case a server follows automatically daylight saving time
      (DST) time zone offset changes.  The canonical format for
      date-and-time values with an unknown time zone (usually
      referring to the notion of local time) uses the time-offset
      -00:00.";
    reference
     "RFC 3339: Date and Time on the Internet: Timestamps
      RFC 2579: Textual Conventions for SMIv2
      XSD-TYPES: XML Schema Part 2: Datatypes Second Edition";
  }

  typedef timeticks {
    type uint32;
    description
     "The timeticks type represents a non-negative integer that
      represents the time, modulo 2^32 (4294967296 decimal), in
      hundredths of a second between two epochs.  When a schema
      node is defined that uses this type, the description of
      the schema node identifies both of the reference epochs.

      In the value set and its semantics, this type is equivalent
      to the TimeTicks type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef timestamp {
    type yang:timeticks;
    description
     "The timestamp type represents the value of an associated
      timeticks schema node at which a specific occurrence
      happened.  The specific occurrence must be defined in the
      description of any schema node defined using this type.  When
      the specific occurrence occurred prior to the last time the
      associated timeticks attribute was zero, then the timestamp
      value is zero.  Note that this requires all timestamp values
      to be reset to zero when the value of the associated timeticks
      attribute reaches 497+ days and wraps around to zero.

      The associated timeticks schema node must be specified
      in the description of any schema node using this type.

      In the value set and its semantics, this type is equivalent
      to the TimeStamp textual convention of the SMIv2.";
    reference
     "RFC 2579: Textual Conventions for SMIv2";
  }

  /*** collection of generic address types ***/

  typedef phys-address {
    type string {
      pattern '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?';
    }

    description
     "Represents media- or physical-level addresses represented
      as a sequence octets, each octet represented by two hexadecimal
      numbers.  Octets are separated by colons.  The canonical
      representation uses lowercase characters.

      In the value set and its semantics, this type is equivalent
      to the PhysAddress textual convention of the SMIv2.";
    reference
     "RFC 2579: Textual Conventions for SMIv2";
  }

  typedef mac-address {
    type string {
      pattern '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}';
    }
    description
     "The mac-address type represents an IEEE 802 MAC address.
      The canonical representation uses lowercase characters.

      In the value set and its semantics, this type is equivalent
      to the MacAddress textual convention of the SMIv2.";
    reference
     "IEEE 802: IEEE Standard for Local and Metropolitan Area
                Networks: Overview and Architecture
      RFC 2579: Textual Conventions for SMIv2";
  }

  /*** collection of XML-specific types ***/

  typedef xpath1.0 {
    type string;
    description
     "This type represents an XPATH 1.0 expression.

      When a schema node is defined that uses this type, the
      description of the schema node MUST specify the XPath
      context in which the XPath expression is evaluated.";
    reference
     "XPATH: XML Path Language (XPath) Version 1.0";
  }

  /*** collection of string types ***/

  typedef hex-string {
    type string {
      pattern '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?';
    }
    description
     "A hexadecimal string with octets represented as hex digits
      separated by colons.  The canonical representation uses
      lowercase characters.";
  }

  typedef uuid {
    type string {
      pattern '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-'
            + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}';
    }
    description
     "A Universally Unique IDentifier in the string representation
      defined in RFC 4122.  The canonical representation uses
      lowercase characters.

      The following is an example of a UUID in string representation:
      f81d4fae-7dec-11d0-a765-00a0c91e6bf6
      ";
    reference
     "RFC 4122: A Universally Unique IDentifier (UUID) URN
                Namespace";
  }

  typedef dotted-quad {
    type string {
      pattern
        '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
      + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
    }
    description
      "An unsigned 32-bit number expressed in the dotted-quad
       notation, i.e., four octets written as decimal numbers
       and separated with the '.' (full stop) character.";
  }
}""")
    return res


class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /address-family/ipv4/unicast')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /address-family/ipv4/unicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv4', 'unicast'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology__topology_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry(yang.adata.MNode):
    topology_name: str

    mut def __init__(self, topology_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.topology_name = topology_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _topology_name = self.topology_name
        if _topology_name is not None:
            children['topology-name'] = yang.gdata.Leaf('string', _topology_name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry:
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry(topology_name=n.get_str('topology-name'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /address-family/ipv4/multicast/topologies/topology')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology({repr_yang(self.topology_name)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /address-family/ipv4/multicast/topologies/topology'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv4', 'multicast', 'topologies', 'topology'])

class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'topology'
        self.elements = elements

    mut def create(self, topology_name):
        for e in self:
            match = True
            if e.topology_name != topology_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry(topology_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['topology-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology(Iterable[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_topology_name = yang.gdata.from_xml_str(node, 'topology-name')
    yang.gdata.maybe_add(children, 'topology-name', from_data_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology__topology_name, child_topology_name)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_element(e) for e in nodes]
    return yang.gdata.List(keys=['topology-name'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies(yang.adata.MNode):
    topology: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology

    mut def __init__(self, topology: list[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.topology = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology(elements=topology)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _topology = self.topology
        if _topology is not None:
            children['topology'] = _topology.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies(topology=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology.from_gdata(n.get_opt_list('topology')))
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /address-family/ipv4/multicast/topologies')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies()')
        leaves = []
        _topology = self.topology
        for _element in _topology:
            res.append('')
            res.append("# List /address-family/ipv4/multicast/topologies/topology element: {_element.to_gdata().key_str(['topology-name'])}")
            list_elem = 'topology_element = {self_name}.topology.create({repr_yang(_element.topology_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('topology_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /address-family/ipv4/multicast/topologies'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv4', 'multicast', 'topologies'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_topology = yang.gdata.from_xml_opt_list(node, 'topology')
    yang.gdata.maybe_add(children, 'topology', from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology, child_topology)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast(yang.adata.MNode):
    topologies: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies

    mut def __init__(self, topologies: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.topologies = topologies if topologies is not None else Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _topologies = self.topologies
        if _topologies is not None:
            children['topologies'] = _topologies.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast(topologies=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies.from_gdata(n.get_opt_cnt('topologies')))
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /address-family/ipv4/multicast')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast()')
        leaves = []
        _topologies = self.topologies
        if _topologies is not None:
            res.extend(_topologies.prsrc('{self_name}.topologies', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /address-family/ipv4/multicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv4', 'multicast'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_topologies = yang.gdata.from_xml_opt_cnt(node, 'topologies')
    yang.gdata.maybe_add(children, 'topologies', from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies, child_topologies)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4(yang.adata.MNode):
    unicast: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast
    multicast: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast

    mut def __init__(self, unicast: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast=None, multicast: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.unicast = unicast
        self.multicast = multicast if multicast is not None else Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast()

    mut def create_unicast(self):
        existing = self.unicast
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast()
        self.unicast = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _unicast = self.unicast
        if _unicast is not None:
            children['unicast'] = _unicast.to_gdata()
        _multicast = self.multicast
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4(unicast=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast.from_gdata(n.get_opt_cnt('unicast')), multicast=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast.from_gdata(n.get_opt_cnt('multicast')))
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /address-family/ipv4')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4()')
        leaves = []
        _unicast = self.unicast
        if _unicast is not None:
            res.append('')
            res.append('# P-container: /address-family/ipv4/unicast')
            res.append('unicast = {self_name}.create_unicast()')
            res.extend(_unicast.prsrc('unicast', False).splitlines())
        _multicast = self.multicast
        if _multicast is not None:
            res.extend(_multicast.prsrc('{self_name}.multicast', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /address-family/ipv4'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv4'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_unicast = yang.gdata.from_xml_opt_cnt(node, 'unicast')
    yang.gdata.maybe_add(children, 'unicast', from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast, child_unicast)
    child_multicast = yang.gdata.from_xml_opt_cnt(node, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast, child_multicast)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /address-family/ipv6/unicast')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /address-family/ipv6/unicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv6', 'unicast'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology__topology_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry(yang.adata.MNode):
    topology_name: str

    mut def __init__(self, topology_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.topology_name = topology_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _topology_name = self.topology_name
        if _topology_name is not None:
            children['topology-name'] = yang.gdata.Leaf('string', _topology_name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry:
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry(topology_name=n.get_str('topology-name'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /address-family/ipv6/multicast/topologies/topology')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology({repr_yang(self.topology_name)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /address-family/ipv6/multicast/topologies/topology'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv6', 'multicast', 'topologies', 'topology'])

class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'topology'
        self.elements = elements

    mut def create(self, topology_name):
        for e in self:
            match = True
            if e.topology_name != topology_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry(topology_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['topology-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology(Iterable[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_topology_name = yang.gdata.from_xml_str(node, 'topology-name')
    yang.gdata.maybe_add(children, 'topology-name', from_data_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology__topology_name, child_topology_name)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_element(e) for e in nodes]
    return yang.gdata.List(keys=['topology-name'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies(yang.adata.MNode):
    topology: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology

    mut def __init__(self, topology: list[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.topology = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology(elements=topology)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _topology = self.topology
        if _topology is not None:
            children['topology'] = _topology.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies(topology=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology.from_gdata(n.get_opt_list('topology')))
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /address-family/ipv6/multicast/topologies')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies()')
        leaves = []
        _topology = self.topology
        for _element in _topology:
            res.append('')
            res.append("# List /address-family/ipv6/multicast/topologies/topology element: {_element.to_gdata().key_str(['topology-name'])}")
            list_elem = 'topology_element = {self_name}.topology.create({repr_yang(_element.topology_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('topology_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /address-family/ipv6/multicast/topologies'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv6', 'multicast', 'topologies'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_topology = yang.gdata.from_xml_opt_list(node, 'topology')
    yang.gdata.maybe_add(children, 'topology', from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology, child_topology)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast(yang.adata.MNode):
    topologies: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies

    mut def __init__(self, topologies: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.topologies = topologies if topologies is not None else Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _topologies = self.topologies
        if _topologies is not None:
            children['topologies'] = _topologies.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast(topologies=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies.from_gdata(n.get_opt_cnt('topologies')))
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /address-family/ipv6/multicast')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast()')
        leaves = []
        _topologies = self.topologies
        if _topologies is not None:
            res.extend(_topologies.prsrc('{self_name}.topologies', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /address-family/ipv6/multicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv6', 'multicast'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_topologies = yang.gdata.from_xml_opt_cnt(node, 'topologies')
    yang.gdata.maybe_add(children, 'topologies', from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies, child_topologies)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6(yang.adata.MNode):
    unicast: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast
    multicast: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast

    mut def __init__(self, unicast: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast=None, multicast: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.unicast = unicast
        self.multicast = multicast if multicast is not None else Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast()

    mut def create_unicast(self):
        existing = self.unicast
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast()
        self.unicast = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _unicast = self.unicast
        if _unicast is not None:
            children['unicast'] = _unicast.to_gdata()
        _multicast = self.multicast
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6(unicast=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast.from_gdata(n.get_opt_cnt('unicast')), multicast=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast.from_gdata(n.get_opt_cnt('multicast')))
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /address-family/ipv6')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6()')
        leaves = []
        _unicast = self.unicast
        if _unicast is not None:
            res.append('')
            res.append('# P-container: /address-family/ipv6/unicast')
            res.append('unicast = {self_name}.create_unicast()')
            res.extend(_unicast.prsrc('unicast', False).splitlines())
        _multicast = self.multicast
        if _multicast is not None:
            res.extend(_multicast.prsrc('{self_name}.multicast', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /address-family/ipv6'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv6'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_unicast = yang.gdata.from_xml_opt_cnt(node, 'unicast')
    yang.gdata.maybe_add(children, 'unicast', from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast, child_unicast)
    child_multicast = yang.gdata.from_xml_opt_cnt(node, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast, child_multicast)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__address_family(yang.adata.MNode):
    ipv4: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4
    ipv6: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6

    mut def __init__(self, ipv4: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4=None, ipv6: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.ipv4 = ipv4 if ipv4 is not None else Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4()
        self.ipv6 = ipv6 if ipv6 is not None else Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            children['ipv4'] = _ipv4.to_gdata()
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            children['ipv6'] = _ipv6.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', module='Cisco-IOS-XR-um-vrf-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family(ipv4=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4.from_gdata(n.get_opt_cnt('ipv4')), ipv6=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6.from_gdata(n.get_opt_cnt('ipv6')))
        return Cisco_IOS_XR_um_vrf_cfg__address_family()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /address-family')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__address_family()')
        leaves = []
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            res.extend(_ipv4.prsrc('{self_name}.ipv4', False).splitlines())
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            res.extend(_ipv6.prsrc('{self_name}.ipv6', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /address-family'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.from_xml_opt_cnt(node, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.from_xml_opt_cnt(node, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6, child_ipv6)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', module='Cisco-IOS-XR-um-vrf-cfg')

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vrf_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt__as_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt__index(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt__stitching(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry(yang.adata.MNode):
    as_number: bigint
    index: bigint
    stitching: bool

    mut def __init__(self, as_number: bigint, index: bigint, stitching: bool):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index
        self.stitching = stitching

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _as_number = self.as_number
        if _as_number is not None:
            children['as-number'] = yang.gdata.Leaf('uint32', _as_number)
        _index = self.index
        if _index is not None:
            children['index'] = yang.gdata.Leaf('uint32', _index)
        _stitching = self.stitching
        if _stitching is not None:
            children['stitching'] = yang.gdata.Leaf('boolean', _stitching)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number=n.get_bigint('as-number'), index=n.get_bigint('index'), stitching=n.get_bool('stitching'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv4/unicast/import/route-target/two-byte-as-rts/two-byte-as-rt')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt({repr_yang(self.as_number)}, {repr_yang(self.index)}, {repr_yang(self.stitching)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv4/unicast/import/route-target/two-byte-as-rts/two-byte-as-rt'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import', 'route-target', 'two-byte-as-rts', 'two-byte-as-rt'])

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'two-byte-as-rt'
        self.elements = elements

    mut def create(self, as_number, index, stitching):
        for e in self:
            match = True
            if e.as_number != as_number:
                match = False
                continue
            if e.index != index:
                match = False
                continue
            if e.stitching != stitching:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number, index, stitching)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['as-number', 'index', 'stitching'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(Iterable[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_as_number = yang.gdata.from_xml_bigint(node, 'as-number')
    yang.gdata.maybe_add(children, 'as-number', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt__as_number, child_as_number)
    child_index = yang.gdata.from_xml_bigint(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt__index, child_index)
    child_stitching = yang.gdata.from_xml_bool(node, 'stitching')
    yang.gdata.maybe_add(children, 'stitching', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt__stitching, child_stitching)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_element(e) for e in nodes]
    return yang.gdata.List(keys=['as-number', 'index', 'stitching'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts(yang.adata.MNode):
    two_byte_as_rt: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt

    mut def __init__(self, two_byte_as_rt: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rt = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(elements=two_byte_as_rt)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _two_byte_as_rt = self.two_byte_as_rt
        if _two_byte_as_rt is not None:
            children['two-byte-as-rt'] = _two_byte_as_rt.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts(two_byte_as_rt=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt.from_gdata(n.get_opt_list('two-byte-as-rt')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv4/unicast/import/route-target/two-byte-as-rts')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts()')
        leaves = []
        _two_byte_as_rt = self.two_byte_as_rt
        for _element in _two_byte_as_rt:
            res.append('')
            res.append("# List /vrfs/vrf/address-family/ipv4/unicast/import/route-target/two-byte-as-rts/two-byte-as-rt element: {_element.to_gdata().key_str(['as-number', 'index', 'stitching'])}")
            list_elem = 'two_byte_as_rt_element = {self_name}.two_byte_as_rt.create({repr_yang(_element.as_number)}, {repr_yang(_element.index)}, {repr_yang(_element.stitching)})'
            res.append(list_elem)
            res.extend(_element.prsrc('two_byte_as_rt_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv4/unicast/import/route-target/two-byte-as-rts'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import', 'route-target', 'two-byte-as-rts'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_two_byte_as_rt = yang.gdata.from_xml_opt_list(node, 'two-byte-as-rt')
    yang.gdata.maybe_add(children, 'two-byte-as-rt', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt, child_two_byte_as_rt)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target(yang.adata.MNode):
    two_byte_as_rts: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts

    mut def __init__(self, two_byte_as_rts: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rts = two_byte_as_rts if two_byte_as_rts is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _two_byte_as_rts = self.two_byte_as_rts
        if _two_byte_as_rts is not None:
            children['two-byte-as-rts'] = _two_byte_as_rts.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target(two_byte_as_rts=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts.from_gdata(n.get_opt_cnt('two-byte-as-rts')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv4/unicast/import/route-target')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target()')
        leaves = []
        _two_byte_as_rts = self.two_byte_as_rts
        if _two_byte_as_rts is not None:
            res.extend(_two_byte_as_rts.prsrc('{self_name}.two_byte_as_rts', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv4/unicast/import/route-target'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import', 'route-target'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_two_byte_as_rts = yang.gdata.from_xml_opt_cnt(node, 'two-byte-as-rts')
    yang.gdata.maybe_add(children, 'two-byte-as-rts', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts, child_two_byte_as_rts)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import(yang.adata.MNode):
    route_target: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target

    mut def __init__(self, route_target: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.route_target = route_target if route_target is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _route_target = self.route_target
        if _route_target is not None:
            children['route-target'] = _route_target.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import(route_target=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target.from_gdata(n.get_opt_cnt('route-target')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv4/unicast/import')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import()')
        leaves = []
        _route_target = self.route_target
        if _route_target is not None:
            res.extend(_route_target.prsrc('{self_name}.route_target', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv4/unicast/import'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_route_target = yang.gdata.from_xml_opt_cnt(node, 'route-target')
    yang.gdata.maybe_add(children, 'route-target', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target, child_route_target)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt__as_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt__index(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt__stitching(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry(yang.adata.MNode):
    as_number: bigint
    index: bigint
    stitching: bool

    mut def __init__(self, as_number: bigint, index: bigint, stitching: bool):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index
        self.stitching = stitching

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _as_number = self.as_number
        if _as_number is not None:
            children['as-number'] = yang.gdata.Leaf('uint32', _as_number)
        _index = self.index
        if _index is not None:
            children['index'] = yang.gdata.Leaf('uint32', _index)
        _stitching = self.stitching
        if _stitching is not None:
            children['stitching'] = yang.gdata.Leaf('boolean', _stitching)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number=n.get_bigint('as-number'), index=n.get_bigint('index'), stitching=n.get_bool('stitching'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv4/unicast/export/route-target/two-byte-as-rts/two-byte-as-rt')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt({repr_yang(self.as_number)}, {repr_yang(self.index)}, {repr_yang(self.stitching)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv4/unicast/export/route-target/two-byte-as-rts/two-byte-as-rt'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export', 'route-target', 'two-byte-as-rts', 'two-byte-as-rt'])

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'two-byte-as-rt'
        self.elements = elements

    mut def create(self, as_number, index, stitching):
        for e in self:
            match = True
            if e.as_number != as_number:
                match = False
                continue
            if e.index != index:
                match = False
                continue
            if e.stitching != stitching:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number, index, stitching)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['as-number', 'index', 'stitching'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(Iterable[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_as_number = yang.gdata.from_xml_bigint(node, 'as-number')
    yang.gdata.maybe_add(children, 'as-number', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt__as_number, child_as_number)
    child_index = yang.gdata.from_xml_bigint(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt__index, child_index)
    child_stitching = yang.gdata.from_xml_bool(node, 'stitching')
    yang.gdata.maybe_add(children, 'stitching', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt__stitching, child_stitching)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_element(e) for e in nodes]
    return yang.gdata.List(keys=['as-number', 'index', 'stitching'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts(yang.adata.MNode):
    two_byte_as_rt: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt

    mut def __init__(self, two_byte_as_rt: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rt = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(elements=two_byte_as_rt)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _two_byte_as_rt = self.two_byte_as_rt
        if _two_byte_as_rt is not None:
            children['two-byte-as-rt'] = _two_byte_as_rt.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts(two_byte_as_rt=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt.from_gdata(n.get_opt_list('two-byte-as-rt')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv4/unicast/export/route-target/two-byte-as-rts')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts()')
        leaves = []
        _two_byte_as_rt = self.two_byte_as_rt
        for _element in _two_byte_as_rt:
            res.append('')
            res.append("# List /vrfs/vrf/address-family/ipv4/unicast/export/route-target/two-byte-as-rts/two-byte-as-rt element: {_element.to_gdata().key_str(['as-number', 'index', 'stitching'])}")
            list_elem = 'two_byte_as_rt_element = {self_name}.two_byte_as_rt.create({repr_yang(_element.as_number)}, {repr_yang(_element.index)}, {repr_yang(_element.stitching)})'
            res.append(list_elem)
            res.extend(_element.prsrc('two_byte_as_rt_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv4/unicast/export/route-target/two-byte-as-rts'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export', 'route-target', 'two-byte-as-rts'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_two_byte_as_rt = yang.gdata.from_xml_opt_list(node, 'two-byte-as-rt')
    yang.gdata.maybe_add(children, 'two-byte-as-rt', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt, child_two_byte_as_rt)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target(yang.adata.MNode):
    two_byte_as_rts: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts

    mut def __init__(self, two_byte_as_rts: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rts = two_byte_as_rts if two_byte_as_rts is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _two_byte_as_rts = self.two_byte_as_rts
        if _two_byte_as_rts is not None:
            children['two-byte-as-rts'] = _two_byte_as_rts.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target(two_byte_as_rts=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts.from_gdata(n.get_opt_cnt('two-byte-as-rts')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv4/unicast/export/route-target')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target()')
        leaves = []
        _two_byte_as_rts = self.two_byte_as_rts
        if _two_byte_as_rts is not None:
            res.extend(_two_byte_as_rts.prsrc('{self_name}.two_byte_as_rts', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv4/unicast/export/route-target'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export', 'route-target'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_two_byte_as_rts = yang.gdata.from_xml_opt_cnt(node, 'two-byte-as-rts')
    yang.gdata.maybe_add(children, 'two-byte-as-rts', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts, child_two_byte_as_rts)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export(yang.adata.MNode):
    route_target: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target

    mut def __init__(self, route_target: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.route_target = route_target if route_target is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _route_target = self.route_target
        if _route_target is not None:
            children['route-target'] = _route_target.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export(route_target=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target.from_gdata(n.get_opt_cnt('route-target')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv4/unicast/export')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export()')
        leaves = []
        _route_target = self.route_target
        if _route_target is not None:
            res.extend(_route_target.prsrc('{self_name}.route_target', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv4/unicast/export'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_route_target = yang.gdata.from_xml_opt_cnt(node, 'route-target')
    yang.gdata.maybe_add(children, 'route-target', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target, child_route_target)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast(yang.adata.MNode):
    import_: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import
    export: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export

    mut def __init__(self, import_: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import=None, export: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.import_ = import_ if import_ is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import()
        self.export = export if export is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _import_ = self.import_
        if _import_ is not None:
            children['import'] = _import_.to_gdata()
        _export = self.export
        if _export is not None:
            children['export'] = _export.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast(import_=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import.from_gdata(n.get_opt_cnt('import')), export=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export.from_gdata(n.get_opt_cnt('export')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv4/unicast')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast()')
        leaves = []
        _import_ = self.import_
        if _import_ is not None:
            res.extend(_import_.prsrc('{self_name}.import_', False).splitlines())
        _export = self.export
        if _export is not None:
            res.extend(_export.prsrc('{self_name}.export', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv4/unicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_import_ = yang.gdata.from_xml_opt_cnt(node, 'import', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg')
    yang.gdata.maybe_add(children, 'import', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import, child_import_)
    child_export = yang.gdata.from_xml_opt_cnt(node, 'export', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg')
    yang.gdata.maybe_add(children, 'export', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export, child_export)
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv4/multicast')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv4/multicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'multicast'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv4/flowspec')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv4/flowspec'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'flowspec'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4(yang.adata.MNode):
    unicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast
    multicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast
    flowspec: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec

    mut def __init__(self, unicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast=None, multicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast=None, flowspec: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.unicast = unicast
        self.multicast = multicast
        self.flowspec = flowspec

    mut def create_unicast(self):
        existing = self.unicast
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast()
        self.unicast = res
        return res

    mut def create_multicast(self):
        existing = self.multicast
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast()
        self.multicast = res
        return res

    mut def create_flowspec(self):
        existing = self.flowspec
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec()
        self.flowspec = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _unicast = self.unicast
        if _unicast is not None:
            children['unicast'] = _unicast.to_gdata()
        _multicast = self.multicast
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        _flowspec = self.flowspec
        if _flowspec is not None:
            children['flowspec'] = _flowspec.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4(unicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast.from_gdata(n.get_opt_cnt('unicast')), multicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast.from_gdata(n.get_opt_cnt('multicast')), flowspec=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec.from_gdata(n.get_opt_cnt('flowspec')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv4')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4()')
        leaves = []
        _unicast = self.unicast
        if _unicast is not None:
            res.append('')
            res.append('# P-container: /vrfs/vrf/address-family/ipv4/unicast')
            res.append('unicast = {self_name}.create_unicast()')
            res.extend(_unicast.prsrc('unicast', False).splitlines())
        _multicast = self.multicast
        if _multicast is not None:
            res.append('')
            res.append('# P-container: /vrfs/vrf/address-family/ipv4/multicast')
            res.append('multicast = {self_name}.create_multicast()')
            res.extend(_multicast.prsrc('multicast', False).splitlines())
        _flowspec = self.flowspec
        if _flowspec is not None:
            res.append('')
            res.append('# P-container: /vrfs/vrf/address-family/ipv4/flowspec')
            res.append('flowspec = {self_name}.create_flowspec()')
            res.extend(_flowspec.prsrc('flowspec', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv4'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_unicast = yang.gdata.from_xml_opt_cnt(node, 'unicast')
    yang.gdata.maybe_add(children, 'unicast', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast, child_unicast)
    child_multicast = yang.gdata.from_xml_opt_cnt(node, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast, child_multicast)
    child_flowspec = yang.gdata.from_xml_opt_cnt(node, 'flowspec')
    yang.gdata.maybe_add(children, 'flowspec', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec, child_flowspec)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt__as_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt__index(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt__stitching(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry(yang.adata.MNode):
    as_number: bigint
    index: bigint
    stitching: bool

    mut def __init__(self, as_number: bigint, index: bigint, stitching: bool):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index
        self.stitching = stitching

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _as_number = self.as_number
        if _as_number is not None:
            children['as-number'] = yang.gdata.Leaf('uint32', _as_number)
        _index = self.index
        if _index is not None:
            children['index'] = yang.gdata.Leaf('uint32', _index)
        _stitching = self.stitching
        if _stitching is not None:
            children['stitching'] = yang.gdata.Leaf('boolean', _stitching)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number=n.get_bigint('as-number'), index=n.get_bigint('index'), stitching=n.get_bool('stitching'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv6/unicast/import/route-target/two-byte-as-rts/two-byte-as-rt')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt({repr_yang(self.as_number)}, {repr_yang(self.index)}, {repr_yang(self.stitching)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv6/unicast/import/route-target/two-byte-as-rts/two-byte-as-rt'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import', 'route-target', 'two-byte-as-rts', 'two-byte-as-rt'])

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'two-byte-as-rt'
        self.elements = elements

    mut def create(self, as_number, index, stitching):
        for e in self:
            match = True
            if e.as_number != as_number:
                match = False
                continue
            if e.index != index:
                match = False
                continue
            if e.stitching != stitching:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number, index, stitching)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['as-number', 'index', 'stitching'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(Iterable[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_as_number = yang.gdata.from_xml_bigint(node, 'as-number')
    yang.gdata.maybe_add(children, 'as-number', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt__as_number, child_as_number)
    child_index = yang.gdata.from_xml_bigint(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt__index, child_index)
    child_stitching = yang.gdata.from_xml_bool(node, 'stitching')
    yang.gdata.maybe_add(children, 'stitching', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt__stitching, child_stitching)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_element(e) for e in nodes]
    return yang.gdata.List(keys=['as-number', 'index', 'stitching'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts(yang.adata.MNode):
    two_byte_as_rt: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt

    mut def __init__(self, two_byte_as_rt: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rt = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(elements=two_byte_as_rt)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _two_byte_as_rt = self.two_byte_as_rt
        if _two_byte_as_rt is not None:
            children['two-byte-as-rt'] = _two_byte_as_rt.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts(two_byte_as_rt=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt.from_gdata(n.get_opt_list('two-byte-as-rt')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv6/unicast/import/route-target/two-byte-as-rts')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts()')
        leaves = []
        _two_byte_as_rt = self.two_byte_as_rt
        for _element in _two_byte_as_rt:
            res.append('')
            res.append("# List /vrfs/vrf/address-family/ipv6/unicast/import/route-target/two-byte-as-rts/two-byte-as-rt element: {_element.to_gdata().key_str(['as-number', 'index', 'stitching'])}")
            list_elem = 'two_byte_as_rt_element = {self_name}.two_byte_as_rt.create({repr_yang(_element.as_number)}, {repr_yang(_element.index)}, {repr_yang(_element.stitching)})'
            res.append(list_elem)
            res.extend(_element.prsrc('two_byte_as_rt_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv6/unicast/import/route-target/two-byte-as-rts'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import', 'route-target', 'two-byte-as-rts'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_two_byte_as_rt = yang.gdata.from_xml_opt_list(node, 'two-byte-as-rt')
    yang.gdata.maybe_add(children, 'two-byte-as-rt', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt, child_two_byte_as_rt)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target(yang.adata.MNode):
    two_byte_as_rts: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts

    mut def __init__(self, two_byte_as_rts: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rts = two_byte_as_rts if two_byte_as_rts is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _two_byte_as_rts = self.two_byte_as_rts
        if _two_byte_as_rts is not None:
            children['two-byte-as-rts'] = _two_byte_as_rts.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target(two_byte_as_rts=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts.from_gdata(n.get_opt_cnt('two-byte-as-rts')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv6/unicast/import/route-target')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target()')
        leaves = []
        _two_byte_as_rts = self.two_byte_as_rts
        if _two_byte_as_rts is not None:
            res.extend(_two_byte_as_rts.prsrc('{self_name}.two_byte_as_rts', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv6/unicast/import/route-target'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import', 'route-target'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_two_byte_as_rts = yang.gdata.from_xml_opt_cnt(node, 'two-byte-as-rts')
    yang.gdata.maybe_add(children, 'two-byte-as-rts', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts, child_two_byte_as_rts)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import(yang.adata.MNode):
    route_target: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target

    mut def __init__(self, route_target: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.route_target = route_target if route_target is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _route_target = self.route_target
        if _route_target is not None:
            children['route-target'] = _route_target.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import(route_target=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target.from_gdata(n.get_opt_cnt('route-target')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv6/unicast/import')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import()')
        leaves = []
        _route_target = self.route_target
        if _route_target is not None:
            res.extend(_route_target.prsrc('{self_name}.route_target', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv6/unicast/import'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_route_target = yang.gdata.from_xml_opt_cnt(node, 'route-target')
    yang.gdata.maybe_add(children, 'route-target', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target, child_route_target)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt__as_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt__index(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt__stitching(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry(yang.adata.MNode):
    as_number: bigint
    index: bigint
    stitching: bool

    mut def __init__(self, as_number: bigint, index: bigint, stitching: bool):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index
        self.stitching = stitching

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _as_number = self.as_number
        if _as_number is not None:
            children['as-number'] = yang.gdata.Leaf('uint32', _as_number)
        _index = self.index
        if _index is not None:
            children['index'] = yang.gdata.Leaf('uint32', _index)
        _stitching = self.stitching
        if _stitching is not None:
            children['stitching'] = yang.gdata.Leaf('boolean', _stitching)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number=n.get_bigint('as-number'), index=n.get_bigint('index'), stitching=n.get_bool('stitching'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv6/unicast/export/route-target/two-byte-as-rts/two-byte-as-rt')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt({repr_yang(self.as_number)}, {repr_yang(self.index)}, {repr_yang(self.stitching)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv6/unicast/export/route-target/two-byte-as-rts/two-byte-as-rt'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export', 'route-target', 'two-byte-as-rts', 'two-byte-as-rt'])

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'two-byte-as-rt'
        self.elements = elements

    mut def create(self, as_number, index, stitching):
        for e in self:
            match = True
            if e.as_number != as_number:
                match = False
                continue
            if e.index != index:
                match = False
                continue
            if e.stitching != stitching:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number, index, stitching)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['as-number', 'index', 'stitching'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(Iterable[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_as_number = yang.gdata.from_xml_bigint(node, 'as-number')
    yang.gdata.maybe_add(children, 'as-number', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt__as_number, child_as_number)
    child_index = yang.gdata.from_xml_bigint(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt__index, child_index)
    child_stitching = yang.gdata.from_xml_bool(node, 'stitching')
    yang.gdata.maybe_add(children, 'stitching', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt__stitching, child_stitching)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_element(e) for e in nodes]
    return yang.gdata.List(keys=['as-number', 'index', 'stitching'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts(yang.adata.MNode):
    two_byte_as_rt: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt

    mut def __init__(self, two_byte_as_rt: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rt = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(elements=two_byte_as_rt)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _two_byte_as_rt = self.two_byte_as_rt
        if _two_byte_as_rt is not None:
            children['two-byte-as-rt'] = _two_byte_as_rt.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts(two_byte_as_rt=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt.from_gdata(n.get_opt_list('two-byte-as-rt')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv6/unicast/export/route-target/two-byte-as-rts')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts()')
        leaves = []
        _two_byte_as_rt = self.two_byte_as_rt
        for _element in _two_byte_as_rt:
            res.append('')
            res.append("# List /vrfs/vrf/address-family/ipv6/unicast/export/route-target/two-byte-as-rts/two-byte-as-rt element: {_element.to_gdata().key_str(['as-number', 'index', 'stitching'])}")
            list_elem = 'two_byte_as_rt_element = {self_name}.two_byte_as_rt.create({repr_yang(_element.as_number)}, {repr_yang(_element.index)}, {repr_yang(_element.stitching)})'
            res.append(list_elem)
            res.extend(_element.prsrc('two_byte_as_rt_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv6/unicast/export/route-target/two-byte-as-rts'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export', 'route-target', 'two-byte-as-rts'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_two_byte_as_rt = yang.gdata.from_xml_opt_list(node, 'two-byte-as-rt')
    yang.gdata.maybe_add(children, 'two-byte-as-rt', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt, child_two_byte_as_rt)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target(yang.adata.MNode):
    two_byte_as_rts: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts

    mut def __init__(self, two_byte_as_rts: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rts = two_byte_as_rts if two_byte_as_rts is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _two_byte_as_rts = self.two_byte_as_rts
        if _two_byte_as_rts is not None:
            children['two-byte-as-rts'] = _two_byte_as_rts.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target(two_byte_as_rts=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts.from_gdata(n.get_opt_cnt('two-byte-as-rts')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv6/unicast/export/route-target')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target()')
        leaves = []
        _two_byte_as_rts = self.two_byte_as_rts
        if _two_byte_as_rts is not None:
            res.extend(_two_byte_as_rts.prsrc('{self_name}.two_byte_as_rts', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv6/unicast/export/route-target'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export', 'route-target'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_two_byte_as_rts = yang.gdata.from_xml_opt_cnt(node, 'two-byte-as-rts')
    yang.gdata.maybe_add(children, 'two-byte-as-rts', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts, child_two_byte_as_rts)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export(yang.adata.MNode):
    route_target: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target

    mut def __init__(self, route_target: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.route_target = route_target if route_target is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _route_target = self.route_target
        if _route_target is not None:
            children['route-target'] = _route_target.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export(route_target=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target.from_gdata(n.get_opt_cnt('route-target')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv6/unicast/export')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export()')
        leaves = []
        _route_target = self.route_target
        if _route_target is not None:
            res.extend(_route_target.prsrc('{self_name}.route_target', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv6/unicast/export'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_route_target = yang.gdata.from_xml_opt_cnt(node, 'route-target')
    yang.gdata.maybe_add(children, 'route-target', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target, child_route_target)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast(yang.adata.MNode):
    import_: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import
    export: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export

    mut def __init__(self, import_: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import=None, export: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.import_ = import_ if import_ is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import()
        self.export = export if export is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _import_ = self.import_
        if _import_ is not None:
            children['import'] = _import_.to_gdata()
        _export = self.export
        if _export is not None:
            children['export'] = _export.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast(import_=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import.from_gdata(n.get_opt_cnt('import')), export=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export.from_gdata(n.get_opt_cnt('export')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv6/unicast')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast()')
        leaves = []
        _import_ = self.import_
        if _import_ is not None:
            res.extend(_import_.prsrc('{self_name}.import_', False).splitlines())
        _export = self.export
        if _export is not None:
            res.extend(_export.prsrc('{self_name}.export', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv6/unicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_import_ = yang.gdata.from_xml_opt_cnt(node, 'import', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg')
    yang.gdata.maybe_add(children, 'import', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import, child_import_)
    child_export = yang.gdata.from_xml_opt_cnt(node, 'export', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg')
    yang.gdata.maybe_add(children, 'export', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export, child_export)
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv6/multicast')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv6/multicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'multicast'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv6/flowspec')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv6/flowspec'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'flowspec'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6(yang.adata.MNode):
    unicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast
    multicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast
    flowspec: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec

    mut def __init__(self, unicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast=None, multicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast=None, flowspec: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.unicast = unicast
        self.multicast = multicast
        self.flowspec = flowspec

    mut def create_unicast(self):
        existing = self.unicast
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast()
        self.unicast = res
        return res

    mut def create_multicast(self):
        existing = self.multicast
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast()
        self.multicast = res
        return res

    mut def create_flowspec(self):
        existing = self.flowspec
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec()
        self.flowspec = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _unicast = self.unicast
        if _unicast is not None:
            children['unicast'] = _unicast.to_gdata()
        _multicast = self.multicast
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        _flowspec = self.flowspec
        if _flowspec is not None:
            children['flowspec'] = _flowspec.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6(unicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast.from_gdata(n.get_opt_cnt('unicast')), multicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast.from_gdata(n.get_opt_cnt('multicast')), flowspec=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec.from_gdata(n.get_opt_cnt('flowspec')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family/ipv6')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6()')
        leaves = []
        _unicast = self.unicast
        if _unicast is not None:
            res.append('')
            res.append('# P-container: /vrfs/vrf/address-family/ipv6/unicast')
            res.append('unicast = {self_name}.create_unicast()')
            res.extend(_unicast.prsrc('unicast', False).splitlines())
        _multicast = self.multicast
        if _multicast is not None:
            res.append('')
            res.append('# P-container: /vrfs/vrf/address-family/ipv6/multicast')
            res.append('multicast = {self_name}.create_multicast()')
            res.extend(_multicast.prsrc('multicast', False).splitlines())
        _flowspec = self.flowspec
        if _flowspec is not None:
            res.append('')
            res.append('# P-container: /vrfs/vrf/address-family/ipv6/flowspec')
            res.append('flowspec = {self_name}.create_flowspec()')
            res.extend(_flowspec.prsrc('flowspec', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family/ipv6'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_unicast = yang.gdata.from_xml_opt_cnt(node, 'unicast')
    yang.gdata.maybe_add(children, 'unicast', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast, child_unicast)
    child_multicast = yang.gdata.from_xml_opt_cnt(node, 'multicast')
    yang.gdata.maybe_add(children, 'multicast', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast, child_multicast)
    child_flowspec = yang.gdata.from_xml_opt_cnt(node, 'flowspec')
    yang.gdata.maybe_add(children, 'flowspec', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec, child_flowspec)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family(yang.adata.MNode):
    ipv4: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4
    ipv6: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6

    mut def __init__(self, ipv4: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4=None, ipv6: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.ipv4 = ipv4 if ipv4 is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4()
        self.ipv6 = ipv6 if ipv6 is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            children['ipv4'] = _ipv4.to_gdata()
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            children['ipv6'] = _ipv6.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family(ipv4=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4.from_gdata(n.get_opt_cnt('ipv4')), ipv6=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6.from_gdata(n.get_opt_cnt('ipv6')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/address-family')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family()')
        leaves = []
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            res.extend(_ipv4.prsrc('{self_name}.ipv4', False).splitlines())
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            res.extend(_ipv6.prsrc('{self_name}.ipv6', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/address-family'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.from_xml_opt_cnt(node, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.from_xml_opt_cnt(node, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6, child_ipv6)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/mode/big')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/mode/big'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'mode', 'big'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode(yang.adata.MNode):
    big: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big

    mut def __init__(self, big: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.big = big

    mut def create_big(self):
        existing = self.big
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big()
        self.big = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _big = self.big
        if _big is not None:
            children['big'] = _big.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode(big=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big.from_gdata(n.get_opt_cnt('big')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/mode')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode()')
        leaves = []
        _big = self.big
        if _big is not None:
            res.append('')
            res.append('# P-container: /vrfs/vrf/mode/big')
            res.append('big = {self_name}.create_big()')
            res.extend(_big.prsrc('big', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/mode'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'mode'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_big = yang.gdata.from_xml_opt_cnt(node, 'big')
    yang.gdata.maybe_add(children, 'big', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big, child_big)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn(yang.adata.MNode):
    id: ?str

    mut def __init__(self, id: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn(id=n.get_opt_str('id'))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/vpn')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn()')
        leaves = []
        _id = self.id
        if _id is not None:
            leaves.append('{self_name}.id = {repr_yang(_id)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/vpn'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'vpn'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_id = yang.gdata.from_xml_opt_str(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn__id, child_id)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/remote-route-filtering/disable')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/remote-route-filtering/disable'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'remote-route-filtering', 'disable'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering(yang.adata.MNode):
    disable: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable

    mut def __init__(self, disable: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.disable = disable

    mut def create_disable(self):
        existing = self.disable
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable()
        self.disable = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _disable = self.disable
        if _disable is not None:
            children['disable'] = _disable.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering(disable=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable.from_gdata(n.get_opt_cnt('disable')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/remote-route-filtering')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering()')
        leaves = []
        _disable = self.disable
        if _disable is not None:
            res.append('')
            res.append('# P-container: /vrfs/vrf/remote-route-filtering/disable')
            res.append('disable = {self_name}.create_disable()')
            res.extend(_disable.prsrc('disable', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/remote-route-filtering'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'remote-route-filtering'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_disable = yang.gdata.from_xml_opt_cnt(node, 'disable')
    yang.gdata.maybe_add(children, 'disable', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable, child_disable)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__fallback_vrf(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as__as_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as__index(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as(yang.adata.MNode):
    as_number: ?str
    index: ?bigint

    mut def __init__(self, as_number: ?str, index: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _as_number = self.as_number
        if _as_number is not None:
            children['as-number'] = yang.gdata.Leaf('string', _as_number)
        _index = self.index
        if _index is not None:
            children['index'] = yang.gdata.Leaf('uint32', _index)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as(as_number=n.get_opt_str('as-number'), index=n.get_opt_bigint('index'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/rd/two-byte-as')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as()')
        leaves = []
        _as_number = self.as_number
        if _as_number is not None:
            leaves.append('{self_name}.as_number = {repr_yang(_as_number)}')
        _index = self.index
        if _index is not None:
            leaves.append('{self_name}.index = {repr_yang(_index)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/rd/two-byte-as'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'Cisco-IOS-XR-um-router-bgp-cfg:rd', 'two-byte-as'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_as_number = yang.gdata.from_xml_opt_str(node, 'as-number')
    yang.gdata.maybe_add(children, 'as-number', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as__as_number, child_as_number)
    child_index = yang.gdata.from_xml_opt_bigint(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as__index, child_index)
    return yang.gdata.Container(children, presence=True)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as__as_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as__index(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as(yang.adata.MNode):
    as_number: ?str
    index: ?bigint

    mut def __init__(self, as_number: ?str, index: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _as_number = self.as_number
        if _as_number is not None:
            children['as-number'] = yang.gdata.Leaf('string', _as_number)
        _index = self.index
        if _index is not None:
            children['index'] = yang.gdata.Leaf('uint32', _index)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as(as_number=n.get_opt_str('as-number'), index=n.get_opt_bigint('index'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/rd/four-byte-as')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as()')
        leaves = []
        _as_number = self.as_number
        if _as_number is not None:
            leaves.append('{self_name}.as_number = {repr_yang(_as_number)}')
        _index = self.index
        if _index is not None:
            leaves.append('{self_name}.index = {repr_yang(_index)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/rd/four-byte-as'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'Cisco-IOS-XR-um-router-bgp-cfg:rd', 'four-byte-as'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_as_number = yang.gdata.from_xml_opt_str(node, 'as-number')
    yang.gdata.maybe_add(children, 'as-number', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as__as_number, child_as_number)
    child_index = yang.gdata.from_xml_opt_bigint(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as__index, child_index)
    return yang.gdata.Container(children, presence=True)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address__ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address__index(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address(yang.adata.MNode):
    ipv4_address: ?str
    index: ?bigint

    mut def __init__(self, ipv4_address: ?str, index: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.ipv4_address = ipv4_address
        self.index = index

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4_address = self.ipv4_address
        if _ipv4_address is not None:
            children['ipv4-address'] = yang.gdata.Leaf('string', _ipv4_address)
        _index = self.index
        if _index is not None:
            children['index'] = yang.gdata.Leaf('uint32', _index)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address(ipv4_address=n.get_opt_str('ipv4-address'), index=n.get_opt_bigint('index'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/rd/ip-address')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address()')
        leaves = []
        _ipv4_address = self.ipv4_address
        if _ipv4_address is not None:
            leaves.append('{self_name}.ipv4_address = {repr_yang(_ipv4_address)}')
        _index = self.index
        if _index is not None:
            leaves.append('{self_name}.index = {repr_yang(_index)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/rd/ip-address'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'Cisco-IOS-XR-um-router-bgp-cfg:rd', 'ip-address'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4_address = yang.gdata.from_xml_opt_str(node, 'ipv4-address')
    yang.gdata.maybe_add(children, 'ipv4-address', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address__ipv4_address, child_ipv4_address)
    child_index = yang.gdata.from_xml_opt_bigint(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address__index, child_index)
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd(yang.adata.MNode):
    two_byte_as: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as
    four_byte_as: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as
    ip_address: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address

    mut def __init__(self, two_byte_as: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as=None, four_byte_as: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as=None, ip_address: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as = two_byte_as
        self.four_byte_as = four_byte_as
        self.ip_address = ip_address

    mut def create_two_byte_as(self, as_number, index):
        existing = self.two_byte_as
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as(as_number, index)
        self.two_byte_as = res
        return res

    mut def create_four_byte_as(self, as_number, index):
        existing = self.four_byte_as
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as(as_number, index)
        self.four_byte_as = res
        return res

    mut def create_ip_address(self, ipv4_address, index):
        existing = self.ip_address
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address(ipv4_address, index)
        self.ip_address = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _two_byte_as = self.two_byte_as
        if _two_byte_as is not None:
            children['two-byte-as'] = _two_byte_as.to_gdata()
        _four_byte_as = self.four_byte_as
        if _four_byte_as is not None:
            children['four-byte-as'] = _four_byte_as.to_gdata()
        _ip_address = self.ip_address
        if _ip_address is not None:
            children['ip-address'] = _ip_address.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd(two_byte_as=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as.from_gdata(n.get_opt_cnt('two-byte-as')), four_byte_as=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as.from_gdata(n.get_opt_cnt('four-byte-as')), ip_address=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address.from_gdata(n.get_opt_cnt('ip-address')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf/rd')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd()')
        leaves = []
        _two_byte_as = self.two_byte_as
        if _two_byte_as is not None:
            res.append('')
            res.append('# P-container: /vrfs/vrf/rd/two-byte-as')
            res.append('two_byte_as = {self_name}.create_two_byte_as()')
            res.extend(_two_byte_as.prsrc('two_byte_as', False).splitlines())
        _four_byte_as = self.four_byte_as
        if _four_byte_as is not None:
            res.append('')
            res.append('# P-container: /vrfs/vrf/rd/four-byte-as')
            res.append('four_byte_as = {self_name}.create_four_byte_as()')
            res.extend(_four_byte_as.prsrc('four_byte_as', False).splitlines())
        _ip_address = self.ip_address
        if _ip_address is not None:
            res.append('')
            res.append('# P-container: /vrfs/vrf/rd/ip-address')
            res.append('ip_address = {self_name}.create_ip_address()')
            res.extend(_ip_address.prsrc('ip_address', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf/rd'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'Cisco-IOS-XR-um-router-bgp-cfg:rd'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_two_byte_as = yang.gdata.from_xml_opt_cnt(node, 'two-byte-as')
    yang.gdata.maybe_add(children, 'two-byte-as', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as, child_two_byte_as)
    child_four_byte_as = yang.gdata.from_xml_opt_cnt(node, 'four-byte-as')
    yang.gdata.maybe_add(children, 'four-byte-as', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as, child_four_byte_as)
    child_ip_address = yang.gdata.from_xml_opt_cnt(node, 'ip-address')
    yang.gdata.maybe_add(children, 'ip-address', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address, child_ip_address)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry(yang.adata.MNode):
    vrf_name: str
    address_family: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family
    mode: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode
    vpn: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn
    description: ?str
    remote_route_filtering: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering
    fallback_vrf: ?str
    rd: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd

    mut def __init__(self, vrf_name: str, address_family: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family=None, mode: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode=None, vpn: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn=None, description: ?str, remote_route_filtering: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering=None, fallback_vrf: ?str, rd: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.vrf_name = vrf_name
        self.address_family = address_family if address_family is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family()
        self.mode = mode if mode is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode()
        self.vpn = vpn if vpn is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn()
        self.description = description
        self.remote_route_filtering = remote_route_filtering if remote_route_filtering is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering()
        self.fallback_vrf = fallback_vrf
        self.rd = rd if rd is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vrf_name = self.vrf_name
        if _vrf_name is not None:
            children['vrf-name'] = yang.gdata.Leaf('string', _vrf_name)
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = _address_family.to_gdata()
        _mode = self.mode
        if _mode is not None:
            children['mode'] = _mode.to_gdata()
        _vpn = self.vpn
        if _vpn is not None:
            children['vpn'] = _vpn.to_gdata()
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        _remote_route_filtering = self.remote_route_filtering
        if _remote_route_filtering is not None:
            children['remote-route-filtering'] = _remote_route_filtering.to_gdata()
        _fallback_vrf = self.fallback_vrf
        if _fallback_vrf is not None:
            children['fallback-vrf'] = yang.gdata.Leaf('string', _fallback_vrf)
        _rd = self.rd
        if _rd is not None:
            children['rd'] = _rd.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry(vrf_name=n.get_str('vrf-name'), address_family=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family.from_gdata(n.get_opt_cnt('address-family')), mode=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode.from_gdata(n.get_opt_cnt('mode')), vpn=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn.from_gdata(n.get_opt_cnt('vpn')), description=n.get_opt_str('description'), remote_route_filtering=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering.from_gdata(n.get_opt_cnt('remote-route-filtering')), fallback_vrf=n.get_opt_str('fallback-vrf'), rd=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd.from_gdata(n.get_opt_cnt('rd')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs/vrf')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf({repr_yang(self.vrf_name)})')
        leaves = []
        _address_family = self.address_family
        if _address_family is not None:
            res.extend(_address_family.prsrc('{self_name}.address_family', False).splitlines())
        _mode = self.mode
        if _mode is not None:
            res.extend(_mode.prsrc('{self_name}.mode', False).splitlines())
        _vpn = self.vpn
        if _vpn is not None:
            res.extend(_vpn.prsrc('{self_name}.vpn', False).splitlines())
        _description = self.description
        if _description is not None:
            leaves.append('{self_name}.description = {repr_yang(_description)}')
        _remote_route_filtering = self.remote_route_filtering
        if _remote_route_filtering is not None:
            res.extend(_remote_route_filtering.prsrc('{self_name}.remote_route_filtering', False).splitlines())
        _fallback_vrf = self.fallback_vrf
        if _fallback_vrf is not None:
            leaves.append('{self_name}.fallback_vrf = {repr_yang(_fallback_vrf)}')
        _rd = self.rd
        if _rd is not None:
            res.extend(_rd.prsrc('{self_name}.rd', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs/vrf'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf'])

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'vrf'
        self.elements = elements

    mut def create(self, vrf_name):
        for e in self:
            match = True
            if e.vrf_name != vrf_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry(vrf_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vrf-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(Iterable[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_vrf_name = yang.gdata.from_xml_str(node, 'vrf-name')
    yang.gdata.maybe_add(children, 'vrf-name', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vrf_name, child_vrf_name)
    child_address_family = yang.gdata.from_xml_opt_cnt(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family, child_address_family)
    child_mode = yang.gdata.from_xml_opt_cnt(node, 'mode')
    yang.gdata.maybe_add(children, 'mode', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode, child_mode)
    child_vpn = yang.gdata.from_xml_opt_cnt(node, 'vpn')
    yang.gdata.maybe_add(children, 'vpn', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn, child_vpn)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__description, child_description)
    child_remote_route_filtering = yang.gdata.from_xml_opt_cnt(node, 'remote-route-filtering')
    yang.gdata.maybe_add(children, 'remote-route-filtering', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering, child_remote_route_filtering)
    child_fallback_vrf = yang.gdata.from_xml_opt_str(node, 'fallback-vrf')
    yang.gdata.maybe_add(children, 'fallback-vrf', from_data_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__fallback_vrf, child_fallback_vrf)
    child_rd = yang.gdata.from_xml_opt_cnt(node, 'rd', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg')
    yang.gdata.maybe_add(children, 'rd', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd, child_rd)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_element(e) for e in nodes]
    return yang.gdata.List(keys=['vrf-name'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__vrfs(yang.adata.MNode):
    vrf: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf

    mut def __init__(self, vrf: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.vrf = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(elements=vrf)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vrf = self.vrf
        if _vrf is not None:
            children['vrf'] = _vrf.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', module='Cisco-IOS-XR-um-vrf-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs(vrf=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf.from_gdata(n.get_opt_list('vrf')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrfs')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrfs()')
        leaves = []
        _vrf = self.vrf
        for _element in _vrf:
            res.append('')
            res.append("# List /vrfs/vrf element: {_element.to_gdata().key_str(['vrf-name'])}")
            list_elem = 'vrf_element = {self_name}.vrf.create({repr_yang(_element.vrf_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('vrf_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrfs'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_vrf = yang.gdata.from_xml_opt_list(node, 'vrf')
    yang.gdata.maybe_add(children, 'vrf', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf, child_vrf)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', module='Cisco-IOS-XR-um-vrf-cfg')

class Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /selective-vrf-download/disable')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /selective-vrf-download/disable'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:selective-vrf-download', 'disable'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download(yang.adata.MNode):
    disable: ?Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable

    mut def __init__(self, disable: ?Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.disable = disable

    mut def create_disable(self):
        existing = self.disable
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable()
        self.disable = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _disable = self.disable
        if _disable is not None:
            children['disable'] = _disable.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', module='Cisco-IOS-XR-um-vrf-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download(disable=Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable.from_gdata(n.get_opt_cnt('disable')))
        return Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /selective-vrf-download')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download()')
        leaves = []
        _disable = self.disable
        if _disable is not None:
            res.append('')
            res.append('# P-container: /selective-vrf-download/disable')
            res.append('disable = {self_name}.create_disable()')
            res.extend(_disable.prsrc('disable', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /selective-vrf-download'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:selective-vrf-download'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_disable = yang.gdata.from_xml_opt_cnt(node, 'disable')
    yang.gdata.maybe_add(children, 'disable', from_xml_Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable, child_disable)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', module='Cisco-IOS-XR-um-vrf-cfg')

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__names__name__srlg_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__names__name__value(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__names__name__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry(yang.adata.MNode):
    srlg_name: str
    value: ?bigint
    description: ?str

    mut def __init__(self, srlg_name: str, value: ?bigint, description: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.srlg_name = srlg_name
        self.value = value
        self.description = description

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _srlg_name = self.srlg_name
        if _srlg_name is not None:
            children['srlg-name'] = yang.gdata.Leaf('string', _srlg_name)
        _value = self.value
        if _value is not None:
            children['value'] = yang.gdata.Leaf('uint32', _value)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry(srlg_name=n.get_str('srlg-name'), value=n.get_opt_bigint('value'), description=n.get_opt_str('description'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/names/name')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__names__name({repr_yang(self.srlg_name)})')
        leaves = []
        _value = self.value
        if _value is not None:
            leaves.append('{self_name}.value = {repr_yang(_value)}')
        _description = self.description
        if _description is not None:
            leaves.append('{self_name}.description = {repr_yang(_description)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/names/name'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'names', 'name'])

class Cisco_IOS_XR_um_vrf_cfg__srlg__names__name(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'name'
        self.elements = elements

    mut def create(self, srlg_name):
        for e in self:
            match = True
            if e.srlg_name != srlg_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry(srlg_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['srlg-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__names__name(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__names__name(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_srlg_name = yang.gdata.from_xml_str(node, 'srlg-name')
    yang.gdata.maybe_add(children, 'srlg-name', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__names__name__srlg_name, child_srlg_name)
    child_value = yang.gdata.from_xml_opt_bigint(node, 'value')
    yang.gdata.maybe_add(children, 'value', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__names__name__value, child_value)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__names__name__description, child_description)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__names__name(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_element(e) for e in nodes]
    return yang.gdata.List(keys=['srlg-name'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__srlg__names(yang.adata.MNode):
    name: Cisco_IOS_XR_um_vrf_cfg__srlg__names__name

    mut def __init__(self, name: list[Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.name = Cisco_IOS_XR_um_vrf_cfg__srlg__names__name(elements=name)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = _name.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__names:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__names(name=Cisco_IOS_XR_um_vrf_cfg__srlg__names__name.from_gdata(n.get_opt_list('name')))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__names()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__names.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/names')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__names()')
        leaves = []
        _name = self.name
        for _element in _name:
            res.append('')
            res.append("# List /srlg/names/name element: {_element.to_gdata().key_str(['srlg-name'])}")
            list_elem = 'name_element = {self_name}.name.create({repr_yang(_element.srlg_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('name_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/names'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'names'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__names(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_name = yang.gdata.from_xml_opt_list(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__names__name, child_name)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__interface_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical__priority(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical(yang.adata.MNode):
    priority: ?str

    mut def __init__(self, priority: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.priority = priority

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _priority = self.priority
        if _priority is not None:
            children['priority'] = yang.gdata.Leaf('enumeration', _priority)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical(priority=n.get_opt_str('priority'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/interfaces/interface/include-optical')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical()')
        leaves = []
        _priority = self.priority
        if _priority is not None:
            leaves.append('{self_name}.priority = {repr_yang(_priority)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/interfaces/interface/include-optical'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface', 'include-optical'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_priority = yang.gdata.from_xml_opt_str(node, 'priority')
    yang.gdata.maybe_add(children, 'priority', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical__priority, child_priority)
    return yang.gdata.Container(children, presence=True)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index__index_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index__value(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index__priority(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry(yang.adata.MNode):
    index_number: bigint
    value: ?bigint
    priority: ?str

    mut def __init__(self, index_number: bigint, value: ?bigint, priority: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.index_number = index_number
        self.value = value
        self.priority = priority

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _index_number = self.index_number
        if _index_number is not None:
            children['index-number'] = yang.gdata.Leaf('uint32', _index_number)
        _value = self.value
        if _value is not None:
            children['value'] = yang.gdata.Leaf('uint32', _value)
        _priority = self.priority
        if _priority is not None:
            children['priority'] = yang.gdata.Leaf('enumeration', _priority)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry(index_number=n.get_bigint('index-number'), value=n.get_opt_bigint('value'), priority=n.get_opt_str('priority'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/interfaces/interface/indexes/index')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index({repr_yang(self.index_number)})')
        leaves = []
        _value = self.value
        if _value is not None:
            leaves.append('{self_name}.value = {repr_yang(_value)}')
        _priority = self.priority
        if _priority is not None:
            leaves.append('{self_name}.priority = {repr_yang(_priority)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/interfaces/interface/indexes/index'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface', 'indexes', 'index'])

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'index'
        self.elements = elements

    mut def create(self, index_number, value, priority):
        for e in self:
            match = True
            if e.index_number != index_number:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry(index_number, value, priority)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['index-number'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_index_number = yang.gdata.from_xml_bigint(node, 'index-number')
    yang.gdata.maybe_add(children, 'index-number', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index__index_number, child_index_number)
    child_value = yang.gdata.from_xml_opt_bigint(node, 'value')
    yang.gdata.maybe_add(children, 'value', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index__value, child_value)
    child_priority = yang.gdata.from_xml_opt_str(node, 'priority')
    yang.gdata.maybe_add(children, 'priority', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index__priority, child_priority)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_element(e) for e in nodes]
    return yang.gdata.List(keys=['index-number'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes(yang.adata.MNode):
    index: Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index

    mut def __init__(self, index: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.index = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index(elements=index)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _index = self.index
        if _index is not None:
            children['index'] = _index.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes(index=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index.from_gdata(n.get_opt_list('index')))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/interfaces/interface/indexes')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes()')
        leaves = []
        _index = self.index
        for _element in _index:
            res.append('')
            res.append("# List /srlg/interfaces/interface/indexes/index element: {_element.to_gdata().key_str(['index-number'])}")
            list_elem = 'index_element = {self_name}.index.create({repr_yang(_element.index_number)})'
            res.append(list_elem)
            res.extend(_element.prsrc('index_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/interfaces/interface/indexes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface', 'indexes'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_index = yang.gdata.from_xml_opt_list(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index, child_index)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name__srlg_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry(yang.adata.MNode):
    srlg_name: str

    mut def __init__(self, srlg_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.srlg_name = srlg_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _srlg_name = self.srlg_name
        if _srlg_name is not None:
            children['srlg-name'] = yang.gdata.Leaf('string', _srlg_name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry(srlg_name=n.get_str('srlg-name'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/interfaces/interface/names/name')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name({repr_yang(self.srlg_name)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/interfaces/interface/names/name'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface', 'names', 'name'])

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'name'
        self.elements = elements

    mut def create(self, srlg_name):
        for e in self:
            match = True
            if e.srlg_name != srlg_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry(srlg_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['srlg-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_srlg_name = yang.gdata.from_xml_str(node, 'srlg-name')
    yang.gdata.maybe_add(children, 'srlg-name', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name__srlg_name, child_srlg_name)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_element(e) for e in nodes]
    return yang.gdata.List(keys=['srlg-name'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names(yang.adata.MNode):
    name: Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name

    mut def __init__(self, name: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.name = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name(elements=name)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = _name.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names(name=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name.from_gdata(n.get_opt_list('name')))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/interfaces/interface/names')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names()')
        leaves = []
        _name = self.name
        for _element in _name:
            res.append('')
            res.append("# List /srlg/interfaces/interface/names/name element: {_element.to_gdata().key_str(['srlg-name'])}")
            list_elem = 'name_element = {self_name}.name.create({repr_yang(_element.srlg_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('name_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/interfaces/interface/names'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface', 'names'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_name = yang.gdata.from_xml_opt_list(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name, child_name)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group__index_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group__group_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry(yang.adata.MNode):
    index_number: bigint
    group_name: ?str

    mut def __init__(self, index_number: bigint, group_name: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.index_number = index_number
        self.group_name = group_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _index_number = self.index_number
        if _index_number is not None:
            children['index-number'] = yang.gdata.Leaf('uint32', _index_number)
        _group_name = self.group_name
        if _group_name is not None:
            children['group-name'] = yang.gdata.Leaf('string', _group_name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry(index_number=n.get_bigint('index-number'), group_name=n.get_opt_str('group-name'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/interfaces/interface/groups/group')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group({repr_yang(self.index_number)})')
        leaves = []
        _group_name = self.group_name
        if _group_name is not None:
            leaves.append('{self_name}.group_name = {repr_yang(_group_name)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/interfaces/interface/groups/group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface', 'groups', 'group'])

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'group'
        self.elements = elements

    mut def create(self, index_number, group_name):
        for e in self:
            match = True
            if e.index_number != index_number:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry(index_number, group_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['index-number'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_index_number = yang.gdata.from_xml_bigint(node, 'index-number')
    yang.gdata.maybe_add(children, 'index-number', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group__index_number, child_index_number)
    child_group_name = yang.gdata.from_xml_opt_str(node, 'group-name')
    yang.gdata.maybe_add(children, 'group-name', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group__group_name, child_group_name)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_element(e) for e in nodes]
    return yang.gdata.List(keys=['index-number'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups(yang.adata.MNode):
    group: Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group

    mut def __init__(self, group: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.group = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group(elements=group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups(group=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group.from_gdata(n.get_opt_list('group')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/interfaces/interface/groups')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups()')
        leaves = []
        _group = self.group
        for _element in _group:
            res.append('')
            res.append("# List /srlg/interfaces/interface/groups/group element: {_element.to_gdata().key_str(['index-number'])}")
            list_elem = 'group_element = {self_name}.group.create({repr_yang(_element.index_number)})'
            res.append(list_elem)
            res.extend(_element.prsrc('group_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/interfaces/interface/groups'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface', 'groups'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.from_xml_opt_list(node, 'group')
    yang.gdata.maybe_add(children, 'group', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group, child_group)
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry(yang.adata.MNode):
    interface_name: str
    include_optical: ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical
    indexes: Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes
    names: Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names
    groups: ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups

    mut def __init__(self, interface_name: str, include_optical: ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical=None, indexes: ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes=None, names: ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names=None, groups: ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.interface_name = interface_name
        self.include_optical = include_optical
        self.indexes = indexes if indexes is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes()
        self.names = names if names is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names()
        self.groups = groups

    mut def create_include_optical(self):
        existing = self.include_optical
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical()
        self.include_optical = res
        return res

    mut def create_groups(self):
        existing = self.groups
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups()
        self.groups = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _interface_name = self.interface_name
        if _interface_name is not None:
            children['interface-name'] = yang.gdata.Leaf('string', _interface_name)
        _include_optical = self.include_optical
        if _include_optical is not None:
            children['include-optical'] = _include_optical.to_gdata()
        _indexes = self.indexes
        if _indexes is not None:
            children['indexes'] = _indexes.to_gdata()
        _names = self.names
        if _names is not None:
            children['names'] = _names.to_gdata()
        _groups = self.groups
        if _groups is not None:
            children['groups'] = _groups.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry(interface_name=n.get_str('interface-name'), include_optical=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical.from_gdata(n.get_opt_cnt('include-optical')), indexes=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes.from_gdata(n.get_opt_cnt('indexes')), names=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names.from_gdata(n.get_opt_cnt('names')), groups=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups.from_gdata(n.get_opt_cnt('groups')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/interfaces/interface')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface({repr_yang(self.interface_name)})')
        leaves = []
        _include_optical = self.include_optical
        if _include_optical is not None:
            res.append('')
            res.append('# P-container: /srlg/interfaces/interface/include-optical')
            res.append('include_optical = {self_name}.create_include_optical()')
            res.extend(_include_optical.prsrc('include_optical', False).splitlines())
        _indexes = self.indexes
        if _indexes is not None:
            res.extend(_indexes.prsrc('{self_name}.indexes', False).splitlines())
        _names = self.names
        if _names is not None:
            res.extend(_names.prsrc('{self_name}.names', False).splitlines())
        _groups = self.groups
        if _groups is not None:
            res.append('')
            res.append('# P-container: /srlg/interfaces/interface/groups')
            res.append('groups = {self_name}.create_groups()')
            res.extend(_groups.prsrc('groups', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/interfaces/interface'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface'])

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'interface'
        self.elements = elements

    mut def create(self, interface_name):
        for e in self:
            match = True
            if e.interface_name != interface_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry(interface_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['interface-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_interface_name = yang.gdata.from_xml_str(node, 'interface-name')
    yang.gdata.maybe_add(children, 'interface-name', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__interface_name, child_interface_name)
    child_include_optical = yang.gdata.from_xml_opt_cnt(node, 'include-optical')
    yang.gdata.maybe_add(children, 'include-optical', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical, child_include_optical)
    child_indexes = yang.gdata.from_xml_opt_cnt(node, 'indexes')
    yang.gdata.maybe_add(children, 'indexes', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes, child_indexes)
    child_names = yang.gdata.from_xml_opt_cnt(node, 'names')
    yang.gdata.maybe_add(children, 'names', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names, child_names)
    child_groups = yang.gdata.from_xml_opt_cnt(node, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups, child_groups)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_element(e) for e in nodes]
    return yang.gdata.List(keys=['interface-name'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces(yang.adata.MNode):
    interface: Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface

    mut def __init__(self, interface: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.interface = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface(elements=interface)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _interface = self.interface
        if _interface is not None:
            children['interface'] = _interface.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces(interface=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface.from_gdata(n.get_opt_list('interface')))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/interfaces')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces()')
        leaves = []
        _interface = self.interface
        for _element in _interface:
            res.append('')
            res.append("# List /srlg/interfaces/interface element: {_element.to_gdata().key_str(['interface-name'])}")
            list_elem = 'interface_element = {self_name}.interface.create({repr_yang(_element.interface_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('interface_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/interfaces'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_interface = yang.gdata.from_xml_opt_list(node, 'interface')
    yang.gdata.maybe_add(children, 'interface', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface, child_interface)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__group_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index__index_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index__value(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index__priority(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry(yang.adata.MNode):
    index_number: bigint
    value: ?bigint
    priority: ?str

    mut def __init__(self, index_number: bigint, value: ?bigint, priority: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.index_number = index_number
        self.value = value
        self.priority = priority

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _index_number = self.index_number
        if _index_number is not None:
            children['index-number'] = yang.gdata.Leaf('uint32', _index_number)
        _value = self.value
        if _value is not None:
            children['value'] = yang.gdata.Leaf('uint32', _value)
        _priority = self.priority
        if _priority is not None:
            children['priority'] = yang.gdata.Leaf('enumeration', _priority)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry(index_number=n.get_bigint('index-number'), value=n.get_opt_bigint('value'), priority=n.get_opt_str('priority'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/groups/group/indexes/index')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index({repr_yang(self.index_number)})')
        leaves = []
        _value = self.value
        if _value is not None:
            leaves.append('{self_name}.value = {repr_yang(_value)}')
        _priority = self.priority
        if _priority is not None:
            leaves.append('{self_name}.priority = {repr_yang(_priority)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/groups/group/indexes/index'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'groups', 'group', 'indexes', 'index'])

class Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'index'
        self.elements = elements

    mut def create(self, index_number, value, priority):
        for e in self:
            match = True
            if e.index_number != index_number:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry(index_number, value, priority)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['index-number'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_index_number = yang.gdata.from_xml_bigint(node, 'index-number')
    yang.gdata.maybe_add(children, 'index-number', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index__index_number, child_index_number)
    child_value = yang.gdata.from_xml_opt_bigint(node, 'value')
    yang.gdata.maybe_add(children, 'value', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index__value, child_value)
    child_priority = yang.gdata.from_xml_opt_str(node, 'priority')
    yang.gdata.maybe_add(children, 'priority', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index__priority, child_priority)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_element(e) for e in nodes]
    return yang.gdata.List(keys=['index-number'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes(yang.adata.MNode):
    index: Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index

    mut def __init__(self, index: list[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.index = Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index(elements=index)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _index = self.index
        if _index is not None:
            children['index'] = _index.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes(index=Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index.from_gdata(n.get_opt_list('index')))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/groups/group/indexes')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes()')
        leaves = []
        _index = self.index
        for _element in _index:
            res.append('')
            res.append("# List /srlg/groups/group/indexes/index element: {_element.to_gdata().key_str(['index-number'])}")
            list_elem = 'index_element = {self_name}.index.create({repr_yang(_element.index_number)})'
            res.append(list_elem)
            res.extend(_element.prsrc('index_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/groups/group/indexes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'groups', 'group', 'indexes'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_index = yang.gdata.from_xml_opt_list(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index, child_index)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry(yang.adata.MNode):
    group_name: str
    indexes: Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes

    mut def __init__(self, group_name: str, indexes: ?Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.group_name = group_name
        self.indexes = indexes if indexes is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_name = self.group_name
        if _group_name is not None:
            children['group-name'] = yang.gdata.Leaf('string', _group_name)
        _indexes = self.indexes
        if _indexes is not None:
            children['indexes'] = _indexes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry(group_name=n.get_str('group-name'), indexes=Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes.from_gdata(n.get_opt_cnt('indexes')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/groups/group')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group({repr_yang(self.group_name)})')
        leaves = []
        _indexes = self.indexes
        if _indexes is not None:
            res.extend(_indexes.prsrc('{self_name}.indexes', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/groups/group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'groups', 'group'])

class Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_name):
        for e in self:
            match = True
            if e.group_name != group_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry(group_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_group_name = yang.gdata.from_xml_str(node, 'group-name')
    yang.gdata.maybe_add(children, 'group-name', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__group_name, child_group_name)
    child_indexes = yang.gdata.from_xml_opt_cnt(node, 'indexes')
    yang.gdata.maybe_add(children, 'indexes', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes, child_indexes)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_element(e) for e in nodes]
    return yang.gdata.List(keys=['group-name'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__srlg__groups(yang.adata.MNode):
    group: Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group

    mut def __init__(self, group: list[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.group = Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group(elements=group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__groups:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__groups(group=Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group.from_gdata(n.get_opt_list('group')))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/groups')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__groups()')
        leaves = []
        _group = self.group
        for _element in _group:
            res.append('')
            res.append("# List /srlg/groups/group element: {_element.to_gdata().key_str(['group-name'])}")
            list_elem = 'group_element = {self_name}.group.create({repr_yang(_element.group_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('group_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/groups'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'groups'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__groups(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_group = yang.gdata.from_xml_opt_list(node, 'group')
    yang.gdata.maybe_add(children, 'group', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group, child_group)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__location_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index__index_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index__value(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index__priority(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry(yang.adata.MNode):
    index_number: bigint
    value: ?bigint
    priority: ?str

    mut def __init__(self, index_number: bigint, value: ?bigint, priority: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.index_number = index_number
        self.value = value
        self.priority = priority

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _index_number = self.index_number
        if _index_number is not None:
            children['index-number'] = yang.gdata.Leaf('uint32', _index_number)
        _value = self.value
        if _value is not None:
            children['value'] = yang.gdata.Leaf('uint32', _value)
        _priority = self.priority
        if _priority is not None:
            children['priority'] = yang.gdata.Leaf('enumeration', _priority)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry(index_number=n.get_bigint('index-number'), value=n.get_opt_bigint('value'), priority=n.get_opt_str('priority'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/inherit-locations/inherit-location/indexes/index')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index({repr_yang(self.index_number)})')
        leaves = []
        _value = self.value
        if _value is not None:
            leaves.append('{self_name}.value = {repr_yang(_value)}')
        _priority = self.priority
        if _priority is not None:
            leaves.append('{self_name}.priority = {repr_yang(_priority)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/inherit-locations/inherit-location/indexes/index'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'inherit-locations', 'inherit-location', 'indexes', 'index'])

class Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'index'
        self.elements = elements

    mut def create(self, index_number, value, priority):
        for e in self:
            match = True
            if e.index_number != index_number:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry(index_number, value, priority)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['index-number'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_index_number = yang.gdata.from_xml_bigint(node, 'index-number')
    yang.gdata.maybe_add(children, 'index-number', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index__index_number, child_index_number)
    child_value = yang.gdata.from_xml_opt_bigint(node, 'value')
    yang.gdata.maybe_add(children, 'value', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index__value, child_value)
    child_priority = yang.gdata.from_xml_opt_str(node, 'priority')
    yang.gdata.maybe_add(children, 'priority', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index__priority, child_priority)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_element(e) for e in nodes]
    return yang.gdata.List(keys=['index-number'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes(yang.adata.MNode):
    index: Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index

    mut def __init__(self, index: list[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.index = Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index(elements=index)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _index = self.index
        if _index is not None:
            children['index'] = _index.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes(index=Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index.from_gdata(n.get_opt_list('index')))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/inherit-locations/inherit-location/indexes')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes()')
        leaves = []
        _index = self.index
        for _element in _index:
            res.append('')
            res.append("# List /srlg/inherit-locations/inherit-location/indexes/index element: {_element.to_gdata().key_str(['index-number'])}")
            list_elem = 'index_element = {self_name}.index.create({repr_yang(_element.index_number)})'
            res.append(list_elem)
            res.extend(_element.prsrc('index_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/inherit-locations/inherit-location/indexes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'inherit-locations', 'inherit-location', 'indexes'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_index = yang.gdata.from_xml_opt_list(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index, child_index)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry(yang.adata.MNode):
    location_name: str
    indexes: Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes

    mut def __init__(self, location_name: str, indexes: ?Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.location_name = location_name
        self.indexes = indexes if indexes is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _location_name = self.location_name
        if _location_name is not None:
            children['location-name'] = yang.gdata.Leaf('string', _location_name)
        _indexes = self.indexes
        if _indexes is not None:
            children['indexes'] = _indexes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry(location_name=n.get_str('location-name'), indexes=Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes.from_gdata(n.get_opt_cnt('indexes')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/inherit-locations/inherit-location')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location({repr_yang(self.location_name)})')
        leaves = []
        _indexes = self.indexes
        if _indexes is not None:
            res.extend(_indexes.prsrc('{self_name}.indexes', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/inherit-locations/inherit-location'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'inherit-locations', 'inherit-location'])

class Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'inherit-location'
        self.elements = elements

    mut def create(self, location_name):
        for e in self:
            match = True
            if e.location_name != location_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry(location_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['location-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_location_name = yang.gdata.from_xml_str(node, 'location-name')
    yang.gdata.maybe_add(children, 'location-name', from_data_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__location_name, child_location_name)
    child_indexes = yang.gdata.from_xml_opt_cnt(node, 'indexes')
    yang.gdata.maybe_add(children, 'indexes', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes, child_indexes)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_element(e) for e in nodes]
    return yang.gdata.List(keys=['location-name'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations(yang.adata.MNode):
    inherit_location: Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location

    mut def __init__(self, inherit_location: list[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.inherit_location = Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location(elements=inherit_location)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _inherit_location = self.inherit_location
        if _inherit_location is not None:
            children['inherit-location'] = _inherit_location.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations(inherit_location=Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location.from_gdata(n.get_opt_list('inherit-location')))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg/inherit-locations')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations()')
        leaves = []
        _inherit_location = self.inherit_location
        for _element in _inherit_location:
            res.append('')
            res.append("# List /srlg/inherit-locations/inherit-location element: {_element.to_gdata().key_str(['location-name'])}")
            list_elem = 'inherit_location_element = {self_name}.inherit_location.create({repr_yang(_element.location_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('inherit_location_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg/inherit-locations'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'inherit-locations'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_inherit_location = yang.gdata.from_xml_opt_list(node, 'inherit-location')
    yang.gdata.maybe_add(children, 'inherit-location', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location, child_inherit_location)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__srlg(yang.adata.MNode):
    names: Cisco_IOS_XR_um_vrf_cfg__srlg__names
    interfaces: Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces
    groups: Cisco_IOS_XR_um_vrf_cfg__srlg__groups
    inherit_locations: Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations

    mut def __init__(self, names: ?Cisco_IOS_XR_um_vrf_cfg__srlg__names=None, interfaces: ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces=None, groups: ?Cisco_IOS_XR_um_vrf_cfg__srlg__groups=None, inherit_locations: ?Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.names = names if names is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__names()
        self.interfaces = interfaces if interfaces is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces()
        self.groups = groups if groups is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__groups()
        self.inherit_locations = inherit_locations if inherit_locations is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _names = self.names
        if _names is not None:
            children['names'] = _names.to_gdata()
        _interfaces = self.interfaces
        if _interfaces is not None:
            children['interfaces'] = _interfaces.to_gdata()
        _groups = self.groups
        if _groups is not None:
            children['groups'] = _groups.to_gdata()
        _inherit_locations = self.inherit_locations
        if _inherit_locations is not None:
            children['inherit-locations'] = _inherit_locations.to_gdata()
        return yang.gdata.Container(children, presence=True, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', module='Cisco-IOS-XR-um-vrf-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__srlg:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg(names=Cisco_IOS_XR_um_vrf_cfg__srlg__names.from_gdata(n.get_opt_cnt('names')), interfaces=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces.from_gdata(n.get_opt_cnt('interfaces')), groups=Cisco_IOS_XR_um_vrf_cfg__srlg__groups.from_gdata(n.get_opt_cnt('groups')), inherit_locations=Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations.from_gdata(n.get_opt_cnt('inherit-locations')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__srlg.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__srlg.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /srlg')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__srlg()')
        leaves = []
        _names = self.names
        if _names is not None:
            res.extend(_names.prsrc('{self_name}.names', False).splitlines())
        _interfaces = self.interfaces
        if _interfaces is not None:
            res.extend(_interfaces.prsrc('{self_name}.interfaces', False).splitlines())
        _groups = self.groups
        if _groups is not None:
            res.extend(_groups.prsrc('{self_name}.groups', False).splitlines())
        _inherit_locations = self.inherit_locations
        if _inherit_locations is not None:
            res.extend(_inherit_locations.prsrc('{self_name}.inherit_locations', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /srlg'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_names = yang.gdata.from_xml_opt_cnt(node, 'names')
    yang.gdata.maybe_add(children, 'names', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__names, child_names)
    child_interfaces = yang.gdata.from_xml_opt_cnt(node, 'interfaces')
    yang.gdata.maybe_add(children, 'interfaces', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces, child_interfaces)
    child_groups = yang.gdata.from_xml_opt_cnt(node, 'groups')
    yang.gdata.maybe_add(children, 'groups', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__groups, child_groups)
    child_inherit_locations = yang.gdata.from_xml_opt_cnt(node, 'inherit-locations')
    yang.gdata.maybe_add(children, 'inherit-locations', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations, child_inherit_locations)
    return yang.gdata.Container(children, presence=True, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', module='Cisco-IOS-XR-um-vrf-cfg')

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__group_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf__vrf_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry(yang.adata.MNode):
    vrf_name: str

    mut def __init__(self, vrf_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.vrf_name = vrf_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vrf_name = self.vrf_name
        if _vrf_name is not None:
            children['vrf-name'] = yang.gdata.Leaf('string', _vrf_name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry(vrf_name=n.get_str('vrf-name'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrf-groups/vrf-group/vrfs/vrf')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf({repr_yang(self.vrf_name)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrf-groups/vrf-group/vrfs/vrf'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrf-groups', 'vrf-group', 'vrfs', 'vrf'])

class Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'vrf'
        self.elements = elements

    mut def create(self, vrf_name):
        for e in self:
            match = True
            if e.vrf_name != vrf_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry(vrf_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vrf-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf(Iterable[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_vrf_name = yang.gdata.from_xml_str(node, 'vrf-name')
    yang.gdata.maybe_add(children, 'vrf-name', from_data_Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf__vrf_name, child_vrf_name)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_element(e) for e in nodes]
    return yang.gdata.List(keys=['vrf-name'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs(yang.adata.MNode):
    vrf: Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf

    mut def __init__(self, vrf: list[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.vrf = Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf(elements=vrf)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vrf = self.vrf
        if _vrf is not None:
            children['vrf'] = _vrf.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs(vrf=Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf.from_gdata(n.get_opt_list('vrf')))
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrf-groups/vrf-group/vrfs')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs()')
        leaves = []
        _vrf = self.vrf
        for _element in _vrf:
            res.append('')
            res.append("# List /vrf-groups/vrf-group/vrfs/vrf element: {_element.to_gdata().key_str(['vrf-name'])}")
            list_elem = 'vrf_element = {self_name}.vrf.create({repr_yang(_element.vrf_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('vrf_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrf-groups/vrf-group/vrfs'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrf-groups', 'vrf-group', 'vrfs'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_vrf = yang.gdata.from_xml_opt_list(node, 'vrf')
    yang.gdata.maybe_add(children, 'vrf', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf, child_vrf)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry(yang.adata.MNode):
    group_name: str
    vrfs: Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs

    mut def __init__(self, group_name: str, vrfs: ?Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.group_name = group_name
        self.vrfs = vrfs if vrfs is not None else Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_name = self.group_name
        if _group_name is not None:
            children['group-name'] = yang.gdata.Leaf('string', _group_name)
        _vrfs = self.vrfs
        if _vrfs is not None:
            children['vrfs'] = _vrfs.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry(group_name=n.get_str('group-name'), vrfs=Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs.from_gdata(n.get_opt_cnt('vrfs')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrf-groups/vrf-group')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group({repr_yang(self.group_name)})')
        leaves = []
        _vrfs = self.vrfs
        if _vrfs is not None:
            res.extend(_vrfs.prsrc('{self_name}.vrfs', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrf-groups/vrf-group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrf-groups', 'vrf-group'])

class Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'vrf-group'
        self.elements = elements

    mut def create(self, group_name):
        for e in self:
            match = True
            if e.group_name != group_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry(group_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group(Iterable[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_group_name = yang.gdata.from_xml_str(node, 'group-name')
    yang.gdata.maybe_add(children, 'group-name', from_data_Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__group_name, child_group_name)
    child_vrfs = yang.gdata.from_xml_opt_cnt(node, 'vrfs')
    yang.gdata.maybe_add(children, 'vrfs', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs, child_vrfs)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_element(e) for e in nodes]
    return yang.gdata.List(keys=['group-name'], elements=elements)

class Cisco_IOS_XR_um_vrf_cfg__vrf_groups(yang.adata.MNode):
    vrf_group: Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group

    mut def __init__(self, vrf_group: list[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.vrf_group = Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group(elements=vrf_group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vrf_group = self.vrf_group
        if _vrf_group is not None:
            children['vrf-group'] = _vrf_group.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', module='Cisco-IOS-XR-um-vrf-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrf_groups:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrf_groups(vrf_group=Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group.from_gdata(n.get_opt_list('vrf-group')))
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /vrf-groups')
            res.append('{self_name} = Cisco_IOS_XR_um_vrf_cfg__vrf_groups()')
        leaves = []
        _vrf_group = self.vrf_group
        for _element in _vrf_group:
            res.append('')
            res.append("# List /vrf-groups/vrf-group element: {_element.to_gdata().key_str(['group-name'])}")
            list_elem = 'vrf_group_element = {self_name}.vrf_group.create({repr_yang(_element.group_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('vrf_group_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /vrf-groups'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrf-groups'])


mut def from_xml_Cisco_IOS_XR_um_vrf_cfg__vrf_groups(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_vrf_group = yang.gdata.from_xml_opt_list(node, 'vrf-group')
    yang.gdata.maybe_add(children, 'vrf-group', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group, child_vrf_group)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', module='Cisco-IOS-XR-um-vrf-cfg')

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__process_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__is_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net__net_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry(yang.adata.MNode):
    net_id: str

    mut def __init__(self, net_id: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.net_id = net_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _net_id = self.net_id
        if _net_id is not None:
            children['net-id'] = yang.gdata.Leaf('string', _net_id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry:
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry(net_id=n.get_str('net-id'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/nets/net')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net({repr_yang(self.net_id)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/nets/net'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'nets', 'net'])

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self._name = 'net'
        self.elements = elements

    mut def create(self, net_id):
        for e in self:
            match = True
            if e.net_id != net_id:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry(net_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['net-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net(elements=copied_elements)

extension Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net(Iterable[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_net_id = yang.gdata.from_xml_str(node, 'net-id')
    yang.gdata.maybe_add(children, 'net-id', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net__net_id, child_net_id)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_element(e) for e in nodes]
    return yang.gdata.List(keys=['net-id'], elements=elements)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets(yang.adata.MNode):
    net: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net

    mut def __init__(self, net: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.net = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net(elements=net)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _net = self.net
        if _net is not None:
            children['net'] = _net.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets(net=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net.from_gdata(n.get_opt_list('net')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/nets')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets()')
        leaves = []
        _net = self.net
        for _element in _net:
            res.append('')
            res.append("# List /um-router-isis-cfg:router/isis/processes/process/nets/net element: {_element.to_gdata().key_str(['net-id'])}")
            list_elem = 'net_element = {self_name}.net.create({repr_yang(_element.net_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('net_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/nets'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'nets'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_net = yang.gdata.from_xml_opt_list(node, 'net')
    yang.gdata.maybe_add(children, 'net', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net, child_net)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__af_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__saf_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls__sr_prefer(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls(yang.adata.MNode):
    sr_prefer: ?bool

    mut def __init__(self, sr_prefer: ?bool):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.sr_prefer = sr_prefer

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _sr_prefer = self.sr_prefer
        if _sr_prefer is not None:
            children['sr-prefer'] = yang.gdata.Leaf('boolean', _sr_prefer)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls(sr_prefer=n.get_opt_bool('sr-prefer'))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/segment-routing/mpls')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls()')
        leaves = []
        _sr_prefer = self.sr_prefer
        if _sr_prefer is not None:
            leaves.append('{self_name}.sr_prefer = {repr_yang(_sr_prefer)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/segment-routing/mpls'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'segment-routing', 'mpls'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_sr_prefer = yang.gdata.from_xml_opt_bool(node, 'sr-prefer')
    yang.gdata.maybe_add(children, 'sr-prefer', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls__sr_prefer, child_sr_prefer)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing(yang.adata.MNode):
    mpls: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls

    mut def __init__(self, mpls: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.mpls = mpls if mpls is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _mpls = self.mpls
        if _mpls is not None:
            children['mpls'] = _mpls.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing(mpls=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls.from_gdata(n.get_opt_cnt('mpls')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/segment-routing')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing()')
        leaves = []
        _mpls = self.mpls
        if _mpls is not None:
            res.extend(_mpls.prsrc('{self_name}.mpls', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/segment-routing'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'segment-routing'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_mpls = yang.gdata.from_xml_opt_cnt(node, 'mpls')
    yang.gdata.maybe_add(children, 'mpls', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls, child_mpls)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/narrow')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/narrow'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'narrow'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/wide')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/wide'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'wide'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/transition')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/transition'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'transition'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__level_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/levels/level/narrow')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/levels/level/narrow'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'levels', 'level', 'narrow'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/levels/level/wide')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/levels/level/wide'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'levels', 'level', 'wide'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/levels/level/transition')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/levels/level/transition'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'levels', 'level', 'transition'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry(yang.adata.MNode):
    level_id: bigint
    narrow: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow
    wide: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide
    transition: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition

    mut def __init__(self, level_id: bigint, narrow: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow=None, wide: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide=None, transition: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.level_id = level_id
        self.narrow = narrow
        self.wide = wide
        self.transition = transition

    mut def create_narrow(self):
        existing = self.narrow
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow()
        self.narrow = res
        return res

    mut def create_wide(self):
        existing = self.wide
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide()
        self.wide = res
        return res

    mut def create_transition(self):
        existing = self.transition
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition()
        self.transition = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _level_id = self.level_id
        if _level_id is not None:
            children['level-id'] = yang.gdata.Leaf('uint32', _level_id)
        _narrow = self.narrow
        if _narrow is not None:
            children['narrow'] = _narrow.to_gdata()
        _wide = self.wide
        if _wide is not None:
            children['wide'] = _wide.to_gdata()
        _transition = self.transition
        if _transition is not None:
            children['transition'] = _transition.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry:
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry(level_id=n.get_bigint('level-id'), narrow=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow.from_gdata(n.get_opt_cnt('narrow')), wide=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide.from_gdata(n.get_opt_cnt('wide')), transition=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition.from_gdata(n.get_opt_cnt('transition')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/levels/level')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level({repr_yang(self.level_id)})')
        leaves = []
        _narrow = self.narrow
        if _narrow is not None:
            res.append('')
            res.append('# P-container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/levels/level/narrow')
            res.append('narrow = {self_name}.create_narrow()')
            res.extend(_narrow.prsrc('narrow', False).splitlines())
        _wide = self.wide
        if _wide is not None:
            res.append('')
            res.append('# P-container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/levels/level/wide')
            res.append('wide = {self_name}.create_wide()')
            res.extend(_wide.prsrc('wide', False).splitlines())
        _transition = self.transition
        if _transition is not None:
            res.append('')
            res.append('# P-container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/levels/level/transition')
            res.append('transition = {self_name}.create_transition()')
            res.extend(_transition.prsrc('transition', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/levels/level'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'levels', 'level'])

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self._name = 'level'
        self.elements = elements

    mut def create(self, level_id):
        for e in self:
            match = True
            if e.level_id != level_id:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry(level_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['level-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level(elements=copied_elements)

extension Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level(Iterable[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_level_id = yang.gdata.from_xml_bigint(node, 'level-id')
    yang.gdata.maybe_add(children, 'level-id', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__level_id, child_level_id)
    child_narrow = yang.gdata.from_xml_opt_cnt(node, 'narrow')
    yang.gdata.maybe_add(children, 'narrow', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow, child_narrow)
    child_wide = yang.gdata.from_xml_opt_cnt(node, 'wide')
    yang.gdata.maybe_add(children, 'wide', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide, child_wide)
    child_transition = yang.gdata.from_xml_opt_cnt(node, 'transition')
    yang.gdata.maybe_add(children, 'transition', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition, child_transition)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_element(e) for e in nodes]
    return yang.gdata.List(keys=['level-id'], elements=elements)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels(yang.adata.MNode):
    level: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level

    mut def __init__(self, level: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.level = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level(elements=level)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _level = self.level
        if _level is not None:
            children['level'] = _level.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels(level=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level.from_gdata(n.get_opt_list('level')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/levels')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels()')
        leaves = []
        _level = self.level
        for _element in _level:
            res.append('')
            res.append("# List /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/levels/level element: {_element.to_gdata().key_str(['level-id'])}")
            list_elem = 'level_element = {self_name}.level.create({repr_yang(_element.level_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('level_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/levels'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'levels'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_level = yang.gdata.from_xml_opt_list(node, 'level')
    yang.gdata.maybe_add(children, 'level', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level, child_level)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style(yang.adata.MNode):
    narrow: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow
    wide: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide
    transition: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition
    levels: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels

    mut def __init__(self, narrow: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow=None, wide: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide=None, transition: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition=None, levels: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.narrow = narrow
        self.wide = wide
        self.transition = transition
        self.levels = levels if levels is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels()

    mut def create_narrow(self):
        existing = self.narrow
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow()
        self.narrow = res
        return res

    mut def create_wide(self):
        existing = self.wide
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide()
        self.wide = res
        return res

    mut def create_transition(self):
        existing = self.transition
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition()
        self.transition = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _narrow = self.narrow
        if _narrow is not None:
            children['narrow'] = _narrow.to_gdata()
        _wide = self.wide
        if _wide is not None:
            children['wide'] = _wide.to_gdata()
        _transition = self.transition
        if _transition is not None:
            children['transition'] = _transition.to_gdata()
        _levels = self.levels
        if _levels is not None:
            children['levels'] = _levels.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style(narrow=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow.from_gdata(n.get_opt_cnt('narrow')), wide=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide.from_gdata(n.get_opt_cnt('wide')), transition=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition.from_gdata(n.get_opt_cnt('transition')), levels=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels.from_gdata(n.get_opt_cnt('levels')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style()')
        leaves = []
        _narrow = self.narrow
        if _narrow is not None:
            res.append('')
            res.append('# P-container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/narrow')
            res.append('narrow = {self_name}.create_narrow()')
            res.extend(_narrow.prsrc('narrow', False).splitlines())
        _wide = self.wide
        if _wide is not None:
            res.append('')
            res.append('# P-container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/wide')
            res.append('wide = {self_name}.create_wide()')
            res.extend(_wide.prsrc('wide', False).splitlines())
        _transition = self.transition
        if _transition is not None:
            res.append('')
            res.append('# P-container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style/transition')
            res.append('transition = {self_name}.create_transition()')
            res.extend(_transition.prsrc('transition', False).splitlines())
        _levels = self.levels
        if _levels is not None:
            res.extend(_levels.prsrc('{self_name}.levels', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family/metric-style'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_narrow = yang.gdata.from_xml_opt_cnt(node, 'narrow')
    yang.gdata.maybe_add(children, 'narrow', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow, child_narrow)
    child_wide = yang.gdata.from_xml_opt_cnt(node, 'wide')
    yang.gdata.maybe_add(children, 'wide', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide, child_wide)
    child_transition = yang.gdata.from_xml_opt_cnt(node, 'transition')
    yang.gdata.maybe_add(children, 'transition', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition, child_transition)
    child_levels = yang.gdata.from_xml_opt_cnt(node, 'levels')
    yang.gdata.maybe_add(children, 'levels', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels, child_levels)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry(yang.adata.MNode):
    af_name: str
    saf_name: str
    segment_routing: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing
    metric_style: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style

    mut def __init__(self, af_name: str, saf_name: str, segment_routing: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing=None, metric_style: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.af_name = af_name
        self.saf_name = saf_name
        self.segment_routing = segment_routing if segment_routing is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing()
        self.metric_style = metric_style if metric_style is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _af_name = self.af_name
        if _af_name is not None:
            children['af-name'] = yang.gdata.Leaf('enumeration', _af_name)
        _saf_name = self.saf_name
        if _saf_name is not None:
            children['saf-name'] = yang.gdata.Leaf('enumeration', _saf_name)
        _segment_routing = self.segment_routing
        if _segment_routing is not None:
            children['segment-routing'] = _segment_routing.to_gdata()
        _metric_style = self.metric_style
        if _metric_style is not None:
            children['metric-style'] = _metric_style.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry:
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry(af_name=n.get_str('af-name'), saf_name=n.get_str('saf-name'), segment_routing=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing.from_gdata(n.get_opt_cnt('segment-routing')), metric_style=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style.from_gdata(n.get_opt_cnt('metric-style')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family({repr_yang(self.af_name)}, {repr_yang(self.saf_name)})')
        leaves = []
        _segment_routing = self.segment_routing
        if _segment_routing is not None:
            res.extend(_segment_routing.prsrc('{self_name}.segment_routing', False).splitlines())
        _metric_style = self.metric_style
        if _metric_style is not None:
            res.extend(_metric_style.prsrc('{self_name}.metric_style', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/address-families/address-family'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family'])

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af_name, saf_name):
        for e in self:
            match = True
            if e.af_name != af_name:
                match = False
                continue
            if e.saf_name != saf_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry(af_name, saf_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['af-name', 'saf-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family(elements=copied_elements)

extension Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family(Iterable[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_af_name = yang.gdata.from_xml_str(node, 'af-name')
    yang.gdata.maybe_add(children, 'af-name', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__af_name, child_af_name)
    child_saf_name = yang.gdata.from_xml_str(node, 'saf-name')
    yang.gdata.maybe_add(children, 'saf-name', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__saf_name, child_saf_name)
    child_segment_routing = yang.gdata.from_xml_opt_cnt(node, 'segment-routing')
    yang.gdata.maybe_add(children, 'segment-routing', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing, child_segment_routing)
    child_metric_style = yang.gdata.from_xml_opt_cnt(node, 'metric-style')
    yang.gdata.maybe_add(children, 'metric-style', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style, child_metric_style)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_element(e) for e in nodes]
    return yang.gdata.List(keys=['af-name', 'saf-name'], elements=elements)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family

    mut def __init__(self, address_family: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.address_family = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family(elements=address_family)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = _address_family.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families(address_family=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family.from_gdata(n.get_opt_list('address-family')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/address-families')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families()')
        leaves = []
        _address_family = self.address_family
        for _element in _address_family:
            res.append('')
            res.append("# List /um-router-isis-cfg:router/isis/processes/process/address-families/address-family element: {_element.to_gdata().key_str(['af-name', 'saf-name'])}")
            list_elem = 'address_family_element = {self_name}.address_family.create({repr_yang(_element.af_name)}, {repr_yang(_element.saf_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('address_family_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/address-families'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_opt_list(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family, child_address_family)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__interface_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__circuit_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/point-to-point')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/point-to-point'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'point-to-point'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/bfd/fast-detect/ipv4')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/bfd/fast-detect/ipv4'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'bfd', 'fast-detect', 'ipv4'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/bfd/fast-detect/ipv6')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/bfd/fast-detect/ipv6'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'bfd', 'fast-detect', 'ipv6'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect(yang.adata.MNode):
    ipv4: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4
    ipv6: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6

    mut def __init__(self, ipv4: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4=None, ipv6: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.ipv4 = ipv4
        self.ipv6 = ipv6

    mut def create_ipv4(self):
        existing = self.ipv4
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4()
        self.ipv4 = res
        return res

    mut def create_ipv6(self):
        existing = self.ipv6
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6()
        self.ipv6 = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            children['ipv4'] = _ipv4.to_gdata()
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            children['ipv6'] = _ipv6.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect(ipv4=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4.from_gdata(n.get_opt_cnt('ipv4')), ipv6=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6.from_gdata(n.get_opt_cnt('ipv6')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/bfd/fast-detect')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect()')
        leaves = []
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            res.append('')
            res.append('# P-container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/bfd/fast-detect/ipv4')
            res.append('ipv4 = {self_name}.create_ipv4()')
            res.extend(_ipv4.prsrc('ipv4', False).splitlines())
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            res.append('')
            res.append('# P-container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/bfd/fast-detect/ipv6')
            res.append('ipv6 = {self_name}.create_ipv6()')
            res.extend(_ipv6.prsrc('ipv6', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/bfd/fast-detect'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'bfd', 'fast-detect'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4 = yang.gdata.from_xml_opt_cnt(node, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.from_xml_opt_cnt(node, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6, child_ipv6)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__minimum_interval(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__multiplier(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd(yang.adata.MNode):
    fast_detect: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect
    minimum_interval: ?bigint
    multiplier: ?bigint

    mut def __init__(self, fast_detect: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect=None, minimum_interval: ?bigint, multiplier: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.fast_detect = fast_detect if fast_detect is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect()
        self.minimum_interval = minimum_interval
        self.multiplier = multiplier

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _fast_detect = self.fast_detect
        if _fast_detect is not None:
            children['fast-detect'] = _fast_detect.to_gdata()
        _minimum_interval = self.minimum_interval
        if _minimum_interval is not None:
            children['minimum-interval'] = yang.gdata.Leaf('uint32', _minimum_interval)
        _multiplier = self.multiplier
        if _multiplier is not None:
            children['multiplier'] = yang.gdata.Leaf('uint32', _multiplier)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd(fast_detect=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect.from_gdata(n.get_opt_cnt('fast-detect')), minimum_interval=n.get_opt_bigint('minimum-interval'), multiplier=n.get_opt_bigint('multiplier'))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/bfd')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd()')
        leaves = []
        _fast_detect = self.fast_detect
        if _fast_detect is not None:
            res.extend(_fast_detect.prsrc('{self_name}.fast_detect', False).splitlines())
        _minimum_interval = self.minimum_interval
        if _minimum_interval is not None:
            leaves.append('{self_name}.minimum_interval = {repr_yang(_minimum_interval)}')
        _multiplier = self.multiplier
        if _multiplier is not None:
            leaves.append('{self_name}.multiplier = {repr_yang(_multiplier)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/bfd'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'bfd'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_fast_detect = yang.gdata.from_xml_opt_cnt(node, 'fast-detect')
    yang.gdata.maybe_add(children, 'fast-detect', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect, child_fast_detect)
    child_minimum_interval = yang.gdata.from_xml_opt_bigint(node, 'minimum-interval')
    yang.gdata.maybe_add(children, 'minimum-interval', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__minimum_interval, child_minimum_interval)
    child_multiplier = yang.gdata.from_xml_opt_bigint(node, 'multiplier')
    yang.gdata.maybe_add(children, 'multiplier', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__multiplier, child_multiplier)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/passive')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/passive'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'passive'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__af_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__saf_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__default_metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/metric/maximum')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/metric/maximum'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'metric', 'maximum'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__level_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__default_metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/metric/levels/level/maximum')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/metric/levels/level/maximum'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'metric', 'levels', 'level', 'maximum'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry(yang.adata.MNode):
    level_id: bigint
    default_metric: ?bigint
    maximum: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum

    mut def __init__(self, level_id: bigint, default_metric: ?bigint, maximum: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.level_id = level_id
        self.default_metric = default_metric
        self.maximum = maximum

    mut def create_maximum(self):
        existing = self.maximum
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum()
        self.maximum = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _level_id = self.level_id
        if _level_id is not None:
            children['level-id'] = yang.gdata.Leaf('uint32', _level_id)
        _default_metric = self.default_metric
        if _default_metric is not None:
            children['default-metric'] = yang.gdata.Leaf('uint32', _default_metric)
        _maximum = self.maximum
        if _maximum is not None:
            children['maximum'] = _maximum.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry:
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry(level_id=n.get_bigint('level-id'), default_metric=n.get_opt_bigint('default-metric'), maximum=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum.from_gdata(n.get_opt_cnt('maximum')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/metric/levels/level')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level({repr_yang(self.level_id)})')
        leaves = []
        _default_metric = self.default_metric
        if _default_metric is not None:
            leaves.append('{self_name}.default_metric = {repr_yang(_default_metric)}')
        _maximum = self.maximum
        if _maximum is not None:
            res.append('')
            res.append('# P-container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/metric/levels/level/maximum')
            res.append('maximum = {self_name}.create_maximum()')
            res.extend(_maximum.prsrc('maximum', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/metric/levels/level'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'metric', 'levels', 'level'])

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self._name = 'level'
        self.elements = elements

    mut def create(self, level_id):
        for e in self:
            match = True
            if e.level_id != level_id:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry(level_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['level-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level(elements=copied_elements)

extension Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level(Iterable[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_level_id = yang.gdata.from_xml_bigint(node, 'level-id')
    yang.gdata.maybe_add(children, 'level-id', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__level_id, child_level_id)
    child_default_metric = yang.gdata.from_xml_opt_bigint(node, 'default-metric')
    yang.gdata.maybe_add(children, 'default-metric', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__default_metric, child_default_metric)
    child_maximum = yang.gdata.from_xml_opt_cnt(node, 'maximum')
    yang.gdata.maybe_add(children, 'maximum', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum, child_maximum)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_element(e) for e in nodes]
    return yang.gdata.List(keys=['level-id'], elements=elements)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels(yang.adata.MNode):
    level: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level

    mut def __init__(self, level: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.level = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level(elements=level)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _level = self.level
        if _level is not None:
            children['level'] = _level.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels(level=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level.from_gdata(n.get_opt_list('level')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/metric/levels')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels()')
        leaves = []
        _level = self.level
        for _element in _level:
            res.append('')
            res.append("# List /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/metric/levels/level element: {_element.to_gdata().key_str(['level-id'])}")
            list_elem = 'level_element = {self_name}.level.create({repr_yang(_element.level_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('level_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/metric/levels'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'metric', 'levels'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_level = yang.gdata.from_xml_opt_list(node, 'level')
    yang.gdata.maybe_add(children, 'level', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level, child_level)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric(yang.adata.MNode):
    default_metric: ?bigint
    maximum: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum
    levels: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels

    mut def __init__(self, default_metric: ?bigint, maximum: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum=None, levels: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.default_metric = default_metric
        self.maximum = maximum
        self.levels = levels if levels is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels()

    mut def create_maximum(self):
        existing = self.maximum
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum()
        self.maximum = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _default_metric = self.default_metric
        if _default_metric is not None:
            children['default-metric'] = yang.gdata.Leaf('uint32', _default_metric)
        _maximum = self.maximum
        if _maximum is not None:
            children['maximum'] = _maximum.to_gdata()
        _levels = self.levels
        if _levels is not None:
            children['levels'] = _levels.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric(default_metric=n.get_opt_bigint('default-metric'), maximum=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum.from_gdata(n.get_opt_cnt('maximum')), levels=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels.from_gdata(n.get_opt_cnt('levels')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/metric')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric()')
        leaves = []
        _default_metric = self.default_metric
        if _default_metric is not None:
            leaves.append('{self_name}.default_metric = {repr_yang(_default_metric)}')
        _maximum = self.maximum
        if _maximum is not None:
            res.append('')
            res.append('# P-container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/metric/maximum')
            res.append('maximum = {self_name}.create_maximum()')
            res.extend(_maximum.prsrc('maximum', False).splitlines())
        _levels = self.levels
        if _levels is not None:
            res.extend(_levels.prsrc('{self_name}.levels', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/metric'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'metric'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_default_metric = yang.gdata.from_xml_opt_bigint(node, 'default-metric')
    yang.gdata.maybe_add(children, 'default-metric', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__default_metric, child_default_metric)
    child_maximum = yang.gdata.from_xml_opt_cnt(node, 'maximum')
    yang.gdata.maybe_add(children, 'maximum', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum, child_maximum)
    child_levels = yang.gdata.from_xml_opt_cnt(node, 'levels')
    yang.gdata.maybe_add(children, 'levels', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels, child_levels)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index__sid_index(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index(yang.adata.MNode):
    sid_index: ?bigint

    mut def __init__(self, sid_index: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.sid_index = sid_index

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _sid_index = self.sid_index
        if _sid_index is not None:
            children['sid-index'] = yang.gdata.Leaf('uint32', _sid_index)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index(sid_index=n.get_opt_bigint('sid-index'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/prefix-sid/sid/index')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index()')
        leaves = []
        _sid_index = self.sid_index
        if _sid_index is not None:
            leaves.append('{self_name}.sid_index = {repr_yang(_sid_index)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/prefix-sid/sid/index'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'prefix-sid', 'sid', 'index'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_sid_index = yang.gdata.from_xml_opt_bigint(node, 'sid-index')
    yang.gdata.maybe_add(children, 'sid-index', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index__sid_index, child_sid_index)
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid(yang.adata.MNode):
    index: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index

    mut def __init__(self, index: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.index = index

    mut def create_index(self, sid_index):
        existing = self.index
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index(sid_index)
        self.index = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _index = self.index
        if _index is not None:
            children['index'] = _index.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid(index=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index.from_gdata(n.get_opt_cnt('index')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/prefix-sid/sid')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid()')
        leaves = []
        _index = self.index
        if _index is not None:
            res.append('')
            res.append('# P-container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/prefix-sid/sid/index')
            res.append('index = {self_name}.create_index()')
            res.extend(_index.prsrc('index', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/prefix-sid/sid'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'prefix-sid', 'sid'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_index = yang.gdata.from_xml_opt_cnt(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index, child_index)
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid(yang.adata.MNode):
    sid: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid

    mut def __init__(self, sid: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.sid = sid

    mut def create_sid(self):
        existing = self.sid
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid()
        self.sid = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _sid = self.sid
        if _sid is not None:
            children['sid'] = _sid.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid(sid=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid.from_gdata(n.get_opt_cnt('sid')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/prefix-sid')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid()')
        leaves = []
        _sid = self.sid
        if _sid is not None:
            res.append('')
            res.append('# P-container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/prefix-sid/sid')
            res.append('sid = {self_name}.create_sid()')
            res.extend(_sid.prsrc('sid', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family/prefix-sid'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'prefix-sid'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_sid = yang.gdata.from_xml_opt_cnt(node, 'sid')
    yang.gdata.maybe_add(children, 'sid', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid, child_sid)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry(yang.adata.MNode):
    af_name: str
    saf_name: str
    metric: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric
    prefix_sid: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid

    mut def __init__(self, af_name: str, saf_name: str, metric: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric=None, prefix_sid: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.af_name = af_name
        self.saf_name = saf_name
        self.metric = metric if metric is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric()
        self.prefix_sid = prefix_sid if prefix_sid is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _af_name = self.af_name
        if _af_name is not None:
            children['af-name'] = yang.gdata.Leaf('enumeration', _af_name)
        _saf_name = self.saf_name
        if _saf_name is not None:
            children['saf-name'] = yang.gdata.Leaf('enumeration', _saf_name)
        _metric = self.metric
        if _metric is not None:
            children['metric'] = _metric.to_gdata()
        _prefix_sid = self.prefix_sid
        if _prefix_sid is not None:
            children['prefix-sid'] = _prefix_sid.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry:
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry(af_name=n.get_str('af-name'), saf_name=n.get_str('saf-name'), metric=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric.from_gdata(n.get_opt_cnt('metric')), prefix_sid=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid.from_gdata(n.get_opt_cnt('prefix-sid')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family({repr_yang(self.af_name)}, {repr_yang(self.saf_name)})')
        leaves = []
        _metric = self.metric
        if _metric is not None:
            res.extend(_metric.prsrc('{self_name}.metric', False).splitlines())
        _prefix_sid = self.prefix_sid
        if _prefix_sid is not None:
            res.extend(_prefix_sid.prsrc('{self_name}.prefix_sid', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family'])

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af_name, saf_name):
        for e in self:
            match = True
            if e.af_name != af_name:
                match = False
                continue
            if e.saf_name != saf_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry(af_name, saf_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['af-name', 'saf-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family(elements=copied_elements)

extension Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family(Iterable[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_af_name = yang.gdata.from_xml_str(node, 'af-name')
    yang.gdata.maybe_add(children, 'af-name', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__af_name, child_af_name)
    child_saf_name = yang.gdata.from_xml_str(node, 'saf-name')
    yang.gdata.maybe_add(children, 'saf-name', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__saf_name, child_saf_name)
    child_metric = yang.gdata.from_xml_opt_cnt(node, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric, child_metric)
    child_prefix_sid = yang.gdata.from_xml_opt_cnt(node, 'prefix-sid')
    yang.gdata.maybe_add(children, 'prefix-sid', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid, child_prefix_sid)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_element(e) for e in nodes]
    return yang.gdata.List(keys=['af-name', 'saf-name'], elements=elements)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family

    mut def __init__(self, address_family: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.address_family = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family(elements=address_family)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = _address_family.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families(address_family=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family.from_gdata(n.get_opt_list('address-family')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families()')
        leaves = []
        _address_family = self.address_family
        for _element in _address_family:
            res.append('')
            res.append("# List /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families/address-family element: {_element.to_gdata().key_str(['af-name', 'saf-name'])}")
            list_elem = 'address_family_element = {self_name}.address_family.create({repr_yang(_element.af_name)}, {repr_yang(_element.saf_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('address_family_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/address-families'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_opt_list(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family, child_address_family)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry(yang.adata.MNode):
    interface_name: str
    circuit_type: ?str
    point_to_point: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point
    bfd: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd
    passive: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive
    address_families: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families

    mut def __init__(self, interface_name: str, circuit_type: ?str, point_to_point: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point=None, bfd: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd=None, passive: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive=None, address_families: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.interface_name = interface_name
        self.circuit_type = circuit_type
        self.point_to_point = point_to_point
        self.bfd = bfd if bfd is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd()
        self.passive = passive
        self.address_families = address_families if address_families is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families()

    mut def create_point_to_point(self):
        existing = self.point_to_point
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point()
        self.point_to_point = res
        return res

    mut def create_passive(self):
        existing = self.passive
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive()
        self.passive = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _interface_name = self.interface_name
        if _interface_name is not None:
            children['interface-name'] = yang.gdata.Leaf('string', _interface_name)
        _circuit_type = self.circuit_type
        if _circuit_type is not None:
            children['circuit-type'] = yang.gdata.Leaf('enumeration', _circuit_type)
        _point_to_point = self.point_to_point
        if _point_to_point is not None:
            children['point-to-point'] = _point_to_point.to_gdata()
        _bfd = self.bfd
        if _bfd is not None:
            children['bfd'] = _bfd.to_gdata()
        _passive = self.passive
        if _passive is not None:
            children['passive'] = _passive.to_gdata()
        _address_families = self.address_families
        if _address_families is not None:
            children['address-families'] = _address_families.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry:
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry(interface_name=n.get_str('interface-name'), circuit_type=n.get_opt_str('circuit-type'), point_to_point=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point.from_gdata(n.get_opt_cnt('point-to-point')), bfd=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd.from_gdata(n.get_opt_cnt('bfd')), passive=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive.from_gdata(n.get_opt_cnt('passive')), address_families=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families.from_gdata(n.get_opt_cnt('address-families')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface({repr_yang(self.interface_name)})')
        leaves = []
        _circuit_type = self.circuit_type
        if _circuit_type is not None:
            leaves.append('{self_name}.circuit_type = {repr_yang(_circuit_type)}')
        _point_to_point = self.point_to_point
        if _point_to_point is not None:
            res.append('')
            res.append('# P-container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/point-to-point')
            res.append('point_to_point = {self_name}.create_point_to_point()')
            res.extend(_point_to_point.prsrc('point_to_point', False).splitlines())
        _bfd = self.bfd
        if _bfd is not None:
            res.extend(_bfd.prsrc('{self_name}.bfd', False).splitlines())
        _passive = self.passive
        if _passive is not None:
            res.append('')
            res.append('# P-container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface/passive')
            res.append('passive = {self_name}.create_passive()')
            res.extend(_passive.prsrc('passive', False).splitlines())
        _address_families = self.address_families
        if _address_families is not None:
            res.extend(_address_families.prsrc('{self_name}.address_families', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces/interface'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface'])

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self._name = 'interface'
        self.elements = elements

    mut def create(self, interface_name):
        for e in self:
            match = True
            if e.interface_name != interface_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry(interface_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['interface-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface(elements=copied_elements)

extension Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface(Iterable[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_interface_name = yang.gdata.from_xml_str(node, 'interface-name')
    yang.gdata.maybe_add(children, 'interface-name', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__interface_name, child_interface_name)
    child_circuit_type = yang.gdata.from_xml_opt_str(node, 'circuit-type')
    yang.gdata.maybe_add(children, 'circuit-type', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__circuit_type, child_circuit_type)
    child_point_to_point = yang.gdata.from_xml_opt_cnt(node, 'point-to-point')
    yang.gdata.maybe_add(children, 'point-to-point', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point, child_point_to_point)
    child_bfd = yang.gdata.from_xml_opt_cnt(node, 'bfd')
    yang.gdata.maybe_add(children, 'bfd', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd, child_bfd)
    child_passive = yang.gdata.from_xml_opt_cnt(node, 'passive')
    yang.gdata.maybe_add(children, 'passive', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive, child_passive)
    child_address_families = yang.gdata.from_xml_opt_cnt(node, 'address-families')
    yang.gdata.maybe_add(children, 'address-families', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families, child_address_families)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_element(e) for e in nodes]
    return yang.gdata.List(keys=['interface-name'], elements=elements)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces(yang.adata.MNode):
    interface: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface

    mut def __init__(self, interface: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.interface = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface(elements=interface)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _interface = self.interface
        if _interface is not None:
            children['interface'] = _interface.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces(interface=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface.from_gdata(n.get_opt_list('interface')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process/interfaces')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces()')
        leaves = []
        _interface = self.interface
        for _element in _interface:
            res.append('')
            res.append("# List /um-router-isis-cfg:router/isis/processes/process/interfaces/interface element: {_element.to_gdata().key_str(['interface-name'])}")
            list_elem = 'interface_element = {self_name}.interface.create({repr_yang(_element.interface_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('interface_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process/interfaces'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_interface = yang.gdata.from_xml_opt_list(node, 'interface')
    yang.gdata.maybe_add(children, 'interface', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface, child_interface)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry(yang.adata.MNode):
    process_id: str
    is_type: ?str
    nets: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets
    address_families: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families
    interfaces: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces

    mut def __init__(self, process_id: str, is_type: ?str, nets: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets=None, address_families: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families=None, interfaces: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.process_id = process_id
        self.is_type = is_type
        self.nets = nets if nets is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets()
        self.address_families = address_families if address_families is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families()
        self.interfaces = interfaces if interfaces is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _process_id = self.process_id
        if _process_id is not None:
            children['process-id'] = yang.gdata.Leaf('string', _process_id)
        _is_type = self.is_type
        if _is_type is not None:
            children['is-type'] = yang.gdata.Leaf('enumeration', _is_type)
        _nets = self.nets
        if _nets is not None:
            children['nets'] = _nets.to_gdata()
        _address_families = self.address_families
        if _address_families is not None:
            children['address-families'] = _address_families.to_gdata()
        _interfaces = self.interfaces
        if _interfaces is not None:
            children['interfaces'] = _interfaces.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry:
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry(process_id=n.get_str('process-id'), is_type=n.get_opt_str('is-type'), nets=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets.from_gdata(n.get_opt_cnt('nets')), address_families=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families.from_gdata(n.get_opt_cnt('address-families')), interfaces=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces.from_gdata(n.get_opt_cnt('interfaces')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes/process')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process({repr_yang(self.process_id)})')
        leaves = []
        _is_type = self.is_type
        if _is_type is not None:
            leaves.append('{self_name}.is_type = {repr_yang(_is_type)}')
        _nets = self.nets
        if _nets is not None:
            res.extend(_nets.prsrc('{self_name}.nets', False).splitlines())
        _address_families = self.address_families
        if _address_families is not None:
            res.extend(_address_families.prsrc('{self_name}.address_families', False).splitlines())
        _interfaces = self.interfaces
        if _interfaces is not None:
            res.extend(_interfaces.prsrc('{self_name}.interfaces', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes/process'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process'])

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self._name = 'process'
        self.elements = elements

    mut def create(self, process_id):
        for e in self:
            match = True
            if e.process_id != process_id:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry(process_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['process-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process(elements=copied_elements)

extension Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process(Iterable[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_process_id = yang.gdata.from_xml_str(node, 'process-id')
    yang.gdata.maybe_add(children, 'process-id', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__process_id, child_process_id)
    child_is_type = yang.gdata.from_xml_opt_str(node, 'is-type')
    yang.gdata.maybe_add(children, 'is-type', from_data_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__is_type, child_is_type)
    child_nets = yang.gdata.from_xml_opt_cnt(node, 'nets')
    yang.gdata.maybe_add(children, 'nets', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets, child_nets)
    child_address_families = yang.gdata.from_xml_opt_cnt(node, 'address-families')
    yang.gdata.maybe_add(children, 'address-families', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families, child_address_families)
    child_interfaces = yang.gdata.from_xml_opt_cnt(node, 'interfaces')
    yang.gdata.maybe_add(children, 'interfaces', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces, child_interfaces)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_element(e) for e in nodes]
    return yang.gdata.List(keys=['process-id'], elements=elements)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes(yang.adata.MNode):
    process: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process

    mut def __init__(self, process: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.process = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process(elements=process)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _process = self.process
        if _process is not None:
            children['process'] = _process.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes(process=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process.from_gdata(n.get_opt_list('process')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis/processes')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes()')
        leaves = []
        _process = self.process
        for _element in _process:
            res.append('')
            res.append("# List /um-router-isis-cfg:router/isis/processes/process element: {_element.to_gdata().key_str(['process-id'])}")
            list_elem = 'process_element = {self_name}.process.create({repr_yang(_element.process_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('process_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis/processes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_process = yang.gdata.from_xml_opt_list(node, 'process')
    yang.gdata.maybe_add(children, 'process', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process, child_process)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis(yang.adata.MNode):
    processes: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes

    mut def __init__(self, processes: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.processes = processes if processes is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _processes = self.processes
        if _processes is not None:
            children['processes'] = _processes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis(processes=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes.from_gdata(n.get_opt_cnt('processes')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router/isis')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis()')
        leaves = []
        _processes = self.processes
        if _processes is not None:
            res.extend(_processes.prsrc('{self_name}.processes', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router/isis'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_processes = yang.gdata.from_xml_opt_cnt(node, 'processes')
    yang.gdata.maybe_add(children, 'processes', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes, child_processes)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router(yang.adata.MNode):
    isis: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis

    mut def __init__(self, isis: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.isis = isis if isis is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _isis = self.isis
        if _isis is not None:
            children['isis'] = _isis.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', module='Cisco-IOS-XR-um-router-isis-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router(isis=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis.from_gdata(n.get_opt_cnt('isis')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-isis-cfg:router')
            res.append('{self_name} = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router()')
        leaves = []
        _isis = self.isis
        if _isis is not None:
            res.extend(_isis.prsrc('{self_name}.isis', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-isis-cfg:router'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router'])


mut def from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_isis = yang.gdata.from_xml_opt_cnt(node, 'isis')
    yang.gdata.maybe_add(children, 'isis', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis, child_isis)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', module='Cisco-IOS-XR-um-router-isis-cfg')

class Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /as-format/asdot')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /as-format/asdot'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:as-format', 'asdot'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /as-format/asplain')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /as-format/asplain'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:as-format', 'asplain'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_bgp_cfg__as_format(yang.adata.MNode):
    asdot: ?Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot
    asplain: ?Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain

    mut def __init__(self, asdot: ?Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot=None, asplain: ?Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.asdot = asdot
        self.asplain = asplain

    mut def create_asdot(self):
        existing = self.asdot
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot()
        self.asdot = res
        return res

    mut def create_asplain(self):
        existing = self.asplain
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain()
        self.asplain = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _asdot = self.asdot
        if _asdot is not None:
            children['asdot'] = _asdot.to_gdata()
        _asplain = self.asplain
        if _asplain is not None:
            children['asplain'] = _asplain.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__as_format:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__as_format(asdot=Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot.from_gdata(n.get_opt_cnt('asdot')), asplain=Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain.from_gdata(n.get_opt_cnt('asplain')))
        return Cisco_IOS_XR_um_router_bgp_cfg__as_format()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__as_format.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /as-format')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__as_format()')
        leaves = []
        _asdot = self.asdot
        if _asdot is not None:
            res.append('')
            res.append('# P-container: /as-format/asdot')
            res.append('asdot = {self_name}.create_asdot()')
            res.extend(_asdot.prsrc('asdot', False).splitlines())
        _asplain = self.asplain
        if _asplain is not None:
            res.append('')
            res.append('# P-container: /as-format/asplain')
            res.append('asplain = {self_name}.create_asplain()')
            res.extend(_asplain.prsrc('asplain', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /as-format'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:as-format'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__as_format(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_asdot = yang.gdata.from_xml_opt_cnt(node, 'asdot')
    yang.gdata.maybe_add(children, 'asdot', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot, child_asdot)
    child_asplain = yang.gdata.from_xml_opt_cnt(node, 'asplain')
    yang.gdata.maybe_add(children, 'asplain', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain, child_asplain)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__bmp_server_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /bmp/servers/server/shutdown')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /bmp/servers/server/shutdown'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'server', 'shutdown'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host__host_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host__port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host(yang.adata.MNode):
    host_name: ?str
    port: ?bigint

    mut def __init__(self, host_name: ?str, port: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.host_name = host_name
        self.port = port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _host_name = self.host_name
        if _host_name is not None:
            children['host-name'] = yang.gdata.Leaf('string', _host_name)
        _port = self.port
        if _port is not None:
            children['port'] = yang.gdata.Leaf('uint32', _port)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host(host_name=n.get_opt_str('host-name'), port=n.get_opt_bigint('port'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /bmp/servers/server/host')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host()')
        leaves = []
        _host_name = self.host_name
        if _host_name is not None:
            leaves.append('{self_name}.host_name = {repr_yang(_host_name)}')
        _port = self.port
        if _port is not None:
            leaves.append('{self_name}.port = {repr_yang(_port)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /bmp/servers/server/host'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'server', 'host'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_host_name = yang.gdata.from_xml_opt_str(node, 'host-name')
    yang.gdata.maybe_add(children, 'host-name', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host__host_name, child_host_name)
    child_port = yang.gdata.from_xml_opt_bigint(node, 'port')
    yang.gdata.maybe_add(children, 'port', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host__port, child_port)
    return yang.gdata.Container(children, presence=True)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_delay(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__flapping_delay(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__max_buffer_size(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay__initial_delay(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay__spread(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay(yang.adata.MNode):
    initial_delay: ?bigint
    spread: ?bigint

    mut def __init__(self, initial_delay: ?bigint, spread: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.initial_delay = initial_delay
        self.spread = spread

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _initial_delay = self.initial_delay
        if _initial_delay is not None:
            children['initial-delay'] = yang.gdata.Leaf('uint32', _initial_delay)
        _spread = self.spread
        if _spread is not None:
            children['spread'] = yang.gdata.Leaf('uint32', _spread)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay(initial_delay=n.get_opt_bigint('initial-delay'), spread=n.get_opt_bigint('spread'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /bmp/servers/server/initial-refresh/delay')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay()')
        leaves = []
        _initial_delay = self.initial_delay
        if _initial_delay is not None:
            leaves.append('{self_name}.initial_delay = {repr_yang(_initial_delay)}')
        _spread = self.spread
        if _spread is not None:
            leaves.append('{self_name}.spread = {repr_yang(_spread)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /bmp/servers/server/initial-refresh/delay'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'server', 'initial-refresh', 'delay'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_initial_delay = yang.gdata.from_xml_opt_bigint(node, 'initial-delay')
    yang.gdata.maybe_add(children, 'initial-delay', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay__initial_delay, child_initial_delay)
    child_spread = yang.gdata.from_xml_opt_bigint(node, 'spread')
    yang.gdata.maybe_add(children, 'spread', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay__spread, child_spread)
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /bmp/servers/server/initial-refresh/skip')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /bmp/servers/server/initial-refresh/skip'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'server', 'initial-refresh', 'skip'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh(yang.adata.MNode):
    delay: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay
    skip: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip

    mut def __init__(self, delay: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay=None, skip: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.delay = delay
        self.skip = skip

    mut def create_delay(self, initial_delay):
        existing = self.delay
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay(initial_delay)
        self.delay = res
        return res

    mut def create_skip(self):
        existing = self.skip
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip()
        self.skip = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _delay = self.delay
        if _delay is not None:
            children['delay'] = _delay.to_gdata()
        _skip = self.skip
        if _skip is not None:
            children['skip'] = _skip.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh(delay=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay.from_gdata(n.get_opt_cnt('delay')), skip=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip.from_gdata(n.get_opt_cnt('skip')))
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /bmp/servers/server/initial-refresh')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh()')
        leaves = []
        _delay = self.delay
        if _delay is not None:
            res.append('')
            res.append('# P-container: /bmp/servers/server/initial-refresh/delay')
            res.append('delay = {self_name}.create_delay()')
            res.extend(_delay.prsrc('delay', False).splitlines())
        _skip = self.skip
        if _skip is not None:
            res.append('')
            res.append('# P-container: /bmp/servers/server/initial-refresh/skip')
            res.append('skip = {self_name}.create_skip()')
            res.extend(_skip.prsrc('skip', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /bmp/servers/server/initial-refresh'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'server', 'initial-refresh'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_delay = yang.gdata.from_xml_opt_cnt(node, 'delay')
    yang.gdata.maybe_add(children, 'delay', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay, child_delay)
    child_skip = yang.gdata.from_xml_opt_cnt(node, 'skip')
    yang.gdata.maybe_add(children, 'skip', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip, child_skip)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__stats_reporting_period(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__dscp(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__precedence(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__update_source(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__vrf(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp__keep_alive(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp__mss(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp(yang.adata.MNode):
    keep_alive: ?bigint
    mss: ?bigint

    mut def __init__(self, keep_alive: ?bigint, mss: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.keep_alive = keep_alive
        self.mss = mss

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _keep_alive = self.keep_alive
        if _keep_alive is not None:
            children['keep-alive'] = yang.gdata.Leaf('uint32', _keep_alive)
        _mss = self.mss
        if _mss is not None:
            children['mss'] = yang.gdata.Leaf('uint32', _mss)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp(keep_alive=n.get_opt_bigint('keep-alive'), mss=n.get_opt_bigint('mss'))
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /bmp/servers/server/tcp')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp()')
        leaves = []
        _keep_alive = self.keep_alive
        if _keep_alive is not None:
            leaves.append('{self_name}.keep_alive = {repr_yang(_keep_alive)}')
        _mss = self.mss
        if _mss is not None:
            leaves.append('{self_name}.mss = {repr_yang(_mss)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /bmp/servers/server/tcp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'server', 'tcp'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_keep_alive = yang.gdata.from_xml_opt_bigint(node, 'keep-alive')
    yang.gdata.maybe_add(children, 'keep-alive', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp__keep_alive, child_keep_alive)
    child_mss = yang.gdata.from_xml_opt_bigint(node, 'mss')
    yang.gdata.maybe_add(children, 'mss', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp__mss, child_mss)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry(yang.adata.MNode):
    bmp_server_id: bigint
    shutdown: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown
    host: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host
    initial_delay: ?bigint
    flapping_delay: ?bigint
    max_buffer_size: ?bigint
    initial_refresh: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh
    stats_reporting_period: ?bigint
    description: ?str
    dscp: ?str
    precedence: ?str
    update_source: ?str
    vrf: ?str
    tcp: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp

    mut def __init__(self, bmp_server_id: bigint, shutdown: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown=None, host: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host=None, initial_delay: ?bigint, flapping_delay: ?bigint, max_buffer_size: ?bigint, initial_refresh: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh=None, stats_reporting_period: ?bigint, description: ?str, dscp: ?str, precedence: ?str, update_source: ?str, vrf: ?str, tcp: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.bmp_server_id = bmp_server_id
        self.shutdown = shutdown
        self.host = host
        self.initial_delay = initial_delay
        self.flapping_delay = flapping_delay
        self.max_buffer_size = max_buffer_size
        self.initial_refresh = initial_refresh if initial_refresh is not None else Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh()
        self.stats_reporting_period = stats_reporting_period
        self.description = description
        self.dscp = dscp
        self.precedence = precedence
        self.update_source = update_source
        self.vrf = vrf
        self.tcp = tcp if tcp is not None else Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp()

    mut def create_shutdown(self):
        existing = self.shutdown
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown()
        self.shutdown = res
        return res

    mut def create_host(self, host_name):
        existing = self.host
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host(host_name)
        self.host = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _bmp_server_id = self.bmp_server_id
        if _bmp_server_id is not None:
            children['bmp-server-id'] = yang.gdata.Leaf('uint32', _bmp_server_id)
        _shutdown = self.shutdown
        if _shutdown is not None:
            children['shutdown'] = _shutdown.to_gdata()
        _host = self.host
        if _host is not None:
            children['host'] = _host.to_gdata()
        _initial_delay = self.initial_delay
        if _initial_delay is not None:
            children['initial-delay'] = yang.gdata.Leaf('uint32', _initial_delay)
        _flapping_delay = self.flapping_delay
        if _flapping_delay is not None:
            children['flapping-delay'] = yang.gdata.Leaf('uint32', _flapping_delay)
        _max_buffer_size = self.max_buffer_size
        if _max_buffer_size is not None:
            children['max-buffer-size'] = yang.gdata.Leaf('uint32', _max_buffer_size)
        _initial_refresh = self.initial_refresh
        if _initial_refresh is not None:
            children['initial-refresh'] = _initial_refresh.to_gdata()
        _stats_reporting_period = self.stats_reporting_period
        if _stats_reporting_period is not None:
            children['stats-reporting-period'] = yang.gdata.Leaf('uint32', _stats_reporting_period)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        _dscp = self.dscp
        if _dscp is not None:
            children['dscp'] = yang.gdata.Leaf('enumeration', _dscp)
        _precedence = self.precedence
        if _precedence is not None:
            children['precedence'] = yang.gdata.Leaf('enumeration', _precedence)
        _update_source = self.update_source
        if _update_source is not None:
            children['update-source'] = yang.gdata.Leaf('string', _update_source)
        _vrf = self.vrf
        if _vrf is not None:
            children['vrf'] = yang.gdata.Leaf('string', _vrf)
        _tcp = self.tcp
        if _tcp is not None:
            children['tcp'] = _tcp.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry(bmp_server_id=n.get_bigint('bmp-server-id'), shutdown=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown.from_gdata(n.get_opt_cnt('shutdown')), host=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host.from_gdata(n.get_opt_cnt('host')), initial_delay=n.get_opt_bigint('initial-delay'), flapping_delay=n.get_opt_bigint('flapping-delay'), max_buffer_size=n.get_opt_bigint('max-buffer-size'), initial_refresh=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh.from_gdata(n.get_opt_cnt('initial-refresh')), stats_reporting_period=n.get_opt_bigint('stats-reporting-period'), description=n.get_opt_str('description'), dscp=n.get_opt_str('dscp'), precedence=n.get_opt_str('precedence'), update_source=n.get_opt_str('update-source'), vrf=n.get_opt_str('vrf'), tcp=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp.from_gdata(n.get_opt_cnt('tcp')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /bmp/servers/server')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server({repr_yang(self.bmp_server_id)})')
        leaves = []
        _shutdown = self.shutdown
        if _shutdown is not None:
            res.append('')
            res.append('# P-container: /bmp/servers/server/shutdown')
            res.append('shutdown = {self_name}.create_shutdown()')
            res.extend(_shutdown.prsrc('shutdown', False).splitlines())
        _host = self.host
        if _host is not None:
            res.append('')
            res.append('# P-container: /bmp/servers/server/host')
            res.append('host = {self_name}.create_host()')
            res.extend(_host.prsrc('host', False).splitlines())
        _initial_delay = self.initial_delay
        if _initial_delay is not None:
            leaves.append('{self_name}.initial_delay = {repr_yang(_initial_delay)}')
        _flapping_delay = self.flapping_delay
        if _flapping_delay is not None:
            leaves.append('{self_name}.flapping_delay = {repr_yang(_flapping_delay)}')
        _max_buffer_size = self.max_buffer_size
        if _max_buffer_size is not None:
            leaves.append('{self_name}.max_buffer_size = {repr_yang(_max_buffer_size)}')
        _initial_refresh = self.initial_refresh
        if _initial_refresh is not None:
            res.extend(_initial_refresh.prsrc('{self_name}.initial_refresh', False).splitlines())
        _stats_reporting_period = self.stats_reporting_period
        if _stats_reporting_period is not None:
            leaves.append('{self_name}.stats_reporting_period = {repr_yang(_stats_reporting_period)}')
        _description = self.description
        if _description is not None:
            leaves.append('{self_name}.description = {repr_yang(_description)}')
        _dscp = self.dscp
        if _dscp is not None:
            leaves.append('{self_name}.dscp = {repr_yang(_dscp)}')
        _precedence = self.precedence
        if _precedence is not None:
            leaves.append('{self_name}.precedence = {repr_yang(_precedence)}')
        _update_source = self.update_source
        if _update_source is not None:
            leaves.append('{self_name}.update_source = {repr_yang(_update_source)}')
        _vrf = self.vrf
        if _vrf is not None:
            leaves.append('{self_name}.vrf = {repr_yang(_vrf)}')
        _tcp = self.tcp
        if _tcp is not None:
            res.extend(_tcp.prsrc('{self_name}.tcp', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /bmp/servers/server'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'server'])

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'server'
        self.elements = elements

    mut def create(self, bmp_server_id):
        for e in self:
            match = True
            if e.bmp_server_id != bmp_server_id:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry(bmp_server_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['bmp-server-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_bmp_server_id = yang.gdata.from_xml_bigint(node, 'bmp-server-id')
    yang.gdata.maybe_add(children, 'bmp-server-id', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__bmp_server_id, child_bmp_server_id)
    child_shutdown = yang.gdata.from_xml_opt_cnt(node, 'shutdown')
    yang.gdata.maybe_add(children, 'shutdown', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown, child_shutdown)
    child_host = yang.gdata.from_xml_opt_cnt(node, 'host')
    yang.gdata.maybe_add(children, 'host', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host, child_host)
    child_initial_delay = yang.gdata.from_xml_opt_bigint(node, 'initial-delay')
    yang.gdata.maybe_add(children, 'initial-delay', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_delay, child_initial_delay)
    child_flapping_delay = yang.gdata.from_xml_opt_bigint(node, 'flapping-delay')
    yang.gdata.maybe_add(children, 'flapping-delay', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__flapping_delay, child_flapping_delay)
    child_max_buffer_size = yang.gdata.from_xml_opt_bigint(node, 'max-buffer-size')
    yang.gdata.maybe_add(children, 'max-buffer-size', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__max_buffer_size, child_max_buffer_size)
    child_initial_refresh = yang.gdata.from_xml_opt_cnt(node, 'initial-refresh')
    yang.gdata.maybe_add(children, 'initial-refresh', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh, child_initial_refresh)
    child_stats_reporting_period = yang.gdata.from_xml_opt_bigint(node, 'stats-reporting-period')
    yang.gdata.maybe_add(children, 'stats-reporting-period', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__stats_reporting_period, child_stats_reporting_period)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__description, child_description)
    child_dscp = yang.gdata.from_xml_opt_str(node, 'dscp')
    yang.gdata.maybe_add(children, 'dscp', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__dscp, child_dscp)
    child_precedence = yang.gdata.from_xml_opt_str(node, 'precedence')
    yang.gdata.maybe_add(children, 'precedence', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__precedence, child_precedence)
    child_update_source = yang.gdata.from_xml_opt_str(node, 'update-source')
    yang.gdata.maybe_add(children, 'update-source', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__update_source, child_update_source)
    child_vrf = yang.gdata.from_xml_opt_str(node, 'vrf')
    yang.gdata.maybe_add(children, 'vrf', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__vrf, child_vrf)
    child_tcp = yang.gdata.from_xml_opt_cnt(node, 'tcp')
    yang.gdata.maybe_add(children, 'tcp', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp, child_tcp)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_element(e) for e in nodes]
    return yang.gdata.List(keys=['bmp-server-id'], elements=elements)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__max_buffer_size(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode__mode_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode__advertisement_interval(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode__scan_time(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry(yang.adata.MNode):
    mode_name: str
    advertisement_interval: ?bigint
    scan_time: ?bigint

    mut def __init__(self, mode_name: str, advertisement_interval: ?bigint, scan_time: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.mode_name = mode_name
        self.advertisement_interval = advertisement_interval
        self.scan_time = scan_time

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _mode_name = self.mode_name
        if _mode_name is not None:
            children['mode-name'] = yang.gdata.Leaf('enumeration', _mode_name)
        _advertisement_interval = self.advertisement_interval
        if _advertisement_interval is not None:
            children['advertisement-interval'] = yang.gdata.Leaf('uint32', _advertisement_interval)
        _scan_time = self.scan_time
        if _scan_time is not None:
            children['scan-time'] = yang.gdata.Leaf('uint32', _scan_time)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry(mode_name=n.get_str('mode-name'), advertisement_interval=n.get_opt_bigint('advertisement-interval'), scan_time=n.get_opt_bigint('scan-time'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /bmp/servers/all/route-monitoring/bmp-modes/bmp-mode')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode({repr_yang(self.mode_name)})')
        leaves = []
        _advertisement_interval = self.advertisement_interval
        if _advertisement_interval is not None:
            leaves.append('{self_name}.advertisement_interval = {repr_yang(_advertisement_interval)}')
        _scan_time = self.scan_time
        if _scan_time is not None:
            leaves.append('{self_name}.scan_time = {repr_yang(_scan_time)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /bmp/servers/all/route-monitoring/bmp-modes/bmp-mode'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'all', 'route-monitoring', 'bmp-modes', 'bmp-mode'])

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'bmp-mode'
        self.elements = elements

    mut def create(self, mode_name):
        for e in self:
            match = True
            if e.mode_name != mode_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry(mode_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['mode-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_mode_name = yang.gdata.from_xml_str(node, 'mode-name')
    yang.gdata.maybe_add(children, 'mode-name', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode__mode_name, child_mode_name)
    child_advertisement_interval = yang.gdata.from_xml_opt_bigint(node, 'advertisement-interval')
    yang.gdata.maybe_add(children, 'advertisement-interval', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode__advertisement_interval, child_advertisement_interval)
    child_scan_time = yang.gdata.from_xml_opt_bigint(node, 'scan-time')
    yang.gdata.maybe_add(children, 'scan-time', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode__scan_time, child_scan_time)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_element(e) for e in nodes]
    return yang.gdata.List(keys=['mode-name'], elements=elements)

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes(yang.adata.MNode):
    bmp_mode: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode

    mut def __init__(self, bmp_mode: list[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.bmp_mode = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode(elements=bmp_mode)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _bmp_mode = self.bmp_mode
        if _bmp_mode is not None:
            children['bmp-mode'] = _bmp_mode.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes(bmp_mode=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode.from_gdata(n.get_opt_list('bmp-mode')))
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /bmp/servers/all/route-monitoring/bmp-modes')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes()')
        leaves = []
        _bmp_mode = self.bmp_mode
        for _element in _bmp_mode:
            res.append('')
            res.append("# List /bmp/servers/all/route-monitoring/bmp-modes/bmp-mode element: {_element.to_gdata().key_str(['mode-name'])}")
            list_elem = 'bmp_mode_element = {self_name}.bmp_mode.create({repr_yang(_element.mode_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('bmp_mode_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /bmp/servers/all/route-monitoring/bmp-modes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'all', 'route-monitoring', 'bmp-modes'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_bmp_mode = yang.gdata.from_xml_opt_list(node, 'bmp-mode')
    yang.gdata.maybe_add(children, 'bmp-mode', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode, child_bmp_mode)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring(yang.adata.MNode):
    bmp_modes: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes

    mut def __init__(self, bmp_modes: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.bmp_modes = bmp_modes if bmp_modes is not None else Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _bmp_modes = self.bmp_modes
        if _bmp_modes is not None:
            children['bmp-modes'] = _bmp_modes.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring(bmp_modes=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes.from_gdata(n.get_opt_cnt('bmp-modes')))
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /bmp/servers/all/route-monitoring')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring()')
        leaves = []
        _bmp_modes = self.bmp_modes
        if _bmp_modes is not None:
            res.extend(_bmp_modes.prsrc('{self_name}.bmp_modes', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /bmp/servers/all/route-monitoring'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'all', 'route-monitoring'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_bmp_modes = yang.gdata.from_xml_opt_cnt(node, 'bmp-modes')
    yang.gdata.maybe_add(children, 'bmp-modes', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes, child_bmp_modes)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all(yang.adata.MNode):
    max_buffer_size: ?bigint
    route_monitoring: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring

    mut def __init__(self, max_buffer_size: ?bigint, route_monitoring: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.max_buffer_size = max_buffer_size
        self.route_monitoring = route_monitoring if route_monitoring is not None else Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _max_buffer_size = self.max_buffer_size
        if _max_buffer_size is not None:
            children['max-buffer-size'] = yang.gdata.Leaf('uint32', _max_buffer_size)
        _route_monitoring = self.route_monitoring
        if _route_monitoring is not None:
            children['route-monitoring'] = _route_monitoring.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all(max_buffer_size=n.get_opt_bigint('max-buffer-size'), route_monitoring=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring.from_gdata(n.get_opt_cnt('route-monitoring')))
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /bmp/servers/all')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all()')
        leaves = []
        _max_buffer_size = self.max_buffer_size
        if _max_buffer_size is not None:
            leaves.append('{self_name}.max_buffer_size = {repr_yang(_max_buffer_size)}')
        _route_monitoring = self.route_monitoring
        if _route_monitoring is not None:
            res.extend(_route_monitoring.prsrc('{self_name}.route_monitoring', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /bmp/servers/all'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'all'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_max_buffer_size = yang.gdata.from_xml_opt_bigint(node, 'max-buffer-size')
    yang.gdata.maybe_add(children, 'max-buffer-size', from_data_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__max_buffer_size, child_max_buffer_size)
    child_route_monitoring = yang.gdata.from_xml_opt_cnt(node, 'route-monitoring')
    yang.gdata.maybe_add(children, 'route-monitoring', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring, child_route_monitoring)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers(yang.adata.MNode):
    server: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server
    all: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all

    mut def __init__(self, server: list[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry]=[], all: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.server = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server(elements=server)
        self.all = all if all is not None else Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _server = self.server
        if _server is not None:
            children['server'] = _server.to_gdata()
        _all = self.all
        if _all is not None:
            children['all'] = _all.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers(server=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server.from_gdata(n.get_opt_list('server')), all=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all.from_gdata(n.get_opt_cnt('all')))
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /bmp/servers')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers()')
        leaves = []
        _server = self.server
        for _element in _server:
            res.append('')
            res.append("# List /bmp/servers/server element: {_element.to_gdata().key_str(['bmp-server-id'])}")
            list_elem = 'server_element = {self_name}.server.create({repr_yang(_element.bmp_server_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('server_element', False, list_element=True).splitlines())
        _all = self.all
        if _all is not None:
            res.extend(_all.prsrc('{self_name}.all', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /bmp/servers'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_server = yang.gdata.from_xml_opt_list(node, 'server')
    yang.gdata.maybe_add(children, 'server', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server, child_server)
    child_all = yang.gdata.from_xml_opt_cnt(node, 'all')
    yang.gdata.maybe_add(children, 'all', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all, child_all)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_bgp_cfg__bmp(yang.adata.MNode):
    servers: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers

    mut def __init__(self, servers: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.servers = servers if servers is not None else Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _servers = self.servers
        if _servers is not None:
            children['servers'] = _servers.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp(servers=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers.from_gdata(n.get_opt_cnt('servers')))
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /bmp')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__bmp()')
        leaves = []
        _servers = self.servers
        if _servers is not None:
            res.extend(_servers.prsrc('{self_name}.servers', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /bmp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_servers = yang.gdata.from_xml_opt_cnt(node, 'servers')
    yang.gdata.maybe_add(children, 'servers', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers, child_servers)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__as_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__server_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface__interface_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface(yang.adata.MNode):
    interface_name: ?str

    mut def __init__(self, interface_name: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.interface_name = interface_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _interface_name = self.interface_name
        if _interface_name is not None:
            children['interface-name'] = yang.gdata.Leaf('string', _interface_name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface(interface_name=n.get_opt_str('interface-name'))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/bind-source/interface')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface()')
        leaves = []
        _interface_name = self.interface_name
        if _interface_name is not None:
            leaves.append('{self_name}.interface_name = {repr_yang(_interface_name)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/bind-source/interface'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'bind-source', 'interface'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_interface_name = yang.gdata.from_xml_opt_str(node, 'interface-name')
    yang.gdata.maybe_add(children, 'interface-name', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface__interface_name, child_interface_name)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source(yang.adata.MNode):
    interface: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface

    mut def __init__(self, interface: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.interface = interface if interface is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _interface = self.interface
        if _interface is not None:
            children['interface'] = _interface.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source(interface=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface.from_gdata(n.get_opt_cnt('interface')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/bind-source')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source()')
        leaves = []
        _interface = self.interface
        if _interface is not None:
            res.extend(_interface.prsrc('{self_name}.interface', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/bind-source'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'bind-source'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_interface = yang.gdata.from_xml_opt_cnt(node, 'interface')
    yang.gdata.maybe_add(children, 'interface', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface, child_interface)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__preference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__refresh_time_value(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/refresh-time/off')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/refresh-time/off'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'refresh-time', 'off'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time(yang.adata.MNode):
    refresh_time_value: ?bigint
    off: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off

    mut def __init__(self, refresh_time_value: ?bigint, off: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.refresh_time_value = refresh_time_value
        self.off = off

    mut def create_off(self):
        existing = self.off
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off()
        self.off = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _refresh_time_value = self.refresh_time_value
        if _refresh_time_value is not None:
            children['refresh-time-value'] = yang.gdata.Leaf('uint32', _refresh_time_value)
        _off = self.off
        if _off is not None:
            children['off'] = _off.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time(refresh_time_value=n.get_opt_bigint('refresh-time-value'), off=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off.from_gdata(n.get_opt_cnt('off')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/refresh-time')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time()')
        leaves = []
        _refresh_time_value = self.refresh_time_value
        if _refresh_time_value is not None:
            leaves.append('{self_name}.refresh_time_value = {repr_yang(_refresh_time_value)}')
        _off = self.off
        if _off is not None:
            res.append('')
            res.append('# P-container: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/refresh-time/off')
            res.append('off = {self_name}.create_off()')
            res.extend(_off.prsrc('off', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/refresh-time'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'refresh-time'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_refresh_time_value = yang.gdata.from_xml_opt_bigint(node, 'refresh-time-value')
    yang.gdata.maybe_add(children, 'refresh-time-value', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__refresh_time_value, child_refresh_time_value)
    child_off = yang.gdata.from_xml_opt_cnt(node, 'off')
    yang.gdata.maybe_add(children, 'off', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off, child_off)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__response_time_value(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/response-time/off')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/response-time/off'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'response-time', 'off'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time(yang.adata.MNode):
    response_time_value: ?bigint
    off: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off

    mut def __init__(self, response_time_value: ?bigint, off: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.response_time_value = response_time_value
        self.off = off

    mut def create_off(self):
        existing = self.off
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off()
        self.off = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _response_time_value = self.response_time_value
        if _response_time_value is not None:
            children['response-time-value'] = yang.gdata.Leaf('uint32', _response_time_value)
        _off = self.off
        if _off is not None:
            children['off'] = _off.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time(response_time_value=n.get_opt_bigint('response-time-value'), off=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off.from_gdata(n.get_opt_cnt('off')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/response-time')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time()')
        leaves = []
        _response_time_value = self.response_time_value
        if _response_time_value is not None:
            leaves.append('{self_name}.response_time_value = {repr_yang(_response_time_value)}')
        _off = self.off
        if _off is not None:
            res.append('')
            res.append('# P-container: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/response-time/off')
            res.append('off = {self_name}.create_off()')
            res.extend(_off.prsrc('off', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/response-time'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'response-time'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_response_time_value = yang.gdata.from_xml_opt_bigint(node, 'response-time-value')
    yang.gdata.maybe_add(children, 'response-time-value', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__response_time_value, child_response_time_value)
    child_off = yang.gdata.from_xml_opt_cnt(node, 'off')
    yang.gdata.maybe_add(children, 'off', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off, child_off)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__purge_time(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__username(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__password(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp__port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp(yang.adata.MNode):
    port: ?bigint

    mut def __init__(self, port: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.port = port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _port = self.port
        if _port is not None:
            children['port'] = yang.gdata.Leaf('uint32', _port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp(port=n.get_opt_bigint('port'))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/transport/tcp')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp()')
        leaves = []
        _port = self.port
        if _port is not None:
            leaves.append('{self_name}.port = {repr_yang(_port)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/transport/tcp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'transport', 'tcp'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_port = yang.gdata.from_xml_opt_bigint(node, 'port')
    yang.gdata.maybe_add(children, 'port', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp__port, child_port)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh__port(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh(yang.adata.MNode):
    port: ?bigint

    mut def __init__(self, port: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.port = port

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _port = self.port
        if _port is not None:
            children['port'] = yang.gdata.Leaf('uint32', _port)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh(port=n.get_opt_bigint('port'))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/transport/ssh')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh()')
        leaves = []
        _port = self.port
        if _port is not None:
            leaves.append('{self_name}.port = {repr_yang(_port)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/transport/ssh'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'transport', 'ssh'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_port = yang.gdata.from_xml_opt_bigint(node, 'port')
    yang.gdata.maybe_add(children, 'port', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh__port, child_port)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport(yang.adata.MNode):
    tcp: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp
    ssh: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh

    mut def __init__(self, tcp: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp=None, ssh: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.tcp = tcp if tcp is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp()
        self.ssh = ssh if ssh is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _tcp = self.tcp
        if _tcp is not None:
            children['tcp'] = _tcp.to_gdata()
        _ssh = self.ssh
        if _ssh is not None:
            children['ssh'] = _ssh.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport(tcp=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp.from_gdata(n.get_opt_cnt('tcp')), ssh=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh.from_gdata(n.get_opt_cnt('ssh')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/transport')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport()')
        leaves = []
        _tcp = self.tcp
        if _tcp is not None:
            res.extend(_tcp.prsrc('{self_name}.tcp', False).splitlines())
        _ssh = self.ssh
        if _ssh is not None:
            res.extend(_ssh.prsrc('{self_name}.ssh', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/transport'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'transport'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_tcp = yang.gdata.from_xml_opt_cnt(node, 'tcp')
    yang.gdata.maybe_add(children, 'tcp', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp, child_tcp)
    child_ssh = yang.gdata.from_xml_opt_cnt(node, 'ssh')
    yang.gdata.maybe_add(children, 'ssh', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh, child_ssh)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/shutdown')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/shutdown'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'shutdown'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry(yang.adata.MNode):
    server_id: str
    bind_source: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source
    preference: ?bigint
    refresh_time: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time
    response_time: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time
    purge_time: ?bigint
    username: ?str
    password: ?str
    transport: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport
    shutdown: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown

    mut def __init__(self, server_id: str, bind_source: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source=None, preference: ?bigint, refresh_time: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time=None, response_time: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time=None, purge_time: ?bigint, username: ?str, password: ?str, transport: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport=None, shutdown: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.server_id = server_id
        self.bind_source = bind_source if bind_source is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source()
        self.preference = preference
        self.refresh_time = refresh_time if refresh_time is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time()
        self.response_time = response_time if response_time is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time()
        self.purge_time = purge_time
        self.username = username
        self.password = password
        self.transport = transport if transport is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport()
        self.shutdown = shutdown

    mut def create_shutdown(self):
        existing = self.shutdown
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown()
        self.shutdown = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _server_id = self.server_id
        if _server_id is not None:
            children['server-id'] = yang.gdata.Leaf('string', _server_id)
        _bind_source = self.bind_source
        if _bind_source is not None:
            children['bind-source'] = _bind_source.to_gdata()
        _preference = self.preference
        if _preference is not None:
            children['preference'] = yang.gdata.Leaf('uint32', _preference)
        _refresh_time = self.refresh_time
        if _refresh_time is not None:
            children['refresh-time'] = _refresh_time.to_gdata()
        _response_time = self.response_time
        if _response_time is not None:
            children['response-time'] = _response_time.to_gdata()
        _purge_time = self.purge_time
        if _purge_time is not None:
            children['purge-time'] = yang.gdata.Leaf('uint32', _purge_time)
        _username = self.username
        if _username is not None:
            children['username'] = yang.gdata.Leaf('string', _username)
        _password = self.password
        if _password is not None:
            children['password'] = yang.gdata.Leaf('string', _password)
        _transport = self.transport
        if _transport is not None:
            children['transport'] = _transport.to_gdata()
        _shutdown = self.shutdown
        if _shutdown is not None:
            children['shutdown'] = _shutdown.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry(server_id=n.get_str('server-id'), bind_source=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source.from_gdata(n.get_opt_cnt('bind-source')), preference=n.get_opt_bigint('preference'), refresh_time=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time.from_gdata(n.get_opt_cnt('refresh-time')), response_time=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time.from_gdata(n.get_opt_cnt('response-time')), purge_time=n.get_opt_bigint('purge-time'), username=n.get_opt_str('username'), password=n.get_opt_str('password'), transport=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport.from_gdata(n.get_opt_cnt('transport')), shutdown=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown.from_gdata(n.get_opt_cnt('shutdown')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server({repr_yang(self.server_id)})')
        leaves = []
        _bind_source = self.bind_source
        if _bind_source is not None:
            res.extend(_bind_source.prsrc('{self_name}.bind_source', False).splitlines())
        _preference = self.preference
        if _preference is not None:
            leaves.append('{self_name}.preference = {repr_yang(_preference)}')
        _refresh_time = self.refresh_time
        if _refresh_time is not None:
            res.extend(_refresh_time.prsrc('{self_name}.refresh_time', False).splitlines())
        _response_time = self.response_time
        if _response_time is not None:
            res.extend(_response_time.prsrc('{self_name}.response_time', False).splitlines())
        _purge_time = self.purge_time
        if _purge_time is not None:
            leaves.append('{self_name}.purge_time = {repr_yang(_purge_time)}')
        _username = self.username
        if _username is not None:
            leaves.append('{self_name}.username = {repr_yang(_username)}')
        _password = self.password
        if _password is not None:
            leaves.append('{self_name}.password = {repr_yang(_password)}')
        _transport = self.transport
        if _transport is not None:
            res.extend(_transport.prsrc('{self_name}.transport', False).splitlines())
        _shutdown = self.shutdown
        if _shutdown is not None:
            res.append('')
            res.append('# P-container: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server/shutdown')
            res.append('shutdown = {self_name}.create_shutdown()')
            res.extend(_shutdown.prsrc('shutdown', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/rpki/servers/server'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server'])

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'server'
        self.elements = elements

    mut def create(self, server_id):
        for e in self:
            match = True
            if e.server_id != server_id:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry(server_id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['server-id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_server_id = yang.gdata.from_xml_str(node, 'server-id')
    yang.gdata.maybe_add(children, 'server-id', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__server_id, child_server_id)
    child_bind_source = yang.gdata.from_xml_opt_cnt(node, 'bind-source')
    yang.gdata.maybe_add(children, 'bind-source', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source, child_bind_source)
    child_preference = yang.gdata.from_xml_opt_bigint(node, 'preference')
    yang.gdata.maybe_add(children, 'preference', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__preference, child_preference)
    child_refresh_time = yang.gdata.from_xml_opt_cnt(node, 'refresh-time')
    yang.gdata.maybe_add(children, 'refresh-time', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time, child_refresh_time)
    child_response_time = yang.gdata.from_xml_opt_cnt(node, 'response-time')
    yang.gdata.maybe_add(children, 'response-time', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time, child_response_time)
    child_purge_time = yang.gdata.from_xml_opt_bigint(node, 'purge-time')
    yang.gdata.maybe_add(children, 'purge-time', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__purge_time, child_purge_time)
    child_username = yang.gdata.from_xml_opt_str(node, 'username')
    yang.gdata.maybe_add(children, 'username', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__username, child_username)
    child_password = yang.gdata.from_xml_opt_str(node, 'password')
    yang.gdata.maybe_add(children, 'password', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__password, child_password)
    child_transport = yang.gdata.from_xml_opt_cnt(node, 'transport')
    yang.gdata.maybe_add(children, 'transport', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport, child_transport)
    child_shutdown = yang.gdata.from_xml_opt_cnt(node, 'shutdown')
    yang.gdata.maybe_add(children, 'shutdown', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown, child_shutdown)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_element(e) for e in nodes]
    return yang.gdata.List(keys=['server-id'], elements=elements)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers(yang.adata.MNode):
    server: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server

    mut def __init__(self, server: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.server = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server(elements=server)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _server = self.server
        if _server is not None:
            children['server'] = _server.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers(server=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server.from_gdata(n.get_opt_list('server')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/rpki/servers')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers()')
        leaves = []
        _server = self.server
        for _element in _server:
            res.append('')
            res.append("# List /um-router-bgp-cfg:router/bgp/as/rpki/servers/server element: {_element.to_gdata().key_str(['server-id'])}")
            list_elem = 'server_element = {self_name}.server.create({repr_yang(_element.server_id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('server_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/rpki/servers'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_server = yang.gdata.from_xml_opt_list(node, 'server')
    yang.gdata.maybe_add(children, 'server', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server, child_server)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route__minimum_prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route__maximum_prefix_length(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route__origin_as_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry(yang.adata.MNode):
    address: str
    minimum_prefix_length: bigint
    maximum_prefix_length: bigint
    origin_as_number: bigint

    mut def __init__(self, address: str, minimum_prefix_length: bigint, maximum_prefix_length: bigint, origin_as_number: bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.address = address
        self.minimum_prefix_length = minimum_prefix_length
        self.maximum_prefix_length = maximum_prefix_length
        self.origin_as_number = origin_as_number

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address = self.address
        if _address is not None:
            children['address'] = yang.gdata.Leaf('union', _address)
        _minimum_prefix_length = self.minimum_prefix_length
        if _minimum_prefix_length is not None:
            children['minimum-prefix-length'] = yang.gdata.Leaf('union', _minimum_prefix_length)
        _maximum_prefix_length = self.maximum_prefix_length
        if _maximum_prefix_length is not None:
            children['maximum-prefix-length'] = yang.gdata.Leaf('union', _maximum_prefix_length)
        _origin_as_number = self.origin_as_number
        if _origin_as_number is not None:
            children['origin-as-number'] = yang.gdata.Leaf('uint32', _origin_as_number)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry(address=n.get_str('address'), minimum_prefix_length=n.get_bigint('minimum-prefix-length'), maximum_prefix_length=n.get_bigint('maximum-prefix-length'), origin_as_number=n.get_bigint('origin-as-number'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/rpki/routes/route')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route({repr_yang(self.address)}, {repr_yang(self.minimum_prefix_length)}, {repr_yang(self.maximum_prefix_length)}, {repr_yang(self.origin_as_number)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/rpki/routes/route'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'routes', 'route'])

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'route'
        self.elements = elements

    mut def create(self, address, minimum_prefix_length, maximum_prefix_length, origin_as_number):
        for e in self:
            match = True
            if e.address != address:
                match = False
                continue
            if e.minimum_prefix_length != minimum_prefix_length:
                match = False
                continue
            if e.maximum_prefix_length != maximum_prefix_length:
                match = False
                continue
            if e.origin_as_number != origin_as_number:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry(address, minimum_prefix_length, maximum_prefix_length, origin_as_number)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['address', 'minimum-prefix-length', 'maximum-prefix-length', 'origin-as-number'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_address = yang.gdata.from_xml_str(node, 'address')
    yang.gdata.maybe_add(children, 'address', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route__address, child_address)
    child_minimum_prefix_length = yang.gdata.from_xml_bigint(node, 'minimum-prefix-length')
    yang.gdata.maybe_add(children, 'minimum-prefix-length', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route__minimum_prefix_length, child_minimum_prefix_length)
    child_maximum_prefix_length = yang.gdata.from_xml_bigint(node, 'maximum-prefix-length')
    yang.gdata.maybe_add(children, 'maximum-prefix-length', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route__maximum_prefix_length, child_maximum_prefix_length)
    child_origin_as_number = yang.gdata.from_xml_bigint(node, 'origin-as-number')
    yang.gdata.maybe_add(children, 'origin-as-number', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route__origin_as_number, child_origin_as_number)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_element(e) for e in nodes]
    return yang.gdata.List(keys=['address', 'minimum-prefix-length', 'maximum-prefix-length', 'origin-as-number'], elements=elements)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes(yang.adata.MNode):
    route: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route

    mut def __init__(self, route: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.route = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route(elements=route)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _route = self.route
        if _route is not None:
            children['route'] = _route.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes(route=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route.from_gdata(n.get_opt_list('route')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/rpki/routes')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes()')
        leaves = []
        _route = self.route
        for _element in _route:
            res.append('')
            res.append("# List /um-router-bgp-cfg:router/bgp/as/rpki/routes/route element: {_element.to_gdata().key_str(['address', 'minimum-prefix-length', 'maximum-prefix-length', 'origin-as-number'])}")
            list_elem = 'route_element = {self_name}.route.create({repr_yang(_element.address)}, {repr_yang(_element.minimum_prefix_length)}, {repr_yang(_element.maximum_prefix_length)}, {repr_yang(_element.origin_as_number)})'
            res.append(list_elem)
            res.extend(_element.prsrc('route_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/rpki/routes'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'routes'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_route = yang.gdata.from_xml_opt_list(node, 'route')
    yang.gdata.maybe_add(children, 'route', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route, child_route)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__datafile(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki(yang.adata.MNode):
    servers: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers
    routes: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes
    datafile: ?str

    mut def __init__(self, servers: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers=None, routes: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes=None, datafile: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.servers = servers if servers is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers()
        self.routes = routes if routes is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes()
        self.datafile = datafile

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _servers = self.servers
        if _servers is not None:
            children['servers'] = _servers.to_gdata()
        _routes = self.routes
        if _routes is not None:
            children['routes'] = _routes.to_gdata()
        _datafile = self.datafile
        if _datafile is not None:
            children['datafile'] = yang.gdata.Leaf('string', _datafile)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki(servers=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers.from_gdata(n.get_opt_cnt('servers')), routes=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes.from_gdata(n.get_opt_cnt('routes')), datafile=n.get_opt_str('datafile'))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/rpki')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki()')
        leaves = []
        _servers = self.servers
        if _servers is not None:
            res.extend(_servers.prsrc('{self_name}.servers', False).splitlines())
        _routes = self.routes
        if _routes is not None:
            res.extend(_routes.prsrc('{self_name}.routes', False).splitlines())
        _datafile = self.datafile
        if _datafile is not None:
            leaves.append('{self_name}.datafile = {repr_yang(_datafile)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/rpki'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_servers = yang.gdata.from_xml_opt_cnt(node, 'servers')
    yang.gdata.maybe_add(children, 'servers', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers, child_servers)
    child_routes = yang.gdata.from_xml_opt_cnt(node, 'routes')
    yang.gdata.maybe_add(children, 'routes', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes, child_routes)
    child_datafile = yang.gdata.from_xml_opt_str(node, 'datafile')
    yang.gdata.maybe_add(children, 'datafile', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__datafile, child_datafile)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family__af_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry(yang.adata.MNode):
    af_name: str

    mut def __init__(self, af_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.af_name = af_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _af_name = self.af_name
        if _af_name is not None:
            children['af-name'] = yang.gdata.Leaf('enumeration', _af_name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry(af_name=n.get_str('af-name'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/address-families/address-family')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family({repr_yang(self.af_name)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/address-families/address-family'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'address-families', 'address-family'])

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af_name):
        for e in self:
            match = True
            if e.af_name != af_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry(af_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['af-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_af_name = yang.gdata.from_xml_str(node, 'af-name')
    yang.gdata.maybe_add(children, 'af-name', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family__af_name, child_af_name)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_element(e) for e in nodes]
    return yang.gdata.List(keys=['af-name'], elements=elements)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family

    mut def __init__(self, address_family: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.address_family = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family(elements=address_family)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = _address_family.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families(address_family=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family.from_gdata(n.get_opt_list('address-family')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/address-families')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families()')
        leaves = []
        _address_family = self.address_family
        for _element in _address_family:
            res.append('')
            res.append("# List /um-router-bgp-cfg:router/bgp/as/address-families/address-family element: {_element.to_gdata().key_str(['af-name'])}")
            list_elem = 'address_family_element = {self_name}.address_family.create({repr_yang(_element.af_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('address_family_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/address-families'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'address-families'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_opt_list(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family, child_address_family)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__neighbor_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use__session_group(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use__neighbor_group(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use(yang.adata.MNode):
    session_group: ?str
    neighbor_group: ?str

    mut def __init__(self, session_group: ?str, neighbor_group: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.session_group = session_group
        self.neighbor_group = neighbor_group

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _session_group = self.session_group
        if _session_group is not None:
            children['session-group'] = yang.gdata.Leaf('string', _session_group)
        _neighbor_group = self.neighbor_group
        if _neighbor_group is not None:
            children['neighbor-group'] = yang.gdata.Leaf('string', _neighbor_group)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use(session_group=n.get_opt_str('session-group'), neighbor_group=n.get_opt_str('neighbor-group'))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/neighbors/neighbor/use')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use()')
        leaves = []
        _session_group = self.session_group
        if _session_group is not None:
            leaves.append('{self_name}.session_group = {repr_yang(_session_group)}')
        _neighbor_group = self.neighbor_group
        if _neighbor_group is not None:
            leaves.append('{self_name}.neighbor_group = {repr_yang(_neighbor_group)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/neighbors/neighbor/use'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbors', 'neighbor', 'use'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_session_group = yang.gdata.from_xml_opt_str(node, 'session-group')
    yang.gdata.maybe_add(children, 'session-group', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use__session_group, child_session_group)
    child_neighbor_group = yang.gdata.from_xml_opt_str(node, 'neighbor-group')
    yang.gdata.maybe_add(children, 'neighbor-group', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use__neighbor_group, child_neighbor_group)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry(yang.adata.MNode):
    neighbor_address: str
    use: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use
    description: ?str

    mut def __init__(self, neighbor_address: str, use: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use=None, description: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.neighbor_address = neighbor_address
        self.use = use if use is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use()
        self.description = description

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _neighbor_address = self.neighbor_address
        if _neighbor_address is not None:
            children['neighbor-address'] = yang.gdata.Leaf('union', _neighbor_address)
        _use = self.use
        if _use is not None:
            children['use'] = _use.to_gdata()
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry(neighbor_address=n.get_str('neighbor-address'), use=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use.from_gdata(n.get_opt_cnt('use')), description=n.get_opt_str('description'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/neighbors/neighbor')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor({repr_yang(self.neighbor_address)})')
        leaves = []
        _use = self.use
        if _use is not None:
            res.extend(_use.prsrc('{self_name}.use', False).splitlines())
        _description = self.description
        if _description is not None:
            leaves.append('{self_name}.description = {repr_yang(_description)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/neighbors/neighbor'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbors', 'neighbor'])

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'neighbor'
        self.elements = elements

    mut def create(self, neighbor_address):
        for e in self:
            match = True
            if e.neighbor_address != neighbor_address:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry(neighbor_address)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['neighbor-address'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_neighbor_address = yang.gdata.from_xml_str(node, 'neighbor-address')
    yang.gdata.maybe_add(children, 'neighbor-address', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__neighbor_address, child_neighbor_address)
    child_use = yang.gdata.from_xml_opt_cnt(node, 'use')
    yang.gdata.maybe_add(children, 'use', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use, child_use)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__description, child_description)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_element(e) for e in nodes]
    return yang.gdata.List(keys=['neighbor-address'], elements=elements)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors(yang.adata.MNode):
    neighbor: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor

    mut def __init__(self, neighbor: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.neighbor = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor(elements=neighbor)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _neighbor = self.neighbor
        if _neighbor is not None:
            children['neighbor'] = _neighbor.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors(neighbor=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor.from_gdata(n.get_opt_list('neighbor')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/neighbors')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors()')
        leaves = []
        _neighbor = self.neighbor
        for _element in _neighbor:
            res.append('')
            res.append("# List /um-router-bgp-cfg:router/bgp/as/neighbors/neighbor element: {_element.to_gdata().key_str(['neighbor-address'])}")
            list_elem = 'neighbor_element = {self_name}.neighbor.create({repr_yang(_element.neighbor_address)})'
            res.append(list_elem)
            res.extend(_element.prsrc('neighbor_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/neighbors'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbors'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_neighbor = yang.gdata.from_xml_opt_list(node, 'neighbor')
    yang.gdata.maybe_add(children, 'neighbor', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor, child_neighbor)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__neighbor_group_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family__af_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry(yang.adata.MNode):
    af_name: str

    mut def __init__(self, af_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.af_name = af_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _af_name = self.af_name
        if _af_name is not None:
            children['af-name'] = yang.gdata.Leaf('enumeration', _af_name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry(af_name=n.get_str('af-name'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/neighbor-groups/neighbor-group/address-families/address-family')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family({repr_yang(self.af_name)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/neighbor-groups/neighbor-group/address-families/address-family'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbor-groups', 'neighbor-group', 'address-families', 'address-family'])

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af_name):
        for e in self:
            match = True
            if e.af_name != af_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry(af_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['af-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_af_name = yang.gdata.from_xml_str(node, 'af-name')
    yang.gdata.maybe_add(children, 'af-name', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family__af_name, child_af_name)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_element(e) for e in nodes]
    return yang.gdata.List(keys=['af-name'], elements=elements)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family

    mut def __init__(self, address_family: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.address_family = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family(elements=address_family)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = _address_family.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families(address_family=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family.from_gdata(n.get_opt_list('address-family')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/neighbor-groups/neighbor-group/address-families')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families()')
        leaves = []
        _address_family = self.address_family
        for _element in _address_family:
            res.append('')
            res.append("# List /um-router-bgp-cfg:router/bgp/as/neighbor-groups/neighbor-group/address-families/address-family element: {_element.to_gdata().key_str(['af-name'])}")
            list_elem = 'address_family_element = {self_name}.address_family.create({repr_yang(_element.af_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('address_family_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/neighbor-groups/neighbor-group/address-families'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbor-groups', 'neighbor-group', 'address-families'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_opt_list(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family, child_address_family)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__remote_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__encrypted(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/neighbor-groups/neighbor-group/password/inheritance-disable')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/neighbor-groups/neighbor-group/password/inheritance-disable'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbor-groups', 'neighbor-group', 'password', 'inheritance-disable'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password(yang.adata.MNode):
    encrypted: ?str
    inheritance_disable: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable

    mut def __init__(self, encrypted: ?str, inheritance_disable: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.encrypted = encrypted
        self.inheritance_disable = inheritance_disable

    mut def create_inheritance_disable(self):
        existing = self.inheritance_disable
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable()
        self.inheritance_disable = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _encrypted = self.encrypted
        if _encrypted is not None:
            children['encrypted'] = yang.gdata.Leaf('string', _encrypted)
        _inheritance_disable = self.inheritance_disable
        if _inheritance_disable is not None:
            children['inheritance-disable'] = _inheritance_disable.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password(encrypted=n.get_opt_str('encrypted'), inheritance_disable=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable.from_gdata(n.get_opt_cnt('inheritance-disable')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/neighbor-groups/neighbor-group/password')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password()')
        leaves = []
        _encrypted = self.encrypted
        if _encrypted is not None:
            leaves.append('{self_name}.encrypted = {repr_yang(_encrypted)}')
        _inheritance_disable = self.inheritance_disable
        if _inheritance_disable is not None:
            res.append('')
            res.append('# P-container: /um-router-bgp-cfg:router/bgp/as/neighbor-groups/neighbor-group/password/inheritance-disable')
            res.append('inheritance_disable = {self_name}.create_inheritance_disable()')
            res.extend(_inheritance_disable.prsrc('inheritance_disable', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/neighbor-groups/neighbor-group/password'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbor-groups', 'neighbor-group', 'password'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_encrypted = yang.gdata.from_xml_opt_str(node, 'encrypted')
    yang.gdata.maybe_add(children, 'encrypted', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__encrypted, child_encrypted)
    child_inheritance_disable = yang.gdata.from_xml_opt_cnt(node, 'inheritance-disable')
    yang.gdata.maybe_add(children, 'inheritance-disable', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable, child_inheritance_disable)
    return yang.gdata.Container(children, presence=True)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__update_source(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry(yang.adata.MNode):
    neighbor_group_name: str
    address_families: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families
    remote_as: ?str
    description: ?str
    password: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password
    update_source: ?str

    mut def __init__(self, neighbor_group_name: str, address_families: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families=None, remote_as: ?str, description: ?str, password: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password=None, update_source: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.neighbor_group_name = neighbor_group_name
        self.address_families = address_families if address_families is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families()
        self.remote_as = remote_as
        self.description = description
        self.password = password
        self.update_source = update_source

    mut def create_password(self):
        existing = self.password
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password()
        self.password = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _neighbor_group_name = self.neighbor_group_name
        if _neighbor_group_name is not None:
            children['neighbor-group-name'] = yang.gdata.Leaf('string', _neighbor_group_name)
        _address_families = self.address_families
        if _address_families is not None:
            children['address-families'] = _address_families.to_gdata()
        _remote_as = self.remote_as
        if _remote_as is not None:
            children['remote-as'] = yang.gdata.Leaf('string', _remote_as)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        _password = self.password
        if _password is not None:
            children['password'] = _password.to_gdata()
        _update_source = self.update_source
        if _update_source is not None:
            children['update-source'] = yang.gdata.Leaf('string', _update_source)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry(neighbor_group_name=n.get_str('neighbor-group-name'), address_families=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families.from_gdata(n.get_opt_cnt('address-families')), remote_as=n.get_opt_str('remote-as'), description=n.get_opt_str('description'), password=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password.from_gdata(n.get_opt_cnt('password')), update_source=n.get_opt_str('update-source'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/neighbor-groups/neighbor-group')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group({repr_yang(self.neighbor_group_name)})')
        leaves = []
        _address_families = self.address_families
        if _address_families is not None:
            res.extend(_address_families.prsrc('{self_name}.address_families', False).splitlines())
        _remote_as = self.remote_as
        if _remote_as is not None:
            leaves.append('{self_name}.remote_as = {repr_yang(_remote_as)}')
        _description = self.description
        if _description is not None:
            leaves.append('{self_name}.description = {repr_yang(_description)}')
        _password = self.password
        if _password is not None:
            res.append('')
            res.append('# P-container: /um-router-bgp-cfg:router/bgp/as/neighbor-groups/neighbor-group/password')
            res.append('password = {self_name}.create_password()')
            res.extend(_password.prsrc('password', False).splitlines())
        _update_source = self.update_source
        if _update_source is not None:
            leaves.append('{self_name}.update_source = {repr_yang(_update_source)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/neighbor-groups/neighbor-group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbor-groups', 'neighbor-group'])

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'neighbor-group'
        self.elements = elements

    mut def create(self, neighbor_group_name):
        for e in self:
            match = True
            if e.neighbor_group_name != neighbor_group_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry(neighbor_group_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['neighbor-group-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_neighbor_group_name = yang.gdata.from_xml_str(node, 'neighbor-group-name')
    yang.gdata.maybe_add(children, 'neighbor-group-name', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__neighbor_group_name, child_neighbor_group_name)
    child_address_families = yang.gdata.from_xml_opt_cnt(node, 'address-families')
    yang.gdata.maybe_add(children, 'address-families', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families, child_address_families)
    child_remote_as = yang.gdata.from_xml_opt_str(node, 'remote-as')
    yang.gdata.maybe_add(children, 'remote-as', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__remote_as, child_remote_as)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__description, child_description)
    child_password = yang.gdata.from_xml_opt_cnt(node, 'password')
    yang.gdata.maybe_add(children, 'password', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password, child_password)
    child_update_source = yang.gdata.from_xml_opt_str(node, 'update-source')
    yang.gdata.maybe_add(children, 'update-source', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__update_source, child_update_source)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_element(e) for e in nodes]
    return yang.gdata.List(keys=['neighbor-group-name'], elements=elements)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups(yang.adata.MNode):
    neighbor_group: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group

    mut def __init__(self, neighbor_group: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.neighbor_group = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group(elements=neighbor_group)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _neighbor_group = self.neighbor_group
        if _neighbor_group is not None:
            children['neighbor-group'] = _neighbor_group.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups(neighbor_group=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group.from_gdata(n.get_opt_list('neighbor-group')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/neighbor-groups')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups()')
        leaves = []
        _neighbor_group = self.neighbor_group
        for _element in _neighbor_group:
            res.append('')
            res.append("# List /um-router-bgp-cfg:router/bgp/as/neighbor-groups/neighbor-group element: {_element.to_gdata().key_str(['neighbor-group-name'])}")
            list_elem = 'neighbor_group_element = {self_name}.neighbor_group.create({repr_yang(_element.neighbor_group_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('neighbor_group_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/neighbor-groups'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbor-groups'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_neighbor_group = yang.gdata.from_xml_opt_list(node, 'neighbor-group')
    yang.gdata.maybe_add(children, 'neighbor-group', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group, child_neighbor_group)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp__router_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp(yang.adata.MNode):
    router_id: ?str

    mut def __init__(self, router_id: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.router_id = router_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _router_id = self.router_id
        if _router_id is not None:
            children['router-id'] = yang.gdata.Leaf('string', _router_id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp(router_id=n.get_opt_str('router-id'))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/bgp')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp()')
        leaves = []
        _router_id = self.router_id
        if _router_id is not None:
            leaves.append('{self_name}.router_id = {repr_yang(_router_id)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/bgp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'bgp'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_router_id = yang.gdata.from_xml_opt_str(node, 'router-id')
    yang.gdata.maybe_add(children, 'router-id', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp__router_id, child_router_id)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__vrf_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family__af_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry(yang.adata.MNode):
    af_name: str

    mut def __init__(self, af_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.af_name = af_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _af_name = self.af_name
        if _af_name is not None:
            children['af-name'] = yang.gdata.Leaf('enumeration', _af_name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry(af_name=n.get_str('af-name'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/address-families/address-family')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family({repr_yang(self.af_name)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/address-families/address-family'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'address-families', 'address-family'])

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af_name):
        for e in self:
            match = True
            if e.af_name != af_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry(af_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['af-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_af_name = yang.gdata.from_xml_str(node, 'af-name')
    yang.gdata.maybe_add(children, 'af-name', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family__af_name, child_af_name)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_element(e) for e in nodes]
    return yang.gdata.List(keys=['af-name'], elements=elements)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family

    mut def __init__(self, address_family: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.address_family = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family(elements=address_family)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = _address_family.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families(address_family=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family.from_gdata(n.get_opt_list('address-family')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/address-families')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families()')
        leaves = []
        _address_family = self.address_family
        for _element in _address_family:
            res.append('')
            res.append("# List /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/address-families/address-family element: {_element.to_gdata().key_str(['af-name'])}")
            list_elem = 'address_family_element = {self_name}.address_family.create({repr_yang(_element.af_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('address_family_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/address-families'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'address-families'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_opt_list(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family, child_address_family)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__neighbor_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__af_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__in(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__out(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention__route_policy_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention__retention_time(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention(yang.adata.MNode):
    route_policy_name: ?str
    retention_time: ?bigint

    mut def __init__(self, route_policy_name: ?str, retention_time: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.route_policy_name = route_policy_name
        self.retention_time = retention_time

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _route_policy_name = self.route_policy_name
        if _route_policy_name is not None:
            children['route-policy-name'] = yang.gdata.Leaf('string', _route_policy_name)
        _retention_time = self.retention_time
        if _retention_time is not None:
            children['retention-time'] = yang.gdata.Leaf('uint32', _retention_time)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention(route_policy_name=n.get_opt_str('route-policy-name'), retention_time=n.get_opt_bigint('retention-time'))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/address-families/address-family/route-policy/retention')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention()')
        leaves = []
        _route_policy_name = self.route_policy_name
        if _route_policy_name is not None:
            leaves.append('{self_name}.route_policy_name = {repr_yang(_route_policy_name)}')
        _retention_time = self.retention_time
        if _retention_time is not None:
            leaves.append('{self_name}.retention_time = {repr_yang(_retention_time)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/address-families/address-family/route-policy/retention'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'address-families', 'address-family', 'route-policy', 'retention'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_route_policy_name = yang.gdata.from_xml_opt_str(node, 'route-policy-name')
    yang.gdata.maybe_add(children, 'route-policy-name', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention__route_policy_name, child_route_policy_name)
    child_retention_time = yang.gdata.from_xml_opt_bigint(node, 'retention-time')
    yang.gdata.maybe_add(children, 'retention-time', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention__retention_time, child_retention_time)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy(yang.adata.MNode):
    in_: ?str
    out: ?str
    retention: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention

    mut def __init__(self, in_: ?str, out: ?str, retention: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.in_ = in_
        self.out = out
        self.retention = retention if retention is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _in_ = self.in_
        if _in_ is not None:
            children['in'] = yang.gdata.Leaf('string', _in_)
        _out = self.out
        if _out is not None:
            children['out'] = yang.gdata.Leaf('string', _out)
        _retention = self.retention
        if _retention is not None:
            children['retention'] = _retention.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy(in_=n.get_opt_str('in'), out=n.get_opt_str('out'), retention=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention.from_gdata(n.get_opt_cnt('retention')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/address-families/address-family/route-policy')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy()')
        leaves = []
        _in_ = self.in_
        if _in_ is not None:
            leaves.append('{self_name}.in_ = {repr_yang(_in_)}')
        _out = self.out
        if _out is not None:
            leaves.append('{self_name}.out = {repr_yang(_out)}')
        _retention = self.retention
        if _retention is not None:
            res.extend(_retention.prsrc('{self_name}.retention', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/address-families/address-family/route-policy'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'address-families', 'address-family', 'route-policy'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_in_ = yang.gdata.from_xml_opt_str(node, 'in')
    yang.gdata.maybe_add(children, 'in', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__in, child_in_)
    child_out = yang.gdata.from_xml_opt_str(node, 'out')
    yang.gdata.maybe_add(children, 'out', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__out, child_out)
    child_retention = yang.gdata.from_xml_opt_cnt(node, 'retention')
    yang.gdata.maybe_add(children, 'retention', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention, child_retention)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/address-families/address-family/as-override/inheritance-disable')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/address-families/address-family/as-override/inheritance-disable'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'address-families', 'address-family', 'as-override', 'inheritance-disable'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override(yang.adata.MNode):
    inheritance_disable: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable

    mut def __init__(self, inheritance_disable: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.inheritance_disable = inheritance_disable

    mut def create_inheritance_disable(self):
        existing = self.inheritance_disable
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable()
        self.inheritance_disable = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _inheritance_disable = self.inheritance_disable
        if _inheritance_disable is not None:
            children['inheritance-disable'] = _inheritance_disable.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override(inheritance_disable=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable.from_gdata(n.get_opt_cnt('inheritance-disable')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/address-families/address-family/as-override')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override()')
        leaves = []
        _inheritance_disable = self.inheritance_disable
        if _inheritance_disable is not None:
            res.append('')
            res.append('# P-container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/address-families/address-family/as-override/inheritance-disable')
            res.append('inheritance_disable = {self_name}.create_inheritance_disable()')
            res.extend(_inheritance_disable.prsrc('inheritance_disable', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/address-families/address-family/as-override'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'address-families', 'address-family', 'as-override'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_inheritance_disable = yang.gdata.from_xml_opt_cnt(node, 'inheritance-disable')
    yang.gdata.maybe_add(children, 'inheritance-disable', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable, child_inheritance_disable)
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry(yang.adata.MNode):
    af_name: str
    route_policy: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy
    as_override: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override

    mut def __init__(self, af_name: str, route_policy: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy=None, as_override: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.af_name = af_name
        self.route_policy = route_policy if route_policy is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy()
        self.as_override = as_override

    mut def create_as_override(self):
        existing = self.as_override
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override()
        self.as_override = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _af_name = self.af_name
        if _af_name is not None:
            children['af-name'] = yang.gdata.Leaf('enumeration', _af_name)
        _route_policy = self.route_policy
        if _route_policy is not None:
            children['route-policy'] = _route_policy.to_gdata()
        _as_override = self.as_override
        if _as_override is not None:
            children['as-override'] = _as_override.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry(af_name=n.get_str('af-name'), route_policy=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy.from_gdata(n.get_opt_cnt('route-policy')), as_override=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override.from_gdata(n.get_opt_cnt('as-override')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/address-families/address-family')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family({repr_yang(self.af_name)})')
        leaves = []
        _route_policy = self.route_policy
        if _route_policy is not None:
            res.extend(_route_policy.prsrc('{self_name}.route_policy', False).splitlines())
        _as_override = self.as_override
        if _as_override is not None:
            res.append('')
            res.append('# P-container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/address-families/address-family/as-override')
            res.append('as_override = {self_name}.create_as_override()')
            res.extend(_as_override.prsrc('as_override', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/address-families/address-family'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'address-families', 'address-family'])

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af_name):
        for e in self:
            match = True
            if e.af_name != af_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry(af_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['af-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_af_name = yang.gdata.from_xml_str(node, 'af-name')
    yang.gdata.maybe_add(children, 'af-name', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__af_name, child_af_name)
    child_route_policy = yang.gdata.from_xml_opt_cnt(node, 'route-policy')
    yang.gdata.maybe_add(children, 'route-policy', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy, child_route_policy)
    child_as_override = yang.gdata.from_xml_opt_cnt(node, 'as-override')
    yang.gdata.maybe_add(children, 'as-override', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override, child_as_override)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_element(e) for e in nodes]
    return yang.gdata.List(keys=['af-name'], elements=elements)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family

    mut def __init__(self, address_family: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.address_family = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family(elements=address_family)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = _address_family.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families(address_family=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family.from_gdata(n.get_opt_list('address-family')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/address-families')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families()')
        leaves = []
        _address_family = self.address_family
        for _element in _address_family:
            res.append('')
            res.append("# List /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/address-families/address-family element: {_element.to_gdata().key_str(['af-name'])}")
            list_elem = 'address_family_element = {self_name}.address_family.create({repr_yang(_element.af_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('address_family_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/address-families'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'address-families'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_opt_list(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family, child_address_family)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__remote_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__encrypted(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/password/inheritance-disable')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/password/inheritance-disable'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'password', 'inheritance-disable'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password(yang.adata.MNode):
    encrypted: ?str
    inheritance_disable: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable

    mut def __init__(self, encrypted: ?str, inheritance_disable: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.encrypted = encrypted
        self.inheritance_disable = inheritance_disable

    mut def create_inheritance_disable(self):
        existing = self.inheritance_disable
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable()
        self.inheritance_disable = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _encrypted = self.encrypted
        if _encrypted is not None:
            children['encrypted'] = yang.gdata.Leaf('string', _encrypted)
        _inheritance_disable = self.inheritance_disable
        if _inheritance_disable is not None:
            children['inheritance-disable'] = _inheritance_disable.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password(encrypted=n.get_opt_str('encrypted'), inheritance_disable=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable.from_gdata(n.get_opt_cnt('inheritance-disable')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/password')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password()')
        leaves = []
        _encrypted = self.encrypted
        if _encrypted is not None:
            leaves.append('{self_name}.encrypted = {repr_yang(_encrypted)}')
        _inheritance_disable = self.inheritance_disable
        if _inheritance_disable is not None:
            res.append('')
            res.append('# P-container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/password/inheritance-disable')
            res.append('inheritance_disable = {self_name}.create_inheritance_disable()')
            res.extend(_inheritance_disable.prsrc('inheritance_disable', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/password'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'password'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_encrypted = yang.gdata.from_xml_opt_str(node, 'encrypted')
    yang.gdata.maybe_add(children, 'encrypted', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__encrypted, child_encrypted)
    child_inheritance_disable = yang.gdata.from_xml_opt_cnt(node, 'inheritance-disable')
    yang.gdata.maybe_add(children, 'inheritance-disable', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable, child_inheritance_disable)
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry(yang.adata.MNode):
    neighbor_address: str
    address_families: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families
    remote_as: ?str
    description: ?str
    password: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password

    mut def __init__(self, neighbor_address: str, address_families: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families=None, remote_as: ?str, description: ?str, password: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.neighbor_address = neighbor_address
        self.address_families = address_families if address_families is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families()
        self.remote_as = remote_as
        self.description = description
        self.password = password

    mut def create_password(self):
        existing = self.password
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password()
        self.password = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _neighbor_address = self.neighbor_address
        if _neighbor_address is not None:
            children['neighbor-address'] = yang.gdata.Leaf('union', _neighbor_address)
        _address_families = self.address_families
        if _address_families is not None:
            children['address-families'] = _address_families.to_gdata()
        _remote_as = self.remote_as
        if _remote_as is not None:
            children['remote-as'] = yang.gdata.Leaf('string', _remote_as)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        _password = self.password
        if _password is not None:
            children['password'] = _password.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry(neighbor_address=n.get_str('neighbor-address'), address_families=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families.from_gdata(n.get_opt_cnt('address-families')), remote_as=n.get_opt_str('remote-as'), description=n.get_opt_str('description'), password=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password.from_gdata(n.get_opt_cnt('password')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor({repr_yang(self.neighbor_address)})')
        leaves = []
        _address_families = self.address_families
        if _address_families is not None:
            res.extend(_address_families.prsrc('{self_name}.address_families', False).splitlines())
        _remote_as = self.remote_as
        if _remote_as is not None:
            leaves.append('{self_name}.remote_as = {repr_yang(_remote_as)}')
        _description = self.description
        if _description is not None:
            leaves.append('{self_name}.description = {repr_yang(_description)}')
        _password = self.password
        if _password is not None:
            res.append('')
            res.append('# P-container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor/password')
            res.append('password = {self_name}.create_password()')
            res.extend(_password.prsrc('password', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor'])

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'neighbor'
        self.elements = elements

    mut def create(self, neighbor_address):
        for e in self:
            match = True
            if e.neighbor_address != neighbor_address:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry(neighbor_address)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['neighbor-address'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_neighbor_address = yang.gdata.from_xml_str(node, 'neighbor-address')
    yang.gdata.maybe_add(children, 'neighbor-address', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__neighbor_address, child_neighbor_address)
    child_address_families = yang.gdata.from_xml_opt_cnt(node, 'address-families')
    yang.gdata.maybe_add(children, 'address-families', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families, child_address_families)
    child_remote_as = yang.gdata.from_xml_opt_str(node, 'remote-as')
    yang.gdata.maybe_add(children, 'remote-as', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__remote_as, child_remote_as)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__description, child_description)
    child_password = yang.gdata.from_xml_opt_cnt(node, 'password')
    yang.gdata.maybe_add(children, 'password', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password, child_password)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_element(e) for e in nodes]
    return yang.gdata.List(keys=['neighbor-address'], elements=elements)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors(yang.adata.MNode):
    neighbor: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor

    mut def __init__(self, neighbor: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.neighbor = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor(elements=neighbor)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _neighbor = self.neighbor
        if _neighbor is not None:
            children['neighbor'] = _neighbor.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors(neighbor=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor.from_gdata(n.get_opt_list('neighbor')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors()')
        leaves = []
        _neighbor = self.neighbor
        for _element in _neighbor:
            res.append('')
            res.append("# List /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors/neighbor element: {_element.to_gdata().key_str(['neighbor-address'])}")
            list_elem = 'neighbor_element = {self_name}.neighbor.create({repr_yang(_element.neighbor_address)})'
            res.append(list_elem)
            res.extend(_element.prsrc('neighbor_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/neighbors'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_neighbor = yang.gdata.from_xml_opt_list(node, 'neighbor')
    yang.gdata.maybe_add(children, 'neighbor', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor, child_neighbor)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/rd/auto')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/rd/auto'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'rd', 'auto'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as__as_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as__index(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as(yang.adata.MNode):
    as_number: ?str
    index: ?bigint

    mut def __init__(self, as_number: ?str, index: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _as_number = self.as_number
        if _as_number is not None:
            children['as-number'] = yang.gdata.Leaf('string', _as_number)
        _index = self.index
        if _index is not None:
            children['index'] = yang.gdata.Leaf('uint32', _index)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as(as_number=n.get_opt_str('as-number'), index=n.get_opt_bigint('index'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/rd/two-byte-as')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as()')
        leaves = []
        _as_number = self.as_number
        if _as_number is not None:
            leaves.append('{self_name}.as_number = {repr_yang(_as_number)}')
        _index = self.index
        if _index is not None:
            leaves.append('{self_name}.index = {repr_yang(_index)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/rd/two-byte-as'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'rd', 'two-byte-as'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_as_number = yang.gdata.from_xml_opt_str(node, 'as-number')
    yang.gdata.maybe_add(children, 'as-number', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as__as_number, child_as_number)
    child_index = yang.gdata.from_xml_opt_bigint(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as__index, child_index)
    return yang.gdata.Container(children, presence=True)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as__as_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as__index(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as(yang.adata.MNode):
    as_number: ?str
    index: ?bigint

    mut def __init__(self, as_number: ?str, index: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _as_number = self.as_number
        if _as_number is not None:
            children['as-number'] = yang.gdata.Leaf('string', _as_number)
        _index = self.index
        if _index is not None:
            children['index'] = yang.gdata.Leaf('uint32', _index)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as(as_number=n.get_opt_str('as-number'), index=n.get_opt_bigint('index'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/rd/four-byte-as')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as()')
        leaves = []
        _as_number = self.as_number
        if _as_number is not None:
            leaves.append('{self_name}.as_number = {repr_yang(_as_number)}')
        _index = self.index
        if _index is not None:
            leaves.append('{self_name}.index = {repr_yang(_index)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/rd/four-byte-as'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'rd', 'four-byte-as'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_as_number = yang.gdata.from_xml_opt_str(node, 'as-number')
    yang.gdata.maybe_add(children, 'as-number', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as__as_number, child_as_number)
    child_index = yang.gdata.from_xml_opt_bigint(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as__index, child_index)
    return yang.gdata.Container(children, presence=True)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address__ipv4_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address__index(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address(yang.adata.MNode):
    ipv4_address: ?str
    index: ?bigint

    mut def __init__(self, ipv4_address: ?str, index: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.ipv4_address = ipv4_address
        self.index = index

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4_address = self.ipv4_address
        if _ipv4_address is not None:
            children['ipv4-address'] = yang.gdata.Leaf('string', _ipv4_address)
        _index = self.index
        if _index is not None:
            children['index'] = yang.gdata.Leaf('uint32', _index)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address(ipv4_address=n.get_opt_str('ipv4-address'), index=n.get_opt_bigint('index'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/rd/ip-address')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address()')
        leaves = []
        _ipv4_address = self.ipv4_address
        if _ipv4_address is not None:
            leaves.append('{self_name}.ipv4_address = {repr_yang(_ipv4_address)}')
        _index = self.index
        if _index is not None:
            leaves.append('{self_name}.index = {repr_yang(_index)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/rd/ip-address'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'rd', 'ip-address'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4_address = yang.gdata.from_xml_opt_str(node, 'ipv4-address')
    yang.gdata.maybe_add(children, 'ipv4-address', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address__ipv4_address, child_ipv4_address)
    child_index = yang.gdata.from_xml_opt_bigint(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address__index, child_index)
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd(yang.adata.MNode):
    auto: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto
    two_byte_as: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as
    four_byte_as: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as
    ip_address: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address

    mut def __init__(self, auto: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto=None, two_byte_as: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as=None, four_byte_as: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as=None, ip_address: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.auto = auto
        self.two_byte_as = two_byte_as
        self.four_byte_as = four_byte_as
        self.ip_address = ip_address

    mut def create_auto(self):
        existing = self.auto
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto()
        self.auto = res
        return res

    mut def create_two_byte_as(self, as_number, index):
        existing = self.two_byte_as
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as(as_number, index)
        self.two_byte_as = res
        return res

    mut def create_four_byte_as(self, as_number, index):
        existing = self.four_byte_as
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as(as_number, index)
        self.four_byte_as = res
        return res

    mut def create_ip_address(self, ipv4_address, index):
        existing = self.ip_address
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address(ipv4_address, index)
        self.ip_address = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _auto = self.auto
        if _auto is not None:
            children['auto'] = _auto.to_gdata()
        _two_byte_as = self.two_byte_as
        if _two_byte_as is not None:
            children['two-byte-as'] = _two_byte_as.to_gdata()
        _four_byte_as = self.four_byte_as
        if _four_byte_as is not None:
            children['four-byte-as'] = _four_byte_as.to_gdata()
        _ip_address = self.ip_address
        if _ip_address is not None:
            children['ip-address'] = _ip_address.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd(auto=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto.from_gdata(n.get_opt_cnt('auto')), two_byte_as=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as.from_gdata(n.get_opt_cnt('two-byte-as')), four_byte_as=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as.from_gdata(n.get_opt_cnt('four-byte-as')), ip_address=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address.from_gdata(n.get_opt_cnt('ip-address')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/rd')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd()')
        leaves = []
        _auto = self.auto
        if _auto is not None:
            res.append('')
            res.append('# P-container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/rd/auto')
            res.append('auto = {self_name}.create_auto()')
            res.extend(_auto.prsrc('auto', False).splitlines())
        _two_byte_as = self.two_byte_as
        if _two_byte_as is not None:
            res.append('')
            res.append('# P-container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/rd/two-byte-as')
            res.append('two_byte_as = {self_name}.create_two_byte_as()')
            res.extend(_two_byte_as.prsrc('two_byte_as', False).splitlines())
        _four_byte_as = self.four_byte_as
        if _four_byte_as is not None:
            res.append('')
            res.append('# P-container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/rd/four-byte-as')
            res.append('four_byte_as = {self_name}.create_four_byte_as()')
            res.extend(_four_byte_as.prsrc('four_byte_as', False).splitlines())
        _ip_address = self.ip_address
        if _ip_address is not None:
            res.append('')
            res.append('# P-container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/rd/ip-address')
            res.append('ip_address = {self_name}.create_ip_address()')
            res.extend(_ip_address.prsrc('ip_address', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/rd'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'rd'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_auto = yang.gdata.from_xml_opt_cnt(node, 'auto')
    yang.gdata.maybe_add(children, 'auto', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto, child_auto)
    child_two_byte_as = yang.gdata.from_xml_opt_cnt(node, 'two-byte-as')
    yang.gdata.maybe_add(children, 'two-byte-as', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as, child_two_byte_as)
    child_four_byte_as = yang.gdata.from_xml_opt_cnt(node, 'four-byte-as')
    yang.gdata.maybe_add(children, 'four-byte-as', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as, child_four_byte_as)
    child_ip_address = yang.gdata.from_xml_opt_cnt(node, 'ip-address')
    yang.gdata.maybe_add(children, 'ip-address', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address, child_ip_address)
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry(yang.adata.MNode):
    vrf_name: str
    address_families: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families
    neighbors: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors
    rd: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd

    mut def __init__(self, vrf_name: str, address_families: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families=None, neighbors: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors=None, rd: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.vrf_name = vrf_name
        self.address_families = address_families if address_families is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families()
        self.neighbors = neighbors if neighbors is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors()
        self.rd = rd

    mut def create_rd(self):
        existing = self.rd
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd()
        self.rd = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vrf_name = self.vrf_name
        if _vrf_name is not None:
            children['vrf-name'] = yang.gdata.Leaf('string', _vrf_name)
        _address_families = self.address_families
        if _address_families is not None:
            children['address-families'] = _address_families.to_gdata()
        _neighbors = self.neighbors
        if _neighbors is not None:
            children['neighbors'] = _neighbors.to_gdata()
        _rd = self.rd
        if _rd is not None:
            children['rd'] = _rd.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry(vrf_name=n.get_str('vrf-name'), address_families=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families.from_gdata(n.get_opt_cnt('address-families')), neighbors=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors.from_gdata(n.get_opt_cnt('neighbors')), rd=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd.from_gdata(n.get_opt_cnt('rd')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf({repr_yang(self.vrf_name)})')
        leaves = []
        _address_families = self.address_families
        if _address_families is not None:
            res.extend(_address_families.prsrc('{self_name}.address_families', False).splitlines())
        _neighbors = self.neighbors
        if _neighbors is not None:
            res.extend(_neighbors.prsrc('{self_name}.neighbors', False).splitlines())
        _rd = self.rd
        if _rd is not None:
            res.append('')
            res.append('# P-container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf/rd')
            res.append('rd = {self_name}.create_rd()')
            res.extend(_rd.prsrc('rd', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs/vrf'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf'])

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'vrf'
        self.elements = elements

    mut def create(self, vrf_name):
        for e in self:
            match = True
            if e.vrf_name != vrf_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry(vrf_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['vrf-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_vrf_name = yang.gdata.from_xml_str(node, 'vrf-name')
    yang.gdata.maybe_add(children, 'vrf-name', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__vrf_name, child_vrf_name)
    child_address_families = yang.gdata.from_xml_opt_cnt(node, 'address-families')
    yang.gdata.maybe_add(children, 'address-families', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families, child_address_families)
    child_neighbors = yang.gdata.from_xml_opt_cnt(node, 'neighbors')
    yang.gdata.maybe_add(children, 'neighbors', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors, child_neighbors)
    child_rd = yang.gdata.from_xml_opt_cnt(node, 'rd')
    yang.gdata.maybe_add(children, 'rd', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd, child_rd)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_element(e) for e in nodes]
    return yang.gdata.List(keys=['vrf-name'], elements=elements)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs(yang.adata.MNode):
    vrf: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf

    mut def __init__(self, vrf: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.vrf = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf(elements=vrf)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vrf = self.vrf
        if _vrf is not None:
            children['vrf'] = _vrf.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs(vrf=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf.from_gdata(n.get_opt_list('vrf')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as/vrfs')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs()')
        leaves = []
        _vrf = self.vrf
        for _element in _vrf:
            res.append('')
            res.append("# List /um-router-bgp-cfg:router/bgp/as/vrfs/vrf element: {_element.to_gdata().key_str(['vrf-name'])}")
            list_elem = 'vrf_element = {self_name}.vrf.create({repr_yang(_element.vrf_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('vrf_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as/vrfs'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_vrf = yang.gdata.from_xml_opt_list(node, 'vrf')
    yang.gdata.maybe_add(children, 'vrf', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf, child_vrf)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry(yang.adata.MNode):
    as_number: str
    rpki: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki
    address_families: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families
    neighbors: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors
    neighbor_groups: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups
    bgp: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp
    vrfs: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs

    mut def __init__(self, as_number: str, rpki: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki=None, address_families: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families=None, neighbors: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors=None, neighbor_groups: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups=None, bgp: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp=None, vrfs: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.rpki = rpki if rpki is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki()
        self.address_families = address_families if address_families is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families()
        self.neighbors = neighbors if neighbors is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors()
        self.neighbor_groups = neighbor_groups if neighbor_groups is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups()
        self.bgp = bgp if bgp is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp()
        self.vrfs = vrfs if vrfs is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _as_number = self.as_number
        if _as_number is not None:
            children['as-number'] = yang.gdata.Leaf('string', _as_number)
        _rpki = self.rpki
        if _rpki is not None:
            children['rpki'] = _rpki.to_gdata()
        _address_families = self.address_families
        if _address_families is not None:
            children['address-families'] = _address_families.to_gdata()
        _neighbors = self.neighbors
        if _neighbors is not None:
            children['neighbors'] = _neighbors.to_gdata()
        _neighbor_groups = self.neighbor_groups
        if _neighbor_groups is not None:
            children['neighbor-groups'] = _neighbor_groups.to_gdata()
        _bgp = self.bgp
        if _bgp is not None:
            children['bgp'] = _bgp.to_gdata()
        _vrfs = self.vrfs
        if _vrfs is not None:
            children['vrfs'] = _vrfs.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry(as_number=n.get_str('as-number'), rpki=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki.from_gdata(n.get_opt_cnt('rpki')), address_families=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families.from_gdata(n.get_opt_cnt('address-families')), neighbors=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors.from_gdata(n.get_opt_cnt('neighbors')), neighbor_groups=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups.from_gdata(n.get_opt_cnt('neighbor-groups')), bgp=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp.from_gdata(n.get_opt_cnt('bgp')), vrfs=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs.from_gdata(n.get_opt_cnt('vrfs')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp/as')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as({repr_yang(self.as_number)})')
        leaves = []
        _rpki = self.rpki
        if _rpki is not None:
            res.extend(_rpki.prsrc('{self_name}.rpki', False).splitlines())
        _address_families = self.address_families
        if _address_families is not None:
            res.extend(_address_families.prsrc('{self_name}.address_families', False).splitlines())
        _neighbors = self.neighbors
        if _neighbors is not None:
            res.extend(_neighbors.prsrc('{self_name}.neighbors', False).splitlines())
        _neighbor_groups = self.neighbor_groups
        if _neighbor_groups is not None:
            res.extend(_neighbor_groups.prsrc('{self_name}.neighbor_groups', False).splitlines())
        _bgp = self.bgp
        if _bgp is not None:
            res.extend(_bgp.prsrc('{self_name}.bgp', False).splitlines())
        _vrfs = self.vrfs
        if _vrfs is not None:
            res.extend(_vrfs.prsrc('{self_name}.vrfs', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp/as'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as'])

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'as'
        self.elements = elements

    mut def create(self, as_number):
        for e in self:
            match = True
            if e.as_number != as_number:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry(as_number)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['as-number'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_as_number = yang.gdata.from_xml_str(node, 'as-number')
    yang.gdata.maybe_add(children, 'as-number', from_data_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__as_number, child_as_number)
    child_rpki = yang.gdata.from_xml_opt_cnt(node, 'rpki')
    yang.gdata.maybe_add(children, 'rpki', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki, child_rpki)
    child_address_families = yang.gdata.from_xml_opt_cnt(node, 'address-families')
    yang.gdata.maybe_add(children, 'address-families', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families, child_address_families)
    child_neighbors = yang.gdata.from_xml_opt_cnt(node, 'neighbors')
    yang.gdata.maybe_add(children, 'neighbors', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors, child_neighbors)
    child_neighbor_groups = yang.gdata.from_xml_opt_cnt(node, 'neighbor-groups')
    yang.gdata.maybe_add(children, 'neighbor-groups', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups, child_neighbor_groups)
    child_bgp = yang.gdata.from_xml_opt_cnt(node, 'bgp')
    yang.gdata.maybe_add(children, 'bgp', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp, child_bgp)
    child_vrfs = yang.gdata.from_xml_opt_cnt(node, 'vrfs')
    yang.gdata.maybe_add(children, 'vrfs', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs, child_vrfs)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_element(e) for e in nodes]
    return yang.gdata.List(keys=['as-number'], elements=elements)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp(yang.adata.MNode):
    as_: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as

    mut def __init__(self, as_: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_ = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as(elements=as_)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _as_ = self.as_
        if _as_ is not None:
            children['as'] = _as_.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp(as_=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as.from_gdata(n.get_opt_list('as')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router/bgp')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp()')
        leaves = []
        _as_ = self.as_
        for _element in _as_:
            res.append('')
            res.append("# List /um-router-bgp-cfg:router/bgp/as element: {_element.to_gdata().key_str(['as-number'])}")
            list_elem = 'as__element = {self_name}.as_.create({repr_yang(_element.as_number)})'
            res.append(list_elem)
            res.extend(_element.prsrc('as__element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router/bgp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_as_ = yang.gdata.from_xml_opt_list(node, 'as')
    yang.gdata.maybe_add(children, 'as', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as, child_as_)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router(yang.adata.MNode):
    bgp: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp

    mut def __init__(self, bgp: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.bgp = bgp if bgp is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _bgp = self.bgp
        if _bgp is not None:
            children['bgp'] = _bgp.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router(bgp=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp.from_gdata(n.get_opt_cnt('bgp')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /um-router-bgp-cfg:router')
            res.append('{self_name} = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router()')
        leaves = []
        _bgp = self.bgp
        if _bgp is not None:
            res.extend(_bgp.prsrc('{self_name}.bgp', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /um-router-bgp-cfg:router'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router'])


mut def from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_bgp = yang.gdata.from_xml_opt_cnt(node, 'bgp')
    yang.gdata.maybe_add(children, 'bgp', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp, child_bgp)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', module='Cisco-IOS-XR-um-router-bgp-cfg')

mut def from_data_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family__af_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry(yang.adata.MNode):
    af_name: str

    mut def __init__(self, af_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self.af_name = af_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _af_name = self.af_name
        if _af_name is not None:
            children['af-name'] = yang.gdata.Leaf('enumeration', _af_name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry:
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry(af_name=n.get_str('af-name'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /mpls/ldp/address-families/address-family')
            res.append('{self_name} = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family({repr_yang(self.af_name)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /mpls/ldp/address-families/address-family'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-mpls-ldp-cfg:mpls', 'ldp', 'address-families', 'address-family'])

class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af_name):
        for e in self:
            match = True
            if e.af_name != af_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry(af_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['af-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family(elements=copied_elements)

extension Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family(Iterable[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_af_name = yang.gdata.from_xml_str(node, 'af-name')
    yang.gdata.maybe_add(children, 'af-name', from_data_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family__af_name, child_af_name)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_element(e) for e in nodes]
    return yang.gdata.List(keys=['af-name'], elements=elements)

class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family

    mut def __init__(self, address_family: list[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self.address_family = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family(elements=address_family)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = _address_family.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families:
        if n is not None:
            return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families(address_family=Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family.from_gdata(n.get_opt_list('address-family')))
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /mpls/ldp/address-families')
            res.append('{self_name} = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families()')
        leaves = []
        _address_family = self.address_family
        for _element in _address_family:
            res.append('')
            res.append("# List /mpls/ldp/address-families/address-family element: {_element.to_gdata().key_str(['af-name'])}")
            list_elem = 'address_family_element = {self_name}.address_family.create({repr_yang(_element.af_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('address_family_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /mpls/ldp/address-families'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-mpls-ldp-cfg:mpls', 'ldp', 'address-families'])


mut def from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_opt_list(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family, child_address_family)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface__interface_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry(yang.adata.MNode):
    interface_name: str

    mut def __init__(self, interface_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self.interface_name = interface_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _interface_name = self.interface_name
        if _interface_name is not None:
            children['interface-name'] = yang.gdata.Leaf('string', _interface_name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry:
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry(interface_name=n.get_str('interface-name'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /mpls/ldp/interfaces/interface')
            res.append('{self_name} = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface({repr_yang(self.interface_name)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /mpls/ldp/interfaces/interface'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-mpls-ldp-cfg:mpls', 'ldp', 'interfaces', 'interface'])

class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self._name = 'interface'
        self.elements = elements

    mut def create(self, interface_name):
        for e in self:
            match = True
            if e.interface_name != interface_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry(interface_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['interface-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface(elements=copied_elements)

extension Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface(Iterable[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_interface_name = yang.gdata.from_xml_str(node, 'interface-name')
    yang.gdata.maybe_add(children, 'interface-name', from_data_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface__interface_name, child_interface_name)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_element(e) for e in nodes]
    return yang.gdata.List(keys=['interface-name'], elements=elements)

class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces(yang.adata.MNode):
    interface: Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface

    mut def __init__(self, interface: list[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self.interface = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface(elements=interface)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _interface = self.interface
        if _interface is not None:
            children['interface'] = _interface.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces:
        if n is not None:
            return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces(interface=Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface.from_gdata(n.get_opt_list('interface')))
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /mpls/ldp/interfaces')
            res.append('{self_name} = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces()')
        leaves = []
        _interface = self.interface
        for _element in _interface:
            res.append('')
            res.append("# List /mpls/ldp/interfaces/interface element: {_element.to_gdata().key_str(['interface-name'])}")
            list_elem = 'interface_element = {self_name}.interface.create({repr_yang(_element.interface_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('interface_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /mpls/ldp/interfaces'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-mpls-ldp-cfg:mpls', 'ldp', 'interfaces'])


mut def from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_interface = yang.gdata.from_xml_opt_list(node, 'interface')
    yang.gdata.maybe_add(children, 'interface', from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface, child_interface)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp(yang.adata.MNode):
    address_families: Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families
    interfaces: Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces

    mut def __init__(self, address_families: ?Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families=None, interfaces: ?Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self.address_families = address_families if address_families is not None else Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families()
        self.interfaces = interfaces if interfaces is not None else Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_families = self.address_families
        if _address_families is not None:
            children['address-families'] = _address_families.to_gdata()
        _interfaces = self.interfaces
        if _interfaces is not None:
            children['interfaces'] = _interfaces.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp:
        if n is not None:
            return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp(address_families=Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families.from_gdata(n.get_opt_cnt('address-families')), interfaces=Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces.from_gdata(n.get_opt_cnt('interfaces')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /mpls/ldp')
            res.append('{self_name} = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp()')
        leaves = []
        _address_families = self.address_families
        if _address_families is not None:
            res.extend(_address_families.prsrc('{self_name}.address_families', False).splitlines())
        _interfaces = self.interfaces
        if _interfaces is not None:
            res.extend(_interfaces.prsrc('{self_name}.interfaces', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /mpls/ldp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-mpls-ldp-cfg:mpls', 'ldp'])


mut def from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_families = yang.gdata.from_xml_opt_cnt(node, 'address-families')
    yang.gdata.maybe_add(children, 'address-families', from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families, child_address_families)
    child_interfaces = yang.gdata.from_xml_opt_cnt(node, 'interfaces')
    yang.gdata.maybe_add(children, 'interfaces', from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces, child_interfaces)
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls(yang.adata.MNode):
    ldp: ?Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp

    mut def __init__(self, ldp: ?Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self.ldp = ldp

    mut def create_ldp(self):
        existing = self.ldp
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp()
        self.ldp = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ldp = self.ldp
        if _ldp is not None:
            children['ldp'] = _ldp.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg', module='Cisco-IOS-XR-um-mpls-ldp-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_mpls_ldp_cfg__mpls:
        if n is not None:
            return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls(ldp=Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp.from_gdata(n.get_opt_cnt('ldp')))
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /mpls')
            res.append('{self_name} = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls()')
        leaves = []
        _ldp = self.ldp
        if _ldp is not None:
            res.append('')
            res.append('# P-container: /mpls/ldp')
            res.append('ldp = {self_name}.create_ldp()')
            res.extend(_ldp.prsrc('ldp', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /mpls'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-mpls-ldp-cfg:mpls'])


mut def from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ldp = yang.gdata.from_xml_opt_cnt(node, 'ldp')
    yang.gdata.maybe_add(children, 'ldp', from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp, child_ldp)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg', module='Cisco-IOS-XR-um-mpls-ldp-cfg')

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__interface_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/sub-interface-type/l2transport')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/sub-interface-type/l2transport'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'sub-interface-type', 'l2transport'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/sub-interface-type/point-to-point')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/sub-interface-type/point-to-point'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'sub-interface-type', 'point-to-point'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/sub-interface-type/multipoint')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/sub-interface-type/multipoint'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'sub-interface-type', 'multipoint'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type(yang.adata.MNode):
    l2transport: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport
    point_to_point: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point
    multipoint: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint

    mut def __init__(self, l2transport: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport=None, point_to_point: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point=None, multipoint: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        self.l2transport = l2transport
        self.point_to_point = point_to_point
        self.multipoint = multipoint

    mut def create_l2transport(self):
        existing = self.l2transport
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport()
        self.l2transport = res
        return res

    mut def create_point_to_point(self):
        existing = self.point_to_point
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point()
        self.point_to_point = res
        return res

    mut def create_multipoint(self):
        existing = self.multipoint
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint()
        self.multipoint = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _l2transport = self.l2transport
        if _l2transport is not None:
            children['l2transport'] = _l2transport.to_gdata()
        _point_to_point = self.point_to_point
        if _point_to_point is not None:
            children['point-to-point'] = _point_to_point.to_gdata()
        _multipoint = self.multipoint
        if _multipoint is not None:
            children['multipoint'] = _multipoint.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type(l2transport=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport.from_gdata(n.get_opt_cnt('l2transport')), point_to_point=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point.from_gdata(n.get_opt_cnt('point-to-point')), multipoint=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint.from_gdata(n.get_opt_cnt('multipoint')))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/sub-interface-type')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type()')
        leaves = []
        _l2transport = self.l2transport
        if _l2transport is not None:
            res.append('')
            res.append('# P-container: /interfaces/interface/sub-interface-type/l2transport')
            res.append('l2transport = {self_name}.create_l2transport()')
            res.extend(_l2transport.prsrc('l2transport', False).splitlines())
        _point_to_point = self.point_to_point
        if _point_to_point is not None:
            res.append('')
            res.append('# P-container: /interfaces/interface/sub-interface-type/point-to-point')
            res.append('point_to_point = {self_name}.create_point_to_point()')
            res.extend(_point_to_point.prsrc('point_to_point', False).splitlines())
        _multipoint = self.multipoint
        if _multipoint is not None:
            res.append('')
            res.append('# P-container: /interfaces/interface/sub-interface-type/multipoint')
            res.append('multipoint = {self_name}.create_multipoint()')
            res.extend(_multipoint.prsrc('multipoint', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/sub-interface-type'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'sub-interface-type'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_l2transport = yang.gdata.from_xml_opt_cnt(node, 'l2transport')
    yang.gdata.maybe_add(children, 'l2transport', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport, child_l2transport)
    child_point_to_point = yang.gdata.from_xml_opt_cnt(node, 'point-to-point')
    yang.gdata.maybe_add(children, 'point-to-point', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point, child_point_to_point)
    child_multipoint = yang.gdata.from_xml_opt_cnt(node, 'multipoint')
    yang.gdata.maybe_add(children, 'multipoint', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint, child_multipoint)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__netmask(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__route_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(yang.adata.MNode):
    address: ?str
    netmask: ?str
    route_tag: ?bigint
    algorithm: ?bigint

    mut def __init__(self, address: ?str, netmask: ?str, route_tag: ?bigint, algorithm: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg'
        self.address = address
        self.netmask = netmask
        self.route_tag = route_tag
        self.algorithm = algorithm

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address = self.address
        if _address is not None:
            children['address'] = yang.gdata.Leaf('string', _address)
        _netmask = self.netmask
        if _netmask is not None:
            children['netmask'] = yang.gdata.Leaf('string', _netmask)
        _route_tag = self.route_tag
        if _route_tag is not None:
            children['route-tag'] = yang.gdata.Leaf('uint32', _route_tag)
        _algorithm = self.algorithm
        if _algorithm is not None:
            children['algorithm'] = yang.gdata.Leaf('uint32', _algorithm)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(address=n.get_opt_str('address'), netmask=n.get_opt_str('netmask'), route_tag=n.get_opt_bigint('route-tag'), algorithm=n.get_opt_bigint('algorithm'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/ipv4/addresses/address')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address()')
        leaves = []
        _address = self.address
        if _address is not None:
            leaves.append('{self_name}.address = {repr_yang(_address)}')
        _netmask = self.netmask
        if _netmask is not None:
            leaves.append('{self_name}.netmask = {repr_yang(_netmask)}')
        _route_tag = self.route_tag
        if _route_tag is not None:
            leaves.append('{self_name}.route_tag = {repr_yang(_route_tag)}')
        _algorithm = self.algorithm
        if _algorithm is not None:
            leaves.append('{self_name}.algorithm = {repr_yang(_algorithm)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/ipv4/addresses/address'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'ipv4', 'Cisco-IOS-XR-um-if-ip-address-cfg:addresses', 'address'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address = yang.gdata.from_xml_opt_str(node, 'address')
    yang.gdata.maybe_add(children, 'address', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__address, child_address)
    child_netmask = yang.gdata.from_xml_opt_str(node, 'netmask')
    yang.gdata.maybe_add(children, 'netmask', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__netmask, child_netmask)
    child_route_tag = yang.gdata.from_xml_opt_bigint(node, 'route-tag')
    yang.gdata.maybe_add(children, 'route-tag', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__route_tag, child_route_tag)
    child_algorithm = yang.gdata.from_xml_opt_bigint(node, 'algorithm')
    yang.gdata.maybe_add(children, 'algorithm', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__algorithm, child_algorithm)
    return yang.gdata.Container(children, presence=True)

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__netmask(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__route_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry(yang.adata.MNode):
    address: str
    netmask: ?str
    route_tag: ?bigint
    algorithm: ?bigint

    mut def __init__(self, address: str, netmask: ?str, route_tag: ?bigint, algorithm: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg'
        self.address = address
        self.netmask = netmask
        self.route_tag = route_tag
        self.algorithm = algorithm

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address = self.address
        if _address is not None:
            children['address'] = yang.gdata.Leaf('string', _address)
        _netmask = self.netmask
        if _netmask is not None:
            children['netmask'] = yang.gdata.Leaf('string', _netmask)
        _route_tag = self.route_tag
        if _route_tag is not None:
            children['route-tag'] = yang.gdata.Leaf('uint32', _route_tag)
        _algorithm = self.algorithm
        if _algorithm is not None:
            children['algorithm'] = yang.gdata.Leaf('uint32', _algorithm)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry:
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry(address=n.get_str('address'), netmask=n.get_opt_str('netmask'), route_tag=n.get_opt_bigint('route-tag'), algorithm=n.get_opt_bigint('algorithm'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/ipv4/addresses/secondaries/secondary')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary({repr_yang(self.address)})')
        leaves = []
        _netmask = self.netmask
        if _netmask is not None:
            leaves.append('{self_name}.netmask = {repr_yang(_netmask)}')
        _route_tag = self.route_tag
        if _route_tag is not None:
            leaves.append('{self_name}.route_tag = {repr_yang(_route_tag)}')
        _algorithm = self.algorithm
        if _algorithm is not None:
            leaves.append('{self_name}.algorithm = {repr_yang(_algorithm)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/ipv4/addresses/secondaries/secondary'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'ipv4', 'Cisco-IOS-XR-um-if-ip-address-cfg:addresses', 'secondaries', 'secondary'])

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg'
        self._name = 'secondary'
        self.elements = elements

    mut def create(self, address, netmask):
        for e in self:
            match = True
            if e.address != address:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry(address, netmask)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['address'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(elements=copied_elements)

extension Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(Iterable[Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_address = yang.gdata.from_xml_str(node, 'address')
    yang.gdata.maybe_add(children, 'address', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__address, child_address)
    child_netmask = yang.gdata.from_xml_opt_str(node, 'netmask')
    yang.gdata.maybe_add(children, 'netmask', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__netmask, child_netmask)
    child_route_tag = yang.gdata.from_xml_opt_bigint(node, 'route-tag')
    yang.gdata.maybe_add(children, 'route-tag', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__route_tag, child_route_tag)
    child_algorithm = yang.gdata.from_xml_opt_bigint(node, 'algorithm')
    yang.gdata.maybe_add(children, 'algorithm', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__algorithm, child_algorithm)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_element(e) for e in nodes]
    return yang.gdata.List(keys=['address'], elements=elements)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries(yang.adata.MNode):
    secondary: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary

    mut def __init__(self, secondary: list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg'
        self.secondary = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(elements=secondary)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _secondary = self.secondary
        if _secondary is not None:
            children['secondary'] = _secondary.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries(secondary=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary.from_gdata(n.get_opt_list('secondary')))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/ipv4/addresses/secondaries')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries()')
        leaves = []
        _secondary = self.secondary
        for _element in _secondary:
            res.append('')
            res.append("# List /interfaces/interface/ipv4/addresses/secondaries/secondary element: {_element.to_gdata().key_str(['address'])}")
            list_elem = 'secondary_element = {self_name}.secondary.create({repr_yang(_element.address)})'
            res.append(list_elem)
            res.extend(_element.prsrc('secondary_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/ipv4/addresses/secondaries'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'ipv4', 'Cisco-IOS-XR-um-if-ip-address-cfg:addresses', 'secondaries'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_secondary = yang.gdata.from_xml_opt_list(node, 'secondary')
    yang.gdata.maybe_add(children, 'secondary', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary, child_secondary)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__unnumbered(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/ipv4/addresses/dhcp')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/ipv4/addresses/dhcp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'ipv4', 'Cisco-IOS-XR-um-if-ip-address-cfg:addresses', 'dhcp'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses(yang.adata.MNode):
    address: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address
    secondaries: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries
    unnumbered: ?str
    dhcp: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp

    mut def __init__(self, address: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address=None, secondaries: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries=None, unnumbered: ?str, dhcp: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg'
        self.address = address
        self.secondaries = secondaries if secondaries is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries()
        self.unnumbered = unnumbered
        self.dhcp = dhcp

    mut def create_address(self, address, netmask):
        existing = self.address
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(address, netmask)
        self.address = res
        return res

    mut def create_dhcp(self):
        existing = self.dhcp
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp()
        self.dhcp = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address = self.address
        if _address is not None:
            children['address'] = _address.to_gdata()
        _secondaries = self.secondaries
        if _secondaries is not None:
            children['secondaries'] = _secondaries.to_gdata()
        _unnumbered = self.unnumbered
        if _unnumbered is not None:
            children['unnumbered'] = yang.gdata.Leaf('string', _unnumbered)
        _dhcp = self.dhcp
        if _dhcp is not None:
            children['dhcp'] = _dhcp.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', module='Cisco-IOS-XR-um-if-ip-address-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses(address=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address.from_gdata(n.get_opt_cnt('address')), secondaries=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries.from_gdata(n.get_opt_cnt('secondaries')), unnumbered=n.get_opt_str('unnumbered'), dhcp=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp.from_gdata(n.get_opt_cnt('dhcp')))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/ipv4/addresses')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses()')
        leaves = []
        _address = self.address
        if _address is not None:
            res.append('')
            res.append('# P-container: /interfaces/interface/ipv4/addresses/address')
            res.append('address = {self_name}.create_address()')
            res.extend(_address.prsrc('address', False).splitlines())
        _secondaries = self.secondaries
        if _secondaries is not None:
            res.extend(_secondaries.prsrc('{self_name}.secondaries', False).splitlines())
        _unnumbered = self.unnumbered
        if _unnumbered is not None:
            leaves.append('{self_name}.unnumbered = {repr_yang(_unnumbered)}')
        _dhcp = self.dhcp
        if _dhcp is not None:
            res.append('')
            res.append('# P-container: /interfaces/interface/ipv4/addresses/dhcp')
            res.append('dhcp = {self_name}.create_dhcp()')
            res.extend(_dhcp.prsrc('dhcp', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/ipv4/addresses'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'ipv4', 'Cisco-IOS-XR-um-if-ip-address-cfg:addresses'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address = yang.gdata.from_xml_opt_cnt(node, 'address')
    yang.gdata.maybe_add(children, 'address', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address, child_address)
    child_secondaries = yang.gdata.from_xml_opt_cnt(node, 'secondaries')
    yang.gdata.maybe_add(children, 'secondaries', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries, child_secondaries)
    child_unnumbered = yang.gdata.from_xml_opt_str(node, 'unnumbered')
    yang.gdata.maybe_add(children, 'unnumbered', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__unnumbered, child_unnumbered)
    child_dhcp = yang.gdata.from_xml_opt_cnt(node, 'dhcp')
    yang.gdata.maybe_add(children, 'dhcp', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp, child_dhcp)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', module='Cisco-IOS-XR-um-if-ip-address-cfg')

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4(yang.adata.MNode):
    addresses: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses

    mut def __init__(self, addresses: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        self.addresses = addresses if addresses is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _addresses = self.addresses
        if _addresses is not None:
            children['addresses'] = _addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4(addresses=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses.from_gdata(n.get_opt_cnt('addresses')))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/ipv4')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4()')
        leaves = []
        _addresses = self.addresses
        if _addresses is not None:
            res.extend(_addresses.prsrc('{self_name}.addresses', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/ipv4'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'ipv4'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_addresses = yang.gdata.from_xml_opt_cnt(node, 'addresses', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg')
    yang.gdata.maybe_add(children, 'addresses', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses, child_addresses)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6()
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/ipv6')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/ipv6'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'ipv6'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/um-interface-cfg:encapsulation/ppp')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/um-interface-cfg:encapsulation/ppp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'encapsulation', 'ppp'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/um-interface-cfg:encapsulation/hdlc')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/um-interface-cfg:encapsulation/hdlc'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'encapsulation', 'hdlc'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/um-interface-cfg:encapsulation/mfr')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/um-interface-cfg:encapsulation/mfr'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'encapsulation', 'mfr'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/um-interface-cfg:encapsulation/frame-relay/IETF')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/um-interface-cfg:encapsulation/frame-relay/IETF'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'encapsulation', 'frame-relay', 'IETF'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay(yang.adata.MNode):
    IETF: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF

    mut def __init__(self, IETF: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        self.IETF = IETF

    mut def create_IETF(self):
        existing = self.IETF
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF()
        self.IETF = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _IETF = self.IETF
        if _IETF is not None:
            children['IETF'] = _IETF.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay(IETF=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF.from_gdata(n.get_opt_cnt('IETF')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/um-interface-cfg:encapsulation/frame-relay')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay()')
        leaves = []
        _IETF = self.IETF
        if _IETF is not None:
            res.append('')
            res.append('# P-container: /interfaces/interface/um-interface-cfg:encapsulation/frame-relay/IETF')
            res.append('IETF = {self_name}.create_IETF()')
            res.extend(_IETF.prsrc('IETF', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/um-interface-cfg:encapsulation/frame-relay'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'encapsulation', 'frame-relay'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_IETF = yang.gdata.from_xml_opt_cnt(node, 'IETF')
    yang.gdata.maybe_add(children, 'IETF', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF, child_IETF)
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation(yang.adata.MNode):
    ppp: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp
    hdlc: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc
    mfr: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr
    frame_relay: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay

    mut def __init__(self, ppp: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp=None, hdlc: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc=None, mfr: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr=None, frame_relay: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        self.ppp = ppp
        self.hdlc = hdlc
        self.mfr = mfr
        self.frame_relay = frame_relay

    mut def create_ppp(self):
        existing = self.ppp
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp()
        self.ppp = res
        return res

    mut def create_hdlc(self):
        existing = self.hdlc
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc()
        self.hdlc = res
        return res

    mut def create_mfr(self):
        existing = self.mfr
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr()
        self.mfr = res
        return res

    mut def create_frame_relay(self):
        existing = self.frame_relay
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay()
        self.frame_relay = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ppp = self.ppp
        if _ppp is not None:
            children['ppp'] = _ppp.to_gdata()
        _hdlc = self.hdlc
        if _hdlc is not None:
            children['hdlc'] = _hdlc.to_gdata()
        _mfr = self.mfr
        if _mfr is not None:
            children['mfr'] = _mfr.to_gdata()
        _frame_relay = self.frame_relay
        if _frame_relay is not None:
            children['frame-relay'] = _frame_relay.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation(ppp=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp.from_gdata(n.get_opt_cnt('ppp')), hdlc=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc.from_gdata(n.get_opt_cnt('hdlc')), mfr=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr.from_gdata(n.get_opt_cnt('mfr')), frame_relay=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay.from_gdata(n.get_opt_cnt('frame-relay')))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/um-interface-cfg:encapsulation')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation()')
        leaves = []
        _ppp = self.ppp
        if _ppp is not None:
            res.append('')
            res.append('# P-container: /interfaces/interface/um-interface-cfg:encapsulation/ppp')
            res.append('ppp = {self_name}.create_ppp()')
            res.extend(_ppp.prsrc('ppp', False).splitlines())
        _hdlc = self.hdlc
        if _hdlc is not None:
            res.append('')
            res.append('# P-container: /interfaces/interface/um-interface-cfg:encapsulation/hdlc')
            res.append('hdlc = {self_name}.create_hdlc()')
            res.extend(_hdlc.prsrc('hdlc', False).splitlines())
        _mfr = self.mfr
        if _mfr is not None:
            res.append('')
            res.append('# P-container: /interfaces/interface/um-interface-cfg:encapsulation/mfr')
            res.append('mfr = {self_name}.create_mfr()')
            res.extend(_mfr.prsrc('mfr', False).splitlines())
        _frame_relay = self.frame_relay
        if _frame_relay is not None:
            res.append('')
            res.append('# P-container: /interfaces/interface/um-interface-cfg:encapsulation/frame-relay')
            res.append('frame_relay = {self_name}.create_frame_relay()')
            res.extend(_frame_relay.prsrc('frame_relay', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/um-interface-cfg:encapsulation'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'encapsulation'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ppp = yang.gdata.from_xml_opt_cnt(node, 'ppp')
    yang.gdata.maybe_add(children, 'ppp', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp, child_ppp)
    child_hdlc = yang.gdata.from_xml_opt_cnt(node, 'hdlc')
    yang.gdata.maybe_add(children, 'hdlc', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc, child_hdlc)
    child_mfr = yang.gdata.from_xml_opt_cnt(node, 'mfr')
    yang.gdata.maybe_add(children, 'mfr', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr, child_mfr)
    child_frame_relay = yang.gdata.from_xml_opt_cnt(node, 'frame-relay')
    yang.gdata.maybe_add(children, 'frame-relay', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay, child_frame_relay)
    return yang.gdata.Container(children)

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__shutdown(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__mtu(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__vrf(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-vrf-cfg', module='Cisco-IOS-XR-um-if-vrf-cfg')

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q__vlan_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q__second_dot1q(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q(yang.adata.MNode):
    vlan_id: ?bigint
    second_dot1q: ?bigint

    mut def __init__(self, vlan_id: ?bigint, second_dot1q: ?bigint):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg'
        self.vlan_id = vlan_id
        self.second_dot1q = second_dot1q

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vlan_id = self.vlan_id
        if _vlan_id is not None:
            children['vlan-id'] = yang.gdata.Leaf('uint32', _vlan_id)
        _second_dot1q = self.second_dot1q
        if _second_dot1q is not None:
            children['second-dot1q'] = yang.gdata.Leaf('uint32', _second_dot1q)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q(vlan_id=n.get_opt_bigint('vlan-id'), second_dot1q=n.get_opt_bigint('second-dot1q'))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/um-l2-ethernet-cfg:encapsulation/dot1q')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q()')
        leaves = []
        _vlan_id = self.vlan_id
        if _vlan_id is not None:
            leaves.append('{self_name}.vlan_id = {repr_yang(_vlan_id)}')
        _second_dot1q = self.second_dot1q
        if _second_dot1q is not None:
            leaves.append('{self_name}.second_dot1q = {repr_yang(_second_dot1q)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/um-l2-ethernet-cfg:encapsulation/dot1q'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'Cisco-IOS-XR-um-l2-ethernet-cfg:encapsulation', 'dot1q'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_vlan_id = yang.gdata.from_xml_opt_bigint(node, 'vlan-id')
    yang.gdata.maybe_add(children, 'vlan-id', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q__vlan_id, child_vlan_id)
    child_second_dot1q = yang.gdata.from_xml_opt_bigint(node, 'second-dot1q')
    yang.gdata.maybe_add(children, 'second-dot1q', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q__second_dot1q, child_second_dot1q)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation(yang.adata.MNode):
    dot1q: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q

    mut def __init__(self, dot1q: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg'
        self.dot1q = dot1q if dot1q is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _dot1q = self.dot1q
        if _dot1q is not None:
            children['dot1q'] = _dot1q.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg', module='Cisco-IOS-XR-um-l2-ethernet-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation(dot1q=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q.from_gdata(n.get_opt_cnt('dot1q')))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface/um-l2-ethernet-cfg:encapsulation')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation()')
        leaves = []
        _dot1q = self.dot1q
        if _dot1q is not None:
            res.extend(_dot1q.prsrc('{self_name}.dot1q', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface/um-l2-ethernet-cfg:encapsulation'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'Cisco-IOS-XR-um-l2-ethernet-cfg:encapsulation'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_dot1q = yang.gdata.from_xml_opt_cnt(node, 'dot1q')
    yang.gdata.maybe_add(children, 'dot1q', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q, child_dot1q)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg', module='Cisco-IOS-XR-um-l2-ethernet-cfg')

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry(yang.adata.MNode):
    interface_name: str
    sub_interface_type: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type
    ipv4: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4
    ipv6: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6
    um_interface_cfg_encapsulation: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation
    shutdown: ?bool
    mtu: ?bigint
    description: ?str
    vrf: ?str
    um_l2_ethernet_cfg_encapsulation: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation

    mut def __init__(self, interface_name: str, sub_interface_type: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type=None, ipv4: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4=None, ipv6: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6=None, um_interface_cfg_encapsulation: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation=None, shutdown: ?bool, mtu: ?bigint, description: ?str, vrf: ?str, um_l2_ethernet_cfg_encapsulation: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        self.interface_name = interface_name
        self.sub_interface_type = sub_interface_type if sub_interface_type is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type()
        self.ipv4 = ipv4 if ipv4 is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4()
        self.ipv6 = ipv6 if ipv6 is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6()
        self.um_interface_cfg_encapsulation = um_interface_cfg_encapsulation if um_interface_cfg_encapsulation is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation()
        self.shutdown = shutdown
        self.mtu = mtu
        self.description = description
        self.vrf = vrf
        self.um_l2_ethernet_cfg_encapsulation = um_l2_ethernet_cfg_encapsulation if um_l2_ethernet_cfg_encapsulation is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _interface_name = self.interface_name
        if _interface_name is not None:
            children['interface-name'] = yang.gdata.Leaf('string', _interface_name)
        _sub_interface_type = self.sub_interface_type
        if _sub_interface_type is not None:
            children['sub-interface-type'] = _sub_interface_type.to_gdata()
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            children['ipv4'] = _ipv4.to_gdata()
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            children['ipv6'] = _ipv6.to_gdata()
        _um_interface_cfg_encapsulation = self.um_interface_cfg_encapsulation
        if _um_interface_cfg_encapsulation is not None:
            children['um-interface-cfg:encapsulation'] = _um_interface_cfg_encapsulation.to_gdata()
        _shutdown = self.shutdown
        if _shutdown is not None:
            children['shutdown'] = yang.gdata.Leaf('empty', _shutdown)
        _mtu = self.mtu
        if _mtu is not None:
            children['mtu'] = yang.gdata.Leaf('uint32', _mtu)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        _vrf = self.vrf
        if _vrf is not None:
            children['vrf'] = yang.gdata.Leaf('string', _vrf, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-vrf-cfg', module='Cisco-IOS-XR-um-if-vrf-cfg')
        _um_l2_ethernet_cfg_encapsulation = self.um_l2_ethernet_cfg_encapsulation
        if _um_l2_ethernet_cfg_encapsulation is not None:
            children['um-l2-ethernet-cfg:encapsulation'] = _um_l2_ethernet_cfg_encapsulation.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry:
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry(interface_name=n.get_str('interface-name'), sub_interface_type=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type.from_gdata(n.get_opt_cnt('sub-interface-type')), ipv4=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4.from_gdata(n.get_opt_cnt('ipv4')), ipv6=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6.from_gdata(n.get_opt_cnt('ipv6')), um_interface_cfg_encapsulation=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation.from_gdata(n.get_opt_cnt('um-interface-cfg:encapsulation')), shutdown=n.get_opt_empty('shutdown'), mtu=n.get_opt_bigint('mtu'), description=n.get_opt_str('description'), vrf=n.get_opt_str('vrf'), um_l2_ethernet_cfg_encapsulation=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation.from_gdata(n.get_opt_cnt('um-l2-ethernet-cfg:encapsulation')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces/interface')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces__interface({repr_yang(self.interface_name)})')
        leaves = []
        _sub_interface_type = self.sub_interface_type
        if _sub_interface_type is not None:
            res.extend(_sub_interface_type.prsrc('{self_name}.sub_interface_type', False).splitlines())
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            res.extend(_ipv4.prsrc('{self_name}.ipv4', False).splitlines())
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            res.extend(_ipv6.prsrc('{self_name}.ipv6', False).splitlines())
        _um_interface_cfg_encapsulation = self.um_interface_cfg_encapsulation
        if _um_interface_cfg_encapsulation is not None:
            res.extend(_um_interface_cfg_encapsulation.prsrc('{self_name}.um_interface_cfg_encapsulation', False).splitlines())
        _shutdown = self.shutdown
        if _shutdown is not None:
            leaves.append('{self_name}.shutdown = {repr_yang(_shutdown)}')
        _mtu = self.mtu
        if _mtu is not None:
            leaves.append('{self_name}.mtu = {repr_yang(_mtu)}')
        _description = self.description
        if _description is not None:
            leaves.append('{self_name}.description = {repr_yang(_description)}')
        _vrf = self.vrf
        if _vrf is not None:
            leaves.append('{self_name}.vrf = {repr_yang(_vrf)}')
        _um_l2_ethernet_cfg_encapsulation = self.um_l2_ethernet_cfg_encapsulation
        if _um_l2_ethernet_cfg_encapsulation is not None:
            res.extend(_um_l2_ethernet_cfg_encapsulation.prsrc('{self_name}.um_l2_ethernet_cfg_encapsulation', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces/interface'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface'])

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        self._name = 'interface'
        self.elements = elements

    mut def create(self, interface_name):
        for e in self:
            match = True
            if e.interface_name != interface_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry(interface_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['interface-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface(elements=copied_elements)

extension Cisco_IOS_XR_um_interface_cfg__interfaces__interface(Iterable[Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_interface_name = yang.gdata.from_xml_str(node, 'interface-name')
    yang.gdata.maybe_add(children, 'interface-name', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__interface_name, child_interface_name)
    child_sub_interface_type = yang.gdata.from_xml_opt_cnt(node, 'sub-interface-type')
    yang.gdata.maybe_add(children, 'sub-interface-type', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type, child_sub_interface_type)
    child_ipv4 = yang.gdata.from_xml_opt_cnt(node, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.from_xml_opt_cnt(node, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6, child_ipv6)
    child_um_interface_cfg_encapsulation = yang.gdata.from_xml_opt_cnt(node, 'encapsulation')
    yang.gdata.maybe_add(children, 'um-interface-cfg:encapsulation', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation, child_um_interface_cfg_encapsulation)
    child_shutdown = yang.gdata.from_xml_opt_empty(node, 'shutdown')
    yang.gdata.maybe_add(children, 'shutdown', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__shutdown, child_shutdown)
    child_mtu = yang.gdata.from_xml_opt_bigint(node, 'mtu')
    yang.gdata.maybe_add(children, 'mtu', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__mtu, child_mtu)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__description, child_description)
    child_vrf = yang.gdata.from_xml_opt_str(node, 'vrf', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-vrf-cfg')
    yang.gdata.maybe_add(children, 'vrf', from_data_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__vrf, child_vrf)
    child_um_l2_ethernet_cfg_encapsulation = yang.gdata.from_xml_opt_cnt(node, 'encapsulation', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg')
    yang.gdata.maybe_add(children, 'um-l2-ethernet-cfg:encapsulation', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation, child_um_l2_ethernet_cfg_encapsulation)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface_element(e) for e in nodes]
    return yang.gdata.List(keys=['interface-name'], elements=elements)

class Cisco_IOS_XR_um_interface_cfg__interfaces(yang.adata.MNode):
    interface: Cisco_IOS_XR_um_interface_cfg__interfaces__interface

    mut def __init__(self, interface: list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        self.interface = Cisco_IOS_XR_um_interface_cfg__interfaces__interface(elements=interface)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _interface = self.interface
        if _interface is not None:
            children['interface'] = _interface.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', module='Cisco-IOS-XR-um-interface-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces(interface=Cisco_IOS_XR_um_interface_cfg__interfaces__interface.from_gdata(n.get_opt_list('interface')))
        return Cisco_IOS_XR_um_interface_cfg__interfaces()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interfaces')
            res.append('{self_name} = Cisco_IOS_XR_um_interface_cfg__interfaces()')
        leaves = []
        _interface = self.interface
        for _element in _interface:
            res.append('')
            res.append("# List /interfaces/interface element: {_element.to_gdata().key_str(['interface-name'])}")
            list_elem = 'interface_element = {self_name}.interface.create({repr_yang(_element.interface_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('interface_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /interfaces'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces'])


mut def from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_interface = yang.gdata.from_xml_opt_list(node, 'interface')
    yang.gdata.maybe_add(children, 'interface', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces__interface, child_interface)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', module='Cisco-IOS-XR-um-interface-cfg')

class Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict:
        if n is not None:
            return Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /ethernet/egress-filter/strict')
            res.append('{self_name} = Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /ethernet/egress-filter/strict'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-l2-ethernet-cfg:ethernet', 'egress-filter', 'strict'])


mut def from_xml_Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter(yang.adata.MNode):
    strict: ?Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict

    mut def __init__(self, strict: ?Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg'
        self.strict = strict

    mut def create_strict(self):
        existing = self.strict
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict()
        self.strict = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _strict = self.strict
        if _strict is not None:
            children['strict'] = _strict.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter:
        if n is not None:
            return Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter(strict=Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict.from_gdata(n.get_opt_cnt('strict')))
        return Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /ethernet/egress-filter')
            res.append('{self_name} = Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter()')
        leaves = []
        _strict = self.strict
        if _strict is not None:
            res.append('')
            res.append('# P-container: /ethernet/egress-filter/strict')
            res.append('strict = {self_name}.create_strict()')
            res.extend(_strict.prsrc('strict', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /ethernet/egress-filter'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-l2-ethernet-cfg:ethernet', 'egress-filter'])


mut def from_xml_Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_strict = yang.gdata.from_xml_opt_cnt(node, 'strict')
    yang.gdata.maybe_add(children, 'strict', from_xml_Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict, child_strict)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet(yang.adata.MNode):
    egress_filter: Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter

    mut def __init__(self, egress_filter: ?Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg'
        self.egress_filter = egress_filter if egress_filter is not None else Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _egress_filter = self.egress_filter
        if _egress_filter is not None:
            children['egress-filter'] = _egress_filter.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg', module='Cisco-IOS-XR-um-l2-ethernet-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet:
        if n is not None:
            return Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet(egress_filter=Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter.from_gdata(n.get_opt_cnt('egress-filter')))
        return Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /ethernet')
            res.append('{self_name} = Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet()')
        leaves = []
        _egress_filter = self.egress_filter
        if _egress_filter is not None:
            res.extend(_egress_filter.prsrc('{self_name}.egress_filter', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /ethernet'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-l2-ethernet-cfg:ethernet'])


mut def from_xml_Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_egress_filter = yang.gdata.from_xml_opt_cnt(node, 'egress-filter')
    yang.gdata.maybe_add(children, 'egress-filter', from_xml_Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter, child_egress_filter)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg', module='Cisco-IOS-XR-um-l2-ethernet-cfg')

mut def from_data_Cisco_IOS_XR_um_hostname_cfg__hostname__system_network_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_um_hostname_cfg__hostname(yang.adata.MNode):
    system_network_name: ?str

    mut def __init__(self, system_network_name: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg'
        self.system_network_name = system_network_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _system_network_name = self.system_network_name
        if _system_network_name is not None:
            children['system-network-name'] = yang.gdata.Leaf('string', _system_network_name)
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg', module='Cisco-IOS-XR-um-hostname-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_hostname_cfg__hostname:
        if n is not None:
            return Cisco_IOS_XR_um_hostname_cfg__hostname(system_network_name=n.get_opt_str('system-network-name'))
        return Cisco_IOS_XR_um_hostname_cfg__hostname()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_hostname_cfg__hostname.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /hostname')
            res.append('{self_name} = Cisco_IOS_XR_um_hostname_cfg__hostname()')
        leaves = []
        _system_network_name = self.system_network_name
        if _system_network_name is not None:
            leaves.append('{self_name}.system_network_name = {repr_yang(_system_network_name)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /hostname'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-um-hostname-cfg:hostname'])


mut def from_xml_Cisco_IOS_XR_um_hostname_cfg__hostname(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_system_network_name = yang.gdata.from_xml_opt_str(node, 'system-network-name')
    yang.gdata.maybe_add(children, 'system-network-name', from_data_Cisco_IOS_XR_um_hostname_cfg__hostname__system_network_name, child_system_network_name)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg', module='Cisco-IOS-XR-um-hostname-cfg')

mut def from_data_Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy__route_policy_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy__rpl_route_policy(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry(yang.adata.MNode):
    route_policy_name: str
    rpl_route_policy: ?str

    mut def __init__(self, route_policy_name: str, rpl_route_policy: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg'
        self.route_policy_name = route_policy_name
        self.rpl_route_policy = rpl_route_policy

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _route_policy_name = self.route_policy_name
        if _route_policy_name is not None:
            children['route-policy-name'] = yang.gdata.Leaf('string', _route_policy_name)
        _rpl_route_policy = self.rpl_route_policy
        if _rpl_route_policy is not None:
            children['rpl-route-policy'] = yang.gdata.Leaf('string', _rpl_route_policy)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry:
        return Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry(route_policy_name=n.get_str('route-policy-name'), rpl_route_policy=n.get_opt_str('rpl-route-policy'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /routing-policy/route-policies/route-policy')
            res.append('{self_name} = Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy({repr_yang(self.route_policy_name)})')
        leaves = []
        _rpl_route_policy = self.rpl_route_policy
        if _rpl_route_policy is not None:
            leaves.append('{self_name}.rpl_route_policy = {repr_yang(_rpl_route_policy)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /routing-policy/route-policies/route-policy'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-policy-repository-cfg:routing-policy', 'route-policies', 'route-policy'])

class Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg'
        self._name = 'route-policy'
        self.elements = elements

    mut def create(self, route_policy_name, rpl_route_policy):
        for e in self:
            match = True
            if e.route_policy_name != route_policy_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry(route_policy_name, rpl_route_policy)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['route-policy-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry]:
        if n is not None:
            return [Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy(elements=copied_elements)

extension Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy(Iterable[Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry]:
        return self.elements.__iter__()

mut def from_xml_Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_route_policy_name = yang.gdata.from_xml_str(node, 'route-policy-name')
    yang.gdata.maybe_add(children, 'route-policy-name', from_data_Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy__route_policy_name, child_route_policy_name)
    child_rpl_route_policy = yang.gdata.from_xml_opt_str(node, 'rpl-route-policy')
    yang.gdata.maybe_add(children, 'rpl-route-policy', from_data_Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy__rpl_route_policy, child_rpl_route_policy)
    return yang.gdata.Container(children)

mut def from_xml_Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_element(e) for e in nodes]
    return yang.gdata.List(keys=['route-policy-name'], elements=elements)

class Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies(yang.adata.MNode):
    route_policy: Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy

    mut def __init__(self, route_policy: list[Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg'
        self.route_policy = Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy(elements=route_policy)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _route_policy = self.route_policy
        if _route_policy is not None:
            children['route-policy'] = _route_policy.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies:
        if n is not None:
            return Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies(route_policy=Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy.from_gdata(n.get_opt_list('route-policy')))
        return Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /routing-policy/route-policies')
            res.append('{self_name} = Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies()')
        leaves = []
        _route_policy = self.route_policy
        for _element in _route_policy:
            res.append('')
            res.append("# List /routing-policy/route-policies/route-policy element: {_element.to_gdata().key_str(['route-policy-name'])}")
            list_elem = 'route_policy_element = {self_name}.route_policy.create({repr_yang(_element.route_policy_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('route_policy_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /routing-policy/route-policies'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-policy-repository-cfg:routing-policy', 'route-policies'])


mut def from_xml_Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_route_policy = yang.gdata.from_xml_opt_list(node, 'route-policy')
    yang.gdata.maybe_add(children, 'route-policy', from_xml_Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy, child_route_policy)
    return yang.gdata.Container(children)

class Cisco_IOS_XR_policy_repository_cfg__routing_policy(yang.adata.MNode):
    route_policies: Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies

    mut def __init__(self, route_policies: ?Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg'
        self.route_policies = route_policies if route_policies is not None else Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _route_policies = self.route_policies
        if _route_policies is not None:
            children['route-policies'] = _route_policies.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg', module='Cisco-IOS-XR-policy-repository-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_policy_repository_cfg__routing_policy:
        if n is not None:
            return Cisco_IOS_XR_policy_repository_cfg__routing_policy(route_policies=Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies.from_gdata(n.get_opt_cnt('route-policies')))
        return Cisco_IOS_XR_policy_repository_cfg__routing_policy()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_policy_repository_cfg__routing_policy.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /routing-policy')
            res.append('{self_name} = Cisco_IOS_XR_policy_repository_cfg__routing_policy()')
        leaves = []
        _route_policies = self.route_policies
        if _route_policies is not None:
            res.extend(_route_policies.prsrc('{self_name}.route_policies', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /routing-policy'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['Cisco-IOS-XR-policy-repository-cfg:routing-policy'])


mut def from_xml_Cisco_IOS_XR_policy_repository_cfg__routing_policy(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_route_policies = yang.gdata.from_xml_opt_cnt(node, 'route-policies')
    yang.gdata.maybe_add(children, 'route-policies', from_xml_Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies, child_route_policies)
    return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg', module='Cisco-IOS-XR-policy-repository-cfg')

class root(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_vrf_cfg__address_family
    vrfs: Cisco_IOS_XR_um_vrf_cfg__vrfs
    selective_vrf_download: Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download
    srlg: ?Cisco_IOS_XR_um_vrf_cfg__srlg
    vrf_groups: Cisco_IOS_XR_um_vrf_cfg__vrf_groups
    um_router_isis_cfg_router: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router
    as_format: Cisco_IOS_XR_um_router_bgp_cfg__as_format
    bmp: Cisco_IOS_XR_um_router_bgp_cfg__bmp
    um_router_bgp_cfg_router: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router
    mpls: Cisco_IOS_XR_um_mpls_ldp_cfg__mpls
    interfaces: Cisco_IOS_XR_um_interface_cfg__interfaces
    ethernet: Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet
    hostname: Cisco_IOS_XR_um_hostname_cfg__hostname
    routing_policy: Cisco_IOS_XR_policy_repository_cfg__routing_policy

    mut def __init__(self, address_family: ?Cisco_IOS_XR_um_vrf_cfg__address_family=None, vrfs: ?Cisco_IOS_XR_um_vrf_cfg__vrfs=None, selective_vrf_download: ?Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download=None, srlg: ?Cisco_IOS_XR_um_vrf_cfg__srlg=None, vrf_groups: ?Cisco_IOS_XR_um_vrf_cfg__vrf_groups=None, um_router_isis_cfg_router: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router=None, as_format: ?Cisco_IOS_XR_um_router_bgp_cfg__as_format=None, bmp: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp=None, um_router_bgp_cfg_router: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router=None, mpls: ?Cisco_IOS_XR_um_mpls_ldp_cfg__mpls=None, interfaces: ?Cisco_IOS_XR_um_interface_cfg__interfaces=None, ethernet: ?Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet=None, hostname: ?Cisco_IOS_XR_um_hostname_cfg__hostname=None, routing_policy: ?Cisco_IOS_XR_policy_repository_cfg__routing_policy=None):
        self._ns = ''
        self.address_family = address_family if address_family is not None else Cisco_IOS_XR_um_vrf_cfg__address_family()
        self.vrfs = vrfs if vrfs is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs()
        self.selective_vrf_download = selective_vrf_download if selective_vrf_download is not None else Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download()
        self.srlg = srlg
        self.vrf_groups = vrf_groups if vrf_groups is not None else Cisco_IOS_XR_um_vrf_cfg__vrf_groups()
        self.um_router_isis_cfg_router = um_router_isis_cfg_router if um_router_isis_cfg_router is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router()
        self.as_format = as_format if as_format is not None else Cisco_IOS_XR_um_router_bgp_cfg__as_format()
        self.bmp = bmp if bmp is not None else Cisco_IOS_XR_um_router_bgp_cfg__bmp()
        self.um_router_bgp_cfg_router = um_router_bgp_cfg_router if um_router_bgp_cfg_router is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router()
        self.mpls = mpls if mpls is not None else Cisco_IOS_XR_um_mpls_ldp_cfg__mpls()
        self.interfaces = interfaces if interfaces is not None else Cisco_IOS_XR_um_interface_cfg__interfaces()
        self.ethernet = ethernet if ethernet is not None else Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet()
        self.hostname = hostname if hostname is not None else Cisco_IOS_XR_um_hostname_cfg__hostname()
        self.routing_policy = routing_policy if routing_policy is not None else Cisco_IOS_XR_policy_repository_cfg__routing_policy()

    mut def create_srlg(self):
        existing = self.srlg
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__srlg()
        self.srlg = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            children['address-family'] = _address_family.to_gdata()
        _vrfs = self.vrfs
        if _vrfs is not None:
            children['vrfs'] = _vrfs.to_gdata()
        _selective_vrf_download = self.selective_vrf_download
        if _selective_vrf_download is not None:
            children['selective-vrf-download'] = _selective_vrf_download.to_gdata()
        _srlg = self.srlg
        if _srlg is not None:
            children['srlg'] = _srlg.to_gdata()
        _vrf_groups = self.vrf_groups
        if _vrf_groups is not None:
            children['vrf-groups'] = _vrf_groups.to_gdata()
        _um_router_isis_cfg_router = self.um_router_isis_cfg_router
        if _um_router_isis_cfg_router is not None:
            children['um-router-isis-cfg:router'] = _um_router_isis_cfg_router.to_gdata()
        _as_format = self.as_format
        if _as_format is not None:
            children['as-format'] = _as_format.to_gdata()
        _bmp = self.bmp
        if _bmp is not None:
            children['bmp'] = _bmp.to_gdata()
        _um_router_bgp_cfg_router = self.um_router_bgp_cfg_router
        if _um_router_bgp_cfg_router is not None:
            children['um-router-bgp-cfg:router'] = _um_router_bgp_cfg_router.to_gdata()
        _mpls = self.mpls
        if _mpls is not None:
            children['mpls'] = _mpls.to_gdata()
        _interfaces = self.interfaces
        if _interfaces is not None:
            children['interfaces'] = _interfaces.to_gdata()
        _ethernet = self.ethernet
        if _ethernet is not None:
            children['ethernet'] = _ethernet.to_gdata()
        _hostname = self.hostname
        if _hostname is not None:
            children['hostname'] = _hostname.to_gdata()
        _routing_policy = self.routing_policy
        if _routing_policy is not None:
            children['routing-policy'] = _routing_policy.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> root:
        if n is not None:
            return root(address_family=Cisco_IOS_XR_um_vrf_cfg__address_family.from_gdata(n.get_opt_cnt('address-family')), vrfs=Cisco_IOS_XR_um_vrf_cfg__vrfs.from_gdata(n.get_opt_cnt('vrfs')), selective_vrf_download=Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download.from_gdata(n.get_opt_cnt('selective-vrf-download')), srlg=Cisco_IOS_XR_um_vrf_cfg__srlg.from_gdata(n.get_opt_cnt('srlg')), vrf_groups=Cisco_IOS_XR_um_vrf_cfg__vrf_groups.from_gdata(n.get_opt_cnt('vrf-groups')), um_router_isis_cfg_router=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router.from_gdata(n.get_opt_cnt('um-router-isis-cfg:router')), as_format=Cisco_IOS_XR_um_router_bgp_cfg__as_format.from_gdata(n.get_opt_cnt('as-format')), bmp=Cisco_IOS_XR_um_router_bgp_cfg__bmp.from_gdata(n.get_opt_cnt('bmp')), um_router_bgp_cfg_router=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router.from_gdata(n.get_opt_cnt('um-router-bgp-cfg:router')), mpls=Cisco_IOS_XR_um_mpls_ldp_cfg__mpls.from_gdata(n.get_opt_cnt('mpls')), interfaces=Cisco_IOS_XR_um_interface_cfg__interfaces.from_gdata(n.get_opt_cnt('interfaces')), ethernet=Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet.from_gdata(n.get_opt_cnt('ethernet')), hostname=Cisco_IOS_XR_um_hostname_cfg__hostname.from_gdata(n.get_opt_cnt('hostname')), routing_policy=Cisco_IOS_XR_policy_repository_cfg__routing_policy.from_gdata(n.get_opt_cnt('routing-policy')))
        return root()

    def copy(self):
        """Create a deep copy of this adata object"""
        return root.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /')
            res.append('{self_name} = root()')
        leaves = []
        _address_family = self.address_family
        if _address_family is not None:
            res.extend(_address_family.prsrc('{self_name}.address_family', False).splitlines())
        _vrfs = self.vrfs
        if _vrfs is not None:
            res.extend(_vrfs.prsrc('{self_name}.vrfs', False).splitlines())
        _selective_vrf_download = self.selective_vrf_download
        if _selective_vrf_download is not None:
            res.extend(_selective_vrf_download.prsrc('{self_name}.selective_vrf_download', False).splitlines())
        _srlg = self.srlg
        if _srlg is not None:
            res.append('')
            res.append('# P-container: /srlg')
            res.append('srlg = {self_name}.create_srlg()')
            res.extend(_srlg.prsrc('srlg', False).splitlines())
        _vrf_groups = self.vrf_groups
        if _vrf_groups is not None:
            res.extend(_vrf_groups.prsrc('{self_name}.vrf_groups', False).splitlines())
        _um_router_isis_cfg_router = self.um_router_isis_cfg_router
        if _um_router_isis_cfg_router is not None:
            res.extend(_um_router_isis_cfg_router.prsrc('{self_name}.um_router_isis_cfg_router', False).splitlines())
        _as_format = self.as_format
        if _as_format is not None:
            res.extend(_as_format.prsrc('{self_name}.as_format', False).splitlines())
        _bmp = self.bmp
        if _bmp is not None:
            res.extend(_bmp.prsrc('{self_name}.bmp', False).splitlines())
        _um_router_bgp_cfg_router = self.um_router_bgp_cfg_router
        if _um_router_bgp_cfg_router is not None:
            res.extend(_um_router_bgp_cfg_router.prsrc('{self_name}.um_router_bgp_cfg_router', False).splitlines())
        _mpls = self.mpls
        if _mpls is not None:
            res.extend(_mpls.prsrc('{self_name}.mpls', False).splitlines())
        _interfaces = self.interfaces
        if _interfaces is not None:
            res.extend(_interfaces.prsrc('{self_name}.interfaces', False).splitlines())
        _ethernet = self.ethernet
        if _ethernet is not None:
            res.extend(_ethernet.prsrc('{self_name}.ethernet', False).splitlines())
        _hostname = self.hostname
        if _hostname is not None:
            res.extend(_hostname.prsrc('{self_name}.hostname', False).splitlines())
        _routing_policy = self.routing_policy
        if _routing_policy is not None:
            res.extend(_routing_policy.prsrc('{self_name}.routing_policy', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True)


mut def from_xml(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_address_family = yang.gdata.from_xml_opt_cnt(node, 'address-family', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg')
    yang.gdata.maybe_add(children, 'address-family', from_xml_Cisco_IOS_XR_um_vrf_cfg__address_family, child_address_family)
    child_vrfs = yang.gdata.from_xml_opt_cnt(node, 'vrfs', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg')
    yang.gdata.maybe_add(children, 'vrfs', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrfs, child_vrfs)
    child_selective_vrf_download = yang.gdata.from_xml_opt_cnt(node, 'selective-vrf-download', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg')
    yang.gdata.maybe_add(children, 'selective-vrf-download', from_xml_Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download, child_selective_vrf_download)
    child_srlg = yang.gdata.from_xml_opt_cnt(node, 'srlg', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg')
    yang.gdata.maybe_add(children, 'srlg', from_xml_Cisco_IOS_XR_um_vrf_cfg__srlg, child_srlg)
    child_vrf_groups = yang.gdata.from_xml_opt_cnt(node, 'vrf-groups', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg')
    yang.gdata.maybe_add(children, 'vrf-groups', from_xml_Cisco_IOS_XR_um_vrf_cfg__vrf_groups, child_vrf_groups)
    child_um_router_isis_cfg_router = yang.gdata.from_xml_opt_cnt(node, 'router', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg')
    yang.gdata.maybe_add(children, 'um-router-isis-cfg:router', from_xml_Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router, child_um_router_isis_cfg_router)
    child_as_format = yang.gdata.from_xml_opt_cnt(node, 'as-format', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg')
    yang.gdata.maybe_add(children, 'as-format', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__as_format, child_as_format)
    child_bmp = yang.gdata.from_xml_opt_cnt(node, 'bmp', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg')
    yang.gdata.maybe_add(children, 'bmp', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__bmp, child_bmp)
    child_um_router_bgp_cfg_router = yang.gdata.from_xml_opt_cnt(node, 'router', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg')
    yang.gdata.maybe_add(children, 'um-router-bgp-cfg:router', from_xml_Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router, child_um_router_bgp_cfg_router)
    child_mpls = yang.gdata.from_xml_opt_cnt(node, 'mpls', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg')
    yang.gdata.maybe_add(children, 'mpls', from_xml_Cisco_IOS_XR_um_mpls_ldp_cfg__mpls, child_mpls)
    child_interfaces = yang.gdata.from_xml_opt_cnt(node, 'interfaces', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg')
    yang.gdata.maybe_add(children, 'interfaces', from_xml_Cisco_IOS_XR_um_interface_cfg__interfaces, child_interfaces)
    child_ethernet = yang.gdata.from_xml_opt_cnt(node, 'ethernet', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg')
    yang.gdata.maybe_add(children, 'ethernet', from_xml_Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet, child_ethernet)
    child_hostname = yang.gdata.from_xml_opt_cnt(node, 'hostname', 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg')
    yang.gdata.maybe_add(children, 'hostname', from_xml_Cisco_IOS_XR_um_hostname_cfg__hostname, child_hostname)
    child_routing_policy = yang.gdata.from_xml_opt_cnt(node, 'routing-policy', 'http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg')
    yang.gdata.maybe_add(children, 'routing-policy', from_xml_Cisco_IOS_XR_policy_repository_cfg__routing_policy, child_routing_policy)
    return yang.gdata.Container(children)

def from_xml_gen3(node: xml.Node, root_path: list[str]=[]) -> yang.gdata.Container:
    # WARNING: this wrapper for the gen3.from_xml schema-driven parser compiles the schema on every call!
    s = yang.compile(src_yang())
    return yang.gen3.from_data(s, node, loose=True, root_path=root_path)

def prsrc_gen3(data, self_name='ad'):
    # WARNING: this wrapper for the gen3.prsrc schema-driven parser compiles the schema on every call!
    s = yang.compile(src_yang())
    return yang.gen3.pradata(s, data, self_name, loose=True)

schema_namespaces: set[str] = {
    'http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-vrf-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg',
}
