import base64
import json
import xml
import yang
import yang.adata
import yang.gdata
import yang.xml
import yang.xpath
from yang.identityref import Identityref, PartialIdentityref
from yang.pattern import YangPattern
from yang.schema import *
from yang.type import Decimal, Ranges

# == This file is generated ==




_identities: list[DIdentity] = []


SRC_DNODE = DRoot(children=[
    DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='address-family', config=True, description='AFI/SAFI configuration', presence=False, children=[
        DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='ipv4', config=True, description='IPv4 address family', presence=False, children=[
            DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='unicast', config=True, description='Unicast topology', presence=True),
            DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='multicast', config=True, description='Multicast topology', presence=False, children=[
                DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='topologies', config=True, description='Specify a non-default topology', presence=False, children=[
                    DList(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='topology', key=['topology-name'], config=True, description='Specify a non-default topology', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='topology-name', config=True, description='Specify a non-default topology', mandatory=False, type_=DTypeString(name='xr:Cisco-ios-xr-string', description='Special characters are not allowed.', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 32)]), patterns=[YangPattern(yang_regex='[\\w\\-\\.:,_@#%$\\+=\\| ;]+', pcre='^(([\\-\\.:,_@#%$\\+=\\| ;]|(?![\\p{{P}}\\p{{Z}}\\p{{C}}])[\\x{{0000}}-\\x{{10FFFF}}])+)$', invert=False)]))
                    ])
                ])
            ])
        ]),
        DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='ipv6', config=True, description='IPv6 address family', presence=False, children=[
            DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='unicast', config=True, description='Unicast topology', presence=True),
            DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='multicast', config=True, description='Multicast topology', presence=False, children=[
                DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='topologies', config=True, description='Specify a non-default topology', presence=False, children=[
                    DList(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='topology', key=['topology-name'], config=True, description='Specify a non-default topology', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='topology-name', config=True, description='Specify a non-default topology', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 32)]), patterns=[]))
                    ])
                ])
            ])
        ])
    ]),
    DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='vrfs', config=True, description='VRF configuration commands', presence=False, children=[
        DList(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='vrf', key=['vrf-name'], config=True, description='VRF name', min_elements=0, ordered_by='system', children=[
            DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='vrf-name', config=True, description='VRF name', mandatory=False, type_=DTypeString(name='xr:Cisco-ios-xr-string', description='Special characters are not allowed.', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 32)]), patterns=[YangPattern(yang_regex='[\\w\\-\\.:,_@#%$\\+=\\| ;]+', pcre='^(([\\-\\.:,_@#%$\\+=\\| ;]|(?![\\p{{P}}\\p{{Z}}\\p{{C}}])[\\x{{0000}}-\\x{{10FFFF}}])+)$', invert=False)])),
            DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='address-family', config=True, description='AFI/SAFI configuration', presence=False, children=[
                DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='ipv4', config=True, description='IPv4 address family', presence=False, children=[
                    DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='unicast', config=True, description='Unicast sub address family', presence=True, children=[
                        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='import', config=True, description='VRF import', presence=False, children=[
                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='route-target', config=True, description='Specify import route target extended communities', presence=False, children=[
                                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='two-byte-as-rts', config=True, description='Two Byte AS Number Route Target', presence=False, children=[
                                    DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='two-byte-as-rt', key=[
'as-number',
'index',
'stitching'
                                        ], config=True, description='Two Byte AS Number Route Target', min_elements=0, ordered_by='system', children=[
                                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='as-number', config=True, description='Two Byte AS Number', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)]))),
                                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='index', config=True, description='ASN2:index (hex or decimal format)', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 4294967295)]))),
                                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='stitching', config=True, description='These are stitching RTs', mandatory=False, type_=DTypeBoolean(name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None))
                                    ])
                                ])
                            ])
                        ]),
                        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='export', config=True, description='VRF export', presence=False, children=[
                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='route-target', config=True, description='Specify export route target extended communities', presence=False, children=[
                                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='two-byte-as-rts', config=True, description='Two Byte AS Number Route Target', presence=False, children=[
                                    DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='two-byte-as-rt', key=[
'as-number',
'index',
'stitching'
                                        ], config=True, description='Two Byte AS Number Route Target', min_elements=0, ordered_by='system', children=[
                                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='as-number', config=True, description='Two Byte AS Number', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)]))),
                                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='index', config=True, description='ASN2:index (hex or decimal format)', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 4294967295)]))),
                                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='stitching', config=True, description='These are stitching RTs', mandatory=False, type_=DTypeBoolean(name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None))
                                    ])
                                ])
                            ])
                        ])
                    ]),
                    DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='multicast', config=True, description='Multicast topology', presence=True),
                    DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='flowspec', config=True, description='Flowspec sub address family', presence=True)
                ]),
                DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='ipv6', config=True, description='IPv6 address family', presence=False, children=[
                    DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='unicast', config=True, description='Unicast sub address family', presence=True, children=[
                        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='import', config=True, description='VRF import', presence=False, children=[
                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='route-target', config=True, description='Specify import route target extended communities', presence=False, children=[
                                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='two-byte-as-rts', config=True, description='Two Byte AS Number Route Target', presence=False, children=[
                                    DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='two-byte-as-rt', key=[
'as-number',
'index',
'stitching'
                                        ], config=True, description='Two Byte AS Number Route Target', min_elements=0, ordered_by='system', children=[
                                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='as-number', config=True, description='Two Byte AS Number', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)]))),
                                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='index', config=True, description='ASN2:index (hex or decimal format)', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 4294967295)]))),
                                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='stitching', config=True, description='These are stitching RTs', mandatory=False, type_=DTypeBoolean(name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None))
                                    ])
                                ])
                            ])
                        ]),
                        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='export', config=True, description='VRF export', presence=False, children=[
                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='route-target', config=True, description='Specify export route target extended communities', presence=False, children=[
                                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='two-byte-as-rts', config=True, description='Two Byte AS Number Route Target', presence=False, children=[
                                    DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='two-byte-as-rt', key=[
'as-number',
'index',
'stitching'
                                        ], config=True, description='Two Byte AS Number Route Target', min_elements=0, ordered_by='system', children=[
                                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='as-number', config=True, description='Two Byte AS Number', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)]))),
                                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='index', config=True, description='ASN2:index (hex or decimal format)', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 4294967295)]))),
                                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='stitching', config=True, description='These are stitching RTs', mandatory=False, type_=DTypeBoolean(name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None))
                                    ])
                                ])
                            ])
                        ])
                    ]),
                    DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='multicast', config=True, description='Multicast topology', presence=True),
                    DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='flowspec', config=True, description='Flowspec sub address family', presence=True)
                ])
            ]),
            DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='mode', config=True, description='VRF mode which determines the max prefix scale', presence=False, children=[
                DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='big', config=True, description='big to set max prefix scale more than 64 K', presence=True)
            ]),
            DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='vpn', config=True, description='VPN ID for the VRF', presence=False, children=[
                DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='id', config=True, description='VPN ID, (OUI:VPN-Index) format(hex), 4 bytes VPN_Index Part', mandatory=False, type_=DTypeString(name='xr:Vpn-id', description='VPN ID format (OUI:VPN-Index in hex integer)', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='([0-9a-f]{{1,8}}):([0-9a-f]{{1,8}})', pcre='^(([0-9a-f]{{1,8}}):([0-9a-f]{{1,8}}))$', invert=False)]))
            ]),
            DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='description', config=True, description='A description for the VRF', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 1024)]), patterns=[])),
            DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='remote-route-filtering', config=True, description='Enable/Disable remote route filtering per VRF', presence=False, children=[
                DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='disable', config=True, description='Disable remote route filtering per VRF', presence=True)
            ]),
            DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='fallback-vrf', config=True, description='Fallback vrf for this VRF', mandatory=False, type_=DTypeString(name='xr:Cisco-ios-xr-string', description='Special characters are not allowed.', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 32)]), patterns=[YangPattern(yang_regex='[\\w\\-\\.:,_@#%$\\+=\\| ;]+', pcre='^(([\\-\\.:,_@#%$\\+=\\| ;]|(?![\\p{{P}}\\p{{Z}}\\p{{C}}])[\\x{{0000}}-\\x{{10FFFF}}])+)$', invert=False)])),
            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='rd', config=True, description='route distinguisher', presence=False, children=[
                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='two-byte-as', config=True, description=' two-byte-as route distinguisher', must=[
DMust(condition='not(../four-byte-as or ../ip-address)', description=None, error_app_tag=None, error_message=None, reference=None)
                    ], presence=True, children=[
                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='as-number', config=True, description='bgp as-number', mandatory=True, type_=DTypeUnion(name='xr:Bgp-as-number', description='BGP AS number type', reference=None, exts=[], builtin_type='union', default=None, types=[DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)])), DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='([1-9][0-9]{{0,4}}).([0-9]{{1,5}})', pcre='^(([1-9][0-9]{{0,4}}).([0-9]{{1,5}}))$', invert=False)]), DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(65536, 4294967295)]))])),
                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='index', config=True, description='ASN2:index (hex or decimal format)', mandatory=True, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 4294967295)])))
                ]),
                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='four-byte-as', config=True, description='four-byte-as route distinguisher', must=[
DMust(condition='not(../two-byte-as or ../ip-address)', description=None, error_app_tag=None, error_message=None, reference=None)
                    ], presence=True, children=[
                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='as-number', config=True, description='4-byte AS number', mandatory=True, type_=DTypeUnion(name='xr:Bgp-as-number', description='BGP AS number type', reference=None, exts=[], builtin_type='union', default=None, types=[DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)])), DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='([1-9][0-9]{{0,4}}).([0-9]{{1,5}})', pcre='^(([1-9][0-9]{{0,4}}).([0-9]{{1,5}}))$', invert=False)]), DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(65536, 4294967295)]))])),
                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='index', config=True, description='ASN2:index (hex or decimal format)', mandatory=True, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 4294967295)])))
                ]),
                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='ip-address', config=True, description='configure this node', must=[
DMust(condition='not(../two-byte-as or ../four-byte-as)', description=None, error_app_tag=None, error_message=None, reference=None)
                    ], presence=True, children=[
                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='ipv4-address', config=True, description='configure this node', mandatory=True, type_=DTypeString(name='inet:ipv4-address-no-zone', description='An IPv4 address without a zone index.  This type, derived from\nipv4-address, may be used in situations where the zone is\nknown from the context and hence no zone index is needed.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='[0-9\\.]*', pcre='^([0-9\\.]*)$', invert=False)])),
                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='index', config=True, description='IPv4Address:index (hex or decimal format)', mandatory=True, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 65535)])))
                ])
            ])
        ])
    ]),
    DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='selective-vrf-download', config=True, description='Selective VRF Download config commands', presence=False, children=[
        DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='disable', config=True, description='Disable Selective VRF Download', presence=True)
    ]),
    DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='srlg', config=True, description='SRLG configuration commands', presence=True, children=[
        DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='names', config=True, description='SRLG name to value mapping', presence=False, children=[
            DList(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='name', key=['srlg-name'], config=True, description='SRLG name to value mapping', min_elements=0, must=[
DMust(condition='value or description', description=None, error_app_tag=None, error_message=None, reference=None)
                ], ordered_by='system', children=[
                DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='srlg-name', config=True, description='SRLG name to value mapping', mandatory=False, type_=DTypeString(name='xr:Cisco-ios-xr-string', description='Special characters are not allowed.', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 64)]), patterns=[YangPattern(yang_regex='[\\w\\-\\.:,_@#%$\\+=\\| ;]+', pcre='^(([\\-\\.:,_@#%$\\+=\\| ;]|(?![\\p{{P}}\\p{{Z}}\\p{{C}}])[\\x{{0000}}-\\x{{10FFFF}}])+)$', invert=False)])),
                DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='value', config=True, description='Configure SRLG network value', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 4294967295)]))),
                DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='description', config=True, description='Configure SRLG network value', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 800)]), patterns=[]))
            ])
        ]),
        DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='interfaces', config=True, description='SRLG interface configuration submode', presence=False, children=[
            DList(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='interface', key=['interface-name'], config=True, description='SRLG interface configuration submode', min_elements=0, ordered_by='system', children=[
                DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='interface-name', config=True, description='SRLG interface configuration submode', mandatory=False, type_=DTypeString(name='xr:Interface-name', description='An interface name specifying an interface type and\ninstance.\nInterface represents a string defining an interface\ntype and instance, e.g. MgmtEth0/4/CPU1/0 or\nTenGigE0/2/0/0.2 or Bundle-Ether9 or\nBundle-Ether9.98 or Serial0/0/0/0/3/1:1', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='[a-zA-Z0-9.:_/-]+', pcre='^([a-zA-Z0-9.:_/-]+)$', invert=False)])),
                DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='include-optical', config=True, description='Include srlg values from optical layer', presence=True, children=[
                    DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='priority', config=True, description='Set prority for the value', mandatory=False, type_=DTypeEnum(name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'critical':0, 'high':1, 'low':3, 'verylow':4}))
                ]),
                DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='indexes', config=True, description='Index number for this value', presence=False, children=[
                    DList(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='index', key=['index-number'], config=True, description='Index number for this value', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='index-number', config=True, description='Index number for this value', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)]))),
                        DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='value', config=True, description='Configure SRLG network value', mandatory=True, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 4294967295)]))),
                        DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='priority', config=True, description='Set prority for the value', mandatory=True, type_=DTypeEnum(name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'critical':0, 'high':1, 'default':2, 'low':3, 'verylow':4}))
                    ])
                ]),
                DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='names', config=True, description='Bind this SRLG name to the interface', presence=False, children=[
                    DList(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='name', key=['srlg-name'], config=True, description='Bind this SRLG name to the interface', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='srlg-name', config=True, description='Bind this SRLG name to the interface', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 64)]), patterns=[]))
                    ])
                ]),
                DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='groups', config=True, description='Configure group srlg values', presence=True, children=[
                    DList(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='group', key=['index-number'], config=True, description='Group index number for this entry', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='index-number', config=True, description='Group index number for this entry', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 1)]))),
                        DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='group-name', config=True, description='Group name', mandatory=True, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 32)]), patterns=[]))
                    ])
                ])
            ])
        ]),
        DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='groups', config=True, description='SRLG group configuration submode', presence=False, children=[
            DList(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='group', key=['group-name'], config=True, description='SRLG group configuration submode', min_elements=0, ordered_by='system', children=[
                DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='group-name', config=True, description='SRLG group configuration submode', mandatory=False, type_=DTypeString(name='xr:Cisco-ios-xr-string', description='Special characters are not allowed.', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 32)]), patterns=[YangPattern(yang_regex='[\\w\\-\\.:,_@#%$\\+=\\| ;]+', pcre='^(([\\-\\.:,_@#%$\\+=\\| ;]|(?![\\p{{P}}\\p{{Z}}\\p{{C}}])[\\x{{0000}}-\\x{{10FFFF}}])+)$', invert=False)])),
                DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='indexes', config=True, description='Index number for this value', presence=False, children=[
                    DList(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='index', key=['index-number'], config=True, description='Index number for this value', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='index-number', config=True, description='Index number for this value', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)]))),
                        DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='value', config=True, description='Configure SRLG network value', mandatory=True, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 4294967295)]))),
                        DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='priority', config=True, description='Set prority for the value', mandatory=True, type_=DTypeEnum(name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'critical':0, 'high':1, 'default':2, 'low':3, 'verylow':4}))
                    ])
                ])
            ])
        ]),
        DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='inherit-locations', config=True, description='SRLG inherit-location configuration submode', presence=False, children=[
            DList(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='inherit-location', key=['location-name'], config=True, description='SRLG inherit-location configuration submode', min_elements=0, ordered_by='system', children=[
                DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='location-name', config=True, description='The inherit location name', mandatory=False, type_=DTypeString(name='xr:Pq-node-id', description='Partially qualified location which is used for\nwildcarding location specifications, e.g. 1/*/*', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((([a-zA-Z0-9_]*\\d+)|(\\*))/){{2}}(([a-zA-Z0-9_]*\\d+)|(\\*))', pcre='^(((([a-zA-Z0-9_]*\\p{{Nd}}+)|(\\*))/){{2}}(([a-zA-Z0-9_]*\\p{{Nd}}+)|(\\*)))$', invert=False)])),
                DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='indexes', config=True, description='Index number for this value', presence=False, children=[
                    DList(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='index', key=['index-number'], config=True, description='Index number for this value', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='index-number', config=True, description='Index number for this value', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)]))),
                        DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='value', config=True, description='Configure SRLG network value', mandatory=True, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 4294967295)]))),
                        DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='priority', config=True, description='Set prority for the value', mandatory=True, type_=DTypeEnum(name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'critical':0, 'high':1, 'default':2, 'low':3, 'verylow':4}))
                    ])
                ])
            ])
        ])
    ]),
    DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='vrf-groups', config=True, description='VRFGROUP configuration commands', presence=False, children=[
        DList(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='vrf-group', key=['group-name'], config=True, description='Group name', min_elements=0, ordered_by='system', children=[
            DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='group-name', config=True, description='Group name', mandatory=False, type_=DTypeString(name='xr:Cisco-ios-xr-string', description='Special characters are not allowed.', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 32)]), patterns=[YangPattern(yang_regex='[\\w\\-\\.:,_@#%$\\+=\\| ;]+', pcre='^(([\\-\\.:,_@#%$\\+=\\| ;]|(?![\\p{{P}}\\p{{Z}}\\p{{C}}])[\\x{{0000}}-\\x{{10FFFF}}])+)$', invert=False)])),
            DContainer(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='vrfs', config=True, description='Enable the vrf on this vrf-group', presence=False, children=[
                DList(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='vrf', key=['vrf-name'], config=True, description='VRF name', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='Cisco-IOS-XR-um-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg', prefix='um-vrf-cfg', name='vrf-name', config=True, description='VRF name', mandatory=False, type_=DTypeString(name='xr:Cisco-ios-xr-string', description='Special characters are not allowed.', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 32)]), patterns=[YangPattern(yang_regex='[\\w\\-\\.:,_@#%$\\+=\\| ;]+', pcre='^(([\\-\\.:,_@#%$\\+=\\| ;]|(?![\\p{{P}}\\p{{Z}}\\p{{C}}])[\\x{{0000}}-\\x{{10FFFF}}])+)$', invert=False)]))
                ])
            ])
        ])
    ]),
    DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='router', config=True, description='Enable a routing process', presence=False, children=[
        DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='isis', config=True, description='ISO IS-IS', presence=False, children=[
            DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='processes', config=True, description='Process ID', presence=False, children=[
                DList(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='process', key=['process-id'], config=True, description='Process ID', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='process-id', config=True, description='Process ID', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 36)]), patterns=[])),
                    DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='is-type', config=True, description='Area type (level)', mandatory=False, type_=DTypeEnum(name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'level-1':1, 'level-2-only':2, 'level-1-2':3})),
                    DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='nets', config=True, description='A Network Entity Title (NET) for this process', presence=False, children=[
                        DList(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='net', key=['net-id'], config=True, description='A Network Entity Title (NET) for this process', min_elements=0, ordered_by='system', children=[
                            DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='net-id', config=True, description='A Network Entity Title (NET) for this process', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 1024)]), patterns=[]))
                        ])
                    ]),
                    DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='address-families', config=True, description='Enter the IS-IS address-family configuration submode', presence=False, children=[
                        DList(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='address-family', key=[
'af-name',
'saf-name'
                            ], config=True, description='IS-IS address family', min_elements=0, ordered_by='system', children=[
                            DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='af-name', config=True, description='Address family name', mandatory=False, type_=DTypeEnum(name='Isis-af-name', description='Address-family names', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4':0, 'ipv6':1})),
                            DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='saf-name', config=True, description='Sub address family name', mandatory=False, type_=DTypeEnum(name='Isis-saf-name', description='Sub address-family names', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'unicast':0, 'multicast':1})),
                            DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='segment-routing', config=True, description='Enable Segment Routing', presence=False, children=[
                                DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='mpls', config=True, description='Enable Segment Routing using MPLS encapsulation', presence=False, children=[
                                    DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='sr-prefer', config=True, description='Prefer segment routing labels over LDP labels', mandatory=False, type_=DTypeBoolean(name='boolean', description=None, reference=None, exts=[], builtin_type='boolean', default=None), when="../../../saf-name = 'unicast'")
                                ])
                            ]),
                            DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='metric-style', config=True, description='Use old-style (ISO 10589) or new-style packet formats', presence=False, children=[
                                DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='narrow', config=True, description='Use old style of TLVs with narrow metric', must=[
DMust(condition='not(../wide or ../transition)', description=None, error_app_tag=None, error_message=None, reference=None)
                                    ], presence=True),
                                DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='wide', config=True, description='Use new style of TLVs to carry wider metric', must=[
DMust(condition='not(../narrow or ../transition)', description=None, error_app_tag=None, error_message=None, reference=None)
                                    ], presence=True),
                                DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='transition', config=True, description='Send and accept both styles of TLVs during transition', must=[
DMust(condition='not(../narrow or ../wide)', description=None, error_app_tag=None, error_message=None, reference=None)
                                    ], presence=True),
                                DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='levels', config=True, description='Set metric-style for one level only', presence=False, children=[
                                    DList(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='level', key=['level-id'], config=True, description='Set metric-style for one level only', min_elements=0, ordered_by='system', children=[
                                        DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='level-id', config=True, description='Set metric-style for one level only', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 2)]))),
                                        DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='narrow', config=True, description='Use old style of TLVs with narrow metric', must=[
DMust(condition='not(../wide or ../transition)', description=None, error_app_tag=None, error_message=None, reference=None)
                                            ], presence=True),
                                        DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='wide', config=True, description='Use new style of TLVs to carry wider metric', must=[
DMust(condition='not(../narrow or ../transition)', description=None, error_app_tag=None, error_message=None, reference=None)
                                            ], presence=True),
                                        DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='transition', config=True, description='Send and accept both styles of TLVs during transition', must=[
DMust(condition='not(../narrow or ../wide)', description=None, error_app_tag=None, error_message=None, reference=None)
                                            ], presence=True)
                                    ])
                                ])
                            ])
                        ])
                    ]),
                    DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='interfaces', config=True, description='Enter the IS-IS interface configuration submode', presence=False, children=[
                        DList(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='interface', key=['interface-name'], config=True, description='Enter the IS-IS interface configuration submode', min_elements=0, ordered_by='system', children=[
                            DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='interface-name', config=True, description='Enter the IS-IS interface configuration submode', mandatory=False, type_=DTypeString(name='xr:Interface-name', description='An interface name specifying an interface type and\ninstance.\nInterface represents a string defining an interface\ntype and instance, e.g. MgmtEth0/4/CPU1/0 or\nTenGigE0/2/0/0.2 or Bundle-Ether9 or\nBundle-Ether9.98 or Serial0/0/0/0/3/1:1', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='[a-zA-Z0-9.:_/-]+', pcre='^([a-zA-Z0-9.:_/-]+)$', invert=False)])),
                            DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='circuit-type', config=True, description='Configure circuit type for interface', mandatory=False, type_=DTypeEnum(name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'level-1':1, 'level-2-only':2, 'level-1-2':3})),
                            DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='point-to-point', config=True, description='Treat active LAN interface as point-to-point', presence=True),
                            DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='bfd', config=True, description='Configure BFD parameters', presence=False, children=[
                                DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='fast-detect', config=True, description='Enable Fast detection', presence=False, children=[
                                    DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='ipv4', config=True, description='Address Family', presence=True),
                                    DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='ipv6', config=True, description='Address Family', presence=True)
                                ]),
                                DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='minimum-interval', config=True, description='Hello interval', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(3, 30000)]))),
                                DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='multiplier', config=True, description='Detect multiplier', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(2, 50)])))
                            ]),
                            DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='passive', config=True, description='Do not establish adjacencies over this interface', must=[
DMust(condition='not(../suppressed or ../shutdown)', description=None, error_app_tag=None, error_message=None, reference=None)
                                ], presence=True),
                            DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='address-families', config=True, description='Enter the IS-IS interface address-family configuration submode', presence=False, children=[
                                DList(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='address-family', key=[
'af-name',
'saf-name'
                                    ], config=True, description='Address family', min_elements=0, ordered_by='system', children=[
                                    DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='af-name', config=True, description='Address family name', mandatory=False, type_=DTypeEnum(name='Isis-af-name', description='Address-family names', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4':0, 'ipv6':1})),
                                    DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='saf-name', config=True, description='Sub address family name', mandatory=False, type_=DTypeEnum(name='Isis-saf-name', description='Sub address-family names', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'unicast':0, 'multicast':1})),
                                    DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='metric', config=True, description='Configure the metric for interface', presence=False, children=[
                                        DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='default-metric', config=True, description='Default metric', mandatory=False, must=[
DMust(condition='not(../maximum)', description=None, error_app_tag=None, error_message=None, reference=None)
                                            ], type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 16777214)]))),
                                        DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='maximum', config=True, description='Maximum wide metric. All routers will exclude this link from their SPF', must=[
DMust(condition='not(../default-metric)', description=None, error_app_tag=None, error_message=None, reference=None)
                                            ], presence=True),
                                        DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='levels', config=True, description='Set metric for one level only', presence=False, children=[
                                            DList(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='level', key=['level-id'], config=True, description='Set metric for one level only', min_elements=0, ordered_by='system', children=[
                                                DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='level-id', config=True, description='Set metric for one level only', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 2)]))),
                                                DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='default-metric', config=True, description='Default metric', mandatory=False, must=[
DMust(condition='not(../maximum)', description=None, error_app_tag=None, error_message=None, reference=None)
                                                    ], type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 16777214)]))),
                                                DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='maximum', config=True, description='Maximum wide metric. All routers will exclude this link from their SPF', must=[
DMust(condition='not(../default-metric)', description=None, error_app_tag=None, error_message=None, reference=None)
                                                    ], presence=True)
                                            ])
                                        ])
                                    ]),
                                    DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='prefix-sid', config=True, description='Specify the Prefix Segment ID', presence=False, when="../saf-name = 'unicast' and ../../../interface-name[starts-with(text(),'Loopback')]", children=[
                                        DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='sid', config=True, description='Specify the Prefix Segment ID', must=[
DMust(condition='index or absolute', description=None, error_app_tag=None, error_message=None, reference=None)
                                            ], presence=True, children=[
                                            DContainer(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='index', config=True, description='Specify the index of Prefix Segement ID', must=[
DMust(condition='not(../absolute)', description=None, error_app_tag=None, error_message=None, reference=None)
                                                ], presence=True, children=[
                                                DLeaf(module='Cisco-IOS-XR-um-router-isis-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg', prefix='um-router-isis-cfg', name='sid-index', config=True, description='Specify the index of Prefix Segement ID', mandatory=True, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 1048575)])))
                                            ])
                                        ])
                                    ])
                                ])
                            ])
                        ])
                    ])
                ])
            ])
        ])
    ]),
    DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='as-format', config=True, description='Autonomous system number format', presence=False, children=[
        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='asdot', config=True, description='AS Dot format', must=[
DMust(condition='not(../asplain)', description=None, error_app_tag=None, error_message=None, reference=None)
            ], presence=True),
        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='asplain', config=True, description='AS Plain format', must=[
DMust(condition='not(../asdot)', description=None, error_app_tag=None, error_message=None, reference=None)
            ], presence=True)
    ]),
    DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='bmp', config=True, description='BGP Monitoring Protocol commands', presence=False, children=[
        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='servers', config=True, description='BMP server configuration', presence=False, children=[
            DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='server', key=['bmp-server-id'], config=True, description='BMP server ID to configure', min_elements=0, ordered_by='system', children=[
                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='bmp-server-id', config=True, description='BMP server ID to configure', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 8)]))),
                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='shutdown', config=True, description='Shutdown connection to BMP server', presence=True),
                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='host', config=True, description='Hostname of BMP Server', presence=True, children=[
                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='host-name', config=True, description='Hostname of BMP Server', mandatory=True, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 1024)]), patterns=[])),
                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='port', config=True, description='BMP Server Listen Port', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)])))
                ]),
                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='initial-delay', config=True, description='Initial connect delay in sending BMP server updates. Default=0', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 3600)]))),
                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='flapping-delay', config=True, description='delay in connecting to BMP Server after a flap had been detected. Default=300', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(60, 3600)]))),
                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='max-buffer-size', config=True, description='Set BMP message buffer size', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 4294967295)]))),
                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='initial-refresh', config=True, description='Initial refresh to generate BGP updates. DEfault=1', presence=False, children=[
                    DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='delay', config=True, description='Initial delay before sending route refresh request', presence=True, children=[
                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='initial-delay', config=True, description='Initial delay before sending route refresh request', mandatory=True, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 3600)]))),
                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='spread', config=True, description='Maximum additional random delay for initial Refresh Request', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 3600)])))
                    ]),
                    DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='skip', config=True, description='Skip sending Refresh request to Peers', presence=True)
                ]),
                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='stats-reporting-period', config=True, description='Stats reporting period for BMP server. Default=0', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 3600)]))),
                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='description', config=True, description='BMP server specific description', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 1024)]), patterns=[])),
                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='dscp', config=True, description='Set IP DSCP (DiffServ CodePoint)', mandatory=False, type_=DTypeEnum(name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'default':0, 'cs1':8, 'af11':10, 'af12':12, 'af13':14, 'cs2':16, 'af21':18, 'af22':20, 'af23':22, 'cs3':24, 'af31':26, 'af32':28, 'af33':30, 'cs4':32, 'af41':34, 'af42':36, 'af43':38, 'cs5':40, 'ef':46, 'cs6':48, 'cs7':56})),
                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='precedence', config=True, description='Set precedence', mandatory=False, type_=DTypeEnum(name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'routine':0, 'priority':1, 'immediate':2, 'flash':3, 'flash-override':4, 'critical':5, 'internet':6, 'network':7})),
                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='update-source', config=True, description='Source to reach BMP server', mandatory=False, type_=DTypeString(name='xr:Interface-name', description='An interface name specifying an interface type and\ninstance.\nInterface represents a string defining an interface\ntype and instance, e.g. MgmtEth0/4/CPU1/0 or\nTenGigE0/2/0/0.2 or Bundle-Ether9 or\nBundle-Ether9.98 or Serial0/0/0/0/3/1:1', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='[a-zA-Z0-9.:_/-]+', pcre='^([a-zA-Z0-9.:_/-]+)$', invert=False)])),
                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='vrf', config=True, description='VRF for the BMP server', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 1024)]), patterns=[])),
                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='tcp', config=True, description='Configure TCP related parameters', presence=False, children=[
                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='keep-alive', config=True, description='configure TCP keep alives to be exchanged between client and server', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 7200)]))),
                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='mss', config=True, description='configure TCP maximum segment size', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(68, 10000)])))
                ])
            ]),
            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='all', config=True, description='Common commands for all BMP servers', presence=False, children=[
                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='max-buffer-size', config=True, description='Maximum buffer limit upto which BMP messages will be queued to TCP sockets.\nIf total size of BMP messages queued up for BMP sockets exceeds this set limit,\nmessages will be dropped. The maximum buf-size is 20% and default buf-size is 15%\nof the platform virtual memory max-limit (aka rlimit). Please run\nshow bgp process performance-statistics\nto see the individual values. Unit is in MegaBytes.', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 4294967295)]))),
                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='route-monitoring', config=True, description='Enable Route Monitoring capability for the BMP servers.\nBGP update messages will be regenerated with a table walk\n', presence=False, children=[
                    DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='bmp-modes', config=True, description='Enter BMP route monitoring command mode', presence=False, children=[
                        DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='bmp-mode', key=['mode-name'], config=True, description='Enter BMP route monitoring command mode', min_elements=0, ordered_by='system', children=[
                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='mode-name', config=True, description='Enter BMP route monitoring command mode', mandatory=False, type_=DTypeEnum(name='Bmp-mode', description='Bmp route monitor mode', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'inbound-pre-policy':0, 'inbound-post-policy':1, 'local-rib':4})),
                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='advertisement-interval', config=True, description='Minimum interval between updates sent to BMP servers', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(2, 600)])), when="../mode-name = 'inbound-post-policy' or ../mode-name = 'local-rib'"),
                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='scan-time', config=True, description='Configure scanner interval', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(5, 3600)])), when="../mode-name = 'inbound-post-policy'")
                        ])
                    ])
                ])
            ])
        ])
    ]),
    DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='router', config=True, description='Enable a routing process', presence=False, children=[
        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='bgp', config=True, description='BGP configuration subcommands', presence=False, children=[
            DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='as', key=['as-number'], config=True, description='bgp as-number', min_elements=0, ordered_by='system', children=[
                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='as-number', config=True, description='bgp as-number', mandatory=False, type_=DTypeUnion(name='xr:Bgp-as-number', description='BGP AS number type', reference=None, exts=[], builtin_type='union', default=None, types=[DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)])), DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='([1-9][0-9]{{0,4}}).([0-9]{{1,5}})', pcre='^(([1-9][0-9]{{0,4}}).([0-9]{{1,5}}))$', invert=False)]), DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(65536, 4294967295)]))])),
                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='rpki', config=True, description='Configure RPKI', presence=False, children=[
                    DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='servers', config=True, description='Configure RPKI cache-servers', presence=False, children=[
                        DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='server', key=['server-id'], config=True, description='Configure RPKI cache-servers', min_elements=0, ordered_by='system', children=[
                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='server-id', config=True, description='Configure RPKI cache-servers', mandatory=False, type_=DTypeString(name='xr:Cisco-ios-xr-string', description='Special characters are not allowed.', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 1024)]), patterns=[YangPattern(yang_regex='[\\w\\-\\.:,_@#%$\\+=\\| ;]+', pcre='^(([\\-\\.:,_@#%$\\+=\\| ;]|(?![\\p{{P}}\\p{{Z}}\\p{{C}}])[\\x{{0000}}-\\x{{10FFFF}}])+)$', invert=False)])),
                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='bind-source', config=True, description='Specify a bind source for RPKI cache-server', presence=False, children=[
                                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='interface', config=True, description='Specify a source interface to bind the cache-server transport', presence=False, children=[
                                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='interface-name', config=True, description='Interface Name', mandatory=False, type_=DTypeString(name='xr:Interface-name', description='An interface name specifying an interface type and\ninstance.\nInterface represents a string defining an interface\ntype and instance, e.g. MgmtEth0/4/CPU1/0 or\nTenGigE0/2/0/0.2 or Bundle-Ether9 or\nBundle-Ether9.98 or Serial0/0/0/0/3/1:1', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='[a-zA-Z0-9.:_/-]+', pcre='^([a-zA-Z0-9.:_/-]+)$', invert=False)]))
                                ])
                            ]),
                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='preference', config=True, description='(Deprecated from 7.4.1) Specify a preference value for the RPKI cache', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 10)]))),
                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='refresh-time', config=True, description='Time between sending serial-queries for the RPKI cache-server', presence=False, children=[
                                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='refresh-time-value', config=True, description='Refresh time (in seconds)', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(15, 3600)]))),
                                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='off', config=True, description='Do not send serial-queries periodically', presence=True)
                            ]),
                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='response-time', config=True, description='Time to wait for a response from the RPKI cache-server', presence=False, children=[
                                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='response-time-value', config=True, description='Response time (in seconds)', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(15, 3600)]))),
                                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='off', config=True, description='Wait indefinitely for a response', presence=True)
                            ]),
                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='purge-time', config=True, description='Purge time (in seconds)', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(30, 65535)]))),
                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='username', config=True, description='Specify a (SSH) username for the RPKI cache-server', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 1024)]), patterns=[])),
                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='password', config=True, description='Specify a (SSH) password for the RPKI cache-server', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 1024)]), patterns=[])),
                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='transport', config=True, description='Specify a transport method for the RPKI cache-server', presence=False, children=[
                                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='tcp', config=True, description='Connect to the RPKI cache-server using TCP (unencrypted)', presence=False, children=[
                                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='port', config=True, description='Specify a port number for the RPKI cache-server transport', mandatory=False, must=[
DMust(condition='not(../../ssh/port)', description=None, error_app_tag=None, error_message=None, reference=None)
                                        ], type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)])))
                                ]),
                                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='ssh', config=True, description='Connect to the RPKI cache-server using SSH', presence=False, children=[
                                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='port', config=True, description='Specify a port number for the RPKI cache-server transport', mandatory=False, must=[
DMust(condition='not(../../tcp/port)', description=None, error_app_tag=None, error_message=None, reference=None)
                                        ], type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)])))
                                ])
                            ]),
                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='shutdown', config=True, description='Shutdown the RPKI cache-server', presence=True)
                        ])
                    ]),
                    DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='routes', config=True, description='Configure an RPKI route', presence=False, children=[
                        DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='route', key=[
'address',
'minimum-prefix-length',
'maximum-prefix-length',
'origin-as-number'
                            ], config=True, description='Configure an RPKI route', min_elements=0, ordered_by='system', children=[
                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='address', config=True, description='Configure an RPKI route', mandatory=False, type_=DTypeUnion(name='inet:ip-address-no-zone', description='The ip-address-no-zone type represents an IP address and is\nIP version neutral.  The format of the textual representation\nimplies the IP version.  This type does not support scoped\naddresses since it does not allow zone identifiers in the\naddress format.', reference='RFC 4007: IPv6 Scoped Address Architecture', exts=[], builtin_type='union', default=None, types=[DTypeString(name='inet:ipv4-address-no-zone', description='An IPv4 address without a zone index.  This type, derived from\nipv4-address, may be used in situations where the zone is\nknown from the context and hence no zone index is needed.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='[0-9\\.]*', pcre='^([0-9\\.]*)$', invert=False)]), DTypeString(name='inet:ipv6-address-no-zone', description='An IPv6 address without a zone index.  This type, derived from\nipv6-address, may be used in situations where the zone is\nknown from the context and hence no zone index is needed.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False), YangPattern(yang_regex='[0-9a-fA-F:\\.]*', pcre='^([0-9a-fA-F:\\.]*)$', invert=False)])])),
                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='minimum-prefix-length', config=True, description='Minimum prefix length', mandatory=False, type_=DTypeUnion(name='union', description=None, reference=None, exts=[], builtin_type='union', default=None, types=[DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 32)])), DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 128)]))])),
                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='maximum-prefix-length', config=True, description='Maximum prefix length (Default 32/128 for IPv4/IPv6)', mandatory=False, type_=DTypeUnion(name='union', description=None, reference=None, exts=[], builtin_type='union', default=None, types=[DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 32)])), DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 128)]))])),
                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='origin-as-number', config=True, description='Origin Autonomous System number', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 4294967295)])))
                        ])
                    ]),
                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='datafile', config=True, description='(Deprecated from 7.4.1) Configure an RPKI data file', mandatory=False, type_=DTypeString(name='xr:Cisco-ios-xr-string', description='Special characters are not allowed.', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 800)]), patterns=[YangPattern(yang_regex='[\\w\\-\\.:,_@#%$\\+=\\| ;]+', pcre='^(([\\-\\.:,_@#%$\\+=\\| ;]|(?![\\p{{P}}\\p{{Z}}\\p{{C}}])[\\x{{0000}}-\\x{{10FFFF}}])+)$', invert=False)]))
                ]),
                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='address-families', config=True, description='Enter Address Family command mode', presence=False, children=[
                    DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='address-family', key=['af-name'], config=True, description='Enter Address Family command mode', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='af-name', config=True, description='Enter Address Family command mode', mandatory=False, type_=DTypeEnum(name='Bgp-address-family', description='Bgp address family', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4-unicast':0, 'ipv4-multicast':1, 'ipv4-labeled-unicast':2, 'ipv4-tunnel':3, 'vpnv4-unicast':4, 'ipv6-unicast':5, 'ipv6-multicast':6, 'ipv6-labeled-unicast':7, 'vpnv6-unicast':8, 'ipv4-mdt':9, 'l2vpn-vpls-vpws':10, 'ipv4-rt-filter':11, 'ipv4-mvpn':12, 'ipv6-mvpn':13, 'l2vpn-evpn':14, 'link-state-link-state':15, 'vpnv4-multicast':16, 'vpnv6-multicast':17, 'ipv4-flowspec':18, 'ipv6-flowspec':19, 'vpnv4-flowspec':20, 'vpnv6-flowspec':21, 'l2vpn-mspw':22, 'ipv4-sr-policy':23, 'ipv6-sr-policy':24, 'all-address-family':25}))
                    ])
                ]),
                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='neighbors', config=True, description='Specify a neighbor router', presence=False, children=[
                    DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='neighbor', key=['neighbor-address'], config=True, description='Neighbor address', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='neighbor-address', config=True, description='Neighbor address', mandatory=False, type_=DTypeUnion(name='inet:ip-address-no-zone', description='The ip-address-no-zone type represents an IP address and is\nIP version neutral.  The format of the textual representation\nimplies the IP version.  This type does not support scoped\naddresses since it does not allow zone identifiers in the\naddress format.', reference='RFC 4007: IPv6 Scoped Address Architecture', exts=[], builtin_type='union', default=None, types=[DTypeString(name='inet:ipv4-address-no-zone', description='An IPv4 address without a zone index.  This type, derived from\nipv4-address, may be used in situations where the zone is\nknown from the context and hence no zone index is needed.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='[0-9\\.]*', pcre='^([0-9\\.]*)$', invert=False)]), DTypeString(name='inet:ipv6-address-no-zone', description='An IPv6 address without a zone index.  This type, derived from\nipv6-address, may be used in situations where the zone is\nknown from the context and hence no zone index is needed.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False), YangPattern(yang_regex='[0-9a-fA-F:\\.]*', pcre='^([0-9a-fA-F:\\.]*)$', invert=False)])])),
                        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='use', config=True, description='Inherit configuration from a group', presence=False, children=[
                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='session-group', config=True, description='Inherit address-family independent config from a session-group', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 1024)]), patterns=[])),
                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='neighbor-group', config=True, description='Inherit configuration from a neighbor-group', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 1024)]), patterns=[]))
                        ]),
                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='description', config=True, description='Neighbor specific description', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 1024)]), patterns=[]))
                    ])
                ]),
                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='neighbor-groups', config=True, description='Specify a Neighbor-group', presence=False, children=[
                    DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='neighbor-group', key=[
'neighbor-group-name'
                        ], config=True, description='Specify a Neighbor-group', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='neighbor-group-name', config=True, description='Specify a Neighbor-group', mandatory=False, type_=DTypeString(name='xr:Cisco-ios-xr-string', description='Special characters are not allowed.', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 900)]), patterns=[YangPattern(yang_regex='[\\w\\-\\.:,_@#%$\\+=\\| ;]+', pcre='^(([\\-\\.:,_@#%$\\+=\\| ;]|(?![\\p{{P}}\\p{{Z}}\\p{{C}}])[\\x{{0000}}-\\x{{10FFFF}}])+)$', invert=False)])),
                        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='address-families', config=True, description='Enter Address Family command mode', presence=False, children=[
                            DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='address-family', key=['af-name'], config=True, description='Enter Address Family command mode', min_elements=0, ordered_by='system', children=[
                                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='af-name', config=True, description='Enter Address Family command mode', mandatory=False, type_=DTypeEnum(name='Bgp-address-family', description='Bgp address family', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4-unicast':0, 'ipv4-multicast':1, 'ipv4-labeled-unicast':2, 'ipv4-tunnel':3, 'vpnv4-unicast':4, 'ipv6-unicast':5, 'ipv6-multicast':6, 'ipv6-labeled-unicast':7, 'vpnv6-unicast':8, 'ipv4-mdt':9, 'l2vpn-vpls-vpws':10, 'ipv4-rt-filter':11, 'ipv4-mvpn':12, 'ipv6-mvpn':13, 'l2vpn-evpn':14, 'link-state-link-state':15, 'vpnv4-multicast':16, 'vpnv6-multicast':17, 'ipv4-flowspec':18, 'ipv6-flowspec':19, 'vpnv4-flowspec':20, 'vpnv6-flowspec':21, 'l2vpn-mspw':22, 'ipv4-sr-policy':23, 'ipv6-sr-policy':24, 'all-address-family':25}))
                            ])
                        ]),
                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='remote-as', config=True, description='bgp as-number', mandatory=False, type_=DTypeUnion(name='xr:Bgp-as-number', description='BGP AS number type', reference=None, exts=[], builtin_type='union', default=None, types=[DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)])), DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='([1-9][0-9]{{0,4}}).([0-9]{{1,5}})', pcre='^(([1-9][0-9]{{0,4}}).([0-9]{{1,5}}))$', invert=False)]), DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(65536, 4294967295)]))])),
                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='description', config=True, description='Neighbor specific description', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 1024)]), patterns=[])),
                        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='password', config=True, description='Set a password', must=[
DMust(condition='encrypted or inheritance-disable', description=None, error_app_tag=None, error_message=None, reference=None)
                            ], presence=True, children=[
                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='encrypted', config=True, description='Specifies an ENCRYPTED password will follow', mandatory=False, type_=DTypeString(name='xr:Proprietary-password', description="The Proprietary-password type is used to store password\nusing the Cisco proprietary hash function.\nWhen a clear text value is set to a leaf of this type, the\nserver calculates a password hash and stores the result\nin the datastore. The password is never stored in clear text.\n\nWhen a leaf of this type is read, the stored password hash is\nreturned.\n\nA value of this type matches one of the forms:\n\n  !<clear text password>\n  <password hash>\n\nThe '!' prefix signals that the value is clear text. When\nsuch a value is received by the server, a hash value is\ncalculated. This value is stored in the configuration data\nstore.\n\nIf a value starting without '!' is received, the server knows\nthat the value already represents a hashed value, and stores\nit as is in the data store.", reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(!.+)|([^!].+)', pcre='^((!.+)|([^!].+))$', invert=False)])),
                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='inheritance-disable', config=True, description='Prevent password from being inherited from parent', presence=True)
                        ]),
                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='update-source', config=True, description='Source of routing updates', mandatory=False, type_=DTypeString(name='xr:Interface-name', description='An interface name specifying an interface type and\ninstance.\nInterface represents a string defining an interface\ntype and instance, e.g. MgmtEth0/4/CPU1/0 or\nTenGigE0/2/0/0.2 or Bundle-Ether9 or\nBundle-Ether9.98 or Serial0/0/0/0/3/1:1', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='[a-zA-Z0-9.:_/-]+', pcre='^([a-zA-Z0-9.:_/-]+)$', invert=False)]))
                    ])
                ]),
                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='bgp', config=True, description='BGP commands', presence=False, children=[
                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='router-id', config=True, description='Configure Router-id', mandatory=False, type_=DTypeString(name='inet:ipv4-address-no-zone', description='An IPv4 address without a zone index.  This type, derived from\nipv4-address, may be used in situations where the zone is\nknown from the context and hence no zone index is needed.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='[0-9\\.]*', pcre='^([0-9\\.]*)$', invert=False)]))
                ]),
                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='vrfs', config=True, description='Specify a vrf name', presence=False, children=[
                    DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='vrf', key=['vrf-name'], config=True, description='Specify a vrf name', min_elements=0, ordered_by='system', children=[
                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='vrf-name', config=True, description='Specify a vrf name', mandatory=False, type_=DTypeString(name='xr:Cisco-ios-xr-string', description='Special characters are not allowed.', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 32)]), patterns=[YangPattern(yang_regex='[\\w\\-\\.:,_@#%$\\+=\\| ;]+', pcre='^(([\\-\\.:,_@#%$\\+=\\| ;]|(?![\\p{{P}}\\p{{Z}}\\p{{C}}])[\\x{{0000}}-\\x{{10FFFF}}])+)$', invert=False)])),
                        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='address-families', config=True, description='Enter Address Family command mode', presence=False, children=[
                            DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='address-family', key=['af-name'], config=True, description='Enter Address Family command mode', min_elements=0, ordered_by='system', children=[
                                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='af-name', config=True, description='Enter Address Family command mode', mandatory=False, type_=DTypeEnum(name='Bgp-address-family', description='Bgp address family', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4-unicast':0, 'ipv4-multicast':1, 'ipv4-labeled-unicast':2, 'ipv4-tunnel':3, 'vpnv4-unicast':4, 'ipv6-unicast':5, 'ipv6-multicast':6, 'ipv6-labeled-unicast':7, 'vpnv6-unicast':8, 'ipv4-mdt':9, 'l2vpn-vpls-vpws':10, 'ipv4-rt-filter':11, 'ipv4-mvpn':12, 'ipv6-mvpn':13, 'l2vpn-evpn':14, 'link-state-link-state':15, 'vpnv4-multicast':16, 'vpnv6-multicast':17, 'ipv4-flowspec':18, 'ipv6-flowspec':19, 'vpnv4-flowspec':20, 'vpnv6-flowspec':21, 'l2vpn-mspw':22, 'ipv4-sr-policy':23, 'ipv6-sr-policy':24, 'all-address-family':25}))
                            ])
                        ]),
                        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='neighbors', config=True, description='Specify a neighbor router', presence=False, children=[
                            DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='neighbor', key=['neighbor-address'], config=True, description='Neighbor address', min_elements=0, ordered_by='system', children=[
                                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='neighbor-address', config=True, description='Neighbor address', mandatory=False, type_=DTypeUnion(name='inet:ip-address-no-zone', description='The ip-address-no-zone type represents an IP address and is\nIP version neutral.  The format of the textual representation\nimplies the IP version.  This type does not support scoped\naddresses since it does not allow zone identifiers in the\naddress format.', reference='RFC 4007: IPv6 Scoped Address Architecture', exts=[], builtin_type='union', default=None, types=[DTypeString(name='inet:ipv4-address-no-zone', description='An IPv4 address without a zone index.  This type, derived from\nipv4-address, may be used in situations where the zone is\nknown from the context and hence no zone index is needed.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='[0-9\\.]*', pcre='^([0-9\\.]*)$', invert=False)]), DTypeString(name='inet:ipv6-address-no-zone', description='An IPv6 address without a zone index.  This type, derived from\nipv6-address, may be used in situations where the zone is\nknown from the context and hence no zone index is needed.', reference='RFC 4291: IP Version 6 Addressing Architecture\nRFC 4007: IPv6 Scoped Address Architecture\nRFC 5952: A Recommendation for IPv6 Address Text\n          Representation', exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?', pcre='^(((:|[0-9a-fA-F]{{0,4}}):)([0-9a-fA-F]{{0,4}}:){{0,5}}((([0-9a-fA-F]{{0,4}}:)?(:|[0-9a-fA-F]{{0,4}}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){{3}}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='(([^:]+:){{6}}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?', pcre='^((([^\\:]+:){{6}}(([^\\:]+:[^\\:]+)|(.*\\..*)))|((([^\\:]+:)*[^\\:]+)?::(([^\\:]+:)*[^\\:]+)?)(%.+)?)$', invert=False), YangPattern(yang_regex='[0-9a-fA-F:\\.]*', pcre='^([0-9a-fA-F:\\.]*)$', invert=False)])])),
                                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='address-families', config=True, description='Enter Address Family command mode', presence=False, children=[
                                    DList(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='address-family', key=['af-name'], config=True, description='Enter Address Family command mode', min_elements=0, ordered_by='system', children=[
                                        DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='af-name', config=True, description='Enter Address Family command mode', mandatory=False, type_=DTypeEnum(name='Bgp-address-family', description='Bgp address family', reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4-unicast':0, 'ipv4-multicast':1, 'ipv4-labeled-unicast':2, 'ipv4-tunnel':3, 'vpnv4-unicast':4, 'ipv6-unicast':5, 'ipv6-multicast':6, 'ipv6-labeled-unicast':7, 'vpnv6-unicast':8, 'ipv4-mdt':9, 'l2vpn-vpls-vpws':10, 'ipv4-rt-filter':11, 'ipv4-mvpn':12, 'ipv6-mvpn':13, 'l2vpn-evpn':14, 'link-state-link-state':15, 'vpnv4-multicast':16, 'vpnv6-multicast':17, 'ipv4-flowspec':18, 'ipv6-flowspec':19, 'vpnv4-flowspec':20, 'vpnv6-flowspec':21, 'l2vpn-mspw':22, 'ipv4-sr-policy':23, 'ipv6-sr-policy':24, 'all-address-family':25})),
                                        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='route-policy', config=True, description='Apply route policy to neighbor', presence=False, children=[
                                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='in', config=True, description='Apply route policy to inbound routes', mandatory=False, type_=DTypeString(name='xr:Route-policy-name', description='Datatype for route policy name', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 255)]), patterns=[])),
                                            DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='out', config=True, description='Apply route policy to outbound routes', mandatory=False, type_=DTypeString(name='xr:Route-policy-name', description='Datatype for route policy name', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 255)]), patterns=[])),
                                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='retention', config=True, description='Apply retention policy to inbound routes', presence=False, children=[
                                                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='route-policy-name', config=True, description='Apply retention policy to inbound routes', mandatory=False, must=[
DMust(condition='../retention-time', description=None, error_app_tag=None, error_message=None, reference=None)
                                                    ], type_=DTypeString(name='xr:Route-policy-name', description='Datatype for route policy name', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 255)]), patterns=[])),
                                                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='retention-time', config=True, description='Retention-time for this neighbor', mandatory=False, must=[
DMust(condition='../route-policy-name', description=None, error_app_tag=None, error_message=None, reference=None)
                                                    ], type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 4294967295)])))
                                            ])
                                        ]),
                                        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='as-override', config=True, description='Override matching AS-number while sending update', presence=True, children=[
                                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='inheritance-disable', config=True, description='Prevent as-override from being inherited from the parent', presence=True)
                                        ])
                                    ])
                                ]),
                                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='remote-as', config=True, description='bgp as-number', mandatory=False, type_=DTypeUnion(name='xr:Bgp-as-number', description='BGP AS number type', reference=None, exts=[], builtin_type='union', default=None, types=[DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)])), DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='([1-9][0-9]{{0,4}}).([0-9]{{1,5}})', pcre='^(([1-9][0-9]{{0,4}}).([0-9]{{1,5}}))$', invert=False)]), DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(65536, 4294967295)]))])),
                                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='description', config=True, description='Neighbor specific description', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 1024)]), patterns=[])),
                                DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='password', config=True, description='Set a password', must=[
DMust(condition='encrypted or inheritance-disable', description=None, error_app_tag=None, error_message=None, reference=None)
                                    ], presence=True, children=[
                                    DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='encrypted', config=True, description='Specifies an ENCRYPTED password will follow', mandatory=False, type_=DTypeString(name='xr:Proprietary-password', description="The Proprietary-password type is used to store password\nusing the Cisco proprietary hash function.\nWhen a clear text value is set to a leaf of this type, the\nserver calculates a password hash and stores the result\nin the datastore. The password is never stored in clear text.\n\nWhen a leaf of this type is read, the stored password hash is\nreturned.\n\nA value of this type matches one of the forms:\n\n  !<clear text password>\n  <password hash>\n\nThe '!' prefix signals that the value is clear text. When\nsuch a value is received by the server, a hash value is\ncalculated. This value is stored in the configuration data\nstore.\n\nIf a value starting without '!' is received, the server knows\nthat the value already represents a hashed value, and stores\nit as is in the data store.", reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(!.+)|([^!].+)', pcre='^((!.+)|([^!].+))$', invert=False)])),
                                    DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='inheritance-disable', config=True, description='Prevent password from being inherited from parent', presence=True)
                                ])
                            ])
                        ]),
                        DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='rd', config=True, description='route distinguisher', must=[
DMust(condition='auto or two-byte-as or four-byte-as or ip-address', description=None, error_app_tag=None, error_message=None, reference=None)
                            ], presence=True, children=[
                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='auto', config=True, description='Automatic route distinguisher', must=[
DMust(condition='not(../two-byte-as or ../four-byte-as or ../ip-address)', description=None, error_app_tag=None, error_message=None, reference=None)
                                ], presence=True),
                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='two-byte-as', config=True, description='two-byte-as route distinguisher', must=[
DMust(condition='not(../auto or ../four-byte-as or ../ip-address)', description=None, error_app_tag=None, error_message=None, reference=None)
                                ], presence=True, children=[
                                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='as-number', config=True, description='bgp as-number', mandatory=True, type_=DTypeUnion(name='xr:Bgp-as-number', description='BGP AS number type', reference=None, exts=[], builtin_type='union', default=None, types=[DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)])), DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='([1-9][0-9]{{0,4}}).([0-9]{{1,5}})', pcre='^(([1-9][0-9]{{0,4}}).([0-9]{{1,5}}))$', invert=False)]), DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(65536, 4294967295)]))])),
                                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='index', config=True, description='ASN2:index (hex or decimal format)', mandatory=True, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 4294967295)])))
                            ]),
                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='four-byte-as', config=True, description='four-byte-as route distinguisher', must=[
DMust(condition='not(../auto or ../two-byte-as or ../ip-address)', description=None, error_app_tag=None, error_message=None, reference=None)
                                ], presence=True, children=[
                                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='as-number', config=True, description='4-byte AS number', mandatory=True, type_=DTypeUnion(name='xr:Bgp-as-number', description='BGP AS number type', reference=None, exts=[], builtin_type='union', default=None, types=[DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 65535)])), DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='([1-9][0-9]{{0,4}}).([0-9]{{1,5}})', pcre='^(([1-9][0-9]{{0,4}}).([0-9]{{1,5}}))$', invert=False)]), DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(65536, 4294967295)]))])),
                                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='index', config=True, description='ASN2:index (hex or decimal format)', mandatory=True, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 4294967295)])))
                            ]),
                            DContainer(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='ip-address', config=True, description='configure this node', must=[
DMust(condition='not(../auto or ../two-byte-as or ../four-byte-as)', description=None, error_app_tag=None, error_message=None, reference=None)
                                ], presence=True, children=[
                                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='ipv4-address', config=True, description='configure this node', mandatory=True, type_=DTypeString(name='inet:ipv4-address-no-zone', description='An IPv4 address without a zone index.  This type, derived from\nipv4-address, may be used in situations where the zone is\nknown from the context and hence no zone index is needed.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='[0-9\\.]*', pcre='^([0-9\\.]*)$', invert=False)])),
                                DLeaf(module='Cisco-IOS-XR-um-router-bgp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg', prefix='um-router-bgp-cfg', name='index', config=True, description='IPv4Address:index (hex or decimal format)', mandatory=True, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(0, 65535)])))
                            ])
                        ])
                    ])
                ])
            ])
        ])
    ]),
    DContainer(module='Cisco-IOS-XR-um-mpls-ldp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg', prefix='um-mpls-ldp-cfg', name='mpls', config=True, description='Global MPLS configuration subcommands', presence=False, children=[
        DContainer(module='Cisco-IOS-XR-um-mpls-ldp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg', prefix='um-mpls-ldp-cfg', name='ldp', config=True, description='Label Distribution Protocol', presence=True, children=[
            DContainer(module='Cisco-IOS-XR-um-mpls-ldp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg', prefix='um-mpls-ldp-cfg', name='address-families', config=True, description='Configure Address Family and its parameters', presence=False, children=[
                DList(module='Cisco-IOS-XR-um-mpls-ldp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg', prefix='um-mpls-ldp-cfg', name='address-family', key=['af-name'], config=True, description='Configure Address Family and its parameters', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='Cisco-IOS-XR-um-mpls-ldp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg', prefix='um-mpls-ldp-cfg', name='af-name', config=True, description='Configure Address Family and its parameters', mandatory=False, type_=DTypeEnum(name='enumeration', description=None, reference=None, exts=[], builtin_type='enumeration', default=None, name_to_val={'ipv4':4, 'ipv6':6}))
                ])
            ]),
            DContainer(module='Cisco-IOS-XR-um-mpls-ldp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg', prefix='um-mpls-ldp-cfg', name='interfaces', config=True, description='Enable LDP on an interface and enter interface submode', presence=False, children=[
                DList(module='Cisco-IOS-XR-um-mpls-ldp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg', prefix='um-mpls-ldp-cfg', name='interface', key=['interface-name'], config=True, description='Enable LDP on an interface and enter interface submode', min_elements=0, ordered_by='system', children=[
                    DLeaf(module='Cisco-IOS-XR-um-mpls-ldp-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg', prefix='um-mpls-ldp-cfg', name='interface-name', config=True, description='Enable LDP on an interface and enter interface submode', mandatory=False, type_=DTypeString(name='xr:Interface-name', description='An interface name specifying an interface type and\ninstance.\nInterface represents a string defining an interface\ntype and instance, e.g. MgmtEth0/4/CPU1/0 or\nTenGigE0/2/0/0.2 or Bundle-Ether9 or\nBundle-Ether9.98 or Serial0/0/0/0/3/1:1', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='[a-zA-Z0-9.:_/-]+', pcre='^([a-zA-Z0-9.:_/-]+)$', invert=False)]))
                ])
            ])
        ])
    ]),
    DContainer(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='interfaces', config=True, description='Interface configuration', presence=False, children=[
        DList(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='interface', key=['interface-name'], config=True, description='Interface configuration subcommands', min_elements=0, ordered_by='system', children=[
            DLeaf(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='interface-name', config=True, description='Interface configuration subcommands', mandatory=False, type_=DTypeString(name='xr:Interface-name', description='An interface name specifying an interface type and\ninstance.\nInterface represents a string defining an interface\ntype and instance, e.g. MgmtEth0/4/CPU1/0 or\nTenGigE0/2/0/0.2 or Bundle-Ether9 or\nBundle-Ether9.98 or Serial0/0/0/0/3/1:1', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='[a-zA-Z0-9.:_/-]+', pcre='^([a-zA-Z0-9.:_/-]+)$', invert=False)])),
            DContainer(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='sub-interface-type', config=True, description='Specify type of sub-interface', presence=False, children=[
                DContainer(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='l2transport', config=True, description='l2transport sub-interface', presence=True),
                DContainer(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='point-to-point', config=True, description='point-to-point sub-interface', presence=True),
                DContainer(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='multipoint', config=True, description='multipoint sub-interface', presence=True)
            ]),
            DContainer(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='ipv4', config=True, description='Interface IPv4 config commands', presence=False, children=[
                DContainer(module='Cisco-IOS-XR-um-if-ip-address-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', prefix='um-if-ip-address-cfg', name='addresses', config=True, description='Set the IPv4 address of an interface', presence=False, children=[
                    DContainer(module='Cisco-IOS-XR-um-if-ip-address-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', prefix='um-if-ip-address-cfg', name='address', config=True, description='IP address and Mask', presence=True, children=[
                        DLeaf(module='Cisco-IOS-XR-um-if-ip-address-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', prefix='um-if-ip-address-cfg', name='address', config=True, description='IP address', mandatory=True, type_=DTypeString(name='inet:ipv4-address-no-zone', description='An IPv4 address without a zone index.  This type, derived from\nipv4-address, may be used in situations where the zone is\nknown from the context and hence no zone index is needed.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='[0-9\\.]*', pcre='^([0-9\\.]*)$', invert=False)])),
                        DLeaf(module='Cisco-IOS-XR-um-if-ip-address-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', prefix='um-if-ip-address-cfg', name='netmask', config=True, description='IP subnet mask', mandatory=True, type_=DTypeString(name='inet:ipv4-address-no-zone', description='An IPv4 address without a zone index.  This type, derived from\nipv4-address, may be used in situations where the zone is\nknown from the context and hence no zone index is needed.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='[0-9\\.]*', pcre='^([0-9\\.]*)$', invert=False)])),
                        DLeaf(module='Cisco-IOS-XR-um-if-ip-address-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', prefix='um-if-ip-address-cfg', name='route-tag', config=True, description='Route-tag to be associated with this address', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 4294967295)]))),
                        DLeaf(module='Cisco-IOS-XR-um-if-ip-address-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', prefix='um-if-ip-address-cfg', name='algorithm', config=True, description='Algorithm to be associated with this address', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(128, 255)])))
                    ]),
                    DContainer(module='Cisco-IOS-XR-um-if-ip-address-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', prefix='um-if-ip-address-cfg', name='secondaries', config=True, description='Specify a secondary address', presence=False, children=[
                        DList(module='Cisco-IOS-XR-um-if-ip-address-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', prefix='um-if-ip-address-cfg', name='secondary', key=['address'], config=True, description='IP address and Mask', min_elements=0, ordered_by='system', children=[
                            DLeaf(module='Cisco-IOS-XR-um-if-ip-address-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', prefix='um-if-ip-address-cfg', name='address', config=True, description='Secondary IP address', mandatory=False, type_=DTypeString(name='inet:ipv4-address-no-zone', description='An IPv4 address without a zone index.  This type, derived from\nipv4-address, may be used in situations where the zone is\nknown from the context and hence no zone index is needed.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='[0-9\\.]*', pcre='^([0-9\\.]*)$', invert=False)])),
                            DLeaf(module='Cisco-IOS-XR-um-if-ip-address-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', prefix='um-if-ip-address-cfg', name='netmask', config=True, description='Netmask', mandatory=True, type_=DTypeString(name='inet:ipv4-address-no-zone', description='An IPv4 address without a zone index.  This type, derived from\nipv4-address, may be used in situations where the zone is\nknown from the context and hence no zone index is needed.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?', pcre='^((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){{3}}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{{N}}\\p{{L}}]+)?)$', invert=False), YangPattern(yang_regex='[0-9\\.]*', pcre='^([0-9\\.]*)$', invert=False)])),
                            DLeaf(module='Cisco-IOS-XR-um-if-ip-address-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', prefix='um-if-ip-address-cfg', name='route-tag', config=True, description='Route-tag to be associated with this address', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 4294967295)]))),
                            DLeaf(module='Cisco-IOS-XR-um-if-ip-address-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', prefix='um-if-ip-address-cfg', name='algorithm', config=True, description='Algorithm to be associated with this address', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(128, 255)])))
                        ])
                    ]),
                    DLeaf(module='Cisco-IOS-XR-um-if-ip-address-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', prefix='um-if-ip-address-cfg', name='unnumbered', config=True, description='Enable IP processing without an explicit address', mandatory=False, type_=DTypeString(name='xr:Interface-name', description='An interface name specifying an interface type and\ninstance.\nInterface represents a string defining an interface\ntype and instance, e.g. MgmtEth0/4/CPU1/0 or\nTenGigE0/2/0/0.2 or Bundle-Ether9 or\nBundle-Ether9.98 or Serial0/0/0/0/3/1:1', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='[a-zA-Z0-9.:_/-]+', pcre='^([a-zA-Z0-9.:_/-]+)$', invert=False)]), when="../../../um-interface-cfg:interface-name[not(starts-with(text(),'pw-ether'))]"),
                    DContainer(module='Cisco-IOS-XR-um-if-ip-address-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg', prefix='um-if-ip-address-cfg', name='dhcp', config=True, description='IPv4 address and Mask negotiated via DHCP', presence=True, when="../../../um-interface-cfg:interface-name[starts-with(text(),'MgmtEth')] or ../../../um-interface-cfg:interface-name[starts-with(text(),'BVI')]")
                ])
            ]),
            DContainer(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='ipv6', config=True, description='Interface IPv6 config commands', presence=False),
            DContainer(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='encapsulation', config=True, description='Set the encapsulation on an interface', presence=False, when="../interface-name[starts-with(text(),'POS')] or ../interface-name[starts-with(text(),'serial')] or ../interface-name[starts-with(text(),'multilink')]", children=[
                DContainer(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='ppp', config=True, description='Point-to-Point protocol', presence=True),
                DContainer(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='hdlc', config=True, description='Serial HDLC synchronous', presence=True),
                DContainer(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='mfr', config=True, description='Multilink Frame Relay Member Link', presence=True, when="../../interface-name[starts-with(text(),'serial')]"),
                DContainer(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='frame-relay', config=True, description='Frame Relay networks', presence=True, when="../../interface-name[not(contains(text(),'.'))]", children=[
                    DContainer(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='IETF', config=True, description='Use RFC1490/RFC2427 encapsulation', presence=True)
                ])
            ]),
            DLeaf(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='shutdown', config=True, description='shutdown the given interface', mandatory=False, type_=DTypeEmpty(name='empty', description=None, reference=None, exts=[], builtin_type='empty', default=None)),
            DLeaf(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='mtu', config=True, description='Set the MTU on an interface', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(64, 65535)])), when="../interface-name[not(starts-with(text(),'SBC'))] and ../interface-name[not(starts-with(text(),'tunnel-te'))] and ../interface-name[not(starts-with(text(),'tunnel-mte'))] and ../interface-name[not(starts-with(text(),'VASILeft'))] and ../interface-name[not(starts-with(text(),'VASIRight'))] and ../interface-name[not(starts-with(text(),'service-gre'))] and ../interface-name[not(starts-with(text(),'service-ipsec'))] and ../interface-name[not(starts-with(text(),'InterflexLeft'))] and ../interface-name[not(starts-with(text(),'InterflexRight'))] and ../interface-name[not(starts-with(text(),'CEM'))]"),
            DLeaf(module='Cisco-IOS-XR-um-interface-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg', prefix='um-interface-cfg', name='description', config=True, description='Set description for this interface', mandatory=False, type_=DTypeString(name='string', description=None, reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 1024)]), patterns=[])),
            DLeaf(module='Cisco-IOS-XR-um-if-vrf-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-vrf-cfg', prefix='um-if-vrf-cfg', name='vrf', config=True, description='Set VRF in which the interface operates', mandatory=False, type_=DTypeString(name='xr:Cisco-ios-xr-string', description='Special characters are not allowed.', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 32)]), patterns=[YangPattern(yang_regex='[\\w\\-\\.:,_@#%$\\+=\\| ;]+', pcre='^(([\\-\\.:,_@#%$\\+=\\| ;]|(?![\\p{{P}}\\p{{Z}}\\p{{C}}])[\\x{{0000}}-\\x{{10FFFF}}])+)$', invert=False)]), when="../um-interface-cfg:interface-name[not(starts-with(text(),'tunnel-'))] and ../um-interface-cfg:interface-name[not(starts-with(text(),'cem'))] and ../um-interface-cfg:interface-name[not(starts-with(text(),'nve'))]"),
            DContainer(module='Cisco-IOS-XR-um-l2-ethernet-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg', prefix='um-l2-ethernet-cfg', name='encapsulation', config=True, description='Specify which packets will be matched by this sub-interface', presence=False, when="(../um-interface-cfg:interface-name[starts-with(text(),'FastEthernet')] or ../um-interface-cfg:interface-name[starts-with(text(),'GigabitEthernet')] or ../um-interface-cfg:interface-name[starts-with(text(),'TenGigE')] or ../um-interface-cfg:interface-name[starts-with(text(),'FortyGigE')] or ../um-interface-cfg:interface-name[starts-with(text(),'HundredGigE')] or ../um-interface-cfg:interface-name[starts-with(text(),'TwoHundredGigE')] or ../um-interface-cfg:interface-name[starts-with(text(),'FourHundredGigE')] or ../um-interface-cfg:interface-name[starts-with(text(),'EightHundredGigE')] or ../um-interface-cfg:interface-name[starts-with(text(),'TwentyFiveGigE')] or ../um-interface-cfg:interface-name[starts-with(text(),'FiftyGigE')] or ../um-interface-cfg:interface-name[starts-with(text(),'Bundle-Ether')] or ../um-interface-cfg:interface-name[starts-with(text(),'PW-Ether')])and ../um-interface-cfg:interface-name[contains(text(),'.')]and not(../um-interface-cfg:sub-interface-type/um-interface-cfg:l2transport)", children=[
                DContainer(module='Cisco-IOS-XR-um-l2-ethernet-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg', prefix='um-l2-ethernet-cfg', name='dot1q', config=True, description='IEEE 802.1Q VLAN-tagged packets', presence=False, children=[
                    DLeaf(module='Cisco-IOS-XR-um-l2-ethernet-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg', prefix='um-l2-ethernet-cfg', name='vlan-id', config=True, description='Configure first (outer) VLAN ID on the subinterface', mandatory=False, type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 4094)]))),
                    DLeaf(module='Cisco-IOS-XR-um-l2-ethernet-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg', prefix='um-l2-ethernet-cfg', name='second-dot1q', config=True, description='Configure second (inner 802.1Q) VLAN ID on the subinterface', mandatory=False, must=[
DMust(condition='../vlan-id', description=None, error_app_tag=None, error_message=None, reference=None)
                        ], type_=DTypeIntegerUnsigned(name='uint32', description=None, reference=None, exts=[], builtin_type='uint32', default=None, ranges=Ranges([(1, 4094)])))
                ])
            ])
        ])
    ]),
    DContainer(module='Cisco-IOS-XR-um-l2-ethernet-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg', prefix='um-l2-ethernet-cfg', name='ethernet', config=True, description='Ethernet configuration', presence=False, children=[
        DContainer(module='Cisco-IOS-XR-um-l2-ethernet-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg', prefix='um-l2-ethernet-cfg', name='egress-filter', config=True, description='Egress-filter commands', presence=False, children=[
            DContainer(module='Cisco-IOS-XR-um-l2-ethernet-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg', prefix='um-l2-ethernet-cfg', name='strict', config=True, description='Strict egress-filtering on by default', if_feature=['global-ethernet'], presence=True)
        ])
    ]),
    DContainer(module='Cisco-IOS-XR-um-hostname-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg', prefix='um-hostname-cfg', name='hostname', config=True, description="Set system's network name", presence=False, children=[
        DLeaf(module='Cisco-IOS-XR-um-hostname-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg', prefix='um-hostname-cfg', name='system-network-name', config=True, description="Set system's network name", mandatory=False, type_=DTypeString(name='xr:Cisco-ios-xr-string', description='Special characters are not allowed.', reference=None, exts=[], builtin_type='string', default=None, length=Ranges([(1, 253)]), patterns=[YangPattern(yang_regex='[\\w\\-\\.:,_@#%$\\+=\\| ;]+', pcre='^(([\\-\\.:,_@#%$\\+=\\| ;]|(?![\\p{{P}}\\p{{Z}}\\p{{C}}])[\\x{{0000}}-\\x{{10FFFF}}])+)$', invert=False), YangPattern(yang_regex='[a-zA-Z0-9_\\.-]+', pcre='^([a-zA-Z0-9_\\.-]+)$', invert=False)]))
    ]),
    DContainer(module='Cisco-IOS-XR-policy-repository-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg', prefix='policy-repository-cfg', name='routing-policy', config=True, description='Routing policy configuration', presence=False, children=[
        DContainer(module='Cisco-IOS-XR-policy-repository-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg', prefix='policy-repository-cfg', name='route-policies', config=True, description='All configured policies', presence=False, children=[
            DList(module='Cisco-IOS-XR-policy-repository-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg', prefix='policy-repository-cfg', name='route-policy', key=['route-policy-name'], config=True, description='Information about an individual policy', min_elements=0, ordered_by='system', children=[
                DLeaf(module='Cisco-IOS-XR-policy-repository-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg', prefix='policy-repository-cfg', name='route-policy-name', config=True, description='Route policy name', mandatory=False, type_=DTypeString(name='xr:Cisco-ios-xr-string', description='Special characters are not allowed.', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[YangPattern(yang_regex='[\\w\\-\\.:,_@#%$\\+=\\| ;]+', pcre='^(([\\-\\.:,_@#%$\\+=\\| ;]|(?![\\p{{P}}\\p{{Z}}\\p{{C}}])[\\x{{0000}}-\\x{{10FFFF}}])+)$', invert=False)])),
                DLeaf(module='Cisco-IOS-XR-policy-repository-cfg', namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg', prefix='policy-repository-cfg', name='rpl-route-policy', config=True, description='policy statements', mandatory=True, type_=DTypeString(name='xr:Rpl-policy', description='RPL Policy info', reference=None, exts=[], builtin_type='string', default=None, length=None, patterns=[]))
            ])
        ])
    ])
])

def src_yang():
    res = []
    res.append(r"""module Cisco-IOS-XR-policy-repository-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg";
  prefix "policy-repository-cfg";
  import Cisco-IOS-XR-types {
    prefix "xr";
  }
  import cisco-semver {
    prefix "semver";
  }
  organization "Cisco Systems, Inc.";
  contact "Cisco Systems, Inc.
Customer Service

Postal: 170 West Tasman Drive
San Jose, CA 95134

Tel: +1 800 553-NETS

E-mail: cs-yang@cisco.com";
  description "This module contains a collection of YANG definitions
for Cisco IOS-XR policy-repository package configuration.

This module contains definitions
for the following management objects:
  routing-policy: Routing policy configuration

Copyright (c) 2013-2022 by Cisco Systems, Inc.
All rights reserved.";
  revision 2022-12-02 {
    description "Updated RPL knob operations to include extcomm evpn-link-bandwidth.
2022-06-22
  Updating RPL knob for set nexthop with allocate-vpn-label";
    semver:module-version 1.1.0;
  }
  revision 2019-04-05 {
    description "Establish semantic version baseline.";
    semver:module-version 1.0.1;
  }
  revision 2017-09-07 {
    description "Fixing prepend/append/remove containers.";
  }
  revision 2017-09-07 {
    description "Fixed type translation error.";
  }
  revision 2015-08-27 {
    description "IOS XR 5.3.2 revision.";
  }
  container routing-policy {
    description "Routing policy configuration";
    container route-policies {
      description "All configured policies";
      list route-policy {
        key route-policy-name;
        description "Information about an individual policy";
        leaf route-policy-name {
          type xr:Cisco-ios-xr-string;
          description "Route policy name";
        }
        leaf rpl-route-policy {
          type xr:Rpl-policy;
          mandatory true;
          description "policy statements";
        }
      }
    }
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-types {
  namespace "http://cisco.com/ns/yang/cisco-xr-types";
  prefix xr;

  import cisco-semver {
    prefix semver;
  }
  import ietf-inet-types {
    prefix inet;
  }

  organization
    "Cisco Systems, Inc.";
  contact
    "Cisco Systems, Inc.
     Customer Service
     
     Postal: 170 W Tasman Drive
     San Jose, CA 95134
     
     Tel: +1 1800 553-NETS
     
     E-mail: cs-yang@cisco.com";
  description
    "This module contains a collection of IOS-XR derived YANG data
     types.
     
     Copyright (c) 2013-2021 by Cisco Systems, Inc.
     All rights reserved.";

  revision 2023-12-06 {
    description
      "Modified string match pattern of Node-id
       2022-03-09
         Included space in Cisco-ios-xr-string pattern.
       2021-10-19
         Added a new type Hex-long-integer";
    semver:module-version "2.2.0";
  }
  revision 2020-11-18 {
    description
      "Added a new type Hex-integer-8";
    semver:module-version "2.1.0";
  }
  revision 2019-12-03 {
    description
      "Modified string match pattern of Interface-name";
    semver:module-version "2.0.0";
  }
  revision 2019-04-05 {
    description
      "Establish semantic version baseline.";
    semver:module-version "1.0.0";
  }
  revision 2019-01-18 {
    description
      "This revision adds the following new data types:
       - Type10-password";
  }
  revision 2018-06-29 {
    description
      "Modified string match pattern of Interface-name";
  }
  revision 2017-12-01 {
    description
      "Modified string match pattern of Tty-escape-char-num";
  }
  revision 2017-03-07 {
    description
      "This revision adds the following new data types:
       - Type8-password
       - Type9-password";
  }
  revision 2015-06-29 {
    description
      "This revision adds the following new data types:
       - Rpl-policy
       - Rpl-set";
  }
  revision 2015-05-18 {
    description
      "Updated Node-id string pattern to match also shorter ncs4k
         node names.";
  }
  revision 2015-01-19 {
    description
      "This revision adds the following new data types:
       - Bgp-ipv4-flowspec-address
       - Bgp-ipv6-flowspec-address";
  }
  revision 2013-07-22 {
    description
      "Initial revision.";
  }

  extension xr-cli-map {
    argument cli-command;
    description
      "The xr-cli-map statement takes as an argument
       relevant CLI configuration command.";
  }

  extension xr-xml-map {
    argument xr-xml-node;
    description
      "The xr-xml-map statement takes as an argument
       relevant Cisco XML Schema node name.";
  }

  extension cli-command {
    argument command;
    description
      "Corresponding CLI command for this RPC node";
  }

  extension cli-name {
    argument keyword;
    description
      "Corresponding CLI keyword for this node";
  }

  extension xr-task {
    argument task;
    description
      "XR task-id required for operating the yang node";
  }

  extension event-telemetry {
    argument description;
    description
      "Node eligible for telemetry event subscription";
  }

  typedef Route-dist {
    type string {
      pattern "[a-fA-F0-9]{16}";
    }
    description
      "Route distinguisher in hexadecimal notation.";
  }

  typedef Bgp-l2vpn-evpn-addrs {
    type string {
      pattern "[a-fA-F0-9]{58}";
    }
    description
      "L2VPN EVPN Address in hexadecimal notation.";
  }

  typedef Bgp-ls-addr {
    type string {
      pattern "[a-fA-F0-9]+";
    }
    description
      "BGP link state unicast address in hexadecimal
       notation.";
  }

  typedef Bgp-ipv6-mvpn-addr {
    type string {
      pattern "[a-fA-F0-9]{104}";
    }
    description
      "An IPV6 MVPN address in hexadecimal notation.";
  }

  typedef Bgp-ipv4-mvpn-addr {
    type string {
      pattern "[a-fA-F0-9]{56}";
    }
    description
      "An IPV4 MVPN address in hexadecimal notation.";
  }

  typedef Bgp-rt-constrt-addr {
    type string {
      pattern "[a-fA-F0-9]{24}";
    }
    description
      "An IPV4 RTConstraint address in hexadecimal notation.";
  }

  typedef Bgp-ipv4-mdt-addr {
    type string {
      pattern "(([a-f0-9]{16}-)(([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))";
    }
    description
      "An IPV4 MDT address in dotted decimal notation.
       An IPv4 MDT address should be of the form
       0000006400000065-129.29.83.45. This datatype
       restricts the value of each field 16 digits in
       hexadecimal for RD field and between 0 and 255
       for IPv4 address field, i.e.
       [0000000000000000-ffffffffffffffff]-
       [0-255].[0-255].[0-255].[0-255].";
  }

  typedef Bgp-ipv4-tunnel-addr {
    type string {
      pattern "((0:|[1-9][0-9]{0,4}:)(([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))";
    }
    description
      "An IPV4 tunnel address in dotted decimal notation.
       An IPv4 tunnel address should be of the form
       65535:129.29.83.45. This datatype restricts the
       value of each field between 0 and 65535 for prefix
       field and 0 and 255 for IPv4 address field, i.e.
       [0-65535]:[0-255].[0-255].[0-255].[0-255]";
  }

  typedef Cisco-ios-xr-port-number {
    type uint16 {
      range "1..65535";
    }
    description
      "Port number of range from 1 to 65535";
  }

  typedef Interface-name {
    type string {
      pattern "[a-zA-Z0-9.:_/-]+";
    }
    description
      "An interface name specifying an interface type and
       instance.
       Interface represents a string defining an interface
       type and instance, e.g. MgmtEth0/4/CPU1/0 or
       TenGigE0/2/0/0.2 or Bundle-Ether9 or
       Bundle-Ether9.98 or Serial0/0/0/0/3/1:1";
  }

  typedef Controller-name {
    type string {
      pattern "[a-zA-Z0-9.:_/-]+";
    }
    description
      "A controller name specifying a controller type and
       instance.
       Controller represents a string defining a controller
       type and instance, e.g. dwdm0/4/0/0 or
       GigabitEthCtrlr0/2/0/0 or T10/0/0/0";
  }

  typedef Cisco-ios-xr-string {
    type string {
      pattern "[\\w\\-\\.:,_@#%$\\+=\\| ;]+";
    }
    description
      "Special characters are not allowed.";
  }

  typedef Ipv4-prefix-length {
    type uint8 {
      range "0..32";
    }
    description
      "An IPv4 address prefix length.
       Must lie between 0 and 32 inclusive.";
  }

  typedef Ipv6-prefix-length {
    type uint8 {
      range "0..128";
    }
    description
      "An IPv6 address prefix length.
       Must lie between 0 and 32 inclusive.";
  }

  typedef Rack-id {
    type string {
      pattern "[a-zA-Z0-9_]*\\d+";
    }
    description
      "Names the rack portion of a NodeID
       Rack/Slot/Instance triple";
  }

  typedef Slot-id {
    type string {
      pattern "[a-zA-Z0-9_]*\\d+";
    }
    description
      "Names the slot portion of a NodeID
       Rack/Slot/Instance triple";
  }

  typedef Instance-id {
    type string {
      pattern "[a-zA-Z0-9_]*\\d+";
    }
    description
      "Names the instance portion of a NodeID
       Rack/Slot/Instance triple";
  }

  typedef Sub-instance-id {
    type string {
      pattern "[a-zA-Z0-9_]*\\d+";
    }
    description
      "Names the sub-instance portion of an extended
       NodeID Rack/Slot/Instance/SubInstance";
  }

  typedef Encryption-type {
    type enumeration {
      enum "none" {
        value 0;
        description
          "The password string is clear text.";
      }
      enum "md5" {
        value 1;
        description
          "The password is encrypted to an MD5 digest.";
      }
      enum "proprietary" {
        value 2;
        description
          "The password is encrypted using Cisco type 7
           password encryption.";
      }
      enum "type6" {
        value 3;
        description
          "The password is encrypted using Cisco type 6
           password encryption.";
      }
    }
    description
      "The type of encryption used on a password string.";
  }

  typedef Hex-long-integer {
    type string {
      pattern "[0-9a-fA-F]{1,16}";
    }
    description
      "An unsigned 64-bit integer represented in
       hexadecimal format.";
  }

  typedef Hex-integer {
    type string {
      pattern "[0-9a-fA-F]{1,8}";
    }
    description
      "An unsigned 32-bit integer represented in
       hexadecimal format.";
  }

  typedef Hex-integer-16 {
    type string {
      pattern "[0-9a-fA-F]{1,4}";
    }
    description
      "An unsigned 16-bit integer represented in
       hexadecimal format.";
  }

  typedef Hex-integer-8 {
    type string {
      pattern "[0-9a-fA-F]{1,2}";
    }
    description
      "An unsigned 8-bit integer represented in
       hexadecimal format.";
  }

  typedef Osi-system-id {
    type string {
      pattern "[a-fA-F0-9]{4}(\\.[a-fA-F0-9]{4}){2}";
    }
    description
      "An OSI system ID should be of the form
       0123.4567.89ab. This data type restricts each
       character to a hex character.";
  }

  typedef Osi-area-address {
    type string {
      pattern "[a-fA-F0-9]{2}(\\.[a-fA-F0-9]{4}){0,6}";
    }
    description
      "An OSI area address should consist of an odd number
       of octets, and be of the form 01 or 01.2345 etc up
       to 01.2345.6789.abcd.ef01.2345.6789. This data type
       restricts each character to a hex character.";
  }

  typedef Isis-node-id {
    type string {
      pattern "[a-fA-F0-9]{4}(\\.[a-fA-F0-9]{4}){2}\\.[a-fA-F0-9]{2}";
    }
    description
      "An ISIS node ID should be of the form
       0123.4567.89ab.cd. This data type restricts each
       character to a hex character.";
  }

  typedef Isis-snpa {
    type string {
      pattern "[a-fA-F0-9]{4}(\\.[a-fA-F0-9]{4}){2}";
    }
    description
      "String representation of a SNPA, 802.2 MAC address
       in canonical format, e.g. 0123.4567.89ab";
  }

  typedef Isis-lsp-id {
    type string {
      pattern "[a-fA-F0-9]{4}(\\.[a-fA-F0-9]{4}){2}\\.[a-fA-F0-9]{2}\\-[a-fA-F0-9]{2}";
    }
    description
      "An ISIS LSP ID should be of the form
       0123.4567.89ab.cd-ef. This data type restricts each
       character to a hex character.";
  }

  typedef Osi-net {
    type string {
      pattern "[a-fA-F0-9]{2}(\\.[a-fA-F0-9]{4}){3,9}\\.[a-fA-F0-9]{2}";
    }
    description
      "An OSI NET should consist of an even number of
       octets, and be of the form 01.2345.6789.abcd.ef etc
       up to
       01.2345.6789.abcd.ef01.2345.6789.abcd.ef01.2345.67.
       This data type restricts each character to a hex
       character.";
  }

  typedef String-identifier {
    type string {
      pattern "[a-zA-Z0-9_\\-]+";
    }
    description
      "A string for specifying identifier.";
  }

  typedef Char-num {
    type union {
      type string {
        pattern "(0x[0-9A-Fa-f]{1,2}|\\p{IsBasicLatin}|\\p{IsLatin-1Supplement})";
      }
      type uint8;
    }
    description
      "Takes a character or its ASCII decimal equivalent
       (0-255).";
  }

  typedef Tty-escape-char-num {
    type union {
      type string {
        pattern "(0x[0-9A-Fa-f]{1,2}|\\p{IsBasicLatin}|\\p{IsLatin-1Supplement}|DEFAULT|BREAK|NONE)";
      }
      type uint8;
    }
    description
      "Escape character or its ASCII decimal equivalent
       (0-255) or one of the three string DEFAULT, BREAK,
       NONE.";
  }

  typedef Extended-node-id {
    type string {
      pattern "([a-zA-Z0-9_]*\\d+/){3}([a-zA-Z0-9_]*\\d+)";
    }
    description
      "A location used as value information and specified
       as a Rack/Slot/Instance/SubInstance, e.g.
       0/1/CPU0/NPU0";
  }

  typedef Node-id {
    type string {
      pattern "([a-zA-Z0-9_]*\\d+/){1,2}([a-zA-Z0-9_]*\\d*)";
    }
    description
      "A location used as value information.";
  }

  typedef Pq-node-id {
    type string {
      pattern "((([a-zA-Z0-9_]*\\d+)|(\\*))/){2}(([a-zA-Z0-9_]*\\d+)|(\\*))";
    }
    description
      "Partially qualified location which is used for
       wildcarding location specifications, e.g. 1/*/*";
  }

  typedef Md5-password {
    type string {
      pattern "(!.+)|([^!].+)";
    }
    description
      "The Md5-password type is used to store password using the MD5
       hash function.
       When a clear text value is set to a leaf of this type, the
       server calculates a password hash and stores the result
       in the datastore. The password is never stored in clear text.
       
       When a leaf of this type is read, the stored password hash is
       returned.
       
       A value of this type matches one of the forms:
       
         !<clear text password>
         <password hash>
       
       The '!' prefix signals that the value is clear text. When
       such a value is received by the server, a hash value is
       calculated. This value is stored in the configuration data
       store.
       
       If a value starting without '!' is received, the server knows
       that the value already represents a hashed value, and stores
       it as is in the data store.";
  }

  typedef Type8-password {
    type string {
      pattern "(!.+)|([^!].+)";
    }
    description
      "The Type8-password type is used to store password using the
       SHA-256 encryption.
       When a clear text value is set to a leaf of this type, the
       server calculates a password hash and stores the result
       in the datastore. The password is never stored in clear text.
       
       When a leaf of this type is read, the stored password hash is
       returned.
       
       A value of this type matches one of the forms:
       
         !<clear text password>
         <password hash>
       
       The '!' prefix signals that the value is clear text. When
       such a value is received by the server, a hash value is
       calculated. This value is stored in the configuration data
       store.
       
       If a value starting without '!' is received, the server knows
       that the value already represents a hashed value, and stores
       it as is in the data store.";
  }

  typedef Type9-password {
    type string {
      pattern "(!.+)|([^!].+)";
    }
    description
      "The Type9-password type is used to store password using the
       Script algorithmic encryption.
       When a clear text value is set to a leaf of this type, the
       server calculates a password hash and stores the result
       in the datastore. The password is never stored in clear text.
       
       When a leaf of this type is read, the stored password hash is
       returned.
       
       A value of this type matches one of the forms:
       
         !<clear text password>
         <password hash>
       
       The '!' prefix signals that the value is clear text. When
       such a value is received by the server, a hash value is
       calculated. This value is stored in the configuration data
       store.
       
       If a value starting without '!' is received, the server knows
       that the value already represents a hashed value, and stores
       it as is in the data store.";
  }

  typedef Type10-password {
    type string {
      pattern "(!.+)|([^!].+)";
    }
    description
      "The Type10-password type is used to store password using the
       Script algorithmic encryption.
       When a clear text value is set to a leaf of this type, the
       server calculates a password hash and stores the result
       in the datastore. The password is never stored in clear text.
       
       When a leaf of this type is read, the stored password hash is
       returned.
       
       A value of this type matches one of the forms:
       
         !<clear text password>
         <password hash>
       
       The '!' prefix signals that the value is clear text. When
       such a value is received by the server, a hash value is
       calculated. This value is stored in the configuration data
       store.
       
       If a value starting without '!' is received, the server knows
       that the value already represents a hashed value, and stores
       it as is in the data store.";
  }

  typedef Proprietary-password {
    type string {
      pattern "(!.+)|([^!].+)";
    }
    description
      "The Proprietary-password type is used to store password
       using the Cisco proprietary hash function.
       When a clear text value is set to a leaf of this type, the
       server calculates a password hash and stores the result
       in the datastore. The password is never stored in clear text.
       
       When a leaf of this type is read, the stored password hash is
       returned.
       
       A value of this type matches one of the forms:
       
         !<clear text password>
         <password hash>
       
       The '!' prefix signals that the value is clear text. When
       such a value is received by the server, a hash value is
       calculated. This value is stored in the configuration data
       store.
       
       If a value starting without '!' is received, the server knows
       that the value already represents a hashed value, and stores
       it as is in the data store.";
  }

  typedef Type6-password {
    type string {
      pattern "(!.+)|([^!].+)";
    }
    description
      "The Type6-password type is used to store password
       using the Cisco type 6 hash function.
       When a clear text value is set to a leaf of this type, the
       server calculates a password hash and stores the result
       in the datastore. The password is never stored in clear text.
       
       When a leaf of this type is read, the stored password hash is
       returned.
       
       A value of this type matches one of the forms:
       
         !<clear text password>
         <password hash>
       
       The '!' prefix signals that the value is clear text. When
       such a value is received by the server, a hash value is
       calculated. This value is stored in the configuration data
       store.
       
       If a value starting without '!' is received, the server knows
       that the value already represents a hashed value, and stores
       it as is in the data store.";
  }

  typedef Bgp-ipv4-flowspec-address {
    type string {
      pattern "[a-fA-F0-9]{4096}";
    }
    description
      "An IPV4 Flowspec address in hexadecimal notation.";
  }

  typedef Bgp-ipv6-flowspec-address {
    type string {
      pattern "[a-fA-F0-9]{4096}";
    }
    description
      "An IPV6 Flowspec address in hexadecimal notation.";
  }

  typedef Rpl-policy {
    type string;
    description
      "RPL Policy info";
  }

  typedef Rpl-set {
    type string;
    description
      "RPL Set info";
  }

  typedef Physical-allowed-node-id {
    type uint32;
    description
      "A physical location encoded as a 32-bit value.";
  }

  typedef Physical-allowed-node-id-string {
    type string;
    description
      "A physical location which is represented internallyusing string format (eg: 0_6_CPU0).";
  }

  typedef Bgp-as-number {
    type union {
      type uint32 {
        range "1..65535" {
          description
            "2-byte AS number";
        }
      }
      type string {
        pattern "([1-9][0-9]{0,4}).([0-9]{1,5})" {
          description
            "4-byte AS number in asdot (X.Y) format";
        }
      }
      type uint32 {
        range "65536..4294967295" {
          description
            "4-byte AS number in asplain format";
        }
      }
    }
    description
      "BGP AS number type";
  }

  typedef Route-policy-name {
    type string {
      length "1..255";
    }
    description
      "Datatype for route policy name";
  }

  typedef Ospf-area-id {
    type union {
      type uint32 {
        range "0..4294967295";
      }
      type inet:ip-address;
    }
    description
      "OSPF area ID. Either OSPF area ID as a decimal value or OSPF area ID in IP address format";
  }

  typedef Vpn-id {
    type string {
      pattern "([0-9a-f]{1,8}):([0-9a-f]{1,8})" {
        description
          "VPN ID format (OUI:VPN-Index in hex integer)";
      }
    }
    description
      "VPN ID format (OUI:VPN-Index in hex integer)";
  }

  typedef Mpls-label-space-id {
    type string {
      pattern "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]):0" {
        description
          "<IPv4 address>:0";
      }
    }
    description
      "MPLS-LDP labe-space ID format";
  }

  typedef Bgp-route-distinguisher {
    type union {
      type string {
        pattern "([0-9]{1,5}):([0-9]{1,10})" {
          description
            "2-byte AS number:nn (<1-65535>:<0-4294967295>)";
        }
      }
      type string {
        pattern "([0-9]{5,10}):([0-9]{1,10})" {
          description
            "4-byte AS number:nn (<65536-4294967295>:<0-4294967295>)";
        }
      }
      type string {
        pattern "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]):([0-9]{1,10})" {
          description
            "IP address:nn (A.B.C.D:<0-4294967295>)";
        }
      }
    }
    description
      "BGP route distinguisher number format";
  }

  typedef Evpn-esi-value {
    type string {
      pattern "[0-9a-f]{1,2}(\\.[0-9a-f]{1,2}){8}";
    }
    description
      "EVPN 9-octet ESI value";
  }

  typedef Docker-app-id {
    type string {
      pattern "[a-zA-Z0-9][a-zA-Z0-9_.-]+";
    }
    description
      "A Docker container name format.";
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-hostname-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg";
  prefix um-hostname-cfg;

  import Cisco-IOS-XR-types {
    prefix xr;
  }
  import cisco-semver {
    prefix semver;
  }

  organization
    "Cisco Systems, Inc.";
  contact
    "Cisco Systems, Inc.
     Customer Service
     
     Postal: 170 West Tasman Drive
     San Jose, CA 95134
     
     Tel: +1 800 553-NETS
     
     E-mail: cs-yang@cisco.com";
  description
    "This module contains a collection of YANG definitions
     for Cisco IOS-XR hostname package configuration.
     
     This YANG module augments the
     modules with configuration data.
     
     Copyright (c) 2021-2022 by Cisco Systems, Inc.
     All rights reserved.";

  revision 2021-04-21 {
    description
      "Initial release";
    semver:module-version "1.0.0";
  }

  container hostname {
    description
      "Set system's network name";
    leaf system-network-name {
      type xr:Cisco-ios-xr-string {
        length "1..253" {
          description
            "This system's network name";
        }
        pattern "[a-zA-Z0-9_.-]+";
      }
      description
        "Set system's network name";
    }
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-if-ip-address-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg";
  prefix um-if-ip-address-cfg;

  import cisco-semver {
    prefix semver;
  }
  import ietf-inet-types {
    prefix inet;
  }
  import Cisco-IOS-XR-types {
    prefix xr;
  }
  import Cisco-IOS-XR-um-interface-cfg {
    prefix a1;
  }

  organization
    "Cisco Systems, Inc.";
  contact
    "Cisco Systems, Inc.
     Customer Service
     
     Postal: 170 West Tasman Drive
     San Jose, CA 95134
     
     Tel: +1 800 553-NETS
     
     E-mail: cs-yang@cisco.com";
  description
    "This module contains a collection of YANG definitions
     for Cisco IOS-XR interface package configuration.
     
     This YANG module augments the
     modules with configuration data.
     
     Copyright (c) 2019-2022 by Cisco Systems, Inc.
     All rights reserved.";

  revision 2022-07-11 {
    description
      "Added missing description statement to nodes
       2021-09-14
         Added leaf algorithm under container address, secondaries and eui64-addresses";
    semver:module-version "3.1.0";
  }
  revision 2020-05-27 {
    description
      "- Included BVI interface under when statement for container dhcp
       - Added container dhcp and dhcp-client-options under ipv6 addresses";
    semver:module-version "3.0.0";
  }
  revision 2019-06-10 {
    description
      "Establish semantic version baseline.";
    semver:module-version "2.0.0";
  }
  revision 2019-03-29 {
    description
      "Initial version";
  }

  grouping GROUP-IPV4 {
    description
      "Interface IPv4 config commands";
    container addresses {
      description
        "Set the IPv4 address of an interface";
      container address {
        presence "Indicates a address node is configured.";
        description
          "IP address and Mask";
        leaf address {
          type inet:ipv4-address-no-zone;
          mandatory true;
          description
            "IP address";
        }
        leaf netmask {
          type inet:ipv4-address-no-zone;
          mandatory true;
          description
            "IP subnet mask";
        }
        leaf route-tag {
          type uint32 {
            range "1..4294967295";
          }
          description
            "Route-tag to be associated with this address";
        }
        leaf algorithm {
          type uint32 {
            range "128..255" {
              description
                "Algorithm value (default: no algo)";
            }
          }
          description
            "Algorithm to be associated with this address";
        }
      }
      container secondaries {
        description
          "Specify a secondary address";
        list secondary {
          key "address";
          description
            "IP address and Mask";
          leaf address {
            type inet:ipv4-address-no-zone;
            description
              "Secondary IP address";
          }
          leaf netmask {
            type inet:ipv4-address-no-zone;
            mandatory true;
            description
              "Netmask";
          }
          leaf route-tag {
            type uint32 {
              range "1..4294967295";
            }
            description
              "Route-tag to be associated with this address";
          }
          leaf algorithm {
            type uint32 {
              range "128..255" {
                description
                  "Algorithm value (default: no algo)";
              }
            }
            description
              "Algorithm to be associated with this address";
          }
        }
      }
      leaf unnumbered {
        when "../../../a1:interface-name[not(starts-with(text(),'pw-ether'))]" {
        }
        type xr:Interface-name;
        description
          "Enable IP processing without an explicit address";
      }
      container dhcp {
        when "../../../a1:interface-name[starts-with(text(),'MgmtEth')] or ../../../a1:interface-name[starts-with(text(),'BVI')]" {
        }
        presence "Indicates a dampening node is configured.";
        description
          "IPv4 address and Mask negotiated via DHCP";
      }
    }
  }

  augment "/a1:interfaces/a1:interface/a1:ipv4" {
    description
      "This augment extends active nodes configuration";
    uses GROUP-IPV4;
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-l2-ethernet-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg";
  prefix "um-l2-ethernet-cfg";
  import Cisco-IOS-XR-types {
    prefix "xr";
  }
  import ietf-yang-types {
    prefix "yang";
  }
  import Cisco-IOS-XR-um-interface-cfg {
    prefix "a1";
  }
  import tailf-common {
    prefix "tailf";
  }
  import cisco-semver {
    prefix "semver";
  }
  organization "Cisco Systems, Inc.";
  contact "Cisco Systems, Inc.
Customer Service

Postal: 170 West Tasman Drive
San Jose, CA 95134

Tel: +1 800 553-NETS

E-mail: cs-yang@cisco.com";
  description "This module contains a collection of YANG definitions
for Cisco IOS-XR l2-ethernet package configuration.

This YANG module augments the
modules with configuration data.

Copyright (c) 2020-2022 by Cisco Systems, Inc.
All rights reserved.";
  revision 2023-06-15 {
    description "Added ethernet conatiner with leaf UNI id in,
IF_BODY grouping.
2022-10-10
  Added must statement dot1q, dot1ad, untagged, and default
2022-07-11
  Added missing description statement to nodes
2022-06-18
  Added container list-extended to support 64 vlan ranges
2022-03-10
  1.Added leaf dot1q-end-vlan-id under l2transport-encapsulation/dot1ad
2.Added leaf second-dot1q-end-vlan-id under l2transport-encapsulation/dot1q";
    semver:module-version 4.0.0;
  }
  revision 2021-03-30 {
    description "Updated with statement for 800G interface";
    semver:module-version 3.0.0;
  }
  revision 2021-02-19 {
    description "Updated when/must statement under carrier-delay, l2transport-encapsulation,
  encapsulation, l2protocol container.
2020-08-01
    Added when/must statement under encapsulation container.
  Added feature/if-feature for global ethernet config.";
    semver:module-version 2.0.0;
  }
  revision 2020-03-05 {
    description "Initial draft";
    semver:module-version 1.0.0;
  }
  feature global-ethernet {
    description "Global ethernet configuration";
  }
  grouping IF-BODY {
    description "Grouping for interface";
    container encapsulation {
      when "(../a1:interface-name[starts-with(text(),'FastEthernet')] or ../a1:interface-name[starts-with(text(),'GigabitEthernet')] or ../a1:interface-name[starts-with(text(),'TenGigE')] or ../a1:interface-name[starts-with(text(),'FortyGigE')] or ../a1:interface-name[starts-with(text(),'HundredGigE')] or ../a1:interface-name[starts-with(text(),'TwoHundredGigE')] or ../a1:interface-name[starts-with(text(),'FourHundredGigE')] or ../a1:interface-name[starts-with(text(),'EightHundredGigE')] or ../a1:interface-name[starts-with(text(),'TwentyFiveGigE')] or ../a1:interface-name[starts-with(text(),'FiftyGigE')] or ../a1:interface-name[starts-with(text(),'Bundle-Ether')] or ../a1:interface-name[starts-with(text(),'PW-Ether')])and ../a1:interface-name[contains(text(),'.')]and not(../a1:sub-interface-type/a1:l2transport)" {
        tailf:dependency "../a1:interface-name";
      }
      description "Specify which packets will be matched by this sub-interface";
      container dot1q {
        description "IEEE 802.1Q VLAN-tagged packets";
        leaf vlan-id {
          type uint32 {
            range "1..4094" {
              description "Configure first (outer) VLAN ID on the subinterface";
            }
          }
          description "Configure first (outer) VLAN ID on the subinterface";
        }
        leaf second-dot1q {
          type uint32 {
            range "1..4094" {
              description "Configure second (inner 802.1Q) VLAN ID on the subinterface";
            }
          }
          must "../vlan-id";
          description "Configure second (inner 802.1Q) VLAN ID on the subinterface";
        }
      }
    }
  }
  grouping L2TRANS-BODY {
    description "Grouping for l2transport";
    container l2protocol {
      when "(../../a1:interface-name[starts-with(text(),'FastEthernet')] or ../../a1:interface-name[starts-with(text(),'GigabitEthernet')] or ../../a1:interface-name[starts-with(text(),'TenGigE')] or ../../a1:interface-name[starts-with(text(),'FortyGigE')] or ../../a1:interface-name[starts-with(text(),'HundredGigE')] or ../../a1:interface-name[starts-with(text(),'TwentyFiveGigE')] or ../../a1:interface-name[starts-with(text(),'Ethernet')] or ../../a1:interface-name[starts-with(text(),'Bundle-Ether')] or ../../a1:interface-name[starts-with(text(),'PW-Ether')] or ../../a1:interface-name[starts-with(text(),'Interflex')]) and (../../a1:interface-name[not(contains(text(),'.'))] or ../../a1:sub-interface-type/a1:l2transport)" {
        tailf:dependency "../../a1:interface-name";
      }
      description "Layer 2 protocol handling";
      container cpsv {
        description "CDP, PVST+, STP, and VTP protocols";
        container tunnel {
          must "not(../reverse-tunnel) and not(../drop)";
          presence "Indicates a tunnel node is configured.";
          description "Tunnel at ingress";
        }
        container reverse-tunnel {
          must "not(../tunnel) and not(../drop)";
          presence "Indicates a reverse-tunnel node is configured.";
          description "Tunnel at egress";
        }
        container drop {
          must "not(../tunnel) and not(../reverse-tunnel)";
          presence "Indicates a drop node is configured.";
          description "Drop these protocol packets";
        }
      }
      container cdp {
        description "Cisco Discovery Protocol";
        container drop {
          must "not(../tunnel) and not(../forward)";
          presence "Indicates a drop node is configured.";
          description "Drop this protocol's packets";
        }
        container forward {
          must "not(../drop) and not(../tunnel)";
          presence "Indicates a forward node is configured.";
          description "Forward this protocol's packets";
        }
        container tunnel {
          must "not(../drop) and not(../forward)";
          presence "Indicates a tunnel node is configured.";
          description "Tunnel this protocol's packets";
        }
        container experimental {
          description "Modify the MPLS Experimental bits";
          leaf mpls-experimental-bits {
            type uint32 {
              range "0..7" {
                description "Set the MPLS experimental bits for this interface";
              }
            }
            must "../../forward or ../../tunnel";
            description "Set the MPLS experimental bits for this interface";
          }
        }
      }
      container stp {
        description "Spanning Tree Protocol";
        container drop {
          must "not(../tunnel) and not(../forward)";
          presence "Indicates a drop node is configured.";
          description "Drop this protocol's packets";
        }
        container forward {
          must "not(../drop) and not(../tunnel)";
          presence "Indicates a forward node is configured.";
          description "Forward this protocol's packets";
        }
        container tunnel {
          must "not(../drop) and not(../forward)";
          presence "Indicates a tunnel node is configured.";
          description "Tunnel this protocol's packets";
        }
        container experimental {
          description "Modify the MPLS Experimental bits";
          leaf mpls-experimental-bits {
            type uint32 {
              range "0..7" {
                description "Set the MPLS experimental bits for this interface";
              }
            }
            must "../../forward or ../../tunnel";
            description "Set the MPLS experimental bits for this interface";
          }
        }
      }
      container vtp {
        description "VLAN Trunk Protocol";
        container drop {
          must "not(../tunnel) and not(../forward)";
          presence "Indicates a drop node is configured.";
          description "Drop this protocol's packets";
        }
        container forward {
          must "not(../drop) and not(../tunnel)";
          presence "Indicates a forward node is configured.";
          description "Forward this protocol's packets";
        }
        container tunnel {
          must "not(../drop) and not(../forward)";
          presence "Indicates a tunnel node is configured.";
          description "Tunnel this protocol's packets";
        }
        container experimental {
          description "Modify the MPLS Experimental bits";
          leaf mpls-experimental-bits {
            type uint32 {
              range "0..7" {
                description "Set the MPLS experimental bits for this interface";
              }
            }
            must "../../forward or ../../tunnel";
            description "Set the MPLS experimental bits for this interface";
          }
        }
      }
      container pvst {
        description "Per VLAN Spanning Tree";
        container drop {
          must "not(../tunnel) and not(../forward)";
          presence "Indicates a drop node is configured.";
          description "Drop this protocol's packets";
        }
        container forward {
          must "not(../drop) and not(../tunnel)";
          presence "Indicates a forward node is configured.";
          description "Forward this protocol's packets";
        }
        container tunnel {
          must "not(../drop) and not(../forward)";
          presence "Indicates a tunnel node is configured.";
          description "Tunnel this protocol's packets";
        }
        container experimental {
          description "Modify the MPLS Experimental bits";
          leaf mpls-experimental-bits {
            type uint32 {
              range "0..7" {
                description "Set the MPLS experimental bits for this interface";
              }
            }
            must "../../forward or ../../tunnel";
            description "Set the MPLS experimental bits for this interface";
          }
        }
      }
    }
    container propagate {
      description "Select events to propagate";
      container remote-status {
        presence "Indicates a remote-status node is configured.";
        description "Propagate remote link status changes";
      }
    }
  }
  augment "/a1:interfaces/a1:interface" {
    description "This augment extends active nodes configuration";
    uses IF-BODY;
  }
  container ethernet {
    description "Ethernet configuration";
    container egress-filter {
      description "Egress-filter commands";
      container strict {
        if-feature "global-ethernet";
        presence "Indicates a strict node is configured.";
        description "Strict egress-filtering on by default";
      }
    }
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-if-vrf-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-vrf-cfg";
  prefix um-if-vrf-cfg;

  import cisco-semver {
    prefix semver;
  }
  import Cisco-IOS-XR-types {
    prefix xr;
  }
  import Cisco-IOS-XR-um-interface-cfg {
    prefix a1;
  }

  organization
    "Cisco Systems, Inc.";
  contact
    "Cisco Systems, Inc.
     Customer Service
     
     Postal: 170 West Tasman Drive
     San Jose, CA 95134
     
     Tel: +1 800 553-NETS
     
     E-mail: cs-yang@cisco.com";
  description
    "This module contains a collection of YANG definitions
     for Cisco IOS-XR if vrf package configuration.
     
     This YANG module augments the
     modules with configuration data.
     
     Copyright (c) 2019-2022 by Cisco Systems, Inc.
     All rights reserved.";

  revision 2022-07-11 {
    description
      "Added missing description statement to nodes";
    semver:module-version "1.1.0";
  }
  revision 2019-10-10 {
    description
      "Initial version";
    semver:module-version "1.0.0";
  }

  grouping GROUP-IFSUB {
    description
      "Grouping for interface";
    leaf vrf {
      when "../a1:interface-name[not(starts-with(text(),'tunnel-'))] and ../a1:interface-name[not(starts-with(text(),'cem'))] and ../a1:interface-name[not(starts-with(text(),'nve'))]" {
      }
      type xr:Cisco-ios-xr-string {
        length "1..32" {
          description
            "VRF name";
        }
      }
      description
        "Set VRF in which the interface operates";
    }
  }

  augment "/a1:interfaces/a1:interface" {
    description
      "This augment extends active nodes configuration";
    uses GROUP-IFSUB;
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-interface-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg";
  prefix um-interface-cfg;

  import cisco-semver {
    prefix semver;
  }
  import Cisco-IOS-XR-types {
    prefix xr;
  }

  organization
    "Cisco Systems, Inc.";
  contact
    "Cisco Systems, Inc.
     Customer Service
     
     Postal: 170 West Tasman Drive
     San Jose, CA 95134
     
     Tel: +1 800 553-NETS
     
     E-mail: cs-yang@cisco.com";
  description
    "This module contains a collection of YANG definitions
     for Cisco IOS-XR interface package configuration.
     
     This YANG module augments the
     modules with configuration data.
     
     Copyright (c) 2019-2022 by Cisco Systems, Inc.
     All rights reserved.";

  revision 2022-07-11 {
    description
      "Added missing description statement to nodes
       2022-06-01
         Adjusted controller hierarchy";
    semver:module-version "3.0.0";
  }
  revision 2021-05-04 {
    description
      "Added sec-admin-state node under controller";
    semver:module-version "2.0.0";
  }
  revision 2019-06-10 {
    description
      "Establish semantic version baseline.";
    semver:module-version "1.0.1";
  }
  revision 2019-03-29 {
    description
      "Initial version";
  }

  grouping GROUP-BODY {
    description
      "Grouping for group-body";
    container sub-interface-type {
      description
        "Specify type of sub-interface";
      container l2transport {
        presence "Indicates a l2transport node is configured.";
        description
          "l2transport sub-interface";
      }
      container point-to-point {
        presence "Indicates a point-to-point node is configured.";
        description
          "point-to-point sub-interface";
      }
      container multipoint {
        presence "Indicates a multipoint node is configured.";
        description
          "multipoint sub-interface";
      }
    }
    container ipv4 {
      description
        "Interface IPv4 config commands";
    }
    container ipv6 {
      description
        "Interface IPv6 config commands";
    }
    container encapsulation {
      when "../interface-name[starts-with(text(),'POS')] or ../interface-name[starts-with(text(),'serial')] or ../interface-name[starts-with(text(),'multilink')]" {
      }
      description
        "Set the encapsulation on an interface";
      container ppp {
        presence "Indicates a ppp node is configured.";
        description
          "Point-to-Point protocol";
      }
      container hdlc {
        presence "Indicates a hdlc node is configured.";
        description
          "Serial HDLC synchronous";
      }
      container mfr {
        when "../../interface-name[starts-with(text(),'serial')]" {
        }
        presence "Indicates a mfr node is configured.";
        description
          "Multilink Frame Relay Member Link";
      }
      container frame-relay {
        when "../../interface-name[not(contains(text(),'.'))]" {
        }
        presence "Indicates a frame-relay node is configured.";
        description
          "Frame Relay networks";
        container IETF {
          presence "Indicates a IETF node is configured.";
          description
            "Use RFC1490/RFC2427 encapsulation";
        }
      }
    }
    leaf shutdown {
      type empty;
      description
        "shutdown the given interface";
    }
    leaf mtu {
      when "../interface-name[not(starts-with(text(),'SBC'))] and ../interface-name[not(starts-with(text(),'tunnel-te'))] and ../interface-name[not(starts-with(text(),'tunnel-mte'))] and ../interface-name[not(starts-with(text(),'VASILeft'))] and ../interface-name[not(starts-with(text(),'VASIRight'))] and ../interface-name[not(starts-with(text(),'service-gre'))] and ../interface-name[not(starts-with(text(),'service-ipsec'))] and ../interface-name[not(starts-with(text(),'InterflexLeft'))] and ../interface-name[not(starts-with(text(),'InterflexRight'))] and ../interface-name[not(starts-with(text(),'CEM'))]" {
      }
      type uint32 {
        range "64..65535" {
          description
            "MTU size in bytes";
        }
      }
      description
        "Set the MTU on an interface";
    }
    leaf description {
      type string {
        length "1..1024" {
          description
            "Description for this interface";
        }
      }
      description
        "Set description for this interface";
    }
  }

  grouping CONT-BODY {
    description
      "Grouping for controller-body";
    container shutdown {
      when "../controller-name[not(starts-with(text(),'MACSecCtrlr'))] and ../controller-name[not(starts-with(text(),'Odu-Group-'))] and ../controller-name[not(starts-with(text(),'dwdm'))]" {
      }
      presence "Indicates a shutdown node is configured.";
      description
        "shutdown the given controller";
    }
    leaf description {
      when "../controller-name[not(starts-with(text(),'CPRI'))] and ../controller-name[not(starts-with(text(),'MACSecCtrlr'))] and ../controller-name[not(starts-with(text(),'Odu-Group-'))] and ../controller-name[not(starts-with(text(),'STM'))] and ../controller-name[not(starts-with(text(),'STS'))] and ../controller-name[not(starts-with(text(),'VC'))] and ../controller-name[not(starts-with(text(),'dwdm'))]" {
      }
      type string {
        length "1..1024" {
          description
            "Description for this controller";
        }
      }
      description
        "Set description for this controller";
    }
    leaf sec-admin-state {
      when "../controller-name[not(starts-with(text(),'MACSecCtrlr'))] and ../controller-name[not(starts-with(text(),'Odu-Group-'))] and ../controller-name[not(starts-with(text(),'E1'))] and ../controller-name[not(starts-with(text(),'E3'))] and ../controller-name[not(starts-with(text(),'T1'))] and ../controller-name[not(starts-with(text(),'T3'))] and ../controller-name[not(starts-with(text(),'SONET'))] and ../controller-name[not(starts-with(text(),'ODU'))] and ../controller-name[not(starts-with(text(),'OTU'))] and ../controller-name[not(starts-with(text(),'dwdm'))]" {
      }
      type enumeration {
        enum "normal" {
          value 0;
          description
            "change the sec-admin-state to normal, only for optics";
        }
        enum "maintenance" {
          value 1;
          description
            "change the sec-admin-state to maintenance";
        }
      }
      description
        "Configure the secondary admin state, not available for all controllers";
    }
  }

  container interfaces {
    description
      "Interface configuration";
    list interface {
      key "interface-name";
      description
        "Interface configuration subcommands";
      leaf interface-name {
        type xr:Interface-name;
        description
          "Interface configuration subcommands";
      }
      uses GROUP-BODY;
    }
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-mpls-ldp-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg";
  prefix "um-mpls-ldp-cfg";
  import cisco-semver {
    prefix "semver";
  }
  import Cisco-IOS-XR-types {
    prefix "xr";
  }
  import ietf-inet-types {
    prefix "inet";
  }
  organization "Cisco Systems, Inc.";
  contact "Cisco Systems, Inc.
Customer Service

Postal: 170 West Tasman Drive
San Jose, CA 95134

Tel: +1 800 553-NETS

E-mail: cs-yang@cisco.com";
  description "This module contains a collection of YANG definitions
for Cisco IOS-XR mpls-ldp package configuration.

This YANG module augments the
modules with configuration data.

Copyright (c) 2019-2023 by Cisco Systems, Inc.
All rights reserved.";
  revision 2022-06-01 {
    description "added entropy-label-add-el and clone-tunnel support
2021-11-15
  added address-family ipv6 feature and rtr-id-arb-tlv ";
    semver:module-version 3.1.0;
  }
  revision 2021-07-09 {
    description "type correction for the ipv4/v6 address";
    semver:module-version 3.0.0;
  }
  revision 2021-01-29 {
    description "Add enable container under recursive-fec container
2021-01-28
    Added cisco-support task yang nodes
2020-12-08
    Removed cisco-support yang nodes
2020-07-10
    Added when statement to redistribute to show it's only for ipv4";
    semver:module-version 2.0.0;
  }
  revision 2020-05-29 {
    description "Changed description for sac";
  }
  revision 2019-12-10 {
    description "Corrected must statement definition for password/encrypted,disable";
  }
  revision 2019-10-10 {
    description "Moved trap augments into Cisco-IOS-XR-um-traps-mpls-ldp-cfg.";
  }
  revision 2019-09-25 {
    description "Changed the list node name access-list to access-lists.";
    semver:module-version 2.0.0;
  }
  revision 2019-06-10 {
    description "Establish semantic version baseline.";
  }
  revision 2019-03-30 {
    description "Initial version";
  }
  container mpls {
    description "Global MPLS configuration subcommands";
    container ldp {
      presence "Indicates a ldp node is configured.";
      description "Label Distribution Protocol";
      container address-families {
        description "Configure Address Family and its parameters";
        list address-family {
          key af-name;
          description "Configure Address Family and its parameters";
          leaf af-name {
            type enumeration {
              enum ipv4 {
                value 4;
                description "IPv4";
              }
              enum ipv6 {
                value 6;
                description "IPv6";
              }
            }
            description "Configure Address Family and its parameters";
          }
        }
      }
      container interfaces {
        description "Enable LDP on an interface and enter interface submode";
        list interface {
          key interface-name;
          description "Enable LDP on an interface and enter interface submode";
          leaf interface-name {
            type xr:Interface-name;
            description "Enable LDP on an interface and enter interface submode";
          }
        }
      }
    }
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-router-bgp-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg";
  prefix "um-router-bgp-cfg";
  import Cisco-IOS-XR-types {
    prefix "xr";
  }
  import ietf-inet-types {
    prefix "inet";
  }
  import Cisco-IOS-XR-um-vrf-cfg {
    prefix "a2";
  }
  import cisco-semver {
    prefix "semver";
  }
  organization "Cisco Systems, Inc.";
  contact "Cisco Systems, Inc.
Customer Service

Postal: 170 West Tasman Drive
San Jose, CA 95134

Tel: +1 800 553-NETS

E-mail: cs-yang@cisco.com";
  description "This module contains a collection of YANG definitions
for Cisco IOS-XR router-bgp package configuration.

This YANG module augments the
modules with configuration data.

Copyright (c) 2019-2024 by Cisco Systems, Inc.
All rights reserved.";
  revision 2024-01-31 {
    description "Removed deprecated policy container under route-monitoring
2024-01-23
  Updated containers for export to vrf allow-imported-vpn
disable-adv-source-vrf-vni allow backup best-external
2023-12-08
  Updated containers for import from vrf advertise-as-vpn allow backup best-external
2023-12-03
  Updated sch-pathnames for next-hop-self
2023-08-04
  Added MPLS-VPN label mode per-vrf-46 option
2023-07-12
  Support for allocate-secondary-label
2023-06-05
  Support for local aggregates OC
2023-05-01
  Added segment-routing srv6 alloc mode per-vrf-46 option
2023-04-18
  1. Added allowconfedas-in leaf
2. Added nexthop route-policy under vrf leafs
2023-03-15
  Added segment-routing SRv6 uSID allocate from
WLIB
2023-02-27
  Added maximum-paths route-policy and eibgp equal-cost leaf
2023-02-06
  Added LPTS secure binding leaf
2023-01-25
  Support for update in error-handling
2022-12-13
  Support for evpn-link-bandwidth
2022-12-09
  Added OC-BGP neighbor logging and addpath
2022-12-08
  1. Added OC-BGP restart timer
2. Added EVPN host import knobs under AF v4/v6 of
global VRF.
2022-11-05
  Updated slow-peer static and dynamic leafs
2022-10-04
  Added OC-BGP replace-private-as
2022-09-23
  Added BMP route-monitoring suport for L3VPN inbound post-policy
and Local RIB,
Deprecated container policy under route-monitoring
2022-09-19
  Added EVPN Gateway IP disable
2022-08-16
  Updated slow-peer feature
2022-07-14
  Added OC-BGP mtu-discovery
2022-07-11
  Added missing description statement to nodes
2022-06-20
  Added delay/startup support under wait-install
2022-03-03
  Added leaf percentage-threshold-high under bandwidth-aware
2022-02-18
  Updated maximum-paths ebgp/eibgp and ibgp to remove unused container 'order' and fix pack format
2021-10-20
  Added force node under sr-policy";
    semver:module-version 5.0.0;
  }
  revision 2021-10-19 {
    description "Added leaf flex-algo under container optimal-route-reflection
2021-09-21
   Added retention under route-policy
2021-08-27
   Increase maximum-paths ebgp range to 1024,
 Added preference  under rpki/server,
 Added datafile under rpki,
 Added unique-nexthop-check-disable under maximum-paths,
 Added table-version under address-family
2021-08-23
   Added epe-bgp/labeled-unicast under advertise and epe/backup/enable
 Added deterministic under unequal-cost of maximum-paths
 Added container export under address family
 Added leaf route-policy under srv6/alloc
 Added container bandwidth-aware
 Added leaf route-policy under srv6/alloc of vrfs
 Added node deterministic under unequal-cost of maximum-paths/address family
2021-07-29
   Removed duplicate enforce-first-as-disable which serve same as enforce-first-as/disable";
    semver:module-version 4.0.0;
  }
  revision 2021-05-31 {
    description "Added must statement under list instances router->bgp
2021-03-15
    Added sr-policy under router-bgp->bgp->bestpath and
  router-bgp->vrf->bgp->bestpath
2021-02-25
    Added multipath container under vrf->neighbors->address-family
2021-02-17
    Added must constraints in af-group list
2021-02-11
    Removed presence statement from match node under eigrp container
2021-02-10
    Added labeled-unicast under best-external
2021-02-04
    Added sr-policy under nexthop & igp-metric
2021-02-03
    Added container option-b-asbr-only
2020-11-16
    Added srte-metric and validation under nexthop
2020-11-10
    Added mask-length under local-address-subnet as needed
2020-10-22
    Added rpki-dropped-only/rpki-tested-only under
  soft-reconfiguration/inbound. Updated must statements accordingly
  to define proper constraints with new nodes.
2020-09-30
    Added multipath under neighbor address-family
2020-08-12
    Added route-target container under retain.
  Added per-nexthop-received-label under mode.
  Added appropriate when statements under retain/mode containers.
  Removed per-prefix under vrf as it's not supported.
2020-08-05
    Added some must statements as needed
2020-07-30
    Added when statement to local-labeled-route under address-family
  hierarchy and removed one presence statement as needed";
    semver:module-version 3.0.0;
  }
  revision 2020-07-24 {
    description "Added internal under remove-private-as. Also added must statements
  under remove-private-as as appropriate.
2020-06-05
  Removed unused nodes from vrf address-family
  Added constraint to nodes under as-format
2020-05-17
  (1) Added enable/label-mode under as
  (2) Added srv6 under encapsulation-type
  (3) Added vpnv4/vpnv6/l2vpn nodes under advertise
  (4) Added segment-routing node under neighbors/neighbor/address-family
  (5) Changed integer range of multipath, message-log-buffer-size, purge-time
  (6) Added minimum-ipv6 node under nexthop/resolution/prefix-length
  (7) Changed sysdb path of log node and its chilren
  (8) Changed sysdb path of suppress node and its children
  (9) Added extended-nexthop-encoding node under suppress
  (10) Added update node under neighbor-group/address-families/address-family
  (11) Added retain-nbr-routes under graceful-restart

2020-04-14
  Added rd augment to vrf model
2020-03-13
  Added corresponding nodes for peer-set-id, adjacencies,
  peer-set and peer-node-sid";
    semver:module-version 2.0.0;
  }
  revision 2019-06-10 {
    description "Establish semantic version baseline.";
    semver:module-version 1.0.0;
  }
  revision 2019-03-30 {
    description "Initial version";
  }
  typedef Bgp-address-family {
    type enumeration {
      enum ipv4-unicast {
        value 0;
        description "IPv4 unicast";
      }
      enum ipv4-multicast {
        value 1;
        description "IPv4 multicast";
      }
      enum ipv4-labeled-unicast {
        value 2;
        description "IPv4 labeled-unicast";
      }
      enum ipv4-tunnel {
        value 3;
        description "IPv4 tunnel";
      }
      enum vpnv4-unicast {
        value 4;
        description "VPNv4 unicast";
      }
      enum ipv6-unicast {
        value 5;
        description "IPv6 unicast";
      }
      enum ipv6-multicast {
        value 6;
        description "IPv6 multicast";
      }
      enum ipv6-labeled-unicast {
        value 7;
        description "IPv6 labeled-unicast";
      }
      enum vpnv6-unicast {
        value 8;
        description "VPNv6 unicast";
      }
      enum ipv4-mdt {
        value 9;
        description "IPv4 MDT";
      }
      enum l2vpn-vpls-vpws {
        value 10;
        description "L2VPN VPLS-VPWS";
      }
      enum ipv4-rt-filter {
        value 11;
        description "IPv4 rt-filter";
      }
      enum ipv4-mvpn {
        value 12;
        description "IPv4 MVPN";
      }
      enum ipv6-mvpn {
        value 13;
        description "IPv6 MVPN";
      }
      enum l2vpn-evpn {
        value 14;
        description "L2VPN EVPN";
      }
      enum link-state-link-state {
        value 15;
        description "Link-state link-state";
      }
      enum vpnv4-multicast {
        value 16;
        description "VPNv4 Multicast";
      }
      enum vpnv6-multicast {
        value 17;
        description "VPNv6 Multicast";
      }
      enum ipv4-flowspec {
        value 18;
        description "IPv4 flowspec";
      }
      enum ipv6-flowspec {
        value 19;
        description "IPv6 flowspec";
      }
      enum vpnv4-flowspec {
        value 20;
        description "VPNv4 flowspec";
      }
      enum vpnv6-flowspec {
        value 21;
        description "VPNv6 flowspec";
      }
      enum l2vpn-mspw {
        value 22;
        description "L2VPN MSPW";
      }
      enum ipv4-sr-policy {
        value 23;
        description "IPv4 SRPolicy";
      }
      enum ipv6-sr-policy {
        value 24;
        description "IPv6 SRPolicy";
      }
      enum all-address-family {
        value 25;
        description "All Address Families";
      }
    }
    description "Bgp address family";
  }
  typedef Bgp-attribute-code {
    type union {
      type uint32 {
        range "0 | 4..14";
      }
      type uint32 {
        range "6..255";
      }
      type enumeration {
        enum AGGREGATOR {
          value 7;
          description "Aggregator attribute (7)";
        }
        enum AIGP {
          value 26;
          description "AIGP attribute (26)";
        }
        enum AS4-AGGREGATOR {
          value 18;
          description "AS4_AGGREGATOR attribute (18)";
        }
        enum AS4-PATH {
          value 17;
          description "AS4_PATH attribute (17)";
        }
        enum ATOMIC-AGGREGATE {
          value 6;
          description "Atomic aggrgate attribute (6)";
        }
        enum ATTRSET {
          value 128;
          description "ATTR_SET attribute (128)";
        }
        enum CLUSTER-LIST {
          value 10;
          description "Cluster List attribute (10)";
        }
        enum COMMUNITY {
          value 8;
          description "Community attribute (8)";
        }
        enum CONNECTOR {
          value 20;
          description "Connector attribute (20)";
        }
        enum EXTENDED-COMMUNITIES {
          value 16;
          description "Extended community attribute (16)";
        }
        enum LARGE-COMMUNITY {
          value 32;
          description "Large Community attribute (32)";
        }
        enum LOCAL-PREF {
          value 5;
          description "Local Preference attribute (5)";
        }
        enum LSATTR {
          value 29;
          description "Link-state attribute (29)";
        }
        enum MULTI-EXIT-DISC {
          value 4;
          description "MED attribute (4)";
        }
        enum ORIGINATOR-ID {
          value 9;
          description "Originator attribute (9)";
        }
        enum PMSI-TUNNEL {
          value 22;
          description "PMSI Tunnel attribute (22)";
        }
        enum PPMP {
          value 70;
          description "PPMP attribute (70)";
        }
        enum PREFIX-SID {
          value 40;
          description "Prefix-SID attribute (40)";
        }
        enum SSA {
          value 19;
          description "SAFI specific attribute (19)";
        }
        enum TUNNEL-ENCAP {
          value 23;
          description "Tunnel-Encapsulation attribute (23)";
        }
      }
    }
    description "Bgp attribute code";
  }
  typedef Bmp-mode {
    type enumeration {
      enum inbound-pre-policy {
        value 0;
        description "Pickup routes at inbound direction from peer
before application of route-policy";
      }
      enum inbound-post-policy {
        value 1;
        description "Pickup routes at inbound direction from peer
after application of route-policy";
      }
      enum local-rib {
        value 4;
        description "Pickup routes that have been selected by the
local BGP speaker's decision process";
      }
    }
    description "Bmp route monitor mode";
  }
  grouping VRF-COMMON {
    description "Grouping for vrf";
    container import {
      description "VRF import";
      container route-target {
        description "Specify import route target extended communities";
        container two-byte-as-rts {
          description "Two Byte AS Number Route Target";
          list two-byte-as-rt {
            key "as-number index stitching";
            description "Two Byte AS Number Route Target";
            leaf as-number {
              type uint32 {
                range "1..65535";
              }
              description "Two Byte AS Number";
            }
            leaf index {
              type uint32 {
                range "0..4294967295" {
                  description "ASN2:index (hex or decimal format)";
                }
              }
              description "ASN2:index (hex or decimal format)";
            }
            leaf stitching {
              type boolean;
              description "These are stitching RTs";
            }
          }
        }
      }
    }
    container export {
      description "VRF export";
      container route-target {
        description "Specify export route target extended communities";
        container two-byte-as-rts {
          description "Two Byte AS Number Route Target";
          list two-byte-as-rt {
            key "as-number index stitching";
            description "Two Byte AS Number Route Target";
            leaf as-number {
              type uint32 {
                range "1..65535";
              }
              description "Two Byte AS Number";
            }
            leaf index {
              type uint32 {
                range "0..4294967295" {
                  description "ASN2:index (hex or decimal format)";
                }
              }
              description "ASN2:index (hex or decimal format)";
            }
            leaf stitching {
              type boolean;
              description "These are stitching RTs";
            }
          }
        }
      }
    }
  }
  grouping VRF-RD {
    description "Grouping for vrf-rd";
    container rd {
      description "route distinguisher";
      container two-byte-as {
        must "not(../four-byte-as or ../ip-address)";
        presence "Indicates a two-byte-as node is configured.";
        description " two-byte-as route distinguisher";
        leaf as-number {
          type xr:Bgp-as-number;
          mandatory true;
          description "bgp as-number";
        }
        leaf index {
          type uint32 {
            range "0..4294967295" {
              description "ASN2:index (hex or decimal format)";
            }
          }
          mandatory true;
          description "ASN2:index (hex or decimal format)";
        }
      }
      container four-byte-as {
        must "not(../two-byte-as or ../ip-address)";
        presence "Indicates a four-byte-as node is configured.";
        description "four-byte-as route distinguisher";
        leaf as-number {
          type xr:Bgp-as-number;
          mandatory true;
          description "4-byte AS number";
        }
        leaf index {
          type uint32 {
            range "0..4294967295" {
              description "ASN2:index (hex or decimal format)";
            }
          }
          mandatory true;
          description "ASN2:index (hex or decimal format)";
        }
      }
      container ip-address {
        must "not(../two-byte-as or ../four-byte-as)";
        presence "Indicates a ip-address node is configured.";
        description "configure this node";
        leaf ipv4-address {
          type inet:ipv4-address-no-zone;
          mandatory true;
          description "configure this node";
        }
        leaf index {
          type uint32 {
            range "0..65535" {
              description "IPv4Address:index (hex or decimal format)";
            }
          }
          mandatory true;
          description "IPv4Address:index (hex or decimal format)";
        }
      }
    }
  }
  grouping AS-COMMON {
    description "Grouping for as-common";
    container rpki {
      description "Configure RPKI";
      container servers {
        description "Configure RPKI cache-servers";
        list server {
          key server-id;
          description "Configure RPKI cache-servers";
          leaf server-id {
            type xr:Cisco-ios-xr-string {
              length "1..1024" {
                description "Hostname or IP address";
              }
            }
            description "Configure RPKI cache-servers";
          }
          container bind-source {
            description "Specify a bind source for RPKI cache-server";
            container interface {
              description "Specify a source interface to bind the cache-server transport";
              leaf interface-name {
                type xr:Interface-name;
                description "Interface Name";
              }
            }
          }
          leaf preference {
            type uint32 {
              range "1..10" {
                description "(Deprecated from 7.4.1) RPKI cache-server preference value (lower is better)";
              }
            }
            description "(Deprecated from 7.4.1) Specify a preference value for the RPKI cache";
          }
          container refresh-time {
            description "Time between sending serial-queries for the RPKI cache-server";
            leaf refresh-time-value {
              type uint32 {
                range "15..3600" {
                  description "Refresh time (in seconds)";
                }
              }
              description "Refresh time (in seconds)";
            }
            container off {
              presence "Indicates a off node is configured.";
              description "Do not send serial-queries periodically";
            }
          }
          container response-time {
            description "Time to wait for a response from the RPKI cache-server";
            leaf response-time-value {
              type uint32 {
                range "15..3600" {
                  description "Response time (in seconds)";
                }
              }
              description "Response time (in seconds)";
            }
            container off {
              presence "Indicates a off node is configured.";
              description "Wait indefinitely for a response";
            }
          }
          leaf purge-time {
            type uint32 {
              range "30..65535" {
                description "Purge time (in seconds)";
              }
            }
            description "Purge time (in seconds)";
          }
          leaf username {
            type string {
              length "1..1024" {
                description "RPKI cache (SSH) username";
              }
            }
            description "Specify a (SSH) username for the RPKI cache-server";
          }
          leaf password {
            type string {
              length "1..1024" {
                description "RPKI cache (SSH) password";
              }
            }
            description "Specify a (SSH) password for the RPKI cache-server";
          }
          container transport {
            description "Specify a transport method for the RPKI cache-server";
            container tcp {
              description "Connect to the RPKI cache-server using TCP (unencrypted)";
              leaf port {
                type uint32 {
                  range "1..65535" {
                    description "Specify a port number for the RPKI cache-server transport";
                  }
                }
                must "not(../../ssh/port)";
                description "Specify a port number for the RPKI cache-server transport";
              }
            }
            container ssh {
              description "Connect to the RPKI cache-server using SSH";
              leaf port {
                type uint32 {
                  range "1..65535" {
                    description "Specify a port number for the RPKI cache-server transport";
                  }
                }
                must "not(../../tcp/port)";
                description "Specify a port number for the RPKI cache-server transport";
              }
            }
          }
          container shutdown {
            presence "Indicates a shutdown node is configured.";
            description "Shutdown the RPKI cache-server";
          }
        }
      }
      container routes {
        description "Configure an RPKI route";
        list route {
          key "address minimum-prefix-length maximum-prefix-length origin-as-number";
          description "Configure an RPKI route";
          leaf address {
            type inet:ip-address-no-zone;
            description "Configure an RPKI route";
          }
          leaf minimum-prefix-length {
            type union {
              type uint32 {
                range "0..32" {
                  description "Minimum prefix length for ipv4 address";
                }
              }
              type uint32 {
                range "0..128" {
                  description "Minimum prefix length for ipv6 address";
                }
              }
            }
            description "Minimum prefix length";
          }
          leaf maximum-prefix-length {
            type union {
              type uint32 {
                range "1..32" {
                  description "Maximum prefix length for ipv4 address";
                }
              }
              type uint32 {
                range "1..128" {
                  description "Maximum prefix length for ipv6 addess";
                }
              }
            }
            description "Maximum prefix length (Default 32/128 for IPv4/IPv6)";
          }
          leaf origin-as-number {
            type uint32 {
              range "1..4294967295" {
                description "Origin Autonomous System number (in asplain format)";
              }
            }
            description "Origin Autonomous System number";
          }
        }
      }
      leaf datafile {
        type xr:Cisco-ios-xr-string {
          length "1..800" {
            description "(Deprecated from 7.4.1) File name containing RPKI data entries";
          }
        }
        description "(Deprecated from 7.4.1) Configure an RPKI data file";
      }
    }
    container address-families {
      description "Enter Address Family command mode";
      list address-family {
        key af-name;
        description "Enter Address Family command mode";
        leaf af-name {
          type Bgp-address-family;
          description "Enter Address Family command mode";
        }
      }
    }
    container neighbors {
      description "Specify a neighbor router";
      list neighbor {
        key neighbor-address;
        description "Neighbor address";
        leaf neighbor-address {
          type inet:ip-address-no-zone;
          description "Neighbor address";
        }
        container use {
          description "Inherit configuration from a group";
          leaf session-group {
            type string {
              length "1..1024" {
                description "Session group name";
              }
            }
            description "Inherit address-family independent config from a session-group";
          }
          leaf neighbor-group {
            type string {
              length "1..1024" {
                description "Neighbor-group name";
              }
            }
            description "Inherit configuration from a neighbor-group";
          }
        }
        leaf description {
          type string {
            length "1..1024" {
              description "Up to 80 characters describing this neighbor";
            }
          }
          description "Neighbor specific description";
        }
      }
    }
    container neighbor-groups {
      description "Specify a Neighbor-group";
      list neighbor-group {
        key neighbor-group-name;
        description "Specify a Neighbor-group";
        leaf neighbor-group-name {
          type xr:Cisco-ios-xr-string {
            length "1..900" {
              description "Neighbor-group name";
            }
          }
          description "Specify a Neighbor-group";
        }
        container address-families {
          description "Enter Address Family command mode";
          list address-family {
            key af-name;
            description "Enter Address Family command mode";
            leaf af-name {
              type Bgp-address-family;
              description "Enter Address Family command mode";
            }
          }
        }
        leaf remote-as {
          type xr:Bgp-as-number;
          description "bgp as-number";
        }
        leaf description {
          type string {
            length "1..1024" {
              description "Up to 80 characters describing this neighbor";
            }
          }
          description "Neighbor specific description";
        }
        container password {
          must "encrypted or inheritance-disable";
          presence "Indicates a password node is configured.";
          description "Set a password";
          leaf encrypted {
            type xr:Proprietary-password;
            description "Specifies an ENCRYPTED password will follow";
          }
          container inheritance-disable {
            presence "Indicates a inheritance-disable node is configured.";
            description "Prevent password from being inherited from parent";
          }
        }
        leaf update-source {
          type xr:Interface-name;
          description "Source of routing updates";
        }
      }
    }
    container bgp {
      description "BGP commands";
      leaf router-id {
        type inet:ipv4-address-no-zone;
        description "Configure Router-id";
      }
    }
    container vrfs {
      description "Specify a vrf name";
      list vrf {
        key vrf-name;
        description "Specify a vrf name";
        leaf vrf-name {
          type xr:Cisco-ios-xr-string {
            length "1..32" {
              description "VRF name - maximum length 32 characters";
            }
          }
          description "Specify a vrf name";
        }
        container address-families {
          description "Enter Address Family command mode";
          list address-family {
            key af-name;
            description "Enter Address Family command mode";
            leaf af-name {
              type Bgp-address-family;
              description "Enter Address Family command mode";
            }
          }
        }
        container neighbors {
          description "Specify a neighbor router";
          list neighbor {
            key neighbor-address;
            description "Neighbor address";
            leaf neighbor-address {
              type inet:ip-address-no-zone;
              description "Neighbor address";
            }
            container address-families {
              description "Enter Address Family command mode";
              list address-family {
                key af-name;
                description "Enter Address Family command mode";
                leaf af-name {
                  type Bgp-address-family;
                  description "Enter Address Family command mode";
                }
                container route-policy {
                  description "Apply route policy to neighbor";
                  leaf in {
                    type xr:Route-policy-name;
                    description "Apply route policy to inbound routes";
                  }
                  leaf out {
                    type xr:Route-policy-name;
                    description "Apply route policy to outbound routes";
                  }
                  container retention {
                    description "Apply retention policy to inbound routes";
                    leaf route-policy-name {
                      type xr:Route-policy-name;
                      must "../retention-time";
                      description "Apply retention policy to inbound routes";
                    }
                    leaf retention-time {
                      type uint32 {
                        range "0..4294967295" {
                          description "Max time (seconds)";
                        }
                      }
                      must "../route-policy-name";
                      description "Retention-time for this neighbor";
                    }
                  }
                }
                container as-override {
                  presence "Indicates a as-override node is configured.";
                  description "Override matching AS-number while sending update";
                  container inheritance-disable {
                    presence "Indicates a inheritance-disable node is configured.";
                    description "Prevent as-override from being inherited from the parent";
                  }
                }
              }
            }
            leaf remote-as {
              type xr:Bgp-as-number;
              description "bgp as-number";
            }
            leaf description {
              type string {
                length "1..1024" {
                  description "Up to 80 characters describing this neighbor";
                }
              }
              description "Neighbor specific description";
            }
            container password {
              must "encrypted or inheritance-disable";
              presence "Indicates a password node is configured.";
              description "Set a password";
              leaf encrypted {
                type xr:Proprietary-password;
                description "Specifies an ENCRYPTED password will follow";
              }
              container inheritance-disable {
                presence "Indicates a inheritance-disable node is configured.";
                description "Prevent password from being inherited from parent";
              }
            }
          }
        }
        container rd {
          must "auto or two-byte-as or four-byte-as or ip-address";
          presence "Indicates a rd node is configured.";
          description "route distinguisher";
          container auto {
            must "not(../two-byte-as or ../four-byte-as or ../ip-address)";
            presence "Indicates a auto node is configured.";
            description "Automatic route distinguisher";
          }
          container two-byte-as {
            must "not(../auto or ../four-byte-as or ../ip-address)";
            presence "Indicates a two-byte-as node is configured.";
            description "two-byte-as route distinguisher";
            leaf as-number {
              type xr:Bgp-as-number;
              mandatory true;
              description "bgp as-number";
            }
            leaf index {
              type uint32 {
                range "0..4294967295" {
                  description "ASN2:index (hex or decimal format)";
                }
              }
              mandatory true;
              description "ASN2:index (hex or decimal format)";
            }
          }
          container four-byte-as {
            must "not(../auto or ../two-byte-as or ../ip-address)";
            presence "Indicates a four-byte-as node is configured.";
            description "four-byte-as route distinguisher";
            leaf as-number {
              type xr:Bgp-as-number;
              mandatory true;
              description "4-byte AS number";
            }
            leaf index {
              type uint32 {
                range "0..4294967295" {
                  description "ASN2:index (hex or decimal format)";
                }
              }
              mandatory true;
              description "ASN2:index (hex or decimal format)";
            }
          }
          container ip-address {
            must "not(../auto or ../two-byte-as or ../four-byte-as)";
            presence "Indicates a ip-address node is configured.";
            description "configure this node";
            leaf ipv4-address {
              type inet:ipv4-address-no-zone;
              mandatory true;
              description "configure this node";
            }
            leaf index {
              type uint32 {
                range "0..65535" {
                  description "IPv4Address:index (hex or decimal format)";
                }
              }
              mandatory true;
              description "IPv4Address:index (hex or decimal format)";
            }
          }
        }
      }
    }
  }
  augment "/a2:vrfs/a2:vrf/a2:address-family/a2:ipv4/a2:unicast" {
    description "This augment extends vrf ipv4 unicast nodes
configuration";
    uses VRF-COMMON;
  }
  augment "/a2:vrfs/a2:vrf/a2:address-family/a2:ipv6/a2:unicast" {
    description "This augment extends vrf ipv6 unicast nodes
configuration";
    uses VRF-COMMON;
  }
  augment "/a2:vrfs/a2:vrf" {
    description "This augment extends vrf nodes
configuration";
    uses VRF-RD;
  }
  container as-format {
    description "Autonomous system number format";
    container asdot {
      must "not(../asplain)";
      presence "Indicates a asdot node is configured.";
      description "AS Dot format";
    }
    container asplain {
      must "not(../asdot)";
      presence "Indicates a asplain node is configured.";
      description "AS Plain format";
    }
  }
  container bmp {
    description "BGP Monitoring Protocol commands";
    container servers {
      description "BMP server configuration";
      list server {
        key bmp-server-id;
        description "BMP server ID to configure";
        leaf bmp-server-id {
          type uint32 {
            range "1..8" {
              description "BMP server ID to configure";
            }
          }
          description "BMP server ID to configure";
        }
        container shutdown {
          presence "Indicates a shutdown node is configured.";
          description "Shutdown connection to BMP server";
        }
        container host {
          presence "Indicates a host node is configured.";
          description "Hostname of BMP Server";
          leaf host-name {
            type string {
              length "1..1024" {
                description "Name of the BMP server(accepts IP Address format too)";
              }
            }
            mandatory true;
            description "Hostname of BMP Server";
          }
          leaf port {
            type uint32 {
              range "1..65535" {
                description "Port Number of listening BMP server";
              }
            }
            description "BMP Server Listen Port";
          }
        }
        leaf initial-delay {
          type uint32 {
            range "1..3600" {
              description "Initial connect delay in sending BMP server updates";
            }
          }
          description "Initial connect delay in sending BMP server updates. Default=0";
        }
        leaf flapping-delay {
          type uint32 {
            range "60..3600" {
              description "Range in seconds for the connection delay after flap";
            }
          }
          description "delay in connecting to BMP Server after a flap had been detected. Default=300";
        }
        leaf max-buffer-size {
          type uint32 {
            range "1..4294967295" {
              description "Range in MegaBytes for the maximum buffer size of BMP message queue.";
            }
          }
          description "Set BMP message buffer size";
        }
        container initial-refresh {
          description "Initial refresh to generate BGP updates. DEfault=1";
          container delay {
            presence "Indicates a delay node is configured.";
            description "Initial delay before sending route refresh request";
            leaf initial-delay {
              type uint32 {
                range "1..3600" {
                  description "Delay in sending Refresh request to Peers (default : 30 secs)";
                }
              }
              mandatory true;
              description "Initial delay before sending route refresh request";
            }
            leaf spread {
              type uint32 {
                range "1..3600" {
                  description "Maximum additional random delay (in secs)";
                }
              }
              description "Maximum additional random delay for initial Refresh Request";
            }
          }
          container skip {
            presence "Indicates a skip node is configured.";
            description "Skip sending Refresh request to Peers";
          }
        }
        leaf stats-reporting-period {
          type uint32 {
            range "1..3600" {
              description "Stats-report-period in seconds";
            }
          }
          description "Stats reporting period for BMP server. Default=0";
        }
        leaf description {
          type string {
            length "1..1024" {
              description "Up to 250 characters describing this BMP server";
            }
          }
          description "BMP server specific description";
        }
        leaf dscp {
          type enumeration {
            enum default {
              value 0;
              description "Set packets with default dscp (000000)";
            }
            enum cs1 {
              value 8;
              description "Set packets with CS1(precedence 1) dscp (001000)";
            }
            enum af11 {
              value 10;
              description "Set packets with AF11 dscp (001010)";
            }
            enum af12 {
              value 12;
              description "Set packets with AF12 dscp (001100)";
            }
            enum af13 {
              value 14;
              description "Set packets with AF13 dscp (001110)";
            }
            enum cs2 {
              value 16;
              description "Set packets with CS2(precedence 2) dscp (010000)";
            }
            enum af21 {
              value 18;
              description "Set packets with AF21 dscp (010010)";
            }
            enum af22 {
              value 20;
              description "Set packets with AF22 dscp (010100)";
            }
            enum af23 {
              value 22;
              description "Set packets with AF23 dscp (010110)";
            }
            enum cs3 {
              value 24;
              description "Set packets with CS3(precedence 3) dscp (011000)";
            }
            enum af31 {
              value 26;
              description "Set packets with AF31 dscp (011010)";
            }
            enum af32 {
              value 28;
              description "Set packets with AF32 dscp (011100)";
            }
            enum af33 {
              value 30;
              description "Set packets with AF33 dscp (011110)";
            }
            enum cs4 {
              value 32;
              description "Set packets with CS4(precedence 4) dscp (100000)";
            }
            enum af41 {
              value 34;
              description "Set packets with AF41 dscp (100010)";
            }
            enum af42 {
              value 36;
              description "Set packets with AF42 dscp (100100)";
            }
            enum af43 {
              value 38;
              description "Set packets with AF43 dscp (100110)";
            }
            enum cs5 {
              value 40;
              description "Set packets with CS5(precedence 5) dscp (101000)";
            }
            enum ef {
              value 46;
              description "Set packets with EF dscp (101110)";
            }
            enum cs6 {
              value 48;
              description "Set packets with CS6(precedence 6) dscp (110000)";
            }
            enum cs7 {
              value 56;
              description "Set packets with CS7(precedence 7) dscp (111000)";
            }
          }
          description "Set IP DSCP (DiffServ CodePoint)";
        }
        leaf precedence {
          type enumeration {
            enum routine {
              value 0;
              description "Set packets with routine precedence (0)";
            }
            enum priority {
              value 1;
              description "Set packets with priority precedence (1)";
            }
            enum immediate {
              value 2;
              description "Set packets with immediate precedence (2)";
            }
            enum flash {
              value 3;
              description "Set packets with flash precedence (3)";
            }
            enum flash-override {
              value 4;
              description "Set packets with flash override precedence (4)";
            }
            enum critical {
              value 5;
              description "Set packets with critical precedence (5)";
            }
            enum internet {
              value 6;
              description "Set packets with internetwork control precedence (6)";
            }
            enum network {
              value 7;
              description "Set packets with network control precedence (7)";
            }
          }
          description "Set precedence";
        }
        leaf update-source {
          type xr:Interface-name;
          description "Source to reach BMP server";
        }
        leaf vrf {
          type string {
            length "1..1024" {
              description "VRF Name";
            }
          }
          description "VRF for the BMP server";
        }
        container tcp {
          description "Configure TCP related parameters";
          leaf keep-alive {
            type uint32 {
              range "0..7200" {
                description "Keep Alive interval in seconds";
              }
            }
            description "configure TCP keep alives to be exchanged between client and server";
          }
          leaf mss {
            type uint32 {
              range "68..10000" {
                description "TCP segment size in bytes";
              }
            }
            description "configure TCP maximum segment size";
          }
        }
      }
      container all {
        description "Common commands for all BMP servers";
        leaf max-buffer-size {
          type uint32 {
            range "1..4294967295" {
              description "Range in MegaBytes for the maximum buffer size of BMP message queue.";
            }
          }
          description "Maximum buffer limit upto which BMP messages will be queued to TCP sockets.
If total size of BMP messages queued up for BMP sockets exceeds this set limit,
messages will be dropped. The maximum buf-size is 20% and default buf-size is 15%
of the platform virtual memory max-limit (aka rlimit). Please run
show bgp process performance-statistics
to see the individual values. Unit is in MegaBytes.";
        }
        container route-monitoring {
          description "Enable Route Monitoring capability for the BMP servers.
BGP update messages will be regenerated with a table walk
";
          container bmp-modes {
            description "Enter BMP route monitoring command mode";
            list bmp-mode {
              key mode-name;
              description "Enter BMP route monitoring command mode";
              leaf mode-name {
                type Bmp-mode;
                description "Enter BMP route monitoring command mode";
              }
              leaf advertisement-interval {
                when "../mode-name = 'inbound-post-policy' or ../mode-name = 'local-rib'";
                type uint32 {
                  range "2..600" {
                    description "Time in seconds";
                  }
                }
                description "Minimum interval between updates sent to BMP servers";
              }
              leaf scan-time {
                when "../mode-name = 'inbound-post-policy'";
                type uint32 {
                  range "5..3600" {
                    description "Time in seconds";
                  }
                }
                description "Configure scanner interval";
              }
            }
          }
        }
      }
    }
  }
  container router {
    description "Enable a routing process";
    container bgp {
      description "BGP configuration subcommands";
      list as {
        key as-number;
        description "bgp as-number";
        leaf as-number {
          type xr:Bgp-as-number;
          description "bgp as-number";
        }
        uses AS-COMMON;
      }
    }
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-router-isis-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg";
  prefix "um-router-isis-cfg";
  import Cisco-IOS-XR-types {
    prefix "xr";
  }
  import ietf-inet-types {
    prefix "inet";
  }
  import tailf-common {
    prefix "tailf";
  }
  import cisco-semver {
    prefix "semver";
  }
  organization "Cisco Systems, Inc.";
  contact "Cisco Systems, Inc.
Customer Service

Postal: 170 West Tasman Drive
San Jose, CA 95134

Tel: +1 800 553-NETS

E-mail: cs-yang@cisco.com";
  description "This module contains a collection of YANG definitions
for Cisco IOS-XR router-isis package configuration.

This YANG module augments the
modules with configuration data.

Copyright (c) 2019-2023 by Cisco Systems, Inc.
All rights reserved.";
  revision 2023-08-22 {
    description "Add nsr-restart-time
2023-07-12
  Add flex-algo UCMP
2023-06-28
  Change the must clause from ../../srv6-locator-xxx to srv6-locator-xxx
2023-04-09
  Add maximum paths per route-policy for standard and flex algo
2023-04-03
  Add flex-algo MinimumBandwidth and MaximumDelay constraints
2023-03-13
  Add Uloop filtering suport
2023-02-10
  Modify must statement for SPF interval per-level
2022-11-18
  Add distribute link-state prefix filtering
2022-10-14
  Added new nodes for partition-detect
2022-10-04
  Added support for ISIS Prefix-SID UHP
2022-10-02
  Added hello-padding under router-isis
2022-10-01
  Add support for flex-algo reverse link affinities.
2022-07-25
  Added new node anycast-prefer-igp-cost to traffic-eng tunnel
2022-07-18
  Added new node php-disable to the existing connected-prefix-sid-map, strict-spf and flex-algo.
2022-07-11
  Added missing description statement to nodes
2022-05-12
  Added new node adv-unreachable with sub-node unreachable-component-tag and tag value to an existing ISIS address-family sub-mode summary-prefix command.Added new node prefix-unreachable under ISIS address-family sub-mode.
2022-05-05
  Added new node anomaly to the existing ISIS affinity flex-algo
2022-04-22
  Added support for maximum-paths under flex-algo,
Added container algorithm
2022-04-05
  Added support for te and delay
2022-03-03
  Added container metric & tag under segment-routing/srv6/locators,
Added container format,
Added container lsp-fast-flood
2022-01-19
  Added ietf support for spf-interval
2022-01-04
  Added support for unhidden CLI commands
2021-12-14
  Added authentication-check feature";
    semver:module-version 5.0.0;
  }
  revision 2021-09-23 {
    description "Merged container levels under disable|interval/periodic/address-family-topology,
 Merged container levels under disable|interval/periodic/address-family,
 Merged disable & interval-time into one leaf interval
2021-07-27
   Re-ordered maximum-wait, initial-wait and secondary-wait nodes under
 level container/spf-interval
2021-06-15
   Added when statement to container prefix-attributes";
    semver:module-version 4.0.0;
  }
  revision 2021-05-18 {
    description "Added features, 1. flex-algo srlg exclude
2. advertise application flex-algo link-attributes srlg
2021-04-22
    Added te-metric flex-algo feature
2021-03-02
    Re-ordered maximum-wait, initial-wait and secondary-wait nodes under
  level container
2021-02-11
    Re-ordered per-link, per-prefix nodes under interface fast-reroute container
2021-01-28
    Added cisco-support task yang nodes
2021-01-27
    Re-ordered nodes under lsp-gen-interval, min-lsp-arrivaltime container
2021-01-20
    Moved presence containers as leafs under snmp-server traps
2021-01-18
    Added presence statement and re-ordered few nodes under container max-metric
2021-01-11
    Add support to metric and preferred container under tunnel
2021-01-07
    Updated range value in leaf multiplier under fallback container
2021-01-06
    Added presence statement under link-state container
2020-12-09
    Removed cisco-support yang nodes
2020-12-01
    Added container anomaly under metric/fallback
2020-11-20
    Added metric type te
2020-11-19
    Fixed a must statement under absolute, added presence statement to text
2020-11-13
    Added container receive and attestation under list process.
2020-11-02
    Moved levels container under lsp-password out of it and renamed as
  lsp-password-levels.
2020-08-20
    Added level option under srv6/locator
2020-08-13
    Remove presence container and constraints on the match container
2020-08-10
    Updated the fallback topology
2020-07-21
    Slight changes to prefix-priority nodes
2020-07-17
    Added must statements and moved rib-update-delay up one node
2020-07-15
    Added down-flag-clear node under redistribute isis
2020-07-14
    Added mandatory node to bit-position under affinity-map";
    semver:module-version 3.0.0;
  }
  revision 2020-05-19 {
    description "Added nodes for new ISIS features
2020-05-07
  Added a container anycast and its child nodes
2020-04-14
  Updated the constraints in the nodes under stagger to be less strict
2020-03-09
  Updated lsp-password and summary-prefix trees with proper constaraint
  statements";
    semver:module-version 2.0.0;
  }
  revision 2019-06-10 {
    description "Establish semantic version baseline.";
    semver:module-version 1.0.0;
  }
  revision 2019-03-30 {
    description "Initial draft";
  }
  typedef Isis-af-name {
    type enumeration {
      enum ipv4 {
        value 0;
        description "IPv4";
      }
      enum ipv6 {
        value 1;
        description "IPv6";
      }
    }
    description "Address-family names";
  }
  typedef Isis-saf-name {
    type enumeration {
      enum unicast {
        value 0;
        description "unicast";
      }
      enum multicast {
        value 1;
        description "multicast";
      }
    }
    description "Sub address-family names";
  }
  typedef Isis-saf-multicast {
    type enumeration {
      enum multicast {
        value 1;
        description "multicast";
      }
    }
    description "Sub address-family names (only multicast)";
  }
  container router {
    description "Enable a routing process";
    container isis {
      description "ISO IS-IS";
      container processes {
        description "Process ID";
        list process {
          key process-id;
          description "Process ID";
          leaf process-id {
            type string {
              length "1..36" {
                description "Process ID";
              }
            }
            description "Process ID";
          }
          leaf is-type {
            type enumeration {
              enum level-1 {
                value 1;
                description "Act as a station router only";
              }
              enum level-2-only {
                value 2;
                description "Act as an area router only";
              }
              enum level-1-2 {
                value 3;
                description "Act as both a station router and an area router";
              }
            }
            description "Area type (level)";
          }
          container nets {
            description "A Network Entity Title (NET) for this process";
            list net {
              key net-id;
              description "A Network Entity Title (NET) for this process";
              leaf net-id {
                type string {
                  length "1..1024" {
                    description "NET (XX.XXXX. ... .XXXX.XX)";
                  }
                }
                description "A Network Entity Title (NET) for this process";
              }
            }
          }
          container address-families {
            description "Enter the IS-IS address-family configuration submode";
            list address-family {
              key "af-name saf-name";
              description "IS-IS address family";
              leaf af-name {
                type Isis-af-name;
                description "Address family name";
              }
              leaf saf-name {
                type Isis-saf-name;
                description "Sub address family name";
              }
              container segment-routing {
                description "Enable Segment Routing";
                container mpls {
                  description "Enable Segment Routing using MPLS encapsulation";
                  leaf sr-prefer {
                    when "../../../saf-name = 'unicast'";
                    type boolean;
                    description "Prefer segment routing labels over LDP labels";
                  }
                }
              }
              container metric-style {
                description "Use old-style (ISO 10589) or new-style packet formats";
                container narrow {
                  must "not(../wide or ../transition)";
                  presence "Indicates a narrow node is configured.";
                  description "Use old style of TLVs with narrow metric";
                }
                container wide {
                  must "not(../narrow or ../transition)";
                  presence "Indicates a wide node is configured.";
                  description "Use new style of TLVs to carry wider metric";
                }
                container transition {
                  must "not(../narrow or ../wide)";
                  presence "Indicates a transition node is configured.";
                  description "Send and accept both styles of TLVs during transition";
                }
                container levels {
                  description "Set metric-style for one level only";
                  list level {
                    key level-id;
                    description "Set metric-style for one level only";
                    leaf level-id {
                      type uint32 {
                        range "1..2" {
                          description "Level";
                        }
                      }
                      description "Set metric-style for one level only";
                    }
                    container narrow {
                      must "not(../wide or ../transition)";
                      presence "Indicates a narrow node is configured.";
                      description "Use old style of TLVs with narrow metric";
                    }
                    container wide {
                      must "not(../narrow or ../transition)";
                      presence "Indicates a wide node is configured.";
                      description "Use new style of TLVs to carry wider metric";
                    }
                    container transition {
                      must "not(../narrow or ../wide)";
                      presence "Indicates a transition node is configured.";
                      description "Send and accept both styles of TLVs during transition";
                    }
                  }
                }
              }
            }
          }
          container interfaces {
            description "Enter the IS-IS interface configuration submode";
            list interface {
              key interface-name;
              description "Enter the IS-IS interface configuration submode";
              leaf interface-name {
                type xr:Interface-name;
                description "Enter the IS-IS interface configuration submode";
              }
              leaf circuit-type {
                type enumeration {
                  enum level-1 {
                    value 1;
                    description "Form level-1 adjacencies only";
                  }
                  enum level-2-only {
                    value 2;
                    description "Form level-2 adjacencies only";
                  }
                  enum level-1-2 {
                    value 3;
                    description "Form level-1 and level-2 adjacencies";
                  }
                }
                description "Configure circuit type for interface";
              }
              container point-to-point {
                presence "Indicates a point-to-point node is configured.";
                description "Treat active LAN interface as point-to-point";
              }
              container bfd {
                description "Configure BFD parameters";
                container fast-detect {
                  description "Enable Fast detection";
                  container ipv4 {
                    presence "Indicates a ipv4 node is configured.";
                    description "Address Family";
                  }
                  container ipv6 {
                    presence "Indicates a ipv6 node is configured.";
                    description "Address Family";
                  }
                }
                leaf minimum-interval {
                  type uint32 {
                    range "3..30000" {
                      description "hello interval in milli-seconds";
                    }
                  }
                  description "Hello interval";
                }
                leaf multiplier {
                  type uint32 {
                    range "2..50" {
                      description "Detect multiplier";
                    }
                  }
                  description "Detect multiplier";
                }
              }
              container passive {
                must "not(../suppressed or ../shutdown)";
                presence "Indicates a passive node is configured.";
                description "Do not establish adjacencies over this interface";
              }
              container address-families {
                description "Enter the IS-IS interface address-family configuration submode";
                list address-family {
                  key "af-name saf-name";
                  description "Address family";
                  leaf af-name {
                    type Isis-af-name;
                    description "Address family name";
                  }
                  leaf saf-name {
                    type Isis-saf-name;
                    description "Sub address family name";
                  }
                  container metric {
                    description "Configure the metric for interface";
                    leaf default-metric {
                      type uint32 {
                        range "1..16777214" {
                          description "Default metric: <1-63> for narrow, <1-16777214> for wide";
                        }
                      }
                      must "not(../maximum)";
                      description "Default metric";
                    }
                    container maximum {
                      must "not(../default-metric)";
                      presence "Indicates a maximum node is configured.";
                      description "Maximum wide metric. All routers will exclude this link from their SPF";
                    }
                    container levels {
                      description "Set metric for one level only";
                      list level {
                        key level-id;
                        description "Set metric for one level only";
                        leaf level-id {
                          type uint32 {
                            range "1..2" {
                              description "Set metric at this level only";
                            }
                          }
                          description "Set metric for one level only";
                        }
                        leaf default-metric {
                          type uint32 {
                            range "1..16777214" {
                              description "Default metric: <1-63> for narrow, <1-16777214> for wide";
                            }
                          }
                          must "not(../maximum)";
                          description "Default metric";
                        }
                        container maximum {
                          must "not(../default-metric)";
                          presence "Indicates a maximum node is configured.";
                          description "Maximum wide metric. All routers will exclude this link from their SPF";
                        }
                      }
                    }
                  }
                  container prefix-sid {
                    when "../saf-name = 'unicast' and ../../../interface-name[starts-with(text(),'Loopback')]" {
                      tailf:dependency "../../../interface-name";
                    }
                    description "Specify the Prefix Segment ID";
                    container sid {
                      must "index or absolute";
                      presence "Indicates a sid node is configured.";
                      description "Specify the Prefix Segment ID";
                      container index {
                        must "not(../absolute)";
                        presence "Indicates a index node is configured.";
                        description "Specify the index of Prefix Segement ID";
                        leaf sid-index {
                          type uint32 {
                            range "0..1048575" {
                              description "The Prefix Segment ID index";
                            }
                          }
                          mandatory true;
                          description "Specify the index of Prefix Segement ID";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
""")
    res.append(r"""module Cisco-IOS-XR-um-vrf-cfg {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg";
  prefix "um-vrf-cfg";
  import cisco-semver {
    prefix "semver";
  }
  import Cisco-IOS-XR-types {
    prefix "xr";
  }
  organization "Cisco Systems, Inc.";
  contact "Cisco Systems, Inc.
Customer Service

Postal: 170 West Tasman Drive
San Jose, CA 95134

Tel: +1 800 553-NETS

E-mail: cs-yang@cisco.com";
  description "This module contains a collection of YANG definitions
for Cisco IOS-XR vrf package configuration.

This YANG module augments the
modules with configuration data.

Copyright (c) 2019-2022 by Cisco Systems, Inc.
All rights reserved.";
  revision 2022-07-11 {
    description "Added missing description statement to nodes";
    semver:module-version 4.2.0;
  }
  revision 2021-07-13 {
    description "Removed imported native model Cisco-IOS-XR-config-mda-cfg and imported
 model Cisco-IOS-XR-um-location-cfg";
    semver:module-version 4.1.0;
  }
  revision 2021-01-11 {
    description "Added new leaf description under srlg->names->name
2020-07-23
    Removed unused tailf import";
    semver:module-version 4.0.0;
  }
  revision 2019-10-31 {
    description "Added mandatory nodes";
    semver:module-version 3.0.0;
  }
  revision 2019-10-10 {
    description "Moved interface augments into Cisco-IOS-XR-um-if-vrf-cfg
2019-09-23
  Moved 'selective-vrf-download-locations' and its child nodes to module 'Cisco-IOS-XR-config-mda-cfg' to resolve an issue with duplicated list entries being created between the two models.";
    semver:module-version 2.0.0;
  }
  revision 2019-06-10 {
    description "Establish semantic version baseline.";
    semver:module-version 1.0.0;
  }
  revision 2019-03-29 {
    description "Initial version";
  }
  feature svd-location {
    description "selective-vrf-download location feature";
  }
  grouping GROUP-SVD-LOCATION {
    description "Grouping for svd-location";
    container selective-vrf-download {
      if-feature "svd-location";
      must "role or vrf-groups/vrf-group";
      presence "Indicates a selective-vrf-download node is configured.";
      description "Location for Selective VRF Download configuration";
      container role {
        presence "Indicates a role node is configured.";
        description "Card Role configuration";
        container address-family {
          description "AFI/SAFI configuration";
          container ipv4 {
            description "IPv4 AFI SVD configuration";
            leaf unicast {
              type enumeration {
                enum standard {
                  value 1;
                  description "Standard Role";
                }
                enum core-facing {
                  value 2;
                  description "Core Facing Role";
                }
                enum customer-facing {
                  value 3;
                  description "Customer Facing Role";
                }
                enum not-interested {
                  value 4;
                  description "Not-Interested";
                }
                enum vpnonly-customer-facing {
                  value 5;
                  description "L3VPN Only Cutomer Facing Role";
                }
              }
              mandatory true;
              description "IPv4 Unicast AFI-SAFI SVD configuration";
            }
          }
          container ipv6 {
            description "IPv6 AFI SVD configuration";
            leaf unicast {
              type enumeration {
                enum standard {
                  value 1;
                  description "Standard Role";
                }
                enum core-facing {
                  value 2;
                  description "Core Facing Role";
                }
                enum customer-facing {
                  value 3;
                  description "Customer Facing Role";
                }
                enum not-interested {
                  value 4;
                  description "Not-Interested";
                }
                enum vpnonly-customer-facing {
                  value 5;
                  description "L3VPN Only Cutomer Facing Role";
                }
              }
              mandatory true;
              description "IPv6 Unicast AFI-SAFI SVD configuration";
            }
          }
        }
      }
      container vrf-groups {
        description "Enable this VRF-GROUP on this location";
        list vrf-group {
          key vrf-group-name;
          description "Enable this VRF-GROUP on this location";
          leaf vrf-group-name {
            type xr:Cisco-ios-xr-string {
              length "1..32" {
                description "Group name";
              }
            }
            description "Enable this VRF-GROUP on this location";
          }
        }
      }
    }
  }
  container address-family {
    description "AFI/SAFI configuration";
    container ipv4 {
      description "IPv4 address family";
      container unicast {
        presence "Indicates a unicast node is configured.";
        description "Unicast topology";
      }
      container multicast {
        description "Multicast topology";
        container topologies {
          description "Specify a non-default topology";
          list topology {
            key topology-name;
            description "Specify a non-default topology";
            leaf topology-name {
              type xr:Cisco-ios-xr-string {
                length "1..32" {
                  description "Topology name";
                }
              }
              description "Specify a non-default topology";
            }
          }
        }
      }
    }
    container ipv6 {
      description "IPv6 address family";
      container unicast {
        presence "Indicates a unicast node is configured.";
        description "Unicast topology";
      }
      container multicast {
        description "Multicast topology";
        container topologies {
          description "Specify a non-default topology";
          list topology {
            key topology-name;
            description "Specify a non-default topology";
            leaf topology-name {
              type string {
                length "1..32" {
                  description "Topology name";
                }
              }
              description "Specify a non-default topology";
            }
          }
        }
      }
    }
  }
  container vrfs {
    description "VRF configuration commands";
    list vrf {
      key vrf-name;
      description "VRF name";
      leaf vrf-name {
        type xr:Cisco-ios-xr-string {
          length "1..32" {
            description "VRF name";
          }
        }
        description "VRF name";
      }
      container address-family {
        description "AFI/SAFI configuration";
        container ipv4 {
          description "IPv4 address family";
          container unicast {
            presence "Indicates a unicast node is configured.";
            description "Unicast sub address family";
          }
          container multicast {
            presence "Indicates a multicast node is configured.";
            description "Multicast topology";
          }
          container flowspec {
            presence "Indicates a flowspec node is configured.";
            description "Flowspec sub address family";
          }
        }
        container ipv6 {
          description "IPv6 address family";
          container unicast {
            presence "Indicates a unicast node is configured.";
            description "Unicast sub address family";
          }
          container multicast {
            presence "Indicates a multicast node is configured.";
            description "Multicast topology";
          }
          container flowspec {
            presence "Indicates a flowspec node is configured.";
            description "Flowspec sub address family";
          }
        }
      }
      container mode {
        description "VRF mode which determines the max prefix scale";
        container big {
          presence "Indicates a big node is configured.";
          description "big to set max prefix scale more than 64 K";
        }
      }
      container vpn {
        description "VPN ID for the VRF";
        leaf id {
          type xr:Vpn-id;
          description "VPN ID, (OUI:VPN-Index) format(hex), 4 bytes VPN_Index Part";
        }
      }
      leaf description {
        type string {
          length "1..1024" {
            description "Description for this VRF";
          }
        }
        description "A description for the VRF";
      }
      container remote-route-filtering {
        description "Enable/Disable remote route filtering per VRF";
        container disable {
          presence "Indicates a disable node is configured.";
          description "Disable remote route filtering per VRF";
        }
      }
      leaf fallback-vrf {
        type xr:Cisco-ios-xr-string {
          length "1..32" {
            description "Fallback VRF name";
          }
        }
        description "Fallback vrf for this VRF";
      }
    }
  }
  container selective-vrf-download {
    description "Selective VRF Download config commands";
    container disable {
      presence "Indicates a disable node is configured.";
      description "Disable Selective VRF Download";
    }
  }
  container srlg {
    presence "Indicates a srlg node is configured.";
    description "SRLG configuration commands";
    container names {
      description "SRLG name to value mapping";
      list name {
        must "value or description";
        key srlg-name;
        description "SRLG name to value mapping";
        leaf srlg-name {
          type xr:Cisco-ios-xr-string {
            length "1..64" {
              description "SRLG Name";
            }
          }
          description "SRLG name to value mapping";
        }
        leaf value {
          type uint32 {
            range "0..4294967295" {
              description "Network SRLG value";
            }
          }
          description "Configure SRLG network value";
        }
        leaf description {
          type string {
            length "1..800" {
              description "SRLG description";
            }
          }
          description "Configure SRLG network value";
        }
      }
    }
    container interfaces {
      description "SRLG interface configuration submode";
      list interface {
        key interface-name;
        description "SRLG interface configuration submode";
        leaf interface-name {
          type xr:Interface-name;
          description "SRLG interface configuration submode";
        }
        container include-optical {
          presence "Indicates a include-optical node is configured.";
          description "Include srlg values from optical layer";
          leaf priority {
            type enumeration {
              enum critical {
                value 0;
                description "Critical priority";
              }
              enum high {
                value 1;
                description "High priority";
              }
              enum low {
                value 3;
                description "Low priority";
              }
              enum verylow {
                value 4;
                description "Very low priority";
              }
            }
            description "Set prority for the value";
          }
        }
        container indexes {
          description "Index number for this value";
          list index {
            key index-number;
            description "Index number for this value";
            leaf index-number {
              type uint32 {
                range "1..65535" {
                  description "Index number for this value";
                }
              }
              description "Index number for this value";
            }
            leaf value {
              type uint32 {
                range "0..4294967295" {
                  description "Network SRLG value";
                }
              }
              mandatory true;
              description "Configure SRLG network value";
            }
            leaf priority {
              type enumeration {
                enum critical {
                  value 0;
                  description "Critical priority";
                }
                enum high {
                  value 1;
                  description "High priority";
                }
                enum default {
                  value 2;
                  description "Default priority";
                }
                enum low {
                  value 3;
                  description "Low priority";
                }
                enum verylow {
                  value 4;
                  description "Very low priority";
                }
              }
              mandatory true;
              description "Set prority for the value";
            }
          }
        }
        container names {
          description "Bind this SRLG name to the interface";
          list name {
            key srlg-name;
            description "Bind this SRLG name to the interface";
            leaf srlg-name {
              type string {
                length "1..64" {
                  description "SRLG Name";
                }
              }
              description "Bind this SRLG name to the interface";
            }
          }
        }
        container groups {
          presence "Indicates a groups node is configured.";
          description "Configure group srlg values";
          list group {
            key index-number;
            description "Group index number for this entry";
            leaf index-number {
              type uint32 {
                range "1" {
                  description "Group index number for this entry";
                }
              }
              description "Group index number for this entry";
            }
            leaf group-name {
              type string {
                length "1..32" {
                  description "Group name";
                }
              }
              mandatory true;
              description "Group name";
            }
          }
        }
      }
    }
    container groups {
      description "SRLG group configuration submode";
      list group {
        key group-name;
        description "SRLG group configuration submode";
        leaf group-name {
          type xr:Cisco-ios-xr-string {
            length "1..32" {
              description "Group name";
            }
          }
          description "SRLG group configuration submode";
        }
        container indexes {
          description "Index number for this value";
          list index {
            key index-number;
            description "Index number for this value";
            leaf index-number {
              type uint32 {
                range "1..65535" {
                  description "Index number for this value";
                }
              }
              description "Index number for this value";
            }
            leaf value {
              type uint32 {
                range "0..4294967295" {
                  description "Network SRLG value";
                }
              }
              mandatory true;
              description "Configure SRLG network value";
            }
            leaf priority {
              type enumeration {
                enum critical {
                  value 0;
                  description "Critical priority";
                }
                enum high {
                  value 1;
                  description "High priority";
                }
                enum default {
                  value 2;
                  description "Default priority";
                }
                enum low {
                  value 3;
                  description "Low priority";
                }
                enum verylow {
                  value 4;
                  description "Very low priority";
                }
              }
              mandatory true;
              description "Set prority for the value";
            }
          }
        }
      }
    }
    container inherit-locations {
      description "SRLG inherit-location configuration submode";
      list inherit-location {
        key location-name;
        description "SRLG inherit-location configuration submode";
        leaf location-name {
          type xr:Pq-node-id;
          description "The inherit location name";
        }
        container indexes {
          description "Index number for this value";
          list index {
            key index-number;
            description "Index number for this value";
            leaf index-number {
              type uint32 {
                range "1..65535" {
                  description "Index number for this value";
                }
              }
              description "Index number for this value";
            }
            leaf value {
              type uint32 {
                range "0..4294967295" {
                  description "Network SRLG value";
                }
              }
              mandatory true;
              description "Configure SRLG network value";
            }
            leaf priority {
              type enumeration {
                enum critical {
                  value 0;
                  description "Critical priority";
                }
                enum high {
                  value 1;
                  description "High priority";
                }
                enum default {
                  value 2;
                  description "Default priority";
                }
                enum low {
                  value 3;
                  description "Low priority";
                }
                enum verylow {
                  value 4;
                  description "Very low priority";
                }
              }
              mandatory true;
              description "Set prority for the value";
            }
          }
        }
      }
    }
  }
  container vrf-groups {
    description "VRFGROUP configuration commands";
    list vrf-group {
      key group-name;
      description "Group name";
      leaf group-name {
        type xr:Cisco-ios-xr-string {
          length "1..32" {
            description "Group name";
          }
        }
        description "Group name";
      }
      container vrfs {
        description "Enable the vrf on this vrf-group";
        list vrf {
          key vrf-name;
          description "VRF name";
          leaf vrf-name {
            type xr:Cisco-ios-xr-string {
              length "1..32" {
                description "VRF name";
              }
            }
            description "VRF name";
          }
        }
      }
    }
  }
}
""")
    res.append(r"""module cisco-semver {
    namespace "http://cisco.com/ns/yang/cisco-semver";

    prefix cisco-semver;

    organization
        "Cisco Systems
     170 West Tasman Drive
     San Jose, CA 95134-1706
     USA";

    contact
        "Mailing list: <cs-yang@cisco.com>";

    description
        "This YANG module defines semantic version for Cisco defined YANG models. 
     Copyright (c) 2019 by Cisco Systems, Inc.
     All rights reserved.";

    revision 2019-03-13 {
        description
            "Initial Version.";

        reference "draft-verdt-netmod-yang-solutions-00"; 
    }

    extension module-version {
        argument "semver";
        description
            "The version number for the module. This is
      expressed as a semantic version number of the form:
      major.minor.patch(x)  
      where:
        * major corresponds to the major version. 
        * minor corresponds to a minor version. 
        * patch corresponds to a patch version. It is updated only for 
          'editorial' changes that do not change the API semantics in 
          any way. In addition to 'editorial' changes that do not 
          change the YANG module semantics, the patch field can
          also be used in a limited way to indicate major and minor 
          version changes as well. The patch version may be incremented for
          a major or minor change if that change is happening on a 
          non-HEAD or non-latest branch. If the patch field is incremented 
          for a minor version change then it is appended with the 
          suffix '(m)', if the patch field is incremented for a major 
          version change then it is appended with the suffix '(M)', 
          replacing '(m)', if present.

      This version number should be specified as a child of revision 
      statement to indicate that a specific revision had a specific 
      semantic version number. Where several modules are used to build 
      up a single block of functionality, the same module version is 
      specified across each file that makes up the module.

      Following a release of major version 1, all modules will
      update 'major.minor.patch' version number as follows:

      1.  if one or more non-backwards-compatible change is made then
          either the major version number MUST be updated (resetting the
          minor and patch version numbers to 0) or only the patch version
          number MUST be updated and appended with '(M)', replacing '(m)'
          if present.
   
      2.  if one or more backwards-compatible change is made then either
          the minor version number MUST be updated (resetting the patch
          version numbers to 0) or only the patch version number MUST be
          updated and appended with '(m)' unless the previous patch version
          number already had '(M)' appended, in which case the '(M)' suffix
          is retained for the new patch version.
   
      3.  if one or more editorial change is made then the patch version
          number MUST be updated. If the previous patch version number
          already had either an '(m') or '(M)' suffix then it is retained
          for the new patch version regardless of whether the subsequent
          changes are backwards-compatible, non-backwards-compatible, 
          or editorial changes. 

      When a field in the version number is incremented, all following
      fields are reset back to 0.  Major version number 0 indicates that
      the module is not yet stable and allows non-backwards-compatible
      changes without requiring the major version number to be incremented
   
      Where possible, the version number should be updated using the
      standard semantic versioning rules, relying on the '(m)' and '(M)'
      suffixes only used where strictly necessary.";
    }
}
""")
    res.append(r"""module ietf-inet-types {

  namespace "urn:ietf:params:xml:ns:yang:ietf-inet-types";
  prefix "inet";

  organization
   "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
   "WG Web:   <http://tools.ietf.org/wg/netmod/>
    WG List:  <mailto:netmod@ietf.org>

    WG Chair: David Kessens
              <mailto:david.kessens@nsn.com>

    WG Chair: Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>

    Editor:   Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>";

  description
   "This module contains a collection of generally useful derived
    YANG data types for Internet addresses and related things.

    Copyright (c) 2013 IETF Trust and the persons identified as
    authors of the code.  All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, is permitted pursuant to, and subject
    to the license terms contained in, the Simplified BSD License
    set forth in Section 4.c of the IETF Trust's Legal Provisions
    Relating to IETF Documents
    (http://trustee.ietf.org/license-info).

    This version of this YANG module is part of RFC 6991; see
    the RFC itself for full legal notices.";

  revision 2013-07-15 {
    description
     "This revision adds the following new data types:
      - ip-address-no-zone
      - ipv4-address-no-zone
      - ipv6-address-no-zone";
    reference
     "RFC 6991: Common YANG Data Types";
  }

  revision 2010-09-24 {
    description
     "Initial revision.";
    reference
     "RFC 6021: Common YANG Data Types";
  }

  /*** collection of types related to protocol fields ***/

  typedef ip-version {
    type enumeration {
      enum unknown {
        value "0";
        description
         "An unknown or unspecified version of the Internet
          protocol.";
      }
      enum ipv4 {
        value "1";
        description
         "The IPv4 protocol as defined in RFC 791.";
      }
      enum ipv6 {
        value "2";
        description
         "The IPv6 protocol as defined in RFC 2460.";
      }
    }
    description
     "This value represents the version of the IP protocol.

      In the value set and its semantics, this type is equivalent
      to the InetVersion textual convention of the SMIv2.";
    reference
     "RFC  791: Internet Protocol
      RFC 2460: Internet Protocol, Version 6 (IPv6) Specification
      RFC 4001: Textual Conventions for Internet Network Addresses";
  }

  typedef dscp {
    type uint8 {
      range "0..63";
    }
    description
     "The dscp type represents a Differentiated Services Code Point
      that may be used for marking packets in a traffic stream.
      In the value set and its semantics, this type is equivalent
      to the Dscp textual convention of the SMIv2.";
    reference
     "RFC 3289: Management Information Base for the Differentiated
                Services Architecture
      RFC 2474: Definition of the Differentiated Services Field
                (DS Field) in the IPv4 and IPv6 Headers
      RFC 2780: IANA Allocation Guidelines For Values In
                the Internet Protocol and Related Headers";
  }

  typedef ipv6-flow-label {
    type uint32 {
      range "0..1048575";
    }
    description
     "The ipv6-flow-label type represents the flow identifier or Flow
      Label in an IPv6 packet header that may be used to
      discriminate traffic flows.

      In the value set and its semantics, this type is equivalent
      to the IPv6FlowLabel textual convention of the SMIv2.";
    reference
     "RFC 3595: Textual Conventions for IPv6 Flow Label
      RFC 2460: Internet Protocol, Version 6 (IPv6) Specification";
  }

  typedef port-number {
    type uint16 {
      range "0..65535";
    }
    description
     "The port-number type represents a 16-bit port number of an
      Internet transport-layer protocol such as UDP, TCP, DCCP, or
      SCTP.  Port numbers are assigned by IANA.  A current list of
      all assignments is available from <http://www.iana.org/>.

      Note that the port number value zero is reserved by IANA.  In
      situations where the value zero does not make sense, it can
      be excluded by subtyping the port-number type.
      In the value set and its semantics, this type is equivalent
      to the InetPortNumber textual convention of the SMIv2.";
    reference
     "RFC  768: User Datagram Protocol
      RFC  793: Transmission Control Protocol
      RFC 4960: Stream Control Transmission Protocol
      RFC 4340: Datagram Congestion Control Protocol (DCCP)
      RFC 4001: Textual Conventions for Internet Network Addresses";
  }

  /*** collection of types related to autonomous systems ***/

  typedef as-number {
    type uint32;
    description
     "The as-number type represents autonomous system numbers
      which identify an Autonomous System (AS).  An AS is a set
      of routers under a single technical administration, using
      an interior gateway protocol and common metrics to route
      packets within the AS, and using an exterior gateway
      protocol to route packets to other ASes.  IANA maintains
      the AS number space and has delegated large parts to the
      regional registries.

      Autonomous system numbers were originally limited to 16
      bits.  BGP extensions have enlarged the autonomous system
      number space to 32 bits.  This type therefore uses an uint32
      base type without a range restriction in order to support
      a larger autonomous system number space.

      In the value set and its semantics, this type is equivalent
      to the InetAutonomousSystemNumber textual convention of
      the SMIv2.";
    reference
     "RFC 1930: Guidelines for creation, selection, and registration
                of an Autonomous System (AS)
      RFC 4271: A Border Gateway Protocol 4 (BGP-4)
      RFC 4001: Textual Conventions for Internet Network Addresses
      RFC 6793: BGP Support for Four-Octet Autonomous System (AS)
                Number Space";
  }

  /*** collection of types related to IP addresses and hostnames ***/

  typedef ip-address {
    type union {
      type inet:ipv4-address;
      type inet:ipv6-address;
    }
    description
     "The ip-address type represents an IP address and is IP
      version neutral.  The format of the textual representation
      implies the IP version.  This type supports scoped addresses
      by allowing zone identifiers in the address format.";
    reference
     "RFC 4007: IPv6 Scoped Address Architecture";
  }

  typedef ipv4-address {
    type string {
      pattern
        '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
      +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
      + '(%[\p{N}\p{L}]+)?';
    }
    description
      "The ipv4-address type represents an IPv4 address in
       dotted-quad notation.  The IPv4 address may include a zone
       index, separated by a % sign.

       The zone index is used to disambiguate identical address
       values.  For link-local addresses, the zone index will
       typically be the interface index number or the name of an
       interface.  If the zone index is not present, the default
       zone of the device will be used.

       The canonical format for the zone index is the numerical
       format";
  }

  typedef ipv6-address {
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
            + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
            + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
            + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
            + '(%[\p{N}\p{L}]+)?';
      pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
            + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
            + '(%.+)?';
    }
    description
     "The ipv6-address type represents an IPv6 address in full,
      mixed, shortened, and shortened-mixed notation.  The IPv6
      address may include a zone index, separated by a % sign.

      The zone index is used to disambiguate identical address
      values.  For link-local addresses, the zone index will
      typically be the interface index number or the name of an
      interface.  If the zone index is not present, the default
      zone of the device will be used.

      The canonical format of IPv6 addresses uses the textual
      representation defined in Section 4 of RFC 5952.  The
      canonical format for the zone index is the numerical
      format as described in Section 11.2 of RFC 4007.";
    reference
     "RFC 4291: IP Version 6 Addressing Architecture
      RFC 4007: IPv6 Scoped Address Architecture
      RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
  }

  typedef ip-address-no-zone {
    type union {
      type inet:ipv4-address-no-zone;
      type inet:ipv6-address-no-zone;
    }
    description
     "The ip-address-no-zone type represents an IP address and is
      IP version neutral.  The format of the textual representation
      implies the IP version.  This type does not support scoped
      addresses since it does not allow zone identifiers in the
      address format.";
    reference
     "RFC 4007: IPv6 Scoped Address Architecture";
  }

  typedef ipv4-address-no-zone {
    type inet:ipv4-address {
      pattern '[0-9\.]*';
    }
    description
      "An IPv4 address without a zone index.  This type, derived from
       ipv4-address, may be used in situations where the zone is
       known from the context and hence no zone index is needed.";
  }

  typedef ipv6-address-no-zone {
    type inet:ipv6-address {
      pattern '[0-9a-fA-F:\.]*';
    }
    description
      "An IPv6 address without a zone index.  This type, derived from
       ipv6-address, may be used in situations where the zone is
       known from the context and hence no zone index is needed.";
    reference
     "RFC 4291: IP Version 6 Addressing Architecture
      RFC 4007: IPv6 Scoped Address Architecture
      RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
  }

  typedef ip-prefix {
    type union {
      type inet:ipv4-prefix;
      type inet:ipv6-prefix;
    }
    description
     "The ip-prefix type represents an IP prefix and is IP
      version neutral.  The format of the textual representations
      implies the IP version.";
  }

  typedef ipv4-prefix {
    type string {
      pattern
         '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
       +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
       + '/(([0-9])|([1-2][0-9])|(3[0-2]))';
    }
    description
     "The ipv4-prefix type represents an IPv4 address prefix.
      The prefix length is given by the number following the
      slash character and must be less than or equal to 32.

      A prefix length value of n corresponds to an IP address
      mask that has n contiguous 1-bits from the most
      significant bit (MSB) and all other bits set to 0.

      The canonical format of an IPv4 prefix has all bits of
      the IPv4 address set to zero that are not part of the
      IPv4 prefix.";
  }

  typedef ipv6-prefix {
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
            + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
            + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
            + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
            + '(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))';
      pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
            + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
            + '(/.+)';
    }
    description
     "The ipv6-prefix type represents an IPv6 address prefix.
      The prefix length is given by the number following the
      slash character and must be less than or equal to 128.

      A prefix length value of n corresponds to an IP address
      mask that has n contiguous 1-bits from the most
      significant bit (MSB) and all other bits set to 0.

      The IPv6 address should have all bits that do not belong
      to the prefix set to zero.

      The canonical format of an IPv6 prefix has all bits of
      the IPv6 address set to zero that are not part of the
      IPv6 prefix.  Furthermore, the IPv6 address is represented
      as defined in Section 4 of RFC 5952.";
    reference
     "RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
  }

  /*** collection of domain name and URI types ***/

  typedef domain-name {
    type string {
      length "1..253";
      pattern
        '((([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.)*'
      + '([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.?)'
      + '|\.';
    }
    description
     "The domain-name type represents a DNS domain name.  The
      name SHOULD be fully qualified whenever possible.

      Internet domain names are only loosely specified.  Section
      3.5 of RFC 1034 recommends a syntax (modified in Section
      2.1 of RFC 1123).  The pattern above is intended to allow
      for current practice in domain name use, and some possible
      future expansion.  It is designed to hold various types of
      domain names, including names used for A or AAAA records
      (host names) and other records, such as SRV records.  Note
      that Internet host names have a stricter syntax (described
      in RFC 952) than the DNS recommendations in RFCs 1034 and
      1123, and that systems that want to store host names in
      schema nodes using the domain-name type are recommended to
      adhere to this stricter standard to ensure interoperability.

      The encoding of DNS names in the DNS protocol is limited
      to 255 characters.  Since the encoding consists of labels
      prefixed by a length bytes and there is a trailing NULL
      byte, only 253 characters can appear in the textual dotted
      notation.

      The description clause of schema nodes using the domain-name
      type MUST describe when and how these names are resolved to
      IP addresses.  Note that the resolution of a domain-name value
      may require to query multiple DNS records (e.g., A for IPv4
      and AAAA for IPv6).  The order of the resolution process and
      which DNS record takes precedence can either be defined
      explicitly or may depend on the configuration of the
      resolver.

      Domain-name values use the US-ASCII encoding.  Their canonical
      format uses lowercase US-ASCII characters.  Internationalized
      domain names MUST be A-labels as per RFC 5890.";
    reference
     "RFC  952: DoD Internet Host Table Specification
      RFC 1034: Domain Names - Concepts and Facilities
      RFC 1123: Requirements for Internet Hosts -- Application
                and Support
      RFC 2782: A DNS RR for specifying the location of services
                (DNS SRV)
      RFC 5890: Internationalized Domain Names in Applications
                (IDNA): Definitions and Document Framework";
  }

  typedef host {
    type union {
      type inet:ip-address;
      type inet:domain-name;
    }
    description
     "The host type represents either an IP address or a DNS
      domain name.";
  }

  typedef uri {
    type string;
    description
     "The uri type represents a Uniform Resource Identifier
      (URI) as defined by STD 66.

      Objects using the uri type MUST be in US-ASCII encoding,
      and MUST be normalized as described by RFC 3986 Sections
      6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary
      percent-encoding is removed, and all case-insensitive
      characters are set to lowercase except for hexadecimal
      digits, which are normalized to uppercase as described in
      Section 6.2.2.1.

      The purpose of this normalization is to help provide
      unique URIs.  Note that this normalization is not
      sufficient to provide uniqueness.  Two URIs that are
      textually distinct after this normalization may still be
      equivalent.

      Objects using the uri type may restrict the schemes that
      they permit.  For example, 'data:' and 'urn:' schemes
      might not be appropriate.

      A zero-length URI is not a valid URI.  This can be used to
      express 'URI absent' where required.

      In the value set and its semantics, this type is equivalent
      to the Uri SMIv2 textual convention defined in RFC 5017.";
    reference
     "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax
      RFC 3305: Report from the Joint W3C/IETF URI Planning Interest
                Group: Uniform Resource Identifiers (URIs), URLs,
                and Uniform Resource Names (URNs): Clarifications
                and Recommendations
      RFC 5017: MIB Textual Conventions for Uniform Resource
                Identifiers (URIs)";
  }

}
""")
    res.append(r"""module ietf-yang-types {

  namespace "urn:ietf:params:xml:ns:yang:ietf-yang-types";
  prefix "yang";

  organization
   "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
   "WG Web:   <http://tools.ietf.org/wg/netmod/>
    WG List:  <mailto:netmod@ietf.org>

    WG Chair: David Kessens
              <mailto:david.kessens@nsn.com>

    WG Chair: Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>

    Editor:   Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>";

  description
   "This module contains a collection of generally useful derived
    YANG data types.

    Copyright (c) 2013 IETF Trust and the persons identified as
    authors of the code.  All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, is permitted pursuant to, and subject
    to the license terms contained in, the Simplified BSD License
    set forth in Section 4.c of the IETF Trust's Legal Provisions
    Relating to IETF Documents
    (http://trustee.ietf.org/license-info).

    This version of this YANG module is part of RFC 6991; see
    the RFC itself for full legal notices.";

  revision 2013-07-15 {
    description
     "This revision adds the following new data types:
      - yang-identifier
      - hex-string
      - uuid
      - dotted-quad";
    reference
     "RFC 6991: Common YANG Data Types";
  }

  revision 2010-09-24 {
    description
     "Initial revision.";
    reference
     "RFC 6021: Common YANG Data Types";
  }

  /*** collection of counter and gauge types ***/

  typedef counter32 {
    type uint32;
    description
     "The counter32 type represents a non-negative integer
      that monotonically increases until it reaches a
      maximum value of 2^32-1 (4294967295 decimal), when it
      wraps around and starts increasing again from zero.

      Counters have no defined 'initial' value, and thus, a
      single value of a counter has (in general) no information
      content.  Discontinuities in the monotonically increasing
      value normally occur at re-initialization of the
      management system, and at other times as specified in the
      description of a schema node using this type.  If such
      other times can occur, for example, the creation of
      a schema node of type counter32 at times other than
      re-initialization, then a corresponding schema node
      should be defined, with an appropriate type, to indicate
      the last discontinuity.

      The counter32 type should not be used for configuration
      schema nodes.  A default statement SHOULD NOT be used in
      combination with the type counter32.

      In the value set and its semantics, this type is equivalent
      to the Counter32 type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef zero-based-counter32 {
    type yang:counter32;
    default "0";
    description
     "The zero-based-counter32 type represents a counter32
      that has the defined 'initial' value zero.

      A schema node of this type will be set to zero (0) on creation
      and will thereafter increase monotonically until it reaches
      a maximum value of 2^32-1 (4294967295 decimal), when it
      wraps around and starts increasing again from zero.

      Provided that an application discovers a new schema node
      of this type within the minimum time to wrap, it can use the
      'initial' value as a delta.  It is important for a management
      station to be aware of this minimum time and the actual time
      between polls, and to discard data if the actual time is too
      long or there is no defined minimum time.

      In the value set and its semantics, this type is equivalent
      to the ZeroBasedCounter32 textual convention of the SMIv2.";
    reference
      "RFC 4502: Remote Network Monitoring Management Information
                 Base Version 2";
  }

  typedef counter64 {
    type uint64;
    description
     "The counter64 type represents a non-negative integer
      that monotonically increases until it reaches a
      maximum value of 2^64-1 (18446744073709551615 decimal),
      when it wraps around and starts increasing again from zero.

      Counters have no defined 'initial' value, and thus, a
      single value of a counter has (in general) no information
      content.  Discontinuities in the monotonically increasing
      value normally occur at re-initialization of the
      management system, and at other times as specified in the
      description of a schema node using this type.  If such
      other times can occur, for example, the creation of
      a schema node of type counter64 at times other than
      re-initialization, then a corresponding schema node
      should be defined, with an appropriate type, to indicate
      the last discontinuity.

      The counter64 type should not be used for configuration
      schema nodes.  A default statement SHOULD NOT be used in
      combination with the type counter64.

      In the value set and its semantics, this type is equivalent
      to the Counter64 type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef zero-based-counter64 {
    type yang:counter64;
    default "0";
    description
     "The zero-based-counter64 type represents a counter64 that
      has the defined 'initial' value zero.

      A schema node of this type will be set to zero (0) on creation
      and will thereafter increase monotonically until it reaches
      a maximum value of 2^64-1 (18446744073709551615 decimal),
      when it wraps around and starts increasing again from zero.

      Provided that an application discovers a new schema node
      of this type within the minimum time to wrap, it can use the
      'initial' value as a delta.  It is important for a management
      station to be aware of this minimum time and the actual time
      between polls, and to discard data if the actual time is too
      long or there is no defined minimum time.

      In the value set and its semantics, this type is equivalent
      to the ZeroBasedCounter64 textual convention of the SMIv2.";
    reference
     "RFC 2856: Textual Conventions for Additional High Capacity
                Data Types";
  }

  typedef gauge32 {
    type uint32;
    description
     "The gauge32 type represents a non-negative integer, which
      may increase or decrease, but shall never exceed a maximum
      value, nor fall below a minimum value.  The maximum value
      cannot be greater than 2^32-1 (4294967295 decimal), and
      the minimum value cannot be smaller than 0.  The value of
      a gauge32 has its maximum value whenever the information
      being modeled is greater than or equal to its maximum
      value, and has its minimum value whenever the information
      being modeled is smaller than or equal to its minimum value.
      If the information being modeled subsequently decreases
      below (increases above) the maximum (minimum) value, the
      gauge32 also decreases (increases).

      In the value set and its semantics, this type is equivalent
      to the Gauge32 type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef gauge64 {
    type uint64;
    description
     "The gauge64 type represents a non-negative integer, which
      may increase or decrease, but shall never exceed a maximum
      value, nor fall below a minimum value.  The maximum value
      cannot be greater than 2^64-1 (18446744073709551615), and
      the minimum value cannot be smaller than 0.  The value of
      a gauge64 has its maximum value whenever the information
      being modeled is greater than or equal to its maximum
      value, and has its minimum value whenever the information
      being modeled is smaller than or equal to its minimum value.
      If the information being modeled subsequently decreases
      below (increases above) the maximum (minimum) value, the
      gauge64 also decreases (increases).

      In the value set and its semantics, this type is equivalent
      to the CounterBasedGauge64 SMIv2 textual convention defined
      in RFC 2856";
    reference
     "RFC 2856: Textual Conventions for Additional High Capacity
                Data Types";
  }

  /*** collection of identifier-related types ***/

  typedef object-identifier {
    type string {
      pattern '(([0-1](\.[1-3]?[0-9]))|(2\.(0|([1-9]\d*))))'
            + '(\.(0|([1-9]\d*)))*';
    }
    description
     "The object-identifier type represents administratively
      assigned names in a registration-hierarchical-name tree.

      Values of this type are denoted as a sequence of numerical
      non-negative sub-identifier values.  Each sub-identifier
      value MUST NOT exceed 2^32-1 (4294967295).  Sub-identifiers
      are separated by single dots and without any intermediate
      whitespace.

      The ASN.1 standard restricts the value space of the first
      sub-identifier to 0, 1, or 2.  Furthermore, the value space
      of the second sub-identifier is restricted to the range
      0 to 39 if the first sub-identifier is 0 or 1.  Finally,
      the ASN.1 standard requires that an object identifier
      has always at least two sub-identifiers.  The pattern
      captures these restrictions.

      Although the number of sub-identifiers is not limited,
      module designers should realize that there may be
      implementations that stick with the SMIv2 limit of 128
      sub-identifiers.

      This type is a superset of the SMIv2 OBJECT IDENTIFIER type
      since it is not restricted to 128 sub-identifiers.  Hence,
      this type SHOULD NOT be used to represent the SMIv2 OBJECT
      IDENTIFIER type; the object-identifier-128 type SHOULD be
      used instead.";
    reference
     "ISO9834-1: Information technology -- Open Systems
      Interconnection -- Procedures for the operation of OSI
      Registration Authorities: General procedures and top
      arcs of the ASN.1 Object Identifier tree";
  }

  typedef object-identifier-128 {
    type object-identifier {
      pattern '\d*(\.\d*){1,127}';
    }
    description
     "This type represents object-identifiers restricted to 128
      sub-identifiers.

      In the value set and its semantics, this type is equivalent
      to the OBJECT IDENTIFIER type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef yang-identifier {
    type string {
      length "1..max";
      pattern '[a-zA-Z_][a-zA-Z0-9\-_.]*';
      pattern '.|..|[^xX].*|.[^mM].*|..[^lL].*';
    }
    description
      "A YANG identifier string as defined by the 'identifier'
       rule in Section 12 of RFC 6020.  An identifier must
       start with an alphabetic character or an underscore
       followed by an arbitrary sequence of alphabetic or
       numeric characters, underscores, hyphens, or dots.

       A YANG identifier MUST NOT start with any possible
       combination of the lowercase or uppercase character
       sequence 'xml'.";
    reference
      "RFC 6020: YANG - A Data Modeling Language for the Network
                 Configuration Protocol (NETCONF)";
  }

  /*** collection of types related to date and time***/

  typedef date-and-time {
    type string {
      pattern '\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?'
            + '(Z|[\+\-]\d{2}:\d{2})';
    }
    description
     "The date-and-time type is a profile of the ISO 8601
      standard for representation of dates and times using the
      Gregorian calendar.  The profile is defined by the
      date-time production in Section 5.6 of RFC 3339.

      The date-and-time type is compatible with the dateTime XML
      schema type with the following notable exceptions:

      (a) The date-and-time type does not allow negative years.

      (b) The date-and-time time-offset -00:00 indicates an unknown
          time zone (see RFC 3339) while -00:00 and +00:00 and Z
          all represent the same time zone in dateTime.

      (c) The canonical format (see below) of data-and-time values
          differs from the canonical format used by the dateTime XML
          schema type, which requires all times to be in UTC using
          the time-offset 'Z'.

      This type is not equivalent to the DateAndTime textual
      convention of the SMIv2 since RFC 3339 uses a different
      separator between full-date and full-time and provides
      higher resolution of time-secfrac.

      The canonical format for date-and-time values with a known time
      zone uses a numeric time zone offset that is calculated using
      the device's configured known offset to UTC time.  A change of
      the device's offset to UTC time will cause date-and-time values
      to change accordingly.  Such changes might happen periodically
      in case a server follows automatically daylight saving time
      (DST) time zone offset changes.  The canonical format for
      date-and-time values with an unknown time zone (usually
      referring to the notion of local time) uses the time-offset
      -00:00.";
    reference
     "RFC 3339: Date and Time on the Internet: Timestamps
      RFC 2579: Textual Conventions for SMIv2
      XSD-TYPES: XML Schema Part 2: Datatypes Second Edition";
  }

  typedef timeticks {
    type uint32;
    description
     "The timeticks type represents a non-negative integer that
      represents the time, modulo 2^32 (4294967296 decimal), in
      hundredths of a second between two epochs.  When a schema
      node is defined that uses this type, the description of
      the schema node identifies both of the reference epochs.

      In the value set and its semantics, this type is equivalent
      to the TimeTicks type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef timestamp {
    type yang:timeticks;
    description
     "The timestamp type represents the value of an associated
      timeticks schema node at which a specific occurrence
      happened.  The specific occurrence must be defined in the
      description of any schema node defined using this type.  When
      the specific occurrence occurred prior to the last time the
      associated timeticks attribute was zero, then the timestamp
      value is zero.  Note that this requires all timestamp values
      to be reset to zero when the value of the associated timeticks
      attribute reaches 497+ days and wraps around to zero.

      The associated timeticks schema node must be specified
      in the description of any schema node using this type.

      In the value set and its semantics, this type is equivalent
      to the TimeStamp textual convention of the SMIv2.";
    reference
     "RFC 2579: Textual Conventions for SMIv2";
  }

  /*** collection of generic address types ***/

  typedef phys-address {
    type string {
      pattern '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?';
    }

    description
     "Represents media- or physical-level addresses represented
      as a sequence octets, each octet represented by two hexadecimal
      numbers.  Octets are separated by colons.  The canonical
      representation uses lowercase characters.

      In the value set and its semantics, this type is equivalent
      to the PhysAddress textual convention of the SMIv2.";
    reference
     "RFC 2579: Textual Conventions for SMIv2";
  }

  typedef mac-address {
    type string {
      pattern '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}';
    }
    description
     "The mac-address type represents an IEEE 802 MAC address.
      The canonical representation uses lowercase characters.

      In the value set and its semantics, this type is equivalent
      to the MacAddress textual convention of the SMIv2.";
    reference
     "IEEE 802: IEEE Standard for Local and Metropolitan Area
                Networks: Overview and Architecture
      RFC 2579: Textual Conventions for SMIv2";
  }

  /*** collection of XML-specific types ***/

  typedef xpath1.0 {
    type string;
    description
     "This type represents an XPATH 1.0 expression.

      When a schema node is defined that uses this type, the
      description of the schema node MUST specify the XPath
      context in which the XPath expression is evaluated.";
    reference
     "XPATH: XML Path Language (XPath) Version 1.0";
  }

  /*** collection of string types ***/

  typedef hex-string {
    type string {
      pattern '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?';
    }
    description
     "A hexadecimal string with octets represented as hex digits
      separated by colons.  The canonical representation uses
      lowercase characters.";
  }

  typedef uuid {
    type string {
      pattern '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-'
            + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}';
    }
    description
     "A Universally Unique IDentifier in the string representation
      defined in RFC 4122.  The canonical representation uses
      lowercase characters.

      The following is an example of a UUID in string representation:
      f81d4fae-7dec-11d0-a765-00a0c91e6bf6
      ";
    reference
     "RFC 4122: A Universally Unique IDentifier (UUID) URN
                Namespace";
  }

  typedef dotted-quad {
    type string {
      pattern
        '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
      + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
    }
    description
      "An unsigned 32-bit number expressed in the dotted-quad
       notation, i.e., four octets written as decimal numbers
       and separated with the '.' (full stop) character.";
  }
}""")
    return res


NS_Cisco_IOS_XR_policy_repository_cfg = 'http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg'
NS_Cisco_IOS_XR_um_hostname_cfg = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg'
NS_Cisco_IOS_XR_um_if_ip_address_cfg = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg'
NS_Cisco_IOS_XR_um_if_vrf_cfg = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-vrf-cfg'
NS_Cisco_IOS_XR_um_interface_cfg = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
NS_Cisco_IOS_XR_um_l2_ethernet_cfg = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg'
NS_Cisco_IOS_XR_um_mpls_ldp_cfg = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
NS_Cisco_IOS_XR_um_router_bgp_cfg = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
NS_Cisco_IOS_XR_um_router_isis_cfg = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
NS_Cisco_IOS_XR_um_vrf_cfg = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'


class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv4', 'unicast'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast.copy()')


class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry(yang.adata.MNode):
    topology_name: str

    mut def __init__(self, topology_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.topology_name = topology_name

    def _get_attr(self, name: str) -> ?value:
        if name == 'topology_name':
            return self.topology_name
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv4', 'multicast', 'topologies', 'topology'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry:
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry(topology_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'topology-name')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'topology'
        self.elements = elements

    mut def create(self, topology_name):
        for e in self:
            match = True
            if e.topology_name != topology_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry(topology_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology(Iterable[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies(yang.adata.MNode):
    topology: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology

    mut def __init__(self, topology: list[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.topology = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology(elements=topology)

    def _get_attr(self, name: str) -> ?value:
        if name == 'topology':
            return iter(self.topology)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv4', 'multicast', 'topologies'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies(topology=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies__topology.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'topology'))))
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast(yang.adata.MNode):
    topologies: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies

    mut def __init__(self, topologies: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.topologies = topologies if topologies is not None else Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies()

    def _get_attr(self, name: str) -> ?value:
        if name == 'topologies':
            return self.topologies
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv4', 'multicast'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast(topologies=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast__topologies.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'topologies'))))
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4(yang.adata.MNode):
    unicast: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast
    multicast: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast

    mut def __init__(self, unicast: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast=None, multicast: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.unicast = unicast
        self.multicast = multicast if multicast is not None else Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast()

    mut def create_unicast(self):
        existing = self.unicast
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast()
        self.unicast = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'unicast':
            return self.unicast
        if name == 'multicast':
            return self.multicast
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv4'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4(unicast=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__unicast.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'unicast'))), multicast=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4__multicast.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'multicast'))))
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv6', 'unicast'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast.copy()')


class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry(yang.adata.MNode):
    topology_name: str

    mut def __init__(self, topology_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.topology_name = topology_name

    def _get_attr(self, name: str) -> ?value:
        if name == 'topology_name':
            return self.topology_name
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv6', 'multicast', 'topologies', 'topology'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry:
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry(topology_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'topology-name')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'topology'
        self.elements = elements

    mut def create(self, topology_name):
        for e in self:
            match = True
            if e.topology_name != topology_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry(topology_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology(Iterable[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies(yang.adata.MNode):
    topology: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology

    mut def __init__(self, topology: list[Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.topology = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology(elements=topology)

    def _get_attr(self, name: str) -> ?value:
        if name == 'topology':
            return iter(self.topology)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv6', 'multicast', 'topologies'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies(topology=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies__topology.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'topology'))))
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast(yang.adata.MNode):
    topologies: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies

    mut def __init__(self, topologies: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.topologies = topologies if topologies is not None else Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies()

    def _get_attr(self, name: str) -> ?value:
        if name == 'topologies':
            return self.topologies
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv6', 'multicast'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast(topologies=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast__topologies.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'topologies'))))
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6(yang.adata.MNode):
    unicast: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast
    multicast: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast

    mut def __init__(self, unicast: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast=None, multicast: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.unicast = unicast
        self.multicast = multicast if multicast is not None else Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast()

    mut def create_unicast(self):
        existing = self.unicast
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast()
        self.unicast = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'unicast':
            return self.unicast
        if name == 'multicast':
            return self.multicast
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family', 'ipv6'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6(unicast=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__unicast.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'unicast'))), multicast=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6__multicast.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'multicast'))))
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__address_family(yang.adata.MNode):
    ipv4: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4
    ipv6: Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6

    mut def __init__(self, ipv4: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4=None, ipv6: ?Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.ipv4 = ipv4 if ipv4 is not None else Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4()
        self.ipv6 = ipv6 if ipv6 is not None else Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6()

    def _get_attr(self, name: str) -> ?value:
        if name == 'ipv4':
            return self.ipv4
        if name == 'ipv6':
            return self.ipv6
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__address_family')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:address-family'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__address_family:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__address_family(ipv4=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv4.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'ipv4'))), ipv6=Cisco_IOS_XR_um_vrf_cfg__address_family__ipv6.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'ipv6'))))
        return Cisco_IOS_XR_um_vrf_cfg__address_family()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__address_family.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry(yang.adata.MNode):
    as_number: u64
    index: u64
    stitching: bool

    mut def __init__(self, as_number: u64, index: u64, stitching: bool):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index
        self.stitching = stitching

    def _get_attr(self, name: str) -> ?value:
        if name == 'as_number':
            return self.as_number
        if name == 'index':
            return self.index
        if name == 'stitching':
            return self.stitching
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import', 'route-target', 'two-byte-as-rts', 'two-byte-as-rt'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'as-number')), index=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'index')), stitching=n.get_bool(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'stitching')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'two-byte-as-rt'
        self.elements = elements

    mut def create(self, as_number, index, stitching):
        for e in self:
            match = True
            if e.as_number != as_number:
                match = False
                continue
            if e.index != index:
                match = False
                continue
            if e.stitching != stitching:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number, index, stitching)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(Iterable[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts(yang.adata.MNode):
    two_byte_as_rt: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt

    mut def __init__(self, two_byte_as_rt: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rt = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(elements=two_byte_as_rt)

    def _get_attr(self, name: str) -> ?value:
        if name == 'two_byte_as_rt':
            return iter(self.two_byte_as_rt)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import', 'route-target', 'two-byte-as-rts'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts(two_byte_as_rt=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'two-byte-as-rt'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target(yang.adata.MNode):
    two_byte_as_rts: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts

    mut def __init__(self, two_byte_as_rts: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rts = two_byte_as_rts if two_byte_as_rts is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts()

    def _get_attr(self, name: str) -> ?value:
        if name == 'two_byte_as_rts':
            return self.two_byte_as_rts
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import', 'route-target'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target(two_byte_as_rts=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target__two_byte_as_rts.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'two-byte-as-rts'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import(yang.adata.MNode):
    route_target: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target

    mut def __init__(self, route_target: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.route_target = route_target if route_target is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target()

    def _get_attr(self, name: str) -> ?value:
        if name == 'route_target':
            return self.route_target
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import(route_target=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import__route_target.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'route-target'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry(yang.adata.MNode):
    as_number: u64
    index: u64
    stitching: bool

    mut def __init__(self, as_number: u64, index: u64, stitching: bool):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index
        self.stitching = stitching

    def _get_attr(self, name: str) -> ?value:
        if name == 'as_number':
            return self.as_number
        if name == 'index':
            return self.index
        if name == 'stitching':
            return self.stitching
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export', 'route-target', 'two-byte-as-rts', 'two-byte-as-rt'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'as-number')), index=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'index')), stitching=n.get_bool(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'stitching')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'two-byte-as-rt'
        self.elements = elements

    mut def create(self, as_number, index, stitching):
        for e in self:
            match = True
            if e.as_number != as_number:
                match = False
                continue
            if e.index != index:
                match = False
                continue
            if e.stitching != stitching:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number, index, stitching)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(Iterable[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts(yang.adata.MNode):
    two_byte_as_rt: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt

    mut def __init__(self, two_byte_as_rt: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rt = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(elements=two_byte_as_rt)

    def _get_attr(self, name: str) -> ?value:
        if name == 'two_byte_as_rt':
            return iter(self.two_byte_as_rt)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export', 'route-target', 'two-byte-as-rts'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts(two_byte_as_rt=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'two-byte-as-rt'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target(yang.adata.MNode):
    two_byte_as_rts: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts

    mut def __init__(self, two_byte_as_rts: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rts = two_byte_as_rts if two_byte_as_rts is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts()

    def _get_attr(self, name: str) -> ?value:
        if name == 'two_byte_as_rts':
            return self.two_byte_as_rts
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export', 'route-target'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target(two_byte_as_rts=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target__two_byte_as_rts.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'two-byte-as-rts'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export(yang.adata.MNode):
    route_target: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target

    mut def __init__(self, route_target: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.route_target = route_target if route_target is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target()

    def _get_attr(self, name: str) -> ?value:
        if name == 'route_target':
            return self.route_target
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export(route_target=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export__route_target.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'route-target'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast(yang.adata.MNode):
    import_: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import
    export: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export

    mut def __init__(self, import_: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import=None, export: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.import_ = import_ if import_ is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import()
        self.export = export if export is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export()

    def _get_attr(self, name: str) -> ?value:
        if name == 'import_':
            return self.import_
        if name == 'export':
            return self.export
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'unicast'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast(import_=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__import.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'import'))), export=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast__export.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'export'))))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast.copy()')


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'multicast'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast.copy()')


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4', 'flowspec'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec.copy()')


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4(yang.adata.MNode):
    unicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast
    multicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast
    flowspec: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec

    mut def __init__(self, unicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast=None, multicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast=None, flowspec: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.unicast = unicast
        self.multicast = multicast
        self.flowspec = flowspec

    mut def create_unicast(self):
        existing = self.unicast
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast()
        self.unicast = res
        return res

    mut def create_multicast(self):
        existing = self.multicast
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast()
        self.multicast = res
        return res

    mut def create_flowspec(self):
        existing = self.flowspec
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec()
        self.flowspec = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'unicast':
            return self.unicast
        if name == 'multicast':
            return self.multicast
        if name == 'flowspec':
            return self.flowspec
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv4'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4(unicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'unicast'))), multicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'multicast'))), flowspec=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'flowspec'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry(yang.adata.MNode):
    as_number: u64
    index: u64
    stitching: bool

    mut def __init__(self, as_number: u64, index: u64, stitching: bool):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index
        self.stitching = stitching

    def _get_attr(self, name: str) -> ?value:
        if name == 'as_number':
            return self.as_number
        if name == 'index':
            return self.index
        if name == 'stitching':
            return self.stitching
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import', 'route-target', 'two-byte-as-rts', 'two-byte-as-rt'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'as-number')), index=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'index')), stitching=n.get_bool(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'stitching')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'two-byte-as-rt'
        self.elements = elements

    mut def create(self, as_number, index, stitching):
        for e in self:
            match = True
            if e.as_number != as_number:
                match = False
                continue
            if e.index != index:
                match = False
                continue
            if e.stitching != stitching:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number, index, stitching)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(Iterable[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts(yang.adata.MNode):
    two_byte_as_rt: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt

    mut def __init__(self, two_byte_as_rt: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rt = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt(elements=two_byte_as_rt)

    def _get_attr(self, name: str) -> ?value:
        if name == 'two_byte_as_rt':
            return iter(self.two_byte_as_rt)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import', 'route-target', 'two-byte-as-rts'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts(two_byte_as_rt=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts__two_byte_as_rt.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'two-byte-as-rt'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target(yang.adata.MNode):
    two_byte_as_rts: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts

    mut def __init__(self, two_byte_as_rts: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rts = two_byte_as_rts if two_byte_as_rts is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts()

    def _get_attr(self, name: str) -> ?value:
        if name == 'two_byte_as_rts':
            return self.two_byte_as_rts
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import', 'route-target'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target(two_byte_as_rts=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target__two_byte_as_rts.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'two-byte-as-rts'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import(yang.adata.MNode):
    route_target: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target

    mut def __init__(self, route_target: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.route_target = route_target if route_target is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target()

    def _get_attr(self, name: str) -> ?value:
        if name == 'route_target':
            return self.route_target
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:import'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import(route_target=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import__route_target.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'route-target'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry(yang.adata.MNode):
    as_number: u64
    index: u64
    stitching: bool

    mut def __init__(self, as_number: u64, index: u64, stitching: bool):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index
        self.stitching = stitching

    def _get_attr(self, name: str) -> ?value:
        if name == 'as_number':
            return self.as_number
        if name == 'index':
            return self.index
        if name == 'stitching':
            return self.stitching
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export', 'route-target', 'two-byte-as-rts', 'two-byte-as-rt'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'as-number')), index=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'index')), stitching=n.get_bool(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'stitching')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'two-byte-as-rt'
        self.elements = elements

    mut def create(self, as_number, index, stitching):
        for e in self:
            match = True
            if e.as_number != as_number:
                match = False
                continue
            if e.index != index:
                match = False
                continue
            if e.stitching != stitching:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry(as_number, index, stitching)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(Iterable[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts(yang.adata.MNode):
    two_byte_as_rt: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt

    mut def __init__(self, two_byte_as_rt: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rt = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt(elements=two_byte_as_rt)

    def _get_attr(self, name: str) -> ?value:
        if name == 'two_byte_as_rt':
            return iter(self.two_byte_as_rt)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export', 'route-target', 'two-byte-as-rts'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts(two_byte_as_rt=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts__two_byte_as_rt.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'two-byte-as-rt'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target(yang.adata.MNode):
    two_byte_as_rts: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts

    mut def __init__(self, two_byte_as_rts: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as_rts = two_byte_as_rts if two_byte_as_rts is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts()

    def _get_attr(self, name: str) -> ?value:
        if name == 'two_byte_as_rts':
            return self.two_byte_as_rts
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export', 'route-target'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target(two_byte_as_rts=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target__two_byte_as_rts.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'two-byte-as-rts'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export(yang.adata.MNode):
    route_target: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target

    mut def __init__(self, route_target: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.route_target = route_target if route_target is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target()

    def _get_attr(self, name: str) -> ?value:
        if name == 'route_target':
            return self.route_target
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast', 'Cisco-IOS-XR-um-router-bgp-cfg:export'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export(route_target=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export__route_target.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'route-target'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast(yang.adata.MNode):
    import_: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import
    export: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export

    mut def __init__(self, import_: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import=None, export: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.import_ = import_ if import_ is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import()
        self.export = export if export is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export()

    def _get_attr(self, name: str) -> ?value:
        if name == 'import_':
            return self.import_
        if name == 'export':
            return self.export
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'unicast'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast(import_=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__import.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'import'))), export=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast__export.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'export'))))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast.copy()')


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'multicast'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast.copy()')


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6', 'flowspec'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec.copy()')


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6(yang.adata.MNode):
    unicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast
    multicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast
    flowspec: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec

    mut def __init__(self, unicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast=None, multicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast=None, flowspec: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.unicast = unicast
        self.multicast = multicast
        self.flowspec = flowspec

    mut def create_unicast(self):
        existing = self.unicast
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast()
        self.unicast = res
        return res

    mut def create_multicast(self):
        existing = self.multicast
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast()
        self.multicast = res
        return res

    mut def create_flowspec(self):
        existing = self.flowspec
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec()
        self.flowspec = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'unicast':
            return self.unicast
        if name == 'multicast':
            return self.multicast
        if name == 'flowspec':
            return self.flowspec
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family', 'ipv6'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6(unicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'unicast'))), multicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'multicast'))), flowspec=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'flowspec'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family(yang.adata.MNode):
    ipv4: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4
    ipv6: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6

    mut def __init__(self, ipv4: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4=None, ipv6: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.ipv4 = ipv4 if ipv4 is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4()
        self.ipv6 = ipv6 if ipv6 is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6()

    def _get_attr(self, name: str) -> ?value:
        if name == 'ipv4':
            return self.ipv4
        if name == 'ipv6':
            return self.ipv6
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'address-family'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family(ipv4=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'ipv4'))), ipv6=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'ipv6'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'mode', 'big'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big.copy()')


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode(yang.adata.MNode):
    big: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big

    mut def __init__(self, big: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.big = big

    mut def create_big(self):
        existing = self.big
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big()
        self.big = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'big':
            return self.big
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'mode'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode(big=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode__big.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'big'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn(yang.adata.MNode):
    id: ?str

    mut def __init__(self, id: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.id = id

    def _get_attr(self, name: str) -> ?value:
        if name == 'id':
            return self.id
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'vpn'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn(id=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'id')))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'remote-route-filtering', 'disable'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable.copy()')


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering(yang.adata.MNode):
    disable: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable

    mut def __init__(self, disable: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.disable = disable

    mut def create_disable(self):
        existing = self.disable
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable()
        self.disable = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'disable':
            return self.disable
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'remote-route-filtering'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering(disable=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering__disable.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'disable'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as(yang.adata.MNode):
    as_number: ?value
    index: ?u64

    mut def __init__(self, as_number: ?value, index: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index

    def _get_attr(self, name: str) -> ?value:
        if name == 'as_number':
            return self.as_number
        if name == 'index':
            return self.index
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'Cisco-IOS-XR-um-router-bgp-cfg:rd', 'two-byte-as'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as(as_number=n.get_opt_value(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'as-number')), index=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'index')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as.copy()')


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as(yang.adata.MNode):
    as_number: ?value
    index: ?u64

    mut def __init__(self, as_number: ?value, index: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index

    def _get_attr(self, name: str) -> ?value:
        if name == 'as_number':
            return self.as_number
        if name == 'index':
            return self.index
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'Cisco-IOS-XR-um-router-bgp-cfg:rd', 'four-byte-as'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as(as_number=n.get_opt_value(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'as-number')), index=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'index')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as.copy()')


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address(yang.adata.MNode):
    ipv4_address: ?str
    index: ?u64

    mut def __init__(self, ipv4_address: ?str, index: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.ipv4_address = ipv4_address
        self.index = index

    def _get_attr(self, name: str) -> ?value:
        if name == 'ipv4_address':
            return self.ipv4_address
        if name == 'index':
            return self.index
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'Cisco-IOS-XR-um-router-bgp-cfg:rd', 'ip-address'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address(ipv4_address=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'ipv4-address')), index=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'index')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address.copy()')


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd(yang.adata.MNode):
    two_byte_as: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as
    four_byte_as: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as
    ip_address: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address

    mut def __init__(self, two_byte_as: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as=None, four_byte_as: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as=None, ip_address: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.two_byte_as = two_byte_as
        self.four_byte_as = four_byte_as
        self.ip_address = ip_address

    mut def create_two_byte_as(self, as_number, index):
        existing = self.two_byte_as
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as(as_number, index)
        self.two_byte_as = res
        return res

    mut def create_four_byte_as(self, as_number, index):
        existing = self.four_byte_as
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as(as_number, index)
        self.four_byte_as = res
        return res

    mut def create_ip_address(self, ipv4_address, index):
        existing = self.ip_address
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address(ipv4_address, index)
        self.ip_address = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'two_byte_as':
            return self.two_byte_as
        if name == 'four_byte_as':
            return self.four_byte_as
        if name == 'ip_address':
            return self.ip_address
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf', 'Cisco-IOS-XR-um-router-bgp-cfg:rd'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd(two_byte_as=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__two_byte_as.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'two-byte-as'))), four_byte_as=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__four_byte_as.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'four-byte-as'))), ip_address=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd__ip_address.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'ip-address'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry(yang.adata.MNode):
    vrf_name: str
    address_family: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family
    mode: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode
    vpn: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn
    description: ?str
    remote_route_filtering: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering
    fallback_vrf: ?str
    rd: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd

    mut def __init__(self, vrf_name: str, address_family: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family=None, mode: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode=None, vpn: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn=None, description: ?str, remote_route_filtering: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering=None, fallback_vrf: ?str, rd: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.vrf_name = vrf_name
        self.address_family = address_family if address_family is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family()
        self.mode = mode if mode is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode()
        self.vpn = vpn if vpn is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn()
        self.description = description
        self.remote_route_filtering = remote_route_filtering if remote_route_filtering is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering()
        self.fallback_vrf = fallback_vrf
        self.rd = rd if rd is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd()

    def _get_attr(self, name: str) -> ?value:
        if name == 'vrf_name':
            return self.vrf_name
        if name == 'address_family':
            return self.address_family
        if name == 'mode':
            return self.mode
        if name == 'vpn':
            return self.vpn
        if name == 'description':
            return self.description
        if name == 'remote_route_filtering':
            return self.remote_route_filtering
        if name == 'fallback_vrf':
            return self.fallback_vrf
        if name == 'rd':
            return self.rd
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs', 'vrf'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry(vrf_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'vrf-name')), address_family=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'address-family'))), mode=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__mode.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'mode'))), vpn=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'vpn'))), description=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'description')), remote_route_filtering=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__remote_route_filtering.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'remote-route-filtering'))), fallback_vrf=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'fallback-vrf')), rd=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__rd.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'rd'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'vrf'
        self.elements = elements

    mut def create(self, vrf_name):
        for e in self:
            match = True
            if e.vrf_name != vrf_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry(vrf_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(Iterable[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__vrfs(yang.adata.MNode):
    vrf: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf

    mut def __init__(self, vrf: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.vrf = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(elements=vrf)

    def _get_attr(self, name: str) -> ?value:
        if name == 'vrf':
            return iter(self.vrf)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrfs')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrfs'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs(vrf=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'vrf'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrfs.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:selective-vrf-download', 'disable'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable.copy()')


class Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download(yang.adata.MNode):
    disable: ?Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable

    mut def __init__(self, disable: ?Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.disable = disable

    mut def create_disable(self):
        existing = self.disable
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable()
        self.disable = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'disable':
            return self.disable
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:selective-vrf-download'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download(disable=Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download__disable.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'disable'))))
        return Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry(yang.adata.MNode):
    srlg_name: str
    value: ?u64
    description: ?str

    mut def __init__(self, srlg_name: str, value: ?u64, description: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.srlg_name = srlg_name
        self.value = value
        self.description = description

    def _get_attr(self, name: str) -> ?value:
        if name == 'srlg_name':
            return self.srlg_name
        if name == 'value':
            return self.value
        if name == 'description':
            return self.description
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__names__name')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'names', 'name'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry(srlg_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'srlg-name')), value=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'value')), description=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'description')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__srlg__names__name(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'name'
        self.elements = elements

    mut def create(self, srlg_name):
        for e in self:
            match = True
            if e.srlg_name != srlg_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry(srlg_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__names__name(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__names__name(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__srlg__names(yang.adata.MNode):
    name: Cisco_IOS_XR_um_vrf_cfg__srlg__names__name

    mut def __init__(self, name: list[Cisco_IOS_XR_um_vrf_cfg__srlg__names__name_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.name = Cisco_IOS_XR_um_vrf_cfg__srlg__names__name(elements=name)

    def _get_attr(self, name: str) -> ?value:
        if name == 'name':
            return iter(self.name)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__names')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'names'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__names:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__names(name=Cisco_IOS_XR_um_vrf_cfg__srlg__names__name.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'name'))))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__names()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__names.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical(yang.adata.MNode):
    priority: ?str

    mut def __init__(self, priority: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.priority = priority

    def _get_attr(self, name: str) -> ?value:
        if name == 'priority':
            return self.priority
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface', 'include-optical'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical(priority=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'priority')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical.copy()')


class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry(yang.adata.MNode):
    index_number: u64
    value: ?u64
    priority: ?str

    mut def __init__(self, index_number: u64, value: ?u64, priority: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.index_number = index_number
        self.value = value
        self.priority = priority

    def _get_attr(self, name: str) -> ?value:
        if name == 'index_number':
            return self.index_number
        if name == 'value':
            return self.value
        if name == 'priority':
            return self.priority
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface', 'indexes', 'index'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry(index_number=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'index-number')), value=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'value')), priority=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'priority')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'index'
        self.elements = elements

    mut def create(self, index_number, value, priority):
        for e in self:
            match = True
            if e.index_number != index_number:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry(index_number, value, priority)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes(yang.adata.MNode):
    index: Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index

    mut def __init__(self, index: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.index = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index(elements=index)

    def _get_attr(self, name: str) -> ?value:
        if name == 'index':
            return iter(self.index)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface', 'indexes'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes(index=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes__index.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'index'))))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry(yang.adata.MNode):
    srlg_name: str

    mut def __init__(self, srlg_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.srlg_name = srlg_name

    def _get_attr(self, name: str) -> ?value:
        if name == 'srlg_name':
            return self.srlg_name
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface', 'names', 'name'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry(srlg_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'srlg-name')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'name'
        self.elements = elements

    mut def create(self, srlg_name):
        for e in self:
            match = True
            if e.srlg_name != srlg_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry(srlg_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names(yang.adata.MNode):
    name: Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name

    mut def __init__(self, name: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.name = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name(elements=name)

    def _get_attr(self, name: str) -> ?value:
        if name == 'name':
            return iter(self.name)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface', 'names'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names(name=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names__name.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'name'))))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry(yang.adata.MNode):
    index_number: u64
    group_name: ?str

    mut def __init__(self, index_number: u64, group_name: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.index_number = index_number
        self.group_name = group_name

    def _get_attr(self, name: str) -> ?value:
        if name == 'index_number':
            return self.index_number
        if name == 'group_name':
            return self.group_name
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface', 'groups', 'group'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry(index_number=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'index-number')), group_name=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'group-name')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'group'
        self.elements = elements

    mut def create(self, index_number, group_name):
        for e in self:
            match = True
            if e.index_number != index_number:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry(index_number, group_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups(yang.adata.MNode):
    group: Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group

    mut def __init__(self, group: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.group = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group(elements=group)

    def _get_attr(self, name: str) -> ?value:
        if name == 'group':
            return iter(self.group)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface', 'groups'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups(group=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups__group.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'group'))))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups.copy()')


class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry(yang.adata.MNode):
    interface_name: str
    include_optical: ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical
    indexes: Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes
    names: Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names
    groups: ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups

    mut def __init__(self, interface_name: str, include_optical: ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical=None, indexes: ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes=None, names: ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names=None, groups: ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.interface_name = interface_name
        self.include_optical = include_optical
        self.indexes = indexes if indexes is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes()
        self.names = names if names is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names()
        self.groups = groups

    mut def create_include_optical(self):
        existing = self.include_optical
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical()
        self.include_optical = res
        return res

    mut def create_groups(self):
        existing = self.groups
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups()
        self.groups = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'interface_name':
            return self.interface_name
        if name == 'include_optical':
            return self.include_optical
        if name == 'indexes':
            return self.indexes
        if name == 'names':
            return self.names
        if name == 'groups':
            return self.groups
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces', 'interface'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry(interface_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'interface-name')), include_optical=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__include_optical.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'include-optical'))), indexes=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__indexes.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'indexes'))), names=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__names.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'names'))), groups=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface__groups.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'groups'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'interface'
        self.elements = elements

    mut def create(self, interface_name):
        for e in self:
            match = True
            if e.interface_name != interface_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry(interface_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces(yang.adata.MNode):
    interface: Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface

    mut def __init__(self, interface: list[Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.interface = Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface(elements=interface)

    def _get_attr(self, name: str) -> ?value:
        if name == 'interface':
            return iter(self.interface)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'interfaces'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces(interface=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces__interface.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'interface'))))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry(yang.adata.MNode):
    index_number: u64
    value: ?u64
    priority: ?str

    mut def __init__(self, index_number: u64, value: ?u64, priority: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.index_number = index_number
        self.value = value
        self.priority = priority

    def _get_attr(self, name: str) -> ?value:
        if name == 'index_number':
            return self.index_number
        if name == 'value':
            return self.value
        if name == 'priority':
            return self.priority
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'groups', 'group', 'indexes', 'index'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry(index_number=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'index-number')), value=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'value')), priority=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'priority')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'index'
        self.elements = elements

    mut def create(self, index_number, value, priority):
        for e in self:
            match = True
            if e.index_number != index_number:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry(index_number, value, priority)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes(yang.adata.MNode):
    index: Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index

    mut def __init__(self, index: list[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.index = Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index(elements=index)

    def _get_attr(self, name: str) -> ?value:
        if name == 'index':
            return iter(self.index)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'groups', 'group', 'indexes'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes(index=Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes__index.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'index'))))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry(yang.adata.MNode):
    group_name: str
    indexes: Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes

    mut def __init__(self, group_name: str, indexes: ?Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.group_name = group_name
        self.indexes = indexes if indexes is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes()

    def _get_attr(self, name: str) -> ?value:
        if name == 'group_name':
            return self.group_name
        if name == 'indexes':
            return self.indexes
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'groups', 'group'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry(group_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'group-name')), indexes=Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group__indexes.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'indexes'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_name):
        for e in self:
            match = True
            if e.group_name != group_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry(group_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__srlg__groups(yang.adata.MNode):
    group: Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group

    mut def __init__(self, group: list[Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.group = Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group(elements=group)

    def _get_attr(self, name: str) -> ?value:
        if name == 'group':
            return iter(self.group)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__groups')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'groups'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__groups:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__groups(group=Cisco_IOS_XR_um_vrf_cfg__srlg__groups__group.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'group'))))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__groups.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry(yang.adata.MNode):
    index_number: u64
    value: ?u64
    priority: ?str

    mut def __init__(self, index_number: u64, value: ?u64, priority: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.index_number = index_number
        self.value = value
        self.priority = priority

    def _get_attr(self, name: str) -> ?value:
        if name == 'index_number':
            return self.index_number
        if name == 'value':
            return self.value
        if name == 'priority':
            return self.priority
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'inherit-locations', 'inherit-location', 'indexes', 'index'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry(index_number=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'index-number')), value=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'value')), priority=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'priority')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'index'
        self.elements = elements

    mut def create(self, index_number, value, priority):
        for e in self:
            match = True
            if e.index_number != index_number:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry(index_number, value, priority)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes(yang.adata.MNode):
    index: Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index

    mut def __init__(self, index: list[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.index = Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index(elements=index)

    def _get_attr(self, name: str) -> ?value:
        if name == 'index':
            return iter(self.index)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'inherit-locations', 'inherit-location', 'indexes'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes(index=Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes__index.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'index'))))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry(yang.adata.MNode):
    location_name: str
    indexes: Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes

    mut def __init__(self, location_name: str, indexes: ?Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.location_name = location_name
        self.indexes = indexes if indexes is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes()

    def _get_attr(self, name: str) -> ?value:
        if name == 'location_name':
            return self.location_name
        if name == 'indexes':
            return self.indexes
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'inherit-locations', 'inherit-location'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry:
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry(location_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'location-name')), indexes=Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location__indexes.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'indexes'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'inherit-location'
        self.elements = elements

    mut def create(self, location_name):
        for e in self:
            match = True
            if e.location_name != location_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry(location_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location(Iterable[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations(yang.adata.MNode):
    inherit_location: Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location

    mut def __init__(self, inherit_location: list[Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.inherit_location = Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location(elements=inherit_location)

    def _get_attr(self, name: str) -> ?value:
        if name == 'inherit_location':
            return iter(self.inherit_location)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg', 'inherit-locations'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations(inherit_location=Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations__inherit_location.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'inherit-location'))))
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__srlg(yang.adata.MNode):
    names: Cisco_IOS_XR_um_vrf_cfg__srlg__names
    interfaces: Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces
    groups: Cisco_IOS_XR_um_vrf_cfg__srlg__groups
    inherit_locations: Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations

    mut def __init__(self, names: ?Cisco_IOS_XR_um_vrf_cfg__srlg__names=None, interfaces: ?Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces=None, groups: ?Cisco_IOS_XR_um_vrf_cfg__srlg__groups=None, inherit_locations: ?Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.names = names if names is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__names()
        self.interfaces = interfaces if interfaces is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces()
        self.groups = groups if groups is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__groups()
        self.inherit_locations = inherit_locations if inherit_locations is not None else Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations()

    def _get_attr(self, name: str) -> ?value:
        if name == 'names':
            return self.names
        if name == 'interfaces':
            return self.interfaces
        if name == 'groups':
            return self.groups
        if name == 'inherit_locations':
            return self.inherit_locations
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__srlg')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:srlg'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__srlg:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__srlg(names=Cisco_IOS_XR_um_vrf_cfg__srlg__names.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'names'))), interfaces=Cisco_IOS_XR_um_vrf_cfg__srlg__interfaces.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'interfaces'))), groups=Cisco_IOS_XR_um_vrf_cfg__srlg__groups.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'groups'))), inherit_locations=Cisco_IOS_XR_um_vrf_cfg__srlg__inherit_locations.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'inherit-locations'))))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_vrf_cfg__srlg.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_vrf_cfg__srlg.copy()')


class Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry(yang.adata.MNode):
    vrf_name: str

    mut def __init__(self, vrf_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.vrf_name = vrf_name

    def _get_attr(self, name: str) -> ?value:
        if name == 'vrf_name':
            return self.vrf_name
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrf-groups', 'vrf-group', 'vrfs', 'vrf'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry(vrf_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'vrf-name')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'vrf'
        self.elements = elements

    mut def create(self, vrf_name):
        for e in self:
            match = True
            if e.vrf_name != vrf_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry(vrf_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf(Iterable[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs(yang.adata.MNode):
    vrf: Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf

    mut def __init__(self, vrf: list[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.vrf = Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf(elements=vrf)

    def _get_attr(self, name: str) -> ?value:
        if name == 'vrf':
            return iter(self.vrf)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrf-groups', 'vrf-group', 'vrfs'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs(vrf=Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs__vrf.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'vrf'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry(yang.adata.MNode):
    group_name: str
    vrfs: Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs

    mut def __init__(self, group_name: str, vrfs: ?Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.group_name = group_name
        self.vrfs = vrfs if vrfs is not None else Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs()

    def _get_attr(self, name: str) -> ?value:
        if name == 'group_name':
            return self.group_name
        if name == 'vrfs':
            return self.vrfs
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrf-groups', 'vrf-group'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry(group_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'group-name')), vrfs=Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group__vrfs.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'vrfs'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self._name = 'vrf-group'
        self.elements = elements

    mut def create(self, group_name):
        for e in self:
            match = True
            if e.group_name != group_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry(group_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group(elements=copied_elements)

extension Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group(Iterable[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_vrf_cfg__vrf_groups(yang.adata.MNode):
    vrf_group: Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group

    mut def __init__(self, vrf_group: list[Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg'
        self.vrf_group = Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group(elements=vrf_group)

    def _get_attr(self, name: str) -> ?value:
        if name == 'vrf_group':
            return iter(self.vrf_group)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_vrf_cfg__vrf_groups')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-vrf-cfg:vrf-groups'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrf_groups:
        if n is not None:
            return Cisco_IOS_XR_um_vrf_cfg__vrf_groups(vrf_group=Cisco_IOS_XR_um_vrf_cfg__vrf_groups__vrf_group.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'vrf-group'))))
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_vrf_cfg__vrf_groups.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry(yang.adata.MNode):
    net_id: str

    mut def __init__(self, net_id: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.net_id = net_id

    def _get_attr(self, name: str) -> ?value:
        if name == 'net_id':
            return self.net_id
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'nets', 'net'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry:
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry(net_id=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'net-id')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self._name = 'net'
        self.elements = elements

    mut def create(self, net_id):
        for e in self:
            match = True
            if e.net_id != net_id:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry(net_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net(elements=copied_elements)

extension Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net(Iterable[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets(yang.adata.MNode):
    net: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net

    mut def __init__(self, net: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.net = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net(elements=net)

    def _get_attr(self, name: str) -> ?value:
        if name == 'net':
            return iter(self.net)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'nets'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets(net=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets__net.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'net'))))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls(yang.adata.MNode):
    sr_prefer: ?bool

    mut def __init__(self, sr_prefer: ?bool):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.sr_prefer = sr_prefer

    def _get_attr(self, name: str) -> ?value:
        if name == 'sr_prefer':
            return self.sr_prefer
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'segment-routing', 'mpls'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls(sr_prefer=n.get_opt_bool(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'sr-prefer')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing(yang.adata.MNode):
    mpls: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls

    mut def __init__(self, mpls: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.mpls = mpls if mpls is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls()

    def _get_attr(self, name: str) -> ?value:
        if name == 'mpls':
            return self.mpls
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'segment-routing'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing(mpls=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing__mpls.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'mpls'))))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'narrow'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow.copy()')


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'wide'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide.copy()')


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'transition'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition.copy()')


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'levels', 'level', 'narrow'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow.copy()')


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'levels', 'level', 'wide'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide.copy()')


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'levels', 'level', 'transition'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition.copy()')


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry(yang.adata.MNode):
    level_id: u64
    narrow: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow
    wide: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide
    transition: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition

    mut def __init__(self, level_id: u64, narrow: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow=None, wide: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide=None, transition: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.level_id = level_id
        self.narrow = narrow
        self.wide = wide
        self.transition = transition

    mut def create_narrow(self):
        existing = self.narrow
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow()
        self.narrow = res
        return res

    mut def create_wide(self):
        existing = self.wide
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide()
        self.wide = res
        return res

    mut def create_transition(self):
        existing = self.transition
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition()
        self.transition = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'level_id':
            return self.level_id
        if name == 'narrow':
            return self.narrow
        if name == 'wide':
            return self.wide
        if name == 'transition':
            return self.transition
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'levels', 'level'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry:
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry(level_id=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'level-id')), narrow=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__narrow.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'narrow'))), wide=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__wide.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'wide'))), transition=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level__transition.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'transition'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self._name = 'level'
        self.elements = elements

    mut def create(self, level_id):
        for e in self:
            match = True
            if e.level_id != level_id:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry(level_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level(elements=copied_elements)

extension Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level(Iterable[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels(yang.adata.MNode):
    level: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level

    mut def __init__(self, level: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.level = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level(elements=level)

    def _get_attr(self, name: str) -> ?value:
        if name == 'level':
            return iter(self.level)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style', 'levels'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels(level=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels__level.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'level'))))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style(yang.adata.MNode):
    narrow: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow
    wide: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide
    transition: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition
    levels: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels

    mut def __init__(self, narrow: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow=None, wide: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide=None, transition: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition=None, levels: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.narrow = narrow
        self.wide = wide
        self.transition = transition
        self.levels = levels if levels is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels()

    mut def create_narrow(self):
        existing = self.narrow
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow()
        self.narrow = res
        return res

    mut def create_wide(self):
        existing = self.wide
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide()
        self.wide = res
        return res

    mut def create_transition(self):
        existing = self.transition
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition()
        self.transition = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'narrow':
            return self.narrow
        if name == 'wide':
            return self.wide
        if name == 'transition':
            return self.transition
        if name == 'levels':
            return self.levels
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family', 'metric-style'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style(narrow=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__narrow.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'narrow'))), wide=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__wide.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'wide'))), transition=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__transition.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'transition'))), levels=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style__levels.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'levels'))))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry(yang.adata.MNode):
    af_name: str
    saf_name: str
    segment_routing: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing
    metric_style: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style

    mut def __init__(self, af_name: str, saf_name: str, segment_routing: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing=None, metric_style: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.af_name = af_name
        self.saf_name = saf_name
        self.segment_routing = segment_routing if segment_routing is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing()
        self.metric_style = metric_style if metric_style is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style()

    def _get_attr(self, name: str) -> ?value:
        if name == 'af_name':
            return self.af_name
        if name == 'saf_name':
            return self.saf_name
        if name == 'segment_routing':
            return self.segment_routing
        if name == 'metric_style':
            return self.metric_style
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families', 'address-family'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry:
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry(af_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'af-name')), saf_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'saf-name')), segment_routing=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__segment_routing.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'segment-routing'))), metric_style=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family__metric_style.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'metric-style'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af_name, saf_name):
        for e in self:
            match = True
            if e.af_name != af_name:
                match = False
                continue
            if e.saf_name != saf_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry(af_name, saf_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family(elements=copied_elements)

extension Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family(Iterable[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family

    mut def __init__(self, address_family: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.address_family = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family(elements=address_family)

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return iter(self.address_family)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'address-families'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families(address_family=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families__address_family.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'address-family'))))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'point-to-point'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point.copy()')


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'bfd', 'fast-detect', 'ipv4'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4.copy()')


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'bfd', 'fast-detect', 'ipv6'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6.copy()')


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect(yang.adata.MNode):
    ipv4: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4
    ipv6: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6

    mut def __init__(self, ipv4: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4=None, ipv6: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.ipv4 = ipv4
        self.ipv6 = ipv6

    mut def create_ipv4(self):
        existing = self.ipv4
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4()
        self.ipv4 = res
        return res

    mut def create_ipv6(self):
        existing = self.ipv6
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6()
        self.ipv6 = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'ipv4':
            return self.ipv4
        if name == 'ipv6':
            return self.ipv6
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'bfd', 'fast-detect'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect(ipv4=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv4.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'ipv4'))), ipv6=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect__ipv6.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'ipv6'))))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd(yang.adata.MNode):
    fast_detect: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect
    minimum_interval: ?u64
    multiplier: ?u64

    mut def __init__(self, fast_detect: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect=None, minimum_interval: ?u64, multiplier: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.fast_detect = fast_detect if fast_detect is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect()
        self.minimum_interval = minimum_interval
        self.multiplier = multiplier

    def _get_attr(self, name: str) -> ?value:
        if name == 'fast_detect':
            return self.fast_detect
        if name == 'minimum_interval':
            return self.minimum_interval
        if name == 'multiplier':
            return self.multiplier
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'bfd'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd(fast_detect=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd__fast_detect.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'fast-detect'))), minimum_interval=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'minimum-interval')), multiplier=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'multiplier')))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'passive'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive.copy()')


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'metric', 'maximum'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum.copy()')


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'metric', 'levels', 'level', 'maximum'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum.copy()')


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry(yang.adata.MNode):
    level_id: u64
    default_metric: ?u64
    maximum: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum

    mut def __init__(self, level_id: u64, default_metric: ?u64, maximum: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.level_id = level_id
        self.default_metric = default_metric
        self.maximum = maximum

    mut def create_maximum(self):
        existing = self.maximum
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum()
        self.maximum = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'level_id':
            return self.level_id
        if name == 'default_metric':
            return self.default_metric
        if name == 'maximum':
            return self.maximum
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'metric', 'levels', 'level'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry:
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry(level_id=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'level-id')), default_metric=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'default-metric')), maximum=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level__maximum.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'maximum'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self._name = 'level'
        self.elements = elements

    mut def create(self, level_id):
        for e in self:
            match = True
            if e.level_id != level_id:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry(level_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level(elements=copied_elements)

extension Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level(Iterable[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels(yang.adata.MNode):
    level: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level

    mut def __init__(self, level: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.level = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level(elements=level)

    def _get_attr(self, name: str) -> ?value:
        if name == 'level':
            return iter(self.level)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'metric', 'levels'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels(level=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels__level.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'level'))))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric(yang.adata.MNode):
    default_metric: ?u64
    maximum: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum
    levels: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels

    mut def __init__(self, default_metric: ?u64, maximum: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum=None, levels: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.default_metric = default_metric
        self.maximum = maximum
        self.levels = levels if levels is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels()

    mut def create_maximum(self):
        existing = self.maximum
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum()
        self.maximum = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'default_metric':
            return self.default_metric
        if name == 'maximum':
            return self.maximum
        if name == 'levels':
            return self.levels
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'metric'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric(default_metric=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'default-metric')), maximum=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__maximum.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'maximum'))), levels=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric__levels.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'levels'))))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index(yang.adata.MNode):
    sid_index: ?u64

    mut def __init__(self, sid_index: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.sid_index = sid_index

    def _get_attr(self, name: str) -> ?value:
        if name == 'sid_index':
            return self.sid_index
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'prefix-sid', 'sid', 'index'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index(sid_index=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'sid-index')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index.copy()')


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid(yang.adata.MNode):
    index: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index

    mut def __init__(self, index: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.index = index

    mut def create_index(self, sid_index):
        existing = self.index
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index(sid_index)
        self.index = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'index':
            return self.index
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'prefix-sid', 'sid'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid(index=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid__index.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'index'))))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid.copy()')


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid(yang.adata.MNode):
    sid: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid

    mut def __init__(self, sid: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.sid = sid

    mut def create_sid(self):
        existing = self.sid
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid()
        self.sid = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'sid':
            return self.sid
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family', 'prefix-sid'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid(sid=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid__sid.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'sid'))))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry(yang.adata.MNode):
    af_name: str
    saf_name: str
    metric: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric
    prefix_sid: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid

    mut def __init__(self, af_name: str, saf_name: str, metric: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric=None, prefix_sid: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.af_name = af_name
        self.saf_name = saf_name
        self.metric = metric if metric is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric()
        self.prefix_sid = prefix_sid if prefix_sid is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid()

    def _get_attr(self, name: str) -> ?value:
        if name == 'af_name':
            return self.af_name
        if name == 'saf_name':
            return self.saf_name
        if name == 'metric':
            return self.metric
        if name == 'prefix_sid':
            return self.prefix_sid
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families', 'address-family'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry:
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry(af_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'af-name')), saf_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'saf-name')), metric=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__metric.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'metric'))), prefix_sid=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family__prefix_sid.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'prefix-sid'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af_name, saf_name):
        for e in self:
            match = True
            if e.af_name != af_name:
                match = False
                continue
            if e.saf_name != saf_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry(af_name, saf_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family(elements=copied_elements)

extension Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family(Iterable[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family

    mut def __init__(self, address_family: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.address_family = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family(elements=address_family)

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return iter(self.address_family)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface', 'address-families'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families(address_family=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families__address_family.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'address-family'))))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry(yang.adata.MNode):
    interface_name: str
    circuit_type: ?str
    point_to_point: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point
    bfd: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd
    passive: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive
    address_families: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families

    mut def __init__(self, interface_name: str, circuit_type: ?str, point_to_point: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point=None, bfd: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd=None, passive: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive=None, address_families: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.interface_name = interface_name
        self.circuit_type = circuit_type
        self.point_to_point = point_to_point
        self.bfd = bfd if bfd is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd()
        self.passive = passive
        self.address_families = address_families if address_families is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families()

    mut def create_point_to_point(self):
        existing = self.point_to_point
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point()
        self.point_to_point = res
        return res

    mut def create_passive(self):
        existing = self.passive
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive()
        self.passive = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'interface_name':
            return self.interface_name
        if name == 'circuit_type':
            return self.circuit_type
        if name == 'point_to_point':
            return self.point_to_point
        if name == 'bfd':
            return self.bfd
        if name == 'passive':
            return self.passive
        if name == 'address_families':
            return self.address_families
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces', 'interface'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry:
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry(interface_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'interface-name')), circuit_type=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'circuit-type')), point_to_point=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__point_to_point.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'point-to-point'))), bfd=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__bfd.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'bfd'))), passive=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__passive.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'passive'))), address_families=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface__address_families.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'address-families'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self._name = 'interface'
        self.elements = elements

    mut def create(self, interface_name):
        for e in self:
            match = True
            if e.interface_name != interface_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry(interface_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface(elements=copied_elements)

extension Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface(Iterable[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces(yang.adata.MNode):
    interface: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface

    mut def __init__(self, interface: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.interface = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface(elements=interface)

    def _get_attr(self, name: str) -> ?value:
        if name == 'interface':
            return iter(self.interface)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process', 'interfaces'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces(interface=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces__interface.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'interface'))))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry(yang.adata.MNode):
    process_id: str
    is_type: ?str
    nets: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets
    address_families: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families
    interfaces: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces

    mut def __init__(self, process_id: str, is_type: ?str, nets: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets=None, address_families: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families=None, interfaces: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.process_id = process_id
        self.is_type = is_type
        self.nets = nets if nets is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets()
        self.address_families = address_families if address_families is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families()
        self.interfaces = interfaces if interfaces is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces()

    def _get_attr(self, name: str) -> ?value:
        if name == 'process_id':
            return self.process_id
        if name == 'is_type':
            return self.is_type
        if name == 'nets':
            return self.nets
        if name == 'address_families':
            return self.address_families
        if name == 'interfaces':
            return self.interfaces
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes', 'process'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry:
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry(process_id=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'process-id')), is_type=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'is-type')), nets=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__nets.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'nets'))), address_families=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__address_families.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'address-families'))), interfaces=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process__interfaces.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'interfaces'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self._name = 'process'
        self.elements = elements

    mut def create(self, process_id):
        for e in self:
            match = True
            if e.process_id != process_id:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry(process_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process(elements=copied_elements)

extension Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process(Iterable[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes(yang.adata.MNode):
    process: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process

    mut def __init__(self, process: list[Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.process = Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process(elements=process)

    def _get_attr(self, name: str) -> ?value:
        if name == 'process':
            return iter(self.process)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis', 'processes'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes(process=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes__process.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'process'))))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis(yang.adata.MNode):
    processes: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes

    mut def __init__(self, processes: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.processes = processes if processes is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes()

    def _get_attr(self, name: str) -> ?value:
        if name == 'processes':
            return self.processes
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router', 'isis'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis(processes=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis__processes.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'processes'))))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router(yang.adata.MNode):
    isis: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis

    mut def __init__(self, isis: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg'
        self.isis = isis if isis is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis()

    def _get_attr(self, name: str) -> ?value:
        if name == 'isis':
            return self.isis
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-isis-cfg:router'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router:
        if n is not None:
            return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router(isis=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router__isis.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'isis'))))
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:as-format', 'asdot'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:as-format', 'asplain'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__as_format(yang.adata.MNode):
    asdot: ?Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot
    asplain: ?Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain

    mut def __init__(self, asdot: ?Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot=None, asplain: ?Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.asdot = asdot
        self.asplain = asplain

    mut def create_asdot(self):
        existing = self.asdot
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot()
        self.asdot = res
        return res

    mut def create_asplain(self):
        existing = self.asplain
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain()
        self.asplain = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'asdot':
            return self.asdot
        if name == 'asplain':
            return self.asplain
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__as_format')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:as-format'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__as_format:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__as_format(asdot=Cisco_IOS_XR_um_router_bgp_cfg__as_format__asdot.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'asdot'))), asplain=Cisco_IOS_XR_um_router_bgp_cfg__as_format__asplain.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'asplain'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__as_format()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__as_format.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'server', 'shutdown'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host(yang.adata.MNode):
    host_name: ?str
    port: ?u64

    mut def __init__(self, host_name: ?str, port: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.host_name = host_name
        self.port = port

    def _get_attr(self, name: str) -> ?value:
        if name == 'host_name':
            return self.host_name
        if name == 'port':
            return self.port
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'server', 'host'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host(host_name=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'host-name')), port=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'port')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay(yang.adata.MNode):
    initial_delay: ?u64
    spread: ?u64

    mut def __init__(self, initial_delay: ?u64, spread: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.initial_delay = initial_delay
        self.spread = spread

    def _get_attr(self, name: str) -> ?value:
        if name == 'initial_delay':
            return self.initial_delay
        if name == 'spread':
            return self.spread
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'server', 'initial-refresh', 'delay'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay(initial_delay=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'initial-delay')), spread=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'spread')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'server', 'initial-refresh', 'skip'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh(yang.adata.MNode):
    delay: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay
    skip: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip

    mut def __init__(self, delay: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay=None, skip: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.delay = delay
        self.skip = skip

    mut def create_delay(self, initial_delay):
        existing = self.delay
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay(initial_delay)
        self.delay = res
        return res

    mut def create_skip(self):
        existing = self.skip
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip()
        self.skip = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'delay':
            return self.delay
        if name == 'skip':
            return self.skip
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'server', 'initial-refresh'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh(delay=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__delay.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'delay'))), skip=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh__skip.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'skip'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp(yang.adata.MNode):
    keep_alive: ?u64
    mss: ?u64

    mut def __init__(self, keep_alive: ?u64, mss: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.keep_alive = keep_alive
        self.mss = mss

    def _get_attr(self, name: str) -> ?value:
        if name == 'keep_alive':
            return self.keep_alive
        if name == 'mss':
            return self.mss
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'server', 'tcp'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp(keep_alive=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'keep-alive')), mss=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'mss')))
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry(yang.adata.MNode):
    bmp_server_id: u64
    shutdown: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown
    host: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host
    initial_delay: ?u64
    flapping_delay: ?u64
    max_buffer_size: ?u64
    initial_refresh: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh
    stats_reporting_period: ?u64
    description: ?str
    dscp: ?str
    precedence: ?str
    update_source: ?str
    vrf: ?str
    tcp: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp

    mut def __init__(self, bmp_server_id: u64, shutdown: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown=None, host: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host=None, initial_delay: ?u64, flapping_delay: ?u64, max_buffer_size: ?u64, initial_refresh: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh=None, stats_reporting_period: ?u64, description: ?str, dscp: ?str, precedence: ?str, update_source: ?str, vrf: ?str, tcp: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.bmp_server_id = bmp_server_id
        self.shutdown = shutdown
        self.host = host
        self.initial_delay = initial_delay
        self.flapping_delay = flapping_delay
        self.max_buffer_size = max_buffer_size
        self.initial_refresh = initial_refresh if initial_refresh is not None else Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh()
        self.stats_reporting_period = stats_reporting_period
        self.description = description
        self.dscp = dscp
        self.precedence = precedence
        self.update_source = update_source
        self.vrf = vrf
        self.tcp = tcp if tcp is not None else Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp()

    mut def create_shutdown(self):
        existing = self.shutdown
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown()
        self.shutdown = res
        return res

    mut def create_host(self, host_name):
        existing = self.host
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host(host_name)
        self.host = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'bmp_server_id':
            return self.bmp_server_id
        if name == 'shutdown':
            return self.shutdown
        if name == 'host':
            return self.host
        if name == 'initial_delay':
            return self.initial_delay
        if name == 'flapping_delay':
            return self.flapping_delay
        if name == 'max_buffer_size':
            return self.max_buffer_size
        if name == 'initial_refresh':
            return self.initial_refresh
        if name == 'stats_reporting_period':
            return self.stats_reporting_period
        if name == 'description':
            return self.description
        if name == 'dscp':
            return self.dscp
        if name == 'precedence':
            return self.precedence
        if name == 'update_source':
            return self.update_source
        if name == 'vrf':
            return self.vrf
        if name == 'tcp':
            return self.tcp
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'server'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry(bmp_server_id=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'bmp-server-id')), shutdown=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__shutdown.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'shutdown'))), host=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__host.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'host'))), initial_delay=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'initial-delay')), flapping_delay=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'flapping-delay')), max_buffer_size=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'max-buffer-size')), initial_refresh=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__initial_refresh.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'initial-refresh'))), stats_reporting_period=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'stats-reporting-period')), description=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'description')), dscp=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'dscp')), precedence=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'precedence')), update_source=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'update-source')), vrf=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'vrf')), tcp=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server__tcp.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'tcp'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'server'
        self.elements = elements

    mut def create(self, bmp_server_id):
        for e in self:
            match = True
            if e.bmp_server_id != bmp_server_id:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry(bmp_server_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry(yang.adata.MNode):
    mode_name: str
    advertisement_interval: ?u64
    scan_time: ?u64

    mut def __init__(self, mode_name: str, advertisement_interval: ?u64, scan_time: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.mode_name = mode_name
        self.advertisement_interval = advertisement_interval
        self.scan_time = scan_time

    def _get_attr(self, name: str) -> ?value:
        if name == 'mode_name':
            return self.mode_name
        if name == 'advertisement_interval':
            return self.advertisement_interval
        if name == 'scan_time':
            return self.scan_time
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'all', 'route-monitoring', 'bmp-modes', 'bmp-mode'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry(mode_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'mode-name')), advertisement_interval=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'advertisement-interval')), scan_time=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'scan-time')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'bmp-mode'
        self.elements = elements

    mut def create(self, mode_name):
        for e in self:
            match = True
            if e.mode_name != mode_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry(mode_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes(yang.adata.MNode):
    bmp_mode: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode

    mut def __init__(self, bmp_mode: list[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.bmp_mode = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode(elements=bmp_mode)

    def _get_attr(self, name: str) -> ?value:
        if name == 'bmp_mode':
            return iter(self.bmp_mode)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'all', 'route-monitoring', 'bmp-modes'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes(bmp_mode=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes__bmp_mode.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'bmp-mode'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring(yang.adata.MNode):
    bmp_modes: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes

    mut def __init__(self, bmp_modes: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.bmp_modes = bmp_modes if bmp_modes is not None else Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes()

    def _get_attr(self, name: str) -> ?value:
        if name == 'bmp_modes':
            return self.bmp_modes
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'all', 'route-monitoring'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring(bmp_modes=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring__bmp_modes.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'bmp-modes'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all(yang.adata.MNode):
    max_buffer_size: ?u64
    route_monitoring: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring

    mut def __init__(self, max_buffer_size: ?u64, route_monitoring: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.max_buffer_size = max_buffer_size
        self.route_monitoring = route_monitoring if route_monitoring is not None else Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring()

    def _get_attr(self, name: str) -> ?value:
        if name == 'max_buffer_size':
            return self.max_buffer_size
        if name == 'route_monitoring':
            return self.route_monitoring
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers', 'all'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all(max_buffer_size=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'max-buffer-size')), route_monitoring=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all__route_monitoring.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'route-monitoring'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers(yang.adata.MNode):
    server: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server
    all: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all

    mut def __init__(self, server: list[Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server_entry]=[], all: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.server = Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server(elements=server)
        self.all = all if all is not None else Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all()

    def _get_attr(self, name: str) -> ?value:
        if name == 'server':
            return iter(self.server)
        if name == 'all':
            return self.all
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp', 'servers'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers(server=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__server.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'server'))), all=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers__all.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'all'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__bmp(yang.adata.MNode):
    servers: Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers

    mut def __init__(self, servers: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.servers = servers if servers is not None else Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers()

    def _get_attr(self, name: str) -> ?value:
        if name == 'servers':
            return self.servers
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__bmp')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:bmp'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__bmp:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__bmp(servers=Cisco_IOS_XR_um_router_bgp_cfg__bmp__servers.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'servers'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__bmp.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface(yang.adata.MNode):
    interface_name: ?str

    mut def __init__(self, interface_name: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.interface_name = interface_name

    def _get_attr(self, name: str) -> ?value:
        if name == 'interface_name':
            return self.interface_name
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'bind-source', 'interface'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface(interface_name=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'interface-name')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source(yang.adata.MNode):
    interface: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface

    mut def __init__(self, interface: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.interface = interface if interface is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface()

    def _get_attr(self, name: str) -> ?value:
        if name == 'interface':
            return self.interface
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'bind-source'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source(interface=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source__interface.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'interface'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'refresh-time', 'off'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time(yang.adata.MNode):
    refresh_time_value: ?u64
    off: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off

    mut def __init__(self, refresh_time_value: ?u64, off: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.refresh_time_value = refresh_time_value
        self.off = off

    mut def create_off(self):
        existing = self.off
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off()
        self.off = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'refresh_time_value':
            return self.refresh_time_value
        if name == 'off':
            return self.off
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'refresh-time'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time(refresh_time_value=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'refresh-time-value')), off=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time__off.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'off'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'response-time', 'off'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time(yang.adata.MNode):
    response_time_value: ?u64
    off: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off

    mut def __init__(self, response_time_value: ?u64, off: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.response_time_value = response_time_value
        self.off = off

    mut def create_off(self):
        existing = self.off
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off()
        self.off = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'response_time_value':
            return self.response_time_value
        if name == 'off':
            return self.off
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'response-time'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time(response_time_value=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'response-time-value')), off=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time__off.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'off'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp(yang.adata.MNode):
    port: ?u64

    mut def __init__(self, port: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.port = port

    def _get_attr(self, name: str) -> ?value:
        if name == 'port':
            return self.port
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'transport', 'tcp'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp(port=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'port')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh(yang.adata.MNode):
    port: ?u64

    mut def __init__(self, port: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.port = port

    def _get_attr(self, name: str) -> ?value:
        if name == 'port':
            return self.port
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'transport', 'ssh'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh(port=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'port')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport(yang.adata.MNode):
    tcp: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp
    ssh: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh

    mut def __init__(self, tcp: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp=None, ssh: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.tcp = tcp if tcp is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp()
        self.ssh = ssh if ssh is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh()

    def _get_attr(self, name: str) -> ?value:
        if name == 'tcp':
            return self.tcp
        if name == 'ssh':
            return self.ssh
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'transport'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport(tcp=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__tcp.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'tcp'))), ssh=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport__ssh.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'ssh'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server', 'shutdown'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry(yang.adata.MNode):
    server_id: str
    bind_source: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source
    preference: ?u64
    refresh_time: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time
    response_time: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time
    purge_time: ?u64
    username: ?str
    password: ?str
    transport: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport
    shutdown: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown

    mut def __init__(self, server_id: str, bind_source: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source=None, preference: ?u64, refresh_time: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time=None, response_time: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time=None, purge_time: ?u64, username: ?str, password: ?str, transport: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport=None, shutdown: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.server_id = server_id
        self.bind_source = bind_source if bind_source is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source()
        self.preference = preference
        self.refresh_time = refresh_time if refresh_time is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time()
        self.response_time = response_time if response_time is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time()
        self.purge_time = purge_time
        self.username = username
        self.password = password
        self.transport = transport if transport is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport()
        self.shutdown = shutdown

    mut def create_shutdown(self):
        existing = self.shutdown
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown()
        self.shutdown = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'server_id':
            return self.server_id
        if name == 'bind_source':
            return self.bind_source
        if name == 'preference':
            return self.preference
        if name == 'refresh_time':
            return self.refresh_time
        if name == 'response_time':
            return self.response_time
        if name == 'purge_time':
            return self.purge_time
        if name == 'username':
            return self.username
        if name == 'password':
            return self.password
        if name == 'transport':
            return self.transport
        if name == 'shutdown':
            return self.shutdown
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers', 'server'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry(server_id=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'server-id')), bind_source=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__bind_source.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'bind-source'))), preference=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'preference')), refresh_time=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__refresh_time.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'refresh-time'))), response_time=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__response_time.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'response-time'))), purge_time=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'purge-time')), username=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'username')), password=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'password')), transport=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__transport.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'transport'))), shutdown=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server__shutdown.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'shutdown'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'server'
        self.elements = elements

    mut def create(self, server_id):
        for e in self:
            match = True
            if e.server_id != server_id:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry(server_id)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers(yang.adata.MNode):
    server: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server

    mut def __init__(self, server: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.server = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server(elements=server)

    def _get_attr(self, name: str) -> ?value:
        if name == 'server':
            return iter(self.server)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'servers'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers(server=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers__server.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'server'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry(yang.adata.MNode):
    address: str
    minimum_prefix_length: u64
    maximum_prefix_length: u64
    origin_as_number: u64

    mut def __init__(self, address: str, minimum_prefix_length: u64, maximum_prefix_length: u64, origin_as_number: u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.address = address
        self.minimum_prefix_length = minimum_prefix_length
        self.maximum_prefix_length = maximum_prefix_length
        self.origin_as_number = origin_as_number

    def _get_attr(self, name: str) -> ?value:
        if name == 'address':
            return self.address
        if name == 'minimum_prefix_length':
            return self.minimum_prefix_length
        if name == 'maximum_prefix_length':
            return self.maximum_prefix_length
        if name == 'origin_as_number':
            return self.origin_as_number
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'routes', 'route'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry(address=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'address')), minimum_prefix_length=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'minimum-prefix-length')), maximum_prefix_length=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'maximum-prefix-length')), origin_as_number=n.get_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'origin-as-number')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'route'
        self.elements = elements

    mut def create(self, address, minimum_prefix_length, maximum_prefix_length, origin_as_number):
        for e in self:
            match = True
            if e.address != address:
                match = False
                continue
            if e.minimum_prefix_length != minimum_prefix_length:
                match = False
                continue
            if e.maximum_prefix_length != maximum_prefix_length:
                match = False
                continue
            if e.origin_as_number != origin_as_number:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry(address, minimum_prefix_length, maximum_prefix_length, origin_as_number)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes(yang.adata.MNode):
    route: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route

    mut def __init__(self, route: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.route = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route(elements=route)

    def _get_attr(self, name: str) -> ?value:
        if name == 'route':
            return iter(self.route)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki', 'routes'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes(route=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes__route.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'route'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki(yang.adata.MNode):
    servers: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers
    routes: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes
    datafile: ?str

    mut def __init__(self, servers: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers=None, routes: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes=None, datafile: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.servers = servers if servers is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers()
        self.routes = routes if routes is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes()
        self.datafile = datafile

    def _get_attr(self, name: str) -> ?value:
        if name == 'servers':
            return self.servers
        if name == 'routes':
            return self.routes
        if name == 'datafile':
            return self.datafile
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'rpki'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki(servers=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__servers.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'servers'))), routes=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki__routes.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'routes'))), datafile=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'datafile')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry(yang.adata.MNode):
    af_name: str

    mut def __init__(self, af_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.af_name = af_name

    def _get_attr(self, name: str) -> ?value:
        if name == 'af_name':
            return self.af_name
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'address-families', 'address-family'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry(af_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'af-name')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af_name):
        for e in self:
            match = True
            if e.af_name != af_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry(af_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family

    mut def __init__(self, address_family: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.address_family = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family(elements=address_family)

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return iter(self.address_family)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'address-families'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families(address_family=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families__address_family.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'address-family'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use(yang.adata.MNode):
    session_group: ?str
    neighbor_group: ?str

    mut def __init__(self, session_group: ?str, neighbor_group: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.session_group = session_group
        self.neighbor_group = neighbor_group

    def _get_attr(self, name: str) -> ?value:
        if name == 'session_group':
            return self.session_group
        if name == 'neighbor_group':
            return self.neighbor_group
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbors', 'neighbor', 'use'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use(session_group=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'session-group')), neighbor_group=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'neighbor-group')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry(yang.adata.MNode):
    neighbor_address: str
    use: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use
    description: ?str

    mut def __init__(self, neighbor_address: str, use: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use=None, description: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.neighbor_address = neighbor_address
        self.use = use if use is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use()
        self.description = description

    def _get_attr(self, name: str) -> ?value:
        if name == 'neighbor_address':
            return self.neighbor_address
        if name == 'use':
            return self.use
        if name == 'description':
            return self.description
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbors', 'neighbor'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry(neighbor_address=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'neighbor-address')), use=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor__use.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'use'))), description=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'description')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'neighbor'
        self.elements = elements

    mut def create(self, neighbor_address):
        for e in self:
            match = True
            if e.neighbor_address != neighbor_address:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry(neighbor_address)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors(yang.adata.MNode):
    neighbor: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor

    mut def __init__(self, neighbor: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.neighbor = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor(elements=neighbor)

    def _get_attr(self, name: str) -> ?value:
        if name == 'neighbor':
            return iter(self.neighbor)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbors'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors(neighbor=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors__neighbor.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'neighbor'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry(yang.adata.MNode):
    af_name: str

    mut def __init__(self, af_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.af_name = af_name

    def _get_attr(self, name: str) -> ?value:
        if name == 'af_name':
            return self.af_name
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbor-groups', 'neighbor-group', 'address-families', 'address-family'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry(af_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'af-name')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af_name):
        for e in self:
            match = True
            if e.af_name != af_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry(af_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family

    mut def __init__(self, address_family: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.address_family = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family(elements=address_family)

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return iter(self.address_family)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbor-groups', 'neighbor-group', 'address-families'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families(address_family=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families__address_family.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'address-family'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbor-groups', 'neighbor-group', 'password', 'inheritance-disable'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password(yang.adata.MNode):
    encrypted: ?str
    inheritance_disable: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable

    mut def __init__(self, encrypted: ?str, inheritance_disable: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.encrypted = encrypted
        self.inheritance_disable = inheritance_disable

    mut def create_inheritance_disable(self):
        existing = self.inheritance_disable
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable()
        self.inheritance_disable = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'encrypted':
            return self.encrypted
        if name == 'inheritance_disable':
            return self.inheritance_disable
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbor-groups', 'neighbor-group', 'password'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password(encrypted=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'encrypted')), inheritance_disable=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password__inheritance_disable.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'inheritance-disable'))))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry(yang.adata.MNode):
    neighbor_group_name: str
    address_families: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families
    remote_as: ?value
    description: ?str
    password: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password
    update_source: ?str

    mut def __init__(self, neighbor_group_name: str, address_families: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families=None, remote_as: ?value, description: ?str, password: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password=None, update_source: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.neighbor_group_name = neighbor_group_name
        self.address_families = address_families if address_families is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families()
        self.remote_as = remote_as
        self.description = description
        self.password = password
        self.update_source = update_source

    mut def create_password(self):
        existing = self.password
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password()
        self.password = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'neighbor_group_name':
            return self.neighbor_group_name
        if name == 'address_families':
            return self.address_families
        if name == 'remote_as':
            return self.remote_as
        if name == 'description':
            return self.description
        if name == 'password':
            return self.password
        if name == 'update_source':
            return self.update_source
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbor-groups', 'neighbor-group'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry(neighbor_group_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'neighbor-group-name')), address_families=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__address_families.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'address-families'))), remote_as=n.get_opt_value(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'remote-as')), description=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'description')), password=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group__password.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'password'))), update_source=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'update-source')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'neighbor-group'
        self.elements = elements

    mut def create(self, neighbor_group_name):
        for e in self:
            match = True
            if e.neighbor_group_name != neighbor_group_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry(neighbor_group_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups(yang.adata.MNode):
    neighbor_group: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group

    mut def __init__(self, neighbor_group: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.neighbor_group = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group(elements=neighbor_group)

    def _get_attr(self, name: str) -> ?value:
        if name == 'neighbor_group':
            return iter(self.neighbor_group)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'neighbor-groups'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups(neighbor_group=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups__neighbor_group.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'neighbor-group'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp(yang.adata.MNode):
    router_id: ?str

    mut def __init__(self, router_id: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.router_id = router_id

    def _get_attr(self, name: str) -> ?value:
        if name == 'router_id':
            return self.router_id
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'bgp'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp(router_id=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'router-id')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry(yang.adata.MNode):
    af_name: str

    mut def __init__(self, af_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.af_name = af_name

    def _get_attr(self, name: str) -> ?value:
        if name == 'af_name':
            return self.af_name
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'address-families', 'address-family'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry(af_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'af-name')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af_name):
        for e in self:
            match = True
            if e.af_name != af_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry(af_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family

    mut def __init__(self, address_family: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.address_family = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family(elements=address_family)

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return iter(self.address_family)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'address-families'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families(address_family=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families__address_family.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'address-family'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention(yang.adata.MNode):
    route_policy_name: ?str
    retention_time: ?u64

    mut def __init__(self, route_policy_name: ?str, retention_time: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.route_policy_name = route_policy_name
        self.retention_time = retention_time

    def _get_attr(self, name: str) -> ?value:
        if name == 'route_policy_name':
            return self.route_policy_name
        if name == 'retention_time':
            return self.retention_time
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'address-families', 'address-family', 'route-policy', 'retention'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention(route_policy_name=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'route-policy-name')), retention_time=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'retention-time')))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy(yang.adata.MNode):
    in_: ?str
    out: ?str
    retention: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention

    mut def __init__(self, in_: ?str, out: ?str, retention: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.in_ = in_
        self.out = out
        self.retention = retention if retention is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention()

    def _get_attr(self, name: str) -> ?value:
        if name == 'in_':
            return self.in_
        if name == 'out':
            return self.out
        if name == 'retention':
            return self.retention
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'address-families', 'address-family', 'route-policy'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy(in_=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'in')), out=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'out')), retention=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy__retention.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'retention'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'address-families', 'address-family', 'as-override', 'inheritance-disable'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override(yang.adata.MNode):
    inheritance_disable: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable

    mut def __init__(self, inheritance_disable: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.inheritance_disable = inheritance_disable

    mut def create_inheritance_disable(self):
        existing = self.inheritance_disable
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable()
        self.inheritance_disable = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'inheritance_disable':
            return self.inheritance_disable
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'address-families', 'address-family', 'as-override'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override(inheritance_disable=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override__inheritance_disable.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'inheritance-disable'))))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry(yang.adata.MNode):
    af_name: str
    route_policy: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy
    as_override: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override

    mut def __init__(self, af_name: str, route_policy: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy=None, as_override: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.af_name = af_name
        self.route_policy = route_policy if route_policy is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy()
        self.as_override = as_override

    mut def create_as_override(self):
        existing = self.as_override
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override()
        self.as_override = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'af_name':
            return self.af_name
        if name == 'route_policy':
            return self.route_policy
        if name == 'as_override':
            return self.as_override
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'address-families', 'address-family'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry(af_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'af-name')), route_policy=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__route_policy.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'route-policy'))), as_override=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family__as_override.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'as-override'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af_name):
        for e in self:
            match = True
            if e.af_name != af_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry(af_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family

    mut def __init__(self, address_family: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.address_family = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family(elements=address_family)

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return iter(self.address_family)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'address-families'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families(address_family=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families__address_family.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'address-family'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'password', 'inheritance-disable'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password(yang.adata.MNode):
    encrypted: ?str
    inheritance_disable: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable

    mut def __init__(self, encrypted: ?str, inheritance_disable: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.encrypted = encrypted
        self.inheritance_disable = inheritance_disable

    mut def create_inheritance_disable(self):
        existing = self.inheritance_disable
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable()
        self.inheritance_disable = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'encrypted':
            return self.encrypted
        if name == 'inheritance_disable':
            return self.inheritance_disable
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor', 'password'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password(encrypted=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'encrypted')), inheritance_disable=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password__inheritance_disable.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'inheritance-disable'))))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry(yang.adata.MNode):
    neighbor_address: str
    address_families: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families
    remote_as: ?value
    description: ?str
    password: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password

    mut def __init__(self, neighbor_address: str, address_families: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families=None, remote_as: ?value, description: ?str, password: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.neighbor_address = neighbor_address
        self.address_families = address_families if address_families is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families()
        self.remote_as = remote_as
        self.description = description
        self.password = password

    mut def create_password(self):
        existing = self.password
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password()
        self.password = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'neighbor_address':
            return self.neighbor_address
        if name == 'address_families':
            return self.address_families
        if name == 'remote_as':
            return self.remote_as
        if name == 'description':
            return self.description
        if name == 'password':
            return self.password
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors', 'neighbor'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry(neighbor_address=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'neighbor-address')), address_families=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__address_families.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'address-families'))), remote_as=n.get_opt_value(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'remote-as')), description=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'description')), password=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor__password.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'password'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'neighbor'
        self.elements = elements

    mut def create(self, neighbor_address):
        for e in self:
            match = True
            if e.neighbor_address != neighbor_address:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry(neighbor_address)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors(yang.adata.MNode):
    neighbor: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor

    mut def __init__(self, neighbor: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.neighbor = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor(elements=neighbor)

    def _get_attr(self, name: str) -> ?value:
        if name == 'neighbor':
            return iter(self.neighbor)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'neighbors'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors(neighbor=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors__neighbor.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'neighbor'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'rd', 'auto'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as(yang.adata.MNode):
    as_number: ?value
    index: ?u64

    mut def __init__(self, as_number: ?value, index: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index

    def _get_attr(self, name: str) -> ?value:
        if name == 'as_number':
            return self.as_number
        if name == 'index':
            return self.index
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'rd', 'two-byte-as'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as(as_number=n.get_opt_value(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'as-number')), index=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'index')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as(yang.adata.MNode):
    as_number: ?value
    index: ?u64

    mut def __init__(self, as_number: ?value, index: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.index = index

    def _get_attr(self, name: str) -> ?value:
        if name == 'as_number':
            return self.as_number
        if name == 'index':
            return self.index
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'rd', 'four-byte-as'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as(as_number=n.get_opt_value(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'as-number')), index=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'index')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address(yang.adata.MNode):
    ipv4_address: ?str
    index: ?u64

    mut def __init__(self, ipv4_address: ?str, index: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.ipv4_address = ipv4_address
        self.index = index

    def _get_attr(self, name: str) -> ?value:
        if name == 'ipv4_address':
            return self.ipv4_address
        if name == 'index':
            return self.index
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'rd', 'ip-address'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address(ipv4_address=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'ipv4-address')), index=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'index')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd(yang.adata.MNode):
    auto: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto
    two_byte_as: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as
    four_byte_as: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as
    ip_address: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address

    mut def __init__(self, auto: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto=None, two_byte_as: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as=None, four_byte_as: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as=None, ip_address: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.auto = auto
        self.two_byte_as = two_byte_as
        self.four_byte_as = four_byte_as
        self.ip_address = ip_address

    mut def create_auto(self):
        existing = self.auto
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto()
        self.auto = res
        return res

    mut def create_two_byte_as(self, as_number, index):
        existing = self.two_byte_as
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as(as_number, index)
        self.two_byte_as = res
        return res

    mut def create_four_byte_as(self, as_number, index):
        existing = self.four_byte_as
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as(as_number, index)
        self.four_byte_as = res
        return res

    mut def create_ip_address(self, ipv4_address, index):
        existing = self.ip_address
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address(ipv4_address, index)
        self.ip_address = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'auto':
            return self.auto
        if name == 'two_byte_as':
            return self.two_byte_as
        if name == 'four_byte_as':
            return self.four_byte_as
        if name == 'ip_address':
            return self.ip_address
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf', 'rd'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd(auto=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__auto.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'auto'))), two_byte_as=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__two_byte_as.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'two-byte-as'))), four_byte_as=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__four_byte_as.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'four-byte-as'))), ip_address=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd__ip_address.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'ip-address'))))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd.copy()')


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry(yang.adata.MNode):
    vrf_name: str
    address_families: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families
    neighbors: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors
    rd: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd

    mut def __init__(self, vrf_name: str, address_families: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families=None, neighbors: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors=None, rd: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.vrf_name = vrf_name
        self.address_families = address_families if address_families is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families()
        self.neighbors = neighbors if neighbors is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors()
        self.rd = rd

    mut def create_rd(self):
        existing = self.rd
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd()
        self.rd = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'vrf_name':
            return self.vrf_name
        if name == 'address_families':
            return self.address_families
        if name == 'neighbors':
            return self.neighbors
        if name == 'rd':
            return self.rd
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs', 'vrf'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry(vrf_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'vrf-name')), address_families=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__address_families.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'address-families'))), neighbors=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__neighbors.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'neighbors'))), rd=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf__rd.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'rd'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'vrf'
        self.elements = elements

    mut def create(self, vrf_name):
        for e in self:
            match = True
            if e.vrf_name != vrf_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry(vrf_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs(yang.adata.MNode):
    vrf: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf

    mut def __init__(self, vrf: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.vrf = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf(elements=vrf)

    def _get_attr(self, name: str) -> ?value:
        if name == 'vrf':
            return iter(self.vrf)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as', 'vrfs'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs(vrf=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs__vrf.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'vrf'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry(yang.adata.MNode):
    as_number: value
    rpki: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki
    address_families: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families
    neighbors: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors
    neighbor_groups: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups
    bgp: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp
    vrfs: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs

    mut def __init__(self, as_number: value, rpki: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki=None, address_families: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families=None, neighbors: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors=None, neighbor_groups: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups=None, bgp: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp=None, vrfs: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_number = as_number
        self.rpki = rpki if rpki is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki()
        self.address_families = address_families if address_families is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families()
        self.neighbors = neighbors if neighbors is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors()
        self.neighbor_groups = neighbor_groups if neighbor_groups is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups()
        self.bgp = bgp if bgp is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp()
        self.vrfs = vrfs if vrfs is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs()

    def _get_attr(self, name: str) -> ?value:
        if name == 'as_number':
            return self.as_number
        if name == 'rpki':
            return self.rpki
        if name == 'address_families':
            return self.address_families
        if name == 'neighbors':
            return self.neighbors
        if name == 'neighbor_groups':
            return self.neighbor_groups
        if name == 'bgp':
            return self.bgp
        if name == 'vrfs':
            return self.vrfs
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp', 'as'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry:
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry(as_number=n.get_value(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'as-number')), rpki=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__rpki.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'rpki'))), address_families=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__address_families.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'address-families'))), neighbors=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbors.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'neighbors'))), neighbor_groups=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__neighbor_groups.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'neighbor-groups'))), bgp=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__bgp.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'bgp'))), vrfs=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as__vrfs.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'vrfs'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self._name = 'as'
        self.elements = elements

    mut def create(self, as_number):
        for e in self:
            match = True
            e_as_number = e.as_number
            if isinstance(e_as_number, u64) and isinstance(as_number, u64):
                if e_as_number != as_number:
                    match = False
                    continue
            e_as_number = e.as_number
            if isinstance(e_as_number, str) and isinstance(as_number, str):
                if e_as_number != as_number:
                    match = False
                    continue
            if match:
                return e

        res = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry(as_number)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as(elements=copied_elements)

extension Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as(Iterable[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp(yang.adata.MNode):
    as_: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as

    mut def __init__(self, as_: list[Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.as_ = Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as(elements=as_)

    def _get_attr(self, name: str) -> ?value:
        if name == 'as_':
            return iter(self.as_)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router', 'bgp'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp(as_=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp__as.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'as'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router(yang.adata.MNode):
    bgp: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp

    mut def __init__(self, bgp: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg'
        self.bgp = bgp if bgp is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp()

    def _get_attr(self, name: str) -> ?value:
        if name == 'bgp':
            return self.bgp
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-router-bgp-cfg:router'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router:
        if n is not None:
            return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router(bgp=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router__bgp.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'bgp'))))
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry(yang.adata.MNode):
    af_name: str

    mut def __init__(self, af_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self.af_name = af_name

    def _get_attr(self, name: str) -> ?value:
        if name == 'af_name':
            return self.af_name
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-mpls-ldp-cfg:mpls', 'ldp', 'address-families', 'address-family'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry:
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry(af_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_mpls_ldp_cfg, 'af-name')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self._name = 'address-family'
        self.elements = elements

    mut def create(self, af_name):
        for e in self:
            match = True
            if e.af_name != af_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry(af_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family(elements=copied_elements)

extension Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family(Iterable[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family

    mut def __init__(self, address_family: list[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self.address_family = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family(elements=address_family)

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return iter(self.address_family)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-mpls-ldp-cfg:mpls', 'ldp', 'address-families'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families:
        if n is not None:
            return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families(address_family=Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families__address_family.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_mpls_ldp_cfg, 'address-family'))))
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry(yang.adata.MNode):
    interface_name: str

    mut def __init__(self, interface_name: str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self.interface_name = interface_name

    def _get_attr(self, name: str) -> ?value:
        if name == 'interface_name':
            return self.interface_name
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-mpls-ldp-cfg:mpls', 'ldp', 'interfaces', 'interface'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry:
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry(interface_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_mpls_ldp_cfg, 'interface-name')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self._name = 'interface'
        self.elements = elements

    mut def create(self, interface_name):
        for e in self:
            match = True
            if e.interface_name != interface_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry(interface_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface(elements=copied_elements)

extension Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface(Iterable[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces(yang.adata.MNode):
    interface: Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface

    mut def __init__(self, interface: list[Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self.interface = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface(elements=interface)

    def _get_attr(self, name: str) -> ?value:
        if name == 'interface':
            return iter(self.interface)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-mpls-ldp-cfg:mpls', 'ldp', 'interfaces'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces:
        if n is not None:
            return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces(interface=Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces__interface.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_mpls_ldp_cfg, 'interface'))))
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp(yang.adata.MNode):
    address_families: Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families
    interfaces: Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces

    mut def __init__(self, address_families: ?Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families=None, interfaces: ?Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self.address_families = address_families if address_families is not None else Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families()
        self.interfaces = interfaces if interfaces is not None else Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces()

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_families':
            return self.address_families
        if name == 'interfaces':
            return self.interfaces
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-mpls-ldp-cfg:mpls', 'ldp'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp:
        if n is not None:
            return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp(address_families=Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__address_families.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_mpls_ldp_cfg, 'address-families'))), interfaces=Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp__interfaces.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_mpls_ldp_cfg, 'interfaces'))))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp.copy()')


class Cisco_IOS_XR_um_mpls_ldp_cfg__mpls(yang.adata.MNode):
    ldp: ?Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp

    mut def __init__(self, ldp: ?Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg'
        self.ldp = ldp

    mut def create_ldp(self):
        existing = self.ldp
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp()
        self.ldp = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'ldp':
            return self.ldp
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_mpls_ldp_cfg__mpls')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-mpls-ldp-cfg:mpls'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_mpls_ldp_cfg__mpls:
        if n is not None:
            return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls(ldp=Cisco_IOS_XR_um_mpls_ldp_cfg__mpls__ldp.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_mpls_ldp_cfg, 'ldp'))))
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_mpls_ldp_cfg__mpls.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'sub-interface-type', 'l2transport'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport.copy()')


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'sub-interface-type', 'point-to-point'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point.copy()')


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'sub-interface-type', 'multipoint'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint.copy()')


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type(yang.adata.MNode):
    l2transport: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport
    point_to_point: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point
    multipoint: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint

    mut def __init__(self, l2transport: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport=None, point_to_point: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point=None, multipoint: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        self.l2transport = l2transport
        self.point_to_point = point_to_point
        self.multipoint = multipoint

    mut def create_l2transport(self):
        existing = self.l2transport
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport()
        self.l2transport = res
        return res

    mut def create_point_to_point(self):
        existing = self.point_to_point
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point()
        self.point_to_point = res
        return res

    mut def create_multipoint(self):
        existing = self.multipoint
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint()
        self.multipoint = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'l2transport':
            return self.l2transport
        if name == 'point_to_point':
            return self.point_to_point
        if name == 'multipoint':
            return self.multipoint
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'sub-interface-type'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type(l2transport=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'l2transport'))), point_to_point=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'point-to-point'))), multipoint=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'multipoint'))))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(yang.adata.MNode):
    address: ?str
    netmask: ?str
    route_tag: ?u64
    algorithm: ?u64

    mut def __init__(self, address: ?str, netmask: ?str, route_tag: ?u64, algorithm: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg'
        self.address = address
        self.netmask = netmask
        self.route_tag = route_tag
        self.algorithm = algorithm

    def _get_attr(self, name: str) -> ?value:
        if name == 'address':
            return self.address
        if name == 'netmask':
            return self.netmask
        if name == 'route_tag':
            return self.route_tag
        if name == 'algorithm':
            return self.algorithm
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'ipv4', 'Cisco-IOS-XR-um-if-ip-address-cfg:addresses', 'address'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(address=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_if_ip_address_cfg, 'address')), netmask=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_if_ip_address_cfg, 'netmask')), route_tag=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_if_ip_address_cfg, 'route-tag')), algorithm=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_if_ip_address_cfg, 'algorithm')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address.copy()')


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry(yang.adata.MNode):
    address: str
    netmask: ?str
    route_tag: ?u64
    algorithm: ?u64

    mut def __init__(self, address: str, netmask: ?str, route_tag: ?u64, algorithm: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg'
        self.address = address
        self.netmask = netmask
        self.route_tag = route_tag
        self.algorithm = algorithm

    def _get_attr(self, name: str) -> ?value:
        if name == 'address':
            return self.address
        if name == 'netmask':
            return self.netmask
        if name == 'route_tag':
            return self.route_tag
        if name == 'algorithm':
            return self.algorithm
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'ipv4', 'Cisco-IOS-XR-um-if-ip-address-cfg:addresses', 'secondaries', 'secondary'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry:
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry(address=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_if_ip_address_cfg, 'address')), netmask=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_if_ip_address_cfg, 'netmask')), route_tag=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_if_ip_address_cfg, 'route-tag')), algorithm=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_if_ip_address_cfg, 'algorithm')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg'
        self._name = 'secondary'
        self.elements = elements

    mut def create(self, address, netmask):
        for e in self:
            match = True
            if e.address != address:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry(address, netmask)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(elements=copied_elements)

extension Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(Iterable[Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries(yang.adata.MNode):
    secondary: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary

    mut def __init__(self, secondary: list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg'
        self.secondary = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(elements=secondary)

    def _get_attr(self, name: str) -> ?value:
        if name == 'secondary':
            return iter(self.secondary)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'ipv4', 'Cisco-IOS-XR-um-if-ip-address-cfg:addresses', 'secondaries'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries(secondary=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_if_ip_address_cfg, 'secondary'))))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'ipv4', 'Cisco-IOS-XR-um-if-ip-address-cfg:addresses', 'dhcp'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp.copy()')


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses(yang.adata.MNode):
    address: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address
    secondaries: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries
    unnumbered: ?str
    dhcp: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp

    mut def __init__(self, address: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address=None, secondaries: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries=None, unnumbered: ?str, dhcp: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg'
        self.address = address
        self.secondaries = secondaries if secondaries is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries()
        self.unnumbered = unnumbered
        self.dhcp = dhcp

    mut def create_address(self, address, netmask):
        existing = self.address
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(address, netmask)
        self.address = res
        return res

    mut def create_dhcp(self):
        existing = self.dhcp
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp()
        self.dhcp = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'address':
            return self.address
        if name == 'secondaries':
            return self.secondaries
        if name == 'unnumbered':
            return self.unnumbered
        if name == 'dhcp':
            return self.dhcp
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'ipv4', 'Cisco-IOS-XR-um-if-ip-address-cfg:addresses'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses(address=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_if_ip_address_cfg, 'address'))), secondaries=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_if_ip_address_cfg, 'secondaries'))), unnumbered=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_if_ip_address_cfg, 'unnumbered')), dhcp=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_if_ip_address_cfg, 'dhcp'))))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4(yang.adata.MNode):
    addresses: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses

    mut def __init__(self, addresses: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        self.addresses = addresses if addresses is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses()

    def _get_attr(self, name: str) -> ?value:
        if name == 'addresses':
            return self.addresses
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'ipv4'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4(addresses=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_if_ip_address_cfg, 'addresses'))))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'ipv6'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6()
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'encapsulation', 'ppp'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp.copy()')


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'encapsulation', 'hdlc'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc.copy()')


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'encapsulation', 'mfr'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr.copy()')


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'encapsulation', 'frame-relay', 'IETF'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF.copy()')


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay(yang.adata.MNode):
    IETF: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF

    mut def __init__(self, IETF: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        self.IETF = IETF

    mut def create_IETF(self):
        existing = self.IETF
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF()
        self.IETF = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'IETF':
            return self.IETF
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'encapsulation', 'frame-relay'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay(IETF=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay__IETF.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'IETF'))))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay.copy()')


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation(yang.adata.MNode):
    ppp: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp
    hdlc: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc
    mfr: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr
    frame_relay: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay

    mut def __init__(self, ppp: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp=None, hdlc: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc=None, mfr: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr=None, frame_relay: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        self.ppp = ppp
        self.hdlc = hdlc
        self.mfr = mfr
        self.frame_relay = frame_relay

    mut def create_ppp(self):
        existing = self.ppp
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp()
        self.ppp = res
        return res

    mut def create_hdlc(self):
        existing = self.hdlc
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc()
        self.hdlc = res
        return res

    mut def create_mfr(self):
        existing = self.mfr
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr()
        self.mfr = res
        return res

    mut def create_frame_relay(self):
        existing = self.frame_relay
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay()
        self.frame_relay = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'ppp':
            return self.ppp
        if name == 'hdlc':
            return self.hdlc
        if name == 'mfr':
            return self.mfr
        if name == 'frame_relay':
            return self.frame_relay
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'encapsulation'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation(ppp=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__ppp.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'ppp'))), hdlc=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__hdlc.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'hdlc'))), mfr=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__mfr.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'mfr'))), frame_relay=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation__frame_relay.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'frame-relay'))))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q(yang.adata.MNode):
    vlan_id: ?u64
    second_dot1q: ?u64

    mut def __init__(self, vlan_id: ?u64, second_dot1q: ?u64):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg'
        self.vlan_id = vlan_id
        self.second_dot1q = second_dot1q

    def _get_attr(self, name: str) -> ?value:
        if name == 'vlan_id':
            return self.vlan_id
        if name == 'second_dot1q':
            return self.second_dot1q
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'Cisco-IOS-XR-um-l2-ethernet-cfg:encapsulation', 'dot1q'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q(vlan_id=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_l2_ethernet_cfg, 'vlan-id')), second_dot1q=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_l2_ethernet_cfg, 'second-dot1q')))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation(yang.adata.MNode):
    dot1q: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q

    mut def __init__(self, dot1q: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg'
        self.dot1q = dot1q if dot1q is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q()

    def _get_attr(self, name: str) -> ?value:
        if name == 'dot1q':
            return self.dot1q
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface', 'Cisco-IOS-XR-um-l2-ethernet-cfg:encapsulation'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation(dot1q=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation__dot1q.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_l2_ethernet_cfg, 'dot1q'))))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry(yang.adata.MNode):
    interface_name: str
    sub_interface_type: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type
    ipv4: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4
    ipv6: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6
    um_interface_cfg_encapsulation: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation
    shutdown: ?bool
    mtu: ?u64
    description: ?str
    vrf: ?str
    um_l2_ethernet_cfg_encapsulation: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation

    mut def __init__(self, interface_name: str, sub_interface_type: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type=None, ipv4: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4=None, ipv6: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6=None, um_interface_cfg_encapsulation: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation=None, shutdown: ?bool, mtu: ?u64, description: ?str, vrf: ?str, um_l2_ethernet_cfg_encapsulation: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        self.interface_name = interface_name
        self.sub_interface_type = sub_interface_type if sub_interface_type is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type()
        self.ipv4 = ipv4 if ipv4 is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4()
        self.ipv6 = ipv6 if ipv6 is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6()
        self.um_interface_cfg_encapsulation = um_interface_cfg_encapsulation if um_interface_cfg_encapsulation is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation()
        self.shutdown = shutdown
        self.mtu = mtu
        self.description = description
        self.vrf = vrf
        self.um_l2_ethernet_cfg_encapsulation = um_l2_ethernet_cfg_encapsulation if um_l2_ethernet_cfg_encapsulation is not None else Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation()

    def _get_attr(self, name: str) -> ?value:
        if name == 'interface_name':
            return self.interface_name
        if name == 'sub_interface_type':
            return self.sub_interface_type
        if name == 'ipv4':
            return self.ipv4
        if name == 'ipv6':
            return self.ipv6
        if name == 'um_interface_cfg_encapsulation':
            return self.um_interface_cfg_encapsulation
        if name == 'shutdown':
            return self.shutdown
        if name == 'mtu':
            return self.mtu
        if name == 'description':
            return self.description
        if name == 'vrf':
            return self.vrf
        if name == 'um_l2_ethernet_cfg_encapsulation':
            return self.um_l2_ethernet_cfg_encapsulation
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_interface_cfg__interfaces__interface')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces', 'interface'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry:
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry(interface_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'interface-name')), sub_interface_type=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'sub-interface-type'))), ipv4=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'ipv4'))), ipv6=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'ipv6'))), um_interface_cfg_encapsulation=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_interface_cfg_encapsulation.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'encapsulation'))), shutdown=n.get_opt_empty(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'shutdown')), mtu=n.get_opt_u64(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'mtu')), description=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'description')), vrf=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_if_vrf_cfg, 'vrf')), um_l2_ethernet_cfg_encapsulation=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__um_l2_ethernet_cfg_encapsulation.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_l2_ethernet_cfg, 'encapsulation'))))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        self._name = 'interface'
        self.elements = elements

    mut def create(self, interface_name):
        for e in self:
            match = True
            if e.interface_name != interface_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry(interface_name)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry]:
        if n is not None:
            return [Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface(elements=copied_elements)

extension Cisco_IOS_XR_um_interface_cfg__interfaces__interface(Iterable[Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_um_interface_cfg__interfaces(yang.adata.MNode):
    interface: Cisco_IOS_XR_um_interface_cfg__interfaces__interface

    mut def __init__(self, interface: list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg'
        self.interface = Cisco_IOS_XR_um_interface_cfg__interfaces__interface(elements=interface)

    def _get_attr(self, name: str) -> ?value:
        if name == 'interface':
            return iter(self.interface)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_interface_cfg__interfaces')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-interface-cfg:interfaces'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces:
        if n is not None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces(interface=Cisco_IOS_XR_um_interface_cfg__interfaces__interface.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'interface'))))
        return Cisco_IOS_XR_um_interface_cfg__interfaces()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_interface_cfg__interfaces.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-l2-ethernet-cfg:ethernet', 'egress-filter', 'strict'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict:
        if n is not None:
            return Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict.copy()')


class Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter(yang.adata.MNode):
    strict: ?Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict

    mut def __init__(self, strict: ?Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg'
        self.strict = strict

    mut def create_strict(self):
        existing = self.strict
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict()
        self.strict = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'strict':
            return self.strict
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-l2-ethernet-cfg:ethernet', 'egress-filter'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter:
        if n is not None:
            return Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter(strict=Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter__strict.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_l2_ethernet_cfg, 'strict'))))
        return Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet(yang.adata.MNode):
    egress_filter: Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter

    mut def __init__(self, egress_filter: ?Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg'
        self.egress_filter = egress_filter if egress_filter is not None else Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter()

    def _get_attr(self, name: str) -> ?value:
        if name == 'egress_filter':
            return self.egress_filter
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-l2-ethernet-cfg:ethernet'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet:
        if n is not None:
            return Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet(egress_filter=Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet__egress_filter.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_l2_ethernet_cfg, 'egress-filter'))))
        return Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet.from_gdata(self.to_gdata())


class Cisco_IOS_XR_um_hostname_cfg__hostname(yang.adata.MNode):
    system_network_name: ?str

    mut def __init__(self, system_network_name: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg'
        self.system_network_name = system_network_name

    def _get_attr(self, name: str) -> ?value:
        if name == 'system_network_name':
            return self.system_network_name
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_um_hostname_cfg__hostname')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-um-hostname-cfg:hostname'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_hostname_cfg__hostname:
        if n is not None:
            return Cisco_IOS_XR_um_hostname_cfg__hostname(system_network_name=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_um_hostname_cfg, 'system-network-name')))
        return Cisco_IOS_XR_um_hostname_cfg__hostname()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_um_hostname_cfg__hostname.from_gdata(self.to_gdata())


class Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry(yang.adata.MNode):
    route_policy_name: str
    rpl_route_policy: ?str

    mut def __init__(self, route_policy_name: str, rpl_route_policy: ?str):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg'
        self.route_policy_name = route_policy_name
        self.rpl_route_policy = rpl_route_policy

    def _get_attr(self, name: str) -> ?value:
        if name == 'route_policy_name':
            return self.route_policy_name
        if name == 'rpl_route_policy':
            return self.rpl_route_policy
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-policy-repository-cfg:routing-policy', 'route-policies', 'route-policy'])

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry:
        return Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry(route_policy_name=n.get_str(yang.gdata.Id(NS_Cisco_IOS_XR_policy_repository_cfg, 'route-policy-name')), rpl_route_policy=n.get_opt_str(yang.gdata.Id(NS_Cisco_IOS_XR_policy_repository_cfg, 'rpl-route-policy')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry.from_gdata(self.to_gdata())

class Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg'
        self._name = 'route-policy'
        self.elements = elements

    mut def create(self, route_policy_name, rpl_route_policy):
        for e in self:
            match = True
            if e.route_policy_name != route_policy_name:
                match = False
                continue
            if match:
                return e

        res = Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry(route_policy_name, rpl_route_policy)
        self.elements.append(res)
        return res

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry]:
        if n is not None:
            return [Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy(elements=copied_elements)

extension Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy(Iterable[Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry]):
    def __iter__(self) -> Iterator[Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry]:
        return self.elements.__iter__()

class Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies(yang.adata.MNode):
    route_policy: Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy

    mut def __init__(self, route_policy: list[Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy_entry]=[]):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg'
        self.route_policy = Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy(elements=route_policy)

    def _get_attr(self, name: str) -> ?value:
        if name == 'route_policy':
            return iter(self.route_policy)
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-policy-repository-cfg:routing-policy', 'route-policies'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies:
        if n is not None:
            return Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies(route_policy=Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies__route_policy.from_gdata(n.get_opt_list(yang.gdata.Id(NS_Cisco_IOS_XR_policy_repository_cfg, 'route-policy'))))
        return Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies.from_gdata(self.to_gdata())


class Cisco_IOS_XR_policy_repository_cfg__routing_policy(yang.adata.MNode):
    route_policies: Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies

    mut def __init__(self, route_policies: ?Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies=None):
        self._ns = 'http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg'
        self.route_policies = route_policies if route_policies is not None else Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies()

    def _get_attr(self, name: str) -> ?value:
        if name == 'route_policies':
            return self.route_policies
        raise ValueError('Attribute {name} not found in Cisco_IOS_XR_policy_repository_cfg__routing_policy')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True, root_path=['Cisco-IOS-XR-policy-repository-cfg:routing-policy'])

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_policy_repository_cfg__routing_policy:
        if n is not None:
            return Cisco_IOS_XR_policy_repository_cfg__routing_policy(route_policies=Cisco_IOS_XR_policy_repository_cfg__routing_policy__route_policies.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_policy_repository_cfg, 'route-policies'))))
        return Cisco_IOS_XR_policy_repository_cfg__routing_policy()

    def copy(self):
        """Create a deep copy of this adata object"""
        return Cisco_IOS_XR_policy_repository_cfg__routing_policy.from_gdata(self.to_gdata())


class root(yang.adata.MNode):
    address_family: Cisco_IOS_XR_um_vrf_cfg__address_family
    vrfs: Cisco_IOS_XR_um_vrf_cfg__vrfs
    selective_vrf_download: Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download
    srlg: ?Cisco_IOS_XR_um_vrf_cfg__srlg
    vrf_groups: Cisco_IOS_XR_um_vrf_cfg__vrf_groups
    um_router_isis_cfg_router: Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router
    as_format: Cisco_IOS_XR_um_router_bgp_cfg__as_format
    bmp: Cisco_IOS_XR_um_router_bgp_cfg__bmp
    um_router_bgp_cfg_router: Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router
    mpls: Cisco_IOS_XR_um_mpls_ldp_cfg__mpls
    interfaces: Cisco_IOS_XR_um_interface_cfg__interfaces
    ethernet: Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet
    hostname: Cisco_IOS_XR_um_hostname_cfg__hostname
    routing_policy: Cisco_IOS_XR_policy_repository_cfg__routing_policy

    mut def __init__(self, address_family: ?Cisco_IOS_XR_um_vrf_cfg__address_family=None, vrfs: ?Cisco_IOS_XR_um_vrf_cfg__vrfs=None, selective_vrf_download: ?Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download=None, srlg: ?Cisco_IOS_XR_um_vrf_cfg__srlg=None, vrf_groups: ?Cisco_IOS_XR_um_vrf_cfg__vrf_groups=None, um_router_isis_cfg_router: ?Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router=None, as_format: ?Cisco_IOS_XR_um_router_bgp_cfg__as_format=None, bmp: ?Cisco_IOS_XR_um_router_bgp_cfg__bmp=None, um_router_bgp_cfg_router: ?Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router=None, mpls: ?Cisco_IOS_XR_um_mpls_ldp_cfg__mpls=None, interfaces: ?Cisco_IOS_XR_um_interface_cfg__interfaces=None, ethernet: ?Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet=None, hostname: ?Cisco_IOS_XR_um_hostname_cfg__hostname=None, routing_policy: ?Cisco_IOS_XR_policy_repository_cfg__routing_policy=None):
        self._ns = ''
        self.address_family = address_family if address_family is not None else Cisco_IOS_XR_um_vrf_cfg__address_family()
        self.vrfs = vrfs if vrfs is not None else Cisco_IOS_XR_um_vrf_cfg__vrfs()
        self.selective_vrf_download = selective_vrf_download if selective_vrf_download is not None else Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download()
        self.srlg = srlg
        self.vrf_groups = vrf_groups if vrf_groups is not None else Cisco_IOS_XR_um_vrf_cfg__vrf_groups()
        self.um_router_isis_cfg_router = um_router_isis_cfg_router if um_router_isis_cfg_router is not None else Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router()
        self.as_format = as_format if as_format is not None else Cisco_IOS_XR_um_router_bgp_cfg__as_format()
        self.bmp = bmp if bmp is not None else Cisco_IOS_XR_um_router_bgp_cfg__bmp()
        self.um_router_bgp_cfg_router = um_router_bgp_cfg_router if um_router_bgp_cfg_router is not None else Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router()
        self.mpls = mpls if mpls is not None else Cisco_IOS_XR_um_mpls_ldp_cfg__mpls()
        self.interfaces = interfaces if interfaces is not None else Cisco_IOS_XR_um_interface_cfg__interfaces()
        self.ethernet = ethernet if ethernet is not None else Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet()
        self.hostname = hostname if hostname is not None else Cisco_IOS_XR_um_hostname_cfg__hostname()
        self.routing_policy = routing_policy if routing_policy is not None else Cisco_IOS_XR_policy_repository_cfg__routing_policy()

    mut def create_srlg(self):
        existing = self.srlg
        if existing is not None:
            return existing
        res = Cisco_IOS_XR_um_vrf_cfg__srlg()
        self.srlg = res
        return res

    def _get_attr(self, name: str) -> ?value:
        if name == 'address_family':
            return self.address_family
        if name == 'vrfs':
            return self.vrfs
        if name == 'selective_vrf_download':
            return self.selective_vrf_download
        if name == 'srlg':
            return self.srlg
        if name == 'vrf_groups':
            return self.vrf_groups
        if name == 'um_router_isis_cfg_router':
            return self.um_router_isis_cfg_router
        if name == 'as_format':
            return self.as_format
        if name == 'bmp':
            return self.bmp
        if name == 'um_router_bgp_cfg_router':
            return self.um_router_bgp_cfg_router
        if name == 'mpls':
            return self.mpls
        if name == 'interfaces':
            return self.interfaces
        if name == 'ethernet':
            return self.ethernet
        if name == 'hostname':
            return self.hostname
        if name == 'routing_policy':
            return self.routing_policy
        raise ValueError('Attribute {name} not found in root')

    mut def to_gdata(self) -> yang.gdata.Node:
        return yang.adata.from_adata(SRC_DNODE, self, loose=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> root:
        if n is not None:
            return root(address_family=Cisco_IOS_XR_um_vrf_cfg__address_family.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'address-family'))), vrfs=Cisco_IOS_XR_um_vrf_cfg__vrfs.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'vrfs'))), selective_vrf_download=Cisco_IOS_XR_um_vrf_cfg__selective_vrf_download.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'selective-vrf-download'))), srlg=Cisco_IOS_XR_um_vrf_cfg__srlg.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'srlg'))), vrf_groups=Cisco_IOS_XR_um_vrf_cfg__vrf_groups.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_vrf_cfg, 'vrf-groups'))), um_router_isis_cfg_router=Cisco_IOS_XR_um_router_isis_cfg__um_router_isis_cfg_router.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_isis_cfg, 'router'))), as_format=Cisco_IOS_XR_um_router_bgp_cfg__as_format.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'as-format'))), bmp=Cisco_IOS_XR_um_router_bgp_cfg__bmp.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'bmp'))), um_router_bgp_cfg_router=Cisco_IOS_XR_um_router_bgp_cfg__um_router_bgp_cfg_router.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_router_bgp_cfg, 'router'))), mpls=Cisco_IOS_XR_um_mpls_ldp_cfg__mpls.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_mpls_ldp_cfg, 'mpls'))), interfaces=Cisco_IOS_XR_um_interface_cfg__interfaces.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_interface_cfg, 'interfaces'))), ethernet=Cisco_IOS_XR_um_l2_ethernet_cfg__ethernet.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_l2_ethernet_cfg, 'ethernet'))), hostname=Cisco_IOS_XR_um_hostname_cfg__hostname.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_um_hostname_cfg, 'hostname'))), routing_policy=Cisco_IOS_XR_policy_repository_cfg__routing_policy.from_gdata(n.get_opt_cnt(yang.gdata.Id(NS_Cisco_IOS_XR_policy_repository_cfg, 'routing-policy'))))
        return root()

    def copy(self):
        """Create a deep copy of this adata object"""
        return root.from_gdata(self.to_gdata())


schema_namespaces: set[str] = {
    'http://cisco.com/ns/yang/Cisco-IOS-XR-policy-repository-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-vrf-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-l2-ethernet-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-mpls-ldp-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-bgp-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-router-isis-cfg',
    'http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg',
}
