import base64
import json
import xml
import yang
import yang.adata
import yang.gdata
import yang.gen3
from yang.identity import complete_and_validate_identityref
from yang.identityref import Identityref, PartialIdentityref
from yang.schema import DIdentity

# == This file is generated ==


_base_srl_nokia_common_ip_route_type = DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='ip-route-type', base=[])
_base_srl_nokia_common_mpls_label_entry_type = DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='mpls-label-entry-type', base=[])
_base_srl_nokia_common_tunnel_type = DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='tunnel-type', base=[])
_base_srl_nokia_common_bgp_next_hop_resolution_tunnel_type = DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='bgp-next-hop-resolution-tunnel-type', base=[])
_base_srl_nokia_common_routing_policy_protocol_match_type = DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='routing-policy-protocol-match-type', base=[])
_base_srl_nokia_common_table_connection_protocol = DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='table-connection-protocol', base=[])
_base_srl_nokia_common_bgp_address_family = DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='bgp-address-family', base=[])
_base_srl_nokia_interfaces_si_type = DIdentity(module='srl_nokia-interfaces', namespace='urn:nokia.com:srlinux:chassis:interfaces', prefix='srl_nokia-if', name='si-type', base=[])
_base_srl_nokia_interfaces_transceiver_functional_type = DIdentity(module='srl_nokia-interfaces', namespace='urn:nokia.com:srlinux:chassis:interfaces', prefix='srl_nokia-if', name='transceiver-functional-type', base=[])
_base_srl_nokia_network_instance_ni_type = DIdentity(module='srl_nokia-network-instance', namespace='urn:nokia.com:srlinux:net-inst:network-instance', prefix='srl_nokia-netinst', name='ni-type', base=[])
_base_srl_nokia_policy_types_bgp_well_known_community = DIdentity(module='srl_nokia-policy-types', namespace='urn:nokia.com:srlinux:general:policy-types', prefix='srl_nokia-pol-types', name='bgp-well-known-community', base=[])
_identities = [
    _base_srl_nokia_common_ip_route_type,
    _base_srl_nokia_common_mpls_label_entry_type,
    _base_srl_nokia_common_tunnel_type,
    _base_srl_nokia_common_bgp_next_hop_resolution_tunnel_type,
    _base_srl_nokia_common_routing_policy_protocol_match_type,
    _base_srl_nokia_common_table_connection_protocol,
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='aggregate', base=[_base_srl_nokia_common_ip_route_type, _base_srl_nokia_common_routing_policy_protocol_match_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='arp-nd', base=[_base_srl_nokia_common_ip_route_type, _base_srl_nokia_common_routing_policy_protocol_match_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='bgp', base=[_base_srl_nokia_common_ip_route_type, _base_srl_nokia_common_mpls_label_entry_type, _base_srl_nokia_common_tunnel_type, _base_srl_nokia_common_bgp_next_hop_resolution_tunnel_type, _base_srl_nokia_common_routing_policy_protocol_match_type, _base_srl_nokia_common_table_connection_protocol]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='bgp-evpn', base=[_base_srl_nokia_common_ip_route_type, _base_srl_nokia_common_routing_policy_protocol_match_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='bgp-evpn-ifl-host', base=[_base_srl_nokia_common_ip_route_type, _base_srl_nokia_common_routing_policy_protocol_match_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='bgp-ipvpn', base=[_base_srl_nokia_common_ip_route_type, _base_srl_nokia_common_routing_policy_protocol_match_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='bgp-label', base=[_base_srl_nokia_common_ip_route_type, _base_srl_nokia_common_routing_policy_protocol_match_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='dhcp', base=[_base_srl_nokia_common_ip_route_type, _base_srl_nokia_common_routing_policy_protocol_match_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='esi', base=[_base_srl_nokia_common_mpls_label_entry_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='pseudowire', base=[_base_srl_nokia_common_mpls_label_entry_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='gribi', base=[_base_srl_nokia_common_ip_route_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='host', base=[_base_srl_nokia_common_ip_route_type, _base_srl_nokia_common_routing_policy_protocol_match_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='ip-in-ip', base=[_base_srl_nokia_common_tunnel_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='gre', base=[_base_srl_nokia_common_tunnel_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='isis', base=[_base_srl_nokia_common_ip_route_type, _base_srl_nokia_common_routing_policy_protocol_match_type, _base_srl_nokia_common_table_connection_protocol]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='local', base=[_base_srl_nokia_common_ip_route_type, _base_srl_nokia_common_routing_policy_protocol_match_type, _base_srl_nokia_common_table_connection_protocol]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='ldp', base=[_base_srl_nokia_common_mpls_label_entry_type, _base_srl_nokia_common_tunnel_type, _base_srl_nokia_common_bgp_next_hop_resolution_tunnel_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='linux', base=[_base_srl_nokia_common_ip_route_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='ndk1', base=[_base_srl_nokia_common_ip_route_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='ndk2', base=[_base_srl_nokia_common_ip_route_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='network-instance', base=[_base_srl_nokia_common_mpls_label_entry_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='ospfv2', base=[_base_srl_nokia_common_ip_route_type, _base_srl_nokia_common_routing_policy_protocol_match_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='ospfv3', base=[_base_srl_nokia_common_ip_route_type, _base_srl_nokia_common_routing_policy_protocol_match_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='sr-isis', base=[_base_srl_nokia_common_tunnel_type, _base_srl_nokia_common_bgp_next_hop_resolution_tunnel_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='sr-ospfv2', base=[_base_srl_nokia_common_tunnel_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='sr-ospfv3', base=[_base_srl_nokia_common_tunnel_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='sr-mpls', base=[_base_srl_nokia_common_mpls_label_entry_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='sr-submgmt', base=[_base_srl_nokia_common_ip_route_type, _base_srl_nokia_common_routing_policy_protocol_match_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='te-policy-sr-mpls-colored', base=[_base_srl_nokia_common_tunnel_type, _base_srl_nokia_common_bgp_next_hop_resolution_tunnel_type, _base_srl_nokia_common_mpls_label_entry_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='te-policy-sr-mpls-uncolored', base=[_base_srl_nokia_common_tunnel_type, _base_srl_nokia_common_bgp_next_hop_resolution_tunnel_type, _base_srl_nokia_common_mpls_label_entry_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='static', base=[_base_srl_nokia_common_ip_route_type, _base_srl_nokia_common_routing_policy_protocol_match_type, _base_srl_nokia_common_table_connection_protocol]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='static-mpls', base=[_base_srl_nokia_common_mpls_label_entry_type]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='vxlan', base=[_base_srl_nokia_common_tunnel_type]),
    _base_srl_nokia_common_bgp_address_family,
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='ipv4-unicast', base=[_base_srl_nokia_common_bgp_address_family]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='ipv6-unicast', base=[_base_srl_nokia_common_bgp_address_family]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='l3vpn-ipv4-unicast', base=[_base_srl_nokia_common_bgp_address_family]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='l3vpn-ipv6-unicast', base=[_base_srl_nokia_common_bgp_address_family]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='ipv4-labeled-unicast', base=[_base_srl_nokia_common_bgp_address_family]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='ipv6-labeled-unicast', base=[_base_srl_nokia_common_bgp_address_family]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='evpn', base=[_base_srl_nokia_common_bgp_address_family]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='route-target', base=[_base_srl_nokia_common_bgp_address_family]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='srte-policy-ipv4', base=[_base_srl_nokia_common_bgp_address_family]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='srte-policy-ipv6', base=[_base_srl_nokia_common_bgp_address_family]),
    DIdentity(module='srl_nokia-common', namespace='urn:nokia.com:srlinux:general:common', prefix='srl_nokia-comm', name='link-state', base=[_base_srl_nokia_common_bgp_address_family]),
    _base_srl_nokia_interfaces_si_type,
    DIdentity(module='srl_nokia-interfaces', namespace='urn:nokia.com:srlinux:chassis:interfaces', prefix='srl_nokia-if', name='routed', base=[_base_srl_nokia_interfaces_si_type]),
    DIdentity(module='srl_nokia-interfaces', namespace='urn:nokia.com:srlinux:chassis:interfaces', prefix='srl_nokia-if', name='bridged', base=[_base_srl_nokia_interfaces_si_type]),
    DIdentity(module='srl_nokia-interfaces', namespace='urn:nokia.com:srlinux:chassis:interfaces', prefix='srl_nokia-if', name='local-mirror-dest', base=[_base_srl_nokia_interfaces_si_type]),
    _base_srl_nokia_interfaces_transceiver_functional_type,
    DIdentity(module='srl_nokia-interfaces', namespace='urn:nokia.com:srlinux:chassis:interfaces', prefix='srl_nokia-if', name='standard', base=[_base_srl_nokia_interfaces_transceiver_functional_type]),
    DIdentity(module='srl_nokia-interfaces', namespace='urn:nokia.com:srlinux:chassis:interfaces', prefix='srl_nokia-if', name='digital-coherent-optics', base=[_base_srl_nokia_interfaces_transceiver_functional_type]),
    DIdentity(module='srl_nokia-interfaces', namespace='urn:nokia.com:srlinux:chassis:interfaces', prefix='srl_nokia-if', name='optical-line-system', base=[_base_srl_nokia_interfaces_transceiver_functional_type]),
    _base_srl_nokia_network_instance_ni_type,
    DIdentity(module='srl_nokia-network-instance', namespace='urn:nokia.com:srlinux:net-inst:network-instance', prefix='srl_nokia-netinst', name='host', base=[_base_srl_nokia_network_instance_ni_type]),
    DIdentity(module='srl_nokia-network-instance', namespace='urn:nokia.com:srlinux:net-inst:network-instance', prefix='srl_nokia-netinst', name='default', base=[_base_srl_nokia_network_instance_ni_type]),
    DIdentity(module='srl_nokia-network-instance', namespace='urn:nokia.com:srlinux:net-inst:network-instance', prefix='srl_nokia-netinst', name='ip-vrf', base=[_base_srl_nokia_network_instance_ni_type]),
    DIdentity(module='srl_nokia-network-instance', namespace='urn:nokia.com:srlinux:net-inst:network-instance', prefix='srl_nokia-netinst', name='mac-vrf', base=[_base_srl_nokia_network_instance_ni_type]),
    DIdentity(module='srl_nokia-network-instance', namespace='urn:nokia.com:srlinux:net-inst:network-instance', prefix='srl_nokia-netinst', name='vpws', base=[_base_srl_nokia_network_instance_ni_type]),
    _base_srl_nokia_policy_types_bgp_well_known_community,
    DIdentity(module='srl_nokia-policy-types', namespace='urn:nokia.com:srlinux:general:policy-types', prefix='srl_nokia-pol-types', name='no-export', base=[_base_srl_nokia_policy_types_bgp_well_known_community]),
    DIdentity(module='srl_nokia-policy-types', namespace='urn:nokia.com:srlinux:general:policy-types', prefix='srl_nokia-pol-types', name='no-advertise', base=[_base_srl_nokia_policy_types_bgp_well_known_community]),
    DIdentity(module='srl_nokia-policy-types', namespace='urn:nokia.com:srlinux:general:policy-types', prefix='srl_nokia-pol-types', name='no-export-subconfed', base=[_base_srl_nokia_policy_types_bgp_well_known_community]),
]


# Identityref constants
srl_nokia_common_ip_route_type = Identityref('ip-route-type', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_mpls_label_entry_type = Identityref('mpls-label-entry-type', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_tunnel_type = Identityref('tunnel-type', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_bgp_next_hop_resolution_tunnel_type = Identityref('bgp-next-hop-resolution-tunnel-type', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_routing_policy_protocol_match_type = Identityref('routing-policy-protocol-match-type', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_table_connection_protocol = Identityref('table-connection-protocol', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_aggregate = Identityref('aggregate', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_arp_nd = Identityref('arp-nd', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_bgp = Identityref('bgp', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_bgp_evpn = Identityref('bgp-evpn', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_bgp_evpn_ifl_host = Identityref('bgp-evpn-ifl-host', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_bgp_ipvpn = Identityref('bgp-ipvpn', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_bgp_label = Identityref('bgp-label', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_dhcp = Identityref('dhcp', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_esi = Identityref('esi', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_pseudowire = Identityref('pseudowire', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_gribi = Identityref('gribi', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_host = Identityref('host', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_ip_in_ip = Identityref('ip-in-ip', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_gre = Identityref('gre', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_isis = Identityref('isis', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_local = Identityref('local', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_ldp = Identityref('ldp', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_linux = Identityref('linux', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_ndk1 = Identityref('ndk1', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_ndk2 = Identityref('ndk2', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_network_instance = Identityref('network-instance', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_ospfv2 = Identityref('ospfv2', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_ospfv3 = Identityref('ospfv3', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_sr_isis = Identityref('sr-isis', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_sr_ospfv2 = Identityref('sr-ospfv2', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_sr_ospfv3 = Identityref('sr-ospfv3', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_sr_mpls = Identityref('sr-mpls', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_sr_submgmt = Identityref('sr-submgmt', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_te_policy_sr_mpls_colored = Identityref('te-policy-sr-mpls-colored', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_te_policy_sr_mpls_uncolored = Identityref('te-policy-sr-mpls-uncolored', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_static = Identityref('static', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_static_mpls = Identityref('static-mpls', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_vxlan = Identityref('vxlan', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_bgp_address_family = Identityref('bgp-address-family', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_ipv4_unicast = Identityref('ipv4-unicast', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_ipv6_unicast = Identityref('ipv6-unicast', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_l3vpn_ipv4_unicast = Identityref('l3vpn-ipv4-unicast', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_l3vpn_ipv6_unicast = Identityref('l3vpn-ipv6-unicast', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_ipv4_labeled_unicast = Identityref('ipv4-labeled-unicast', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_ipv6_labeled_unicast = Identityref('ipv6-labeled-unicast', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_evpn = Identityref('evpn', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_route_target = Identityref('route-target', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_srte_policy_ipv4 = Identityref('srte-policy-ipv4', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_srte_policy_ipv6 = Identityref('srte-policy-ipv6', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_common_link_state = Identityref('link-state', ns='urn:nokia.com:srlinux:general:common', mod='srl_nokia-common', pfx='srl_nokia-comm')
srl_nokia_interfaces_si_type = Identityref('si-type', ns='urn:nokia.com:srlinux:chassis:interfaces', mod='srl_nokia-interfaces', pfx='srl_nokia-if')
srl_nokia_interfaces_routed = Identityref('routed', ns='urn:nokia.com:srlinux:chassis:interfaces', mod='srl_nokia-interfaces', pfx='srl_nokia-if')
srl_nokia_interfaces_bridged = Identityref('bridged', ns='urn:nokia.com:srlinux:chassis:interfaces', mod='srl_nokia-interfaces', pfx='srl_nokia-if')
srl_nokia_interfaces_local_mirror_dest = Identityref('local-mirror-dest', ns='urn:nokia.com:srlinux:chassis:interfaces', mod='srl_nokia-interfaces', pfx='srl_nokia-if')
srl_nokia_interfaces_transceiver_functional_type = Identityref('transceiver-functional-type', ns='urn:nokia.com:srlinux:chassis:interfaces', mod='srl_nokia-interfaces', pfx='srl_nokia-if')
srl_nokia_interfaces_standard = Identityref('standard', ns='urn:nokia.com:srlinux:chassis:interfaces', mod='srl_nokia-interfaces', pfx='srl_nokia-if')
srl_nokia_interfaces_digital_coherent_optics = Identityref('digital-coherent-optics', ns='urn:nokia.com:srlinux:chassis:interfaces', mod='srl_nokia-interfaces', pfx='srl_nokia-if')
srl_nokia_interfaces_optical_line_system = Identityref('optical-line-system', ns='urn:nokia.com:srlinux:chassis:interfaces', mod='srl_nokia-interfaces', pfx='srl_nokia-if')
srl_nokia_network_instance_ni_type = Identityref('ni-type', ns='urn:nokia.com:srlinux:net-inst:network-instance', mod='srl_nokia-network-instance', pfx='srl_nokia-netinst')
srl_nokia_network_instance_host = Identityref('host', ns='urn:nokia.com:srlinux:net-inst:network-instance', mod='srl_nokia-network-instance', pfx='srl_nokia-netinst')
srl_nokia_network_instance_default = Identityref('default', ns='urn:nokia.com:srlinux:net-inst:network-instance', mod='srl_nokia-network-instance', pfx='srl_nokia-netinst')
srl_nokia_network_instance_ip_vrf = Identityref('ip-vrf', ns='urn:nokia.com:srlinux:net-inst:network-instance', mod='srl_nokia-network-instance', pfx='srl_nokia-netinst')
srl_nokia_network_instance_mac_vrf = Identityref('mac-vrf', ns='urn:nokia.com:srlinux:net-inst:network-instance', mod='srl_nokia-network-instance', pfx='srl_nokia-netinst')
srl_nokia_network_instance_vpws = Identityref('vpws', ns='urn:nokia.com:srlinux:net-inst:network-instance', mod='srl_nokia-network-instance', pfx='srl_nokia-netinst')
srl_nokia_policy_types_bgp_well_known_community = Identityref('bgp-well-known-community', ns='urn:nokia.com:srlinux:general:policy-types', mod='srl_nokia-policy-types', pfx='srl_nokia-pol-types')
srl_nokia_policy_types_no_export = Identityref('no-export', ns='urn:nokia.com:srlinux:general:policy-types', mod='srl_nokia-policy-types', pfx='srl_nokia-pol-types')
srl_nokia_policy_types_no_advertise = Identityref('no-advertise', ns='urn:nokia.com:srlinux:general:policy-types', mod='srl_nokia-policy-types', pfx='srl_nokia-pol-types')
srl_nokia_policy_types_no_export_subconfed = Identityref('no-export-subconfed', ns='urn:nokia.com:srlinux:general:policy-types', mod='srl_nokia-policy-types', pfx='srl_nokia-pol-types')


def src_yang():
    res = []
    res.append(r"""module ietf-yang-types {

  namespace "urn:ietf:params:xml:ns:yang:ietf-yang-types";
  prefix "yang";

  organization
   "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
   "WG Web:   <http://tools.ietf.org/wg/netmod/>
    WG List:  <mailto:netmod@ietf.org>

    WG Chair: David Kessens
              <mailto:david.kessens@nsn.com>

    WG Chair: Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>

    Editor:   Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>";

  description
   "This module contains a collection of generally useful derived
    YANG data types.

    Copyright (c) 2013 IETF Trust and the persons identified as
    authors of the code.  All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, is permitted pursuant to, and subject
    to the license terms contained in, the Simplified BSD License
    set forth in Section 4.c of the IETF Trust's Legal Provisions
    Relating to IETF Documents
    (http://trustee.ietf.org/license-info).

    This version of this YANG module is part of RFC 6991; see
    the RFC itself for full legal notices.";

  revision 2013-07-15 {
    description
     "This revision adds the following new data types:
      - yang-identifier
      - hex-string
      - uuid
      - dotted-quad";
    reference
     "RFC 6991: Common YANG Data Types";
  }

  revision 2010-09-24 {
    description
     "Initial revision.";
    reference
     "RFC 6021: Common YANG Data Types";
  }

  /*** collection of counter and gauge types ***/

  typedef counter32 {
    type uint32;
    description
     "The counter32 type represents a non-negative integer
      that monotonically increases until it reaches a
      maximum value of 2^32-1 (4294967295 decimal), when it
      wraps around and starts increasing again from zero.

      Counters have no defined 'initial' value, and thus, a
      single value of a counter has (in general) no information
      content.  Discontinuities in the monotonically increasing
      value normally occur at re-initialization of the
      management system, and at other times as specified in the
      description of a schema node using this type.  If such
      other times can occur, for example, the creation of
      a schema node of type counter32 at times other than
      re-initialization, then a corresponding schema node
      should be defined, with an appropriate type, to indicate
      the last discontinuity.

      The counter32 type should not be used for configuration
      schema nodes.  A default statement SHOULD NOT be used in
      combination with the type counter32.

      In the value set and its semantics, this type is equivalent
      to the Counter32 type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef zero-based-counter32 {
    type yang:counter32;
    default "0";
    description
     "The zero-based-counter32 type represents a counter32
      that has the defined 'initial' value zero.

      A schema node of this type will be set to zero (0) on creation
      and will thereafter increase monotonically until it reaches
      a maximum value of 2^32-1 (4294967295 decimal), when it
      wraps around and starts increasing again from zero.

      Provided that an application discovers a new schema node
      of this type within the minimum time to wrap, it can use the
      'initial' value as a delta.  It is important for a management
      station to be aware of this minimum time and the actual time
      between polls, and to discard data if the actual time is too
      long or there is no defined minimum time.

      In the value set and its semantics, this type is equivalent
      to the ZeroBasedCounter32 textual convention of the SMIv2.";
    reference
      "RFC 4502: Remote Network Monitoring Management Information
                 Base Version 2";
  }

  typedef counter64 {
    type uint64;
    description
     "The counter64 type represents a non-negative integer
      that monotonically increases until it reaches a
      maximum value of 2^64-1 (18446744073709551615 decimal),
      when it wraps around and starts increasing again from zero.

      Counters have no defined 'initial' value, and thus, a
      single value of a counter has (in general) no information
      content.  Discontinuities in the monotonically increasing
      value normally occur at re-initialization of the
      management system, and at other times as specified in the
      description of a schema node using this type.  If such
      other times can occur, for example, the creation of
      a schema node of type counter64 at times other than
      re-initialization, then a corresponding schema node
      should be defined, with an appropriate type, to indicate
      the last discontinuity.

      The counter64 type should not be used for configuration
      schema nodes.  A default statement SHOULD NOT be used in
      combination with the type counter64.

      In the value set and its semantics, this type is equivalent
      to the Counter64 type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef zero-based-counter64 {
    type yang:counter64;
    default "0";
    description
     "The zero-based-counter64 type represents a counter64 that
      has the defined 'initial' value zero.

      A schema node of this type will be set to zero (0) on creation
      and will thereafter increase monotonically until it reaches
      a maximum value of 2^64-1 (18446744073709551615 decimal),
      when it wraps around and starts increasing again from zero.

      Provided that an application discovers a new schema node
      of this type within the minimum time to wrap, it can use the
      'initial' value as a delta.  It is important for a management
      station to be aware of this minimum time and the actual time
      between polls, and to discard data if the actual time is too
      long or there is no defined minimum time.

      In the value set and its semantics, this type is equivalent
      to the ZeroBasedCounter64 textual convention of the SMIv2.";
    reference
     "RFC 2856: Textual Conventions for Additional High Capacity
                Data Types";
  }

  typedef gauge32 {
    type uint32;
    description
     "The gauge32 type represents a non-negative integer, which
      may increase or decrease, but shall never exceed a maximum
      value, nor fall below a minimum value.  The maximum value
      cannot be greater than 2^32-1 (4294967295 decimal), and
      the minimum value cannot be smaller than 0.  The value of
      a gauge32 has its maximum value whenever the information
      being modeled is greater than or equal to its maximum
      value, and has its minimum value whenever the information
      being modeled is smaller than or equal to its minimum value.
      If the information being modeled subsequently decreases
      below (increases above) the maximum (minimum) value, the
      gauge32 also decreases (increases).

      In the value set and its semantics, this type is equivalent
      to the Gauge32 type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef gauge64 {
    type uint64;
    description
     "The gauge64 type represents a non-negative integer, which
      may increase or decrease, but shall never exceed a maximum
      value, nor fall below a minimum value.  The maximum value
      cannot be greater than 2^64-1 (18446744073709551615), and
      the minimum value cannot be smaller than 0.  The value of
      a gauge64 has its maximum value whenever the information
      being modeled is greater than or equal to its maximum
      value, and has its minimum value whenever the information
      being modeled is smaller than or equal to its minimum value.
      If the information being modeled subsequently decreases
      below (increases above) the maximum (minimum) value, the
      gauge64 also decreases (increases).

      In the value set and its semantics, this type is equivalent
      to the CounterBasedGauge64 SMIv2 textual convention defined
      in RFC 2856";
    reference
     "RFC 2856: Textual Conventions for Additional High Capacity
                Data Types";
  }

  /*** collection of identifier-related types ***/

  typedef object-identifier {
    type string {
      pattern '(([0-1](\.[1-3]?[0-9]))|(2\.(0|([1-9]\d*))))'
            + '(\.(0|([1-9]\d*)))*';
    }
    description
     "The object-identifier type represents administratively
      assigned names in a registration-hierarchical-name tree.

      Values of this type are denoted as a sequence of numerical
      non-negative sub-identifier values.  Each sub-identifier
      value MUST NOT exceed 2^32-1 (4294967295).  Sub-identifiers
      are separated by single dots and without any intermediate
      whitespace.

      The ASN.1 standard restricts the value space of the first
      sub-identifier to 0, 1, or 2.  Furthermore, the value space
      of the second sub-identifier is restricted to the range
      0 to 39 if the first sub-identifier is 0 or 1.  Finally,
      the ASN.1 standard requires that an object identifier
      has always at least two sub-identifiers.  The pattern
      captures these restrictions.

      Although the number of sub-identifiers is not limited,
      module designers should realize that there may be
      implementations that stick with the SMIv2 limit of 128
      sub-identifiers.

      This type is a superset of the SMIv2 OBJECT IDENTIFIER type
      since it is not restricted to 128 sub-identifiers.  Hence,
      this type SHOULD NOT be used to represent the SMIv2 OBJECT
      IDENTIFIER type; the object-identifier-128 type SHOULD be
      used instead.";
    reference
     "ISO9834-1: Information technology -- Open Systems
      Interconnection -- Procedures for the operation of OSI
      Registration Authorities: General procedures and top
      arcs of the ASN.1 Object Identifier tree";
  }

  typedef object-identifier-128 {
    type object-identifier {
      pattern '\d*(\.\d*){1,127}';
    }
    description
     "This type represents object-identifiers restricted to 128
      sub-identifiers.

      In the value set and its semantics, this type is equivalent
      to the OBJECT IDENTIFIER type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef yang-identifier {
    type string {
      length "1..max";
      pattern '[a-zA-Z_][a-zA-Z0-9\-_.]*';
      pattern '.|..|[^xX].*|.[^mM].*|..[^lL].*';
    }
    description
      "A YANG identifier string as defined by the 'identifier'
       rule in Section 12 of RFC 6020.  An identifier must
       start with an alphabetic character or an underscore
       followed by an arbitrary sequence of alphabetic or
       numeric characters, underscores, hyphens, or dots.

       A YANG identifier MUST NOT start with any possible
       combination of the lowercase or uppercase character
       sequence 'xml'.";
    reference
      "RFC 6020: YANG - A Data Modeling Language for the Network
                 Configuration Protocol (NETCONF)";
  }

  /*** collection of types related to date and time***/

  typedef date-and-time {
    type string {
      pattern '\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?'
            + '(Z|[\+\-]\d{2}:\d{2})';
    }
    description
     "The date-and-time type is a profile of the ISO 8601
      standard for representation of dates and times using the
      Gregorian calendar.  The profile is defined by the
      date-time production in Section 5.6 of RFC 3339.

      The date-and-time type is compatible with the dateTime XML
      schema type with the following notable exceptions:

      (a) The date-and-time type does not allow negative years.

      (b) The date-and-time time-offset -00:00 indicates an unknown
          time zone (see RFC 3339) while -00:00 and +00:00 and Z
          all represent the same time zone in dateTime.

      (c) The canonical format (see below) of data-and-time values
          differs from the canonical format used by the dateTime XML
          schema type, which requires all times to be in UTC using
          the time-offset 'Z'.

      This type is not equivalent to the DateAndTime textual
      convention of the SMIv2 since RFC 3339 uses a different
      separator between full-date and full-time and provides
      higher resolution of time-secfrac.

      The canonical format for date-and-time values with a known time
      zone uses a numeric time zone offset that is calculated using
      the device's configured known offset to UTC time.  A change of
      the device's offset to UTC time will cause date-and-time values
      to change accordingly.  Such changes might happen periodically
      in case a server follows automatically daylight saving time
      (DST) time zone offset changes.  The canonical format for
      date-and-time values with an unknown time zone (usually
      referring to the notion of local time) uses the time-offset
      -00:00.";
    reference
     "RFC 3339: Date and Time on the Internet: Timestamps
      RFC 2579: Textual Conventions for SMIv2
      XSD-TYPES: XML Schema Part 2: Datatypes Second Edition";
  }

  typedef timeticks {
    type uint32;
    description
     "The timeticks type represents a non-negative integer that
      represents the time, modulo 2^32 (4294967296 decimal), in
      hundredths of a second between two epochs.  When a schema
      node is defined that uses this type, the description of
      the schema node identifies both of the reference epochs.

      In the value set and its semantics, this type is equivalent
      to the TimeTicks type of the SMIv2.";
    reference
     "RFC 2578: Structure of Management Information Version 2
                (SMIv2)";
  }

  typedef timestamp {
    type yang:timeticks;
    description
     "The timestamp type represents the value of an associated
      timeticks schema node at which a specific occurrence
      happened.  The specific occurrence must be defined in the
      description of any schema node defined using this type.  When
      the specific occurrence occurred prior to the last time the
      associated timeticks attribute was zero, then the timestamp
      value is zero.  Note that this requires all timestamp values
      to be reset to zero when the value of the associated timeticks
      attribute reaches 497+ days and wraps around to zero.

      The associated timeticks schema node must be specified
      in the description of any schema node using this type.

      In the value set and its semantics, this type is equivalent
      to the TimeStamp textual convention of the SMIv2.";
    reference
     "RFC 2579: Textual Conventions for SMIv2";
  }

  /*** collection of generic address types ***/

  typedef phys-address {
    type string {
      pattern '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?';
    }

    description
     "Represents media- or physical-level addresses represented
      as a sequence octets, each octet represented by two hexadecimal
      numbers.  Octets are separated by colons.  The canonical
      representation uses lowercase characters.

      In the value set and its semantics, this type is equivalent
      to the PhysAddress textual convention of the SMIv2.";
    reference
     "RFC 2579: Textual Conventions for SMIv2";
  }

  typedef mac-address {
    type string {
      pattern '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}';
    }
    description
     "The mac-address type represents an IEEE 802 MAC address.
      The canonical representation uses lowercase characters.

      In the value set and its semantics, this type is equivalent
      to the MacAddress textual convention of the SMIv2.";
    reference
     "IEEE 802: IEEE Standard for Local and Metropolitan Area
                Networks: Overview and Architecture
      RFC 2579: Textual Conventions for SMIv2";
  }

  /*** collection of XML-specific types ***/

  typedef xpath1.0 {
    type string;
    description
     "This type represents an XPATH 1.0 expression.

      When a schema node is defined that uses this type, the
      description of the schema node MUST specify the XPath
      context in which the XPath expression is evaluated.";
    reference
     "XPATH: XML Path Language (XPath) Version 1.0";
  }

  /*** collection of string types ***/

  typedef hex-string {
    type string {
      pattern '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?';
    }
    description
     "A hexadecimal string with octets represented as hex digits
      separated by colons.  The canonical representation uses
      lowercase characters.";
  }

  typedef uuid {
    type string {
      pattern '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-'
            + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}';
    }
    description
     "A Universally Unique IDentifier in the string representation
      defined in RFC 4122.  The canonical representation uses
      lowercase characters.

      The following is an example of a UUID in string representation:
      f81d4fae-7dec-11d0-a765-00a0c91e6bf6
      ";
    reference
     "RFC 4122: A Universally Unique IDentifier (UUID) URN
                Namespace";
  }

  typedef dotted-quad {
    type string {
      pattern
        '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
      + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
    }
    description
      "An unsigned 32-bit number expressed in the dotted-quad
       notation, i.e., four octets written as decimal numbers
       and separated with the '.' (full stop) character.";
  }
}
""")
    res.append(r"""module srl_nokia-bgp-evpn {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:net-inst:bgp-evpn";
  prefix srl_nokia-bgp-evpn;

  import srl_nokia-common {
    prefix srl_nokia-comm;
  }
  import srl_nokia-network-instance {
    prefix srl_nokia-netinst;
  }
  import srl_nokia-extensions {
    prefix srl_nokia-ext;
  }
  import srl_nokia-bgp-vpn {
    prefix srl_bgp-vpn;
  }
  import srl_nokia-bgp {
    prefix srl-bgp;
  }
  import srl_nokia-routing-policy {
    prefix srl_nokia-routing-pol;
  }
  import srl_nokia-features {
    prefix srl_nokia-feat;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "This yang file models configuration and state of the bgp-evpn protocol";

  revision 2024-10-31 {
    description
      "SRLinux 24.10.1";
  }
  revision 2024-07-31 {
    description
      "SRLinux 24.7.1";
  }
  revision 2024-03-31 {
    description
      "SRLinux 24.3.1";
  }
  revision 2023-07-31 {
    description
      "SRLinux 23.7.1";
  }
  revision 2023-03-31 {
    description
      "SRLinux 23.3.1";
  }
  revision 2022-06-30 {
    description
      "SRLinux 22.6.1";
  }
  revision 2022-03-31 {
    description
      "SRLinux 22.3.1";
  }
  revision 2021-11-30 {
    description
      "SRLinux 21.11.1";
  }
  revision 2021-03-31 {
    description
      "SRLinux 21.3.1";
  }

  grouping bgp-evpn-top {
    description
      "Top-level grouping containing the bgp-evpn configuration and state.";
    list bgp-instance {
      key "id";
      max-elements 1;
      description
        "bgp evpn instances configured in net-instance";
      leaf id {
        type uint8 {
          range "1..2";
        }
        description
          "The index of the bgp-vpn instance";
      }
      leaf admin-state {
        type srl_nokia-comm:admin-state;
        default "enable";
        description
          "Configurable state of the bgp evpn instance.";
      }
      leaf vxlan-interface {
        if-feature "srl_nokia-feat:vxlan";
        must "../encapsulation-type = 'vxlan'" {
          error-message "supported only when encapsulation is vxlan";
        }
        type leafref {
          path "../../../../srl_nokia-netinst:vxlan-interface/srl_nokia-netinst:name";
        }
        description
          "Identifier of vxlan-interface used in this bgp-instance.";
      }
      leaf evi {
        type srl_nokia-comm:evi;
        description
          "EVPN Instance identifier associated to the bgp-evpn instance.

           Used for auto-derivation of:
           - the bgp-instance route distinguisher in the format <ip-address>:evi (where 'ip-address' is the ipv4 address
             associated to the subinterface lo0.1.
           - the bgp-instance route target in the format <asn>:<evi>, where 'asn' is the autonomous-system configured in
             the network-instance default (under /protocols/bgp/autonomous-system).

           In addition, the evi value is used for the EVPN Multi-Homing Designated Forwarder (DF) Election.";
        mandatory true;
      }
    }
  }

  augment "/srl_nokia-netinst:network-instance/srl_nokia-netinst:protocols/srl_nokia-netinst:bgp-evpn" {
    uses bgp-evpn-top;
  }
}
""")
    res.append(r"""module srl_nokia-bgp-vpn {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:bgp:bgp-vpn";
  prefix srl_nokia-bgp-vpn;

  import srl_nokia-common {
    prefix srl_nokia-comm;
  }
  import srl_nokia-features {
    prefix srl_nokia-feat;
  }
  import srl_nokia-network-instance {
    prefix srl_nokia-netinst;
  }
  import srl_nokia-extensions {
    prefix srl_nokia-ext;
  }
  import srl_nokia-policy-types {
    prefix srl_nokia-pol-types;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "This yang file models configuration and state of the bgp-vpn protocols (EVPN and IPVPN).";

  revision 2025-03-31 {
    description
      "SRLinux 2025.3.1";
  }
  revision 2024-10-31 {
    description
      "SRLinux 24.10.1";
  }
  revision 2024-07-31 {
    description
      "SRLinux 24.7.1";
  }
  revision 2024-03-31 {
    description
      "SRLinux 24.3.1";
  }
  revision 2023-10-31 {
    description
      "SRLinux 23.10.1";
  }
  revision 2022-06-30 {
    description
      "SRLinux 22.6.1";
  }
  revision 2021-03-31 {
    description
      "SRLinux 21.3.1";
  }

  grouping bgp-vpn-top {
    description
      "Top-level grouping containing a list of bgp-vpn instances.";
    container bgp-vpn {
      description
        "Top-level configuration and operational state for common bgp-ipvpn and bgp-evpn parameters";
      presence "Configuration and state of bgp-vpn.";
      must '(/srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../srl_nokia-netinst:name]/srl_nokia-netinst:type != "srl_nokia-netinst:default")' {
        error-message "The bgp-vpn configuration is not possible on network-instance of type default.";
      }
      must '(/srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../srl_nokia-netinst:name]/srl_nokia-netinst:type != "srl_nokia-netinst:host")' {
        error-message "The bgp-vpn configuration is not possible on network-instance of type host.";
      }
      list bgp-instance {
        key "id";
        max-elements 2;
        description
          "List of bgp-vpn instances configured in the network-instance. Only one instance allowed in the current release.";
        leaf id {
          type uint8 {
            range "1..2";
          }
          description
            "The index of the bgp-vpn instance";
        }
        container route-distinguisher {
          description
            "Route Distinguisher (RD) of the bgp-vpn instance.";
          leaf rd {
            srl_nokia-ext:show-importance "high";
            type srl_nokia-comm:route-distinguisher;
            description
              "Route Distinguisher (RD) in the bgp-vpn instance. When used for evpn and if not configured, the RD is auto-derived
               as <ip-address>:<evi> where 'ip-address' is the ipv4 address associated to the subinterface lo0.1.";
            must 'not(starts-with(string(.), "0:"))' {
              error-message "invalid value 0:*";
            }
            must 'not(starts-with(string(.), "0.0:"))' {
              error-message "invalid value 0.0:*";
            }
            must 'not(starts-with(string(.), "0.0.0.0:") and (number(substring-after(string(.), ":")) < 513))' {
              error-message "route-distinguisher value reserved";
            }
          }
          leaf route-distinguisher-origin {
            config false;
            srl_nokia-ext:show-importance "high";
            type enumeration {
              enum auto-derived-from-evi;
              enum auto-derived-from-system-ip:0;
              enum manual;
              enum none;
            }
            description
              "Origin of the operational Route Distinguisher (RD) of the bgp-vpn instance.

                'Auto-derived-from-evi' refers to an RD that is automatically allocated with the format <ip-address>:<evi>
                where 'ip-address' is the ipv4 address associated to the subinterface lo0.1.
                'Auto-derived-from-system-ip:0' refers to the RD for the EVPN Ethernet Segment routes that is automatically allocated with the format <ip-address>:0
                where 'ip-address' is the ipv4 address associated to the subinterface lo0.1.
                'Manual' refers to an RD that is configured.
                'None' indicates that the RD is neither configured nor auto-derived.";
          }
        }
        container route-target {
          description
            "Route Target (RT) of the bgp-vpn instance.";
          leaf export-rt {
            srl_nokia-ext:show-importance "high";
            type srl_nokia-pol-types:bgp-ext-community-type;
            must "starts-with(.,'target')";
            description
              "Export Route Target (RT) in the bgp-vpn instance. When used for evpn and if not configured, the RT is auto-derived
               with the format <asn>:<evi> where 'asn' is the autonomous-system configured in the network-instance default.";
          }
          leaf import-rt {
            srl_nokia-ext:show-importance "high";
            type srl_nokia-pol-types:bgp-ext-community-type;
            must "starts-with(.,'target')";
            description
              "Import Route Target (RT) in the bgp-vpn instance. When used for evpn and if not configured, the RT is
               auto-derived with the format <asn>:<evi> where 'asn' is the autonomous-system configured in the network-instance default.";
          }
        }
      }
    }
  }

  augment "/srl_nokia-netinst:network-instance/srl_nokia-netinst:protocols" {
    uses bgp-vpn-top;
  }
}
""")
    res.append(r"""module srl_nokia-bgp {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:bgp:bgp";
  prefix srl_nokia-bgp;

  import srl_nokia-common {
    prefix srl_nokia-comm;
  }
  import srl_nokia-network-instance {
    prefix srl_nokia-netinst;
  }
  import srl_nokia-segment-routing {
    prefix srl_nokia-sr;
  }
  import srl_nokia-extensions {
    prefix srl_nokia-ext;
  }
  import srl_nokia-routing-policy {
    prefix srl-rpol;
  }
  import srl_nokia-system {
    prefix srl_nokia-system;
  }
  import srl_nokia-system-protocols {
    prefix srl_nokia-system-protocols;
  }
  import srl_nokia-keychains {
    prefix srl-keychain;
  }
  import srl_nokia-features {
    prefix srl_nokia-feat;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "This yang file models configuration and state of the BGP protocol";

  revision 2025-03-31 {
    description
      "SRLinux 2025.3.1";
  }
  revision 2024-10-31 {
    description
      "SRLinux 24.10.1";
  }
  revision 2024-07-31 {
    description
      "SRLinux 24.7.1";
  }
  revision 2024-03-31 {
    description
      "SRLinux 24.3.1";
  }
  revision 2023-10-31 {
    description
      "SRLinux 23.10.1";
  }
  revision 2023-07-31 {
    description
      "SRLinux 23.7.1";
  }
  revision 2023-03-31 {
    description
      "SRLinux 23.3.1";
  }
  revision 2022-11-30 {
    description
      "SRLinux 22.11.1";
  }
  revision 2022-06-30 {
    description
      "SRLinux 22.6.1";
  }
  revision 2022-03-31 {
    description
      "SRLinux 22.3.1";
  }
  revision 2021-11-30 {
    description
      "SRLinux 21.11.1";
  }
  revision 2021-06-30 {
    description
      "SRLinux 21.6.1";
  }
  revision 2021-03-31 {
    description
      "SRLinux 21.3.1";
  }
  revision 2020-06-30 {
    description
      "SRLinux 20.6.1";
  }
  revision 2019-11-30 {
    description
      "SRLinux 19.11.1";
  }

  typedef ip-ecmp {
    description
      "The supported range of ECMP values for IP routes.";
    type uint32 {
      range "1..256";
    }
  }

  typedef percentage {
    type uint8 {
      range "0..100";
    }
    description
      "Integer indicating a percentage value";
  }

  typedef community-type {
    type enumeration {
      enum none {
        description
          "Send no communities";
      }
      enum standard {
        description
          "Send standard communities";
      }
      enum extended {
        description
          "Send extended communities";
      }
      enum large {
        description
          "Send large communities";
      }
    }
    description
      "Type describing variations of community attributes

       standard: standard BGP community [rfc1997]
       extended: extended BGP community [rfc4360]
       large: large BGP community [rfc8092]";
  }

  typedef cluster-id-type {
    type union {
      type uint32 {
        range "1..max" {
          error-message "cluster-id cannot be 0";
        }
      }
      type srl_nokia-comm:dotted-quad {
        pattern '^[0.]+$' {
          modifier "invert-match";
          error-message "cluster-id must be IPv4 address different than 0.0.0.0";
        }
      }
    }
  }

  typedef default-policy-type {
    type enumeration {
      enum accept {
        description
          "Accept all non-matching routes";
      }
      enum reject {
        description
          "Reject all non-matching routes";
      }
    }
    description
      "Type used to specify the processing for routes not matched by any of the applicable policies";
  }

  grouping bgp-group {
    list group {
      key "group-name";
      description
        "Peer group templates";
      leaf group-name {
        type srl_nokia-comm:name {
          length "1..64";
        }
        description
          "The configured name of the peer group";
      }
      leaf admin-state {
        type srl_nokia-comm:admin-state;
        default "enable";
        must ". = 'disable' or
              (((not(../afi-safi[afi-safi-name='ipv4-unicast']/admin-state) and ../../afi-safi[afi-safi-name='ipv4-unicast']/admin-state = 'enable') or (../afi-safi[afi-safi-name='ipv4-unicast']/admin-state = 'enable')) or
              ((not(../afi-safi[afi-safi-name='ipv6-unicast']/admin-state) and ../../afi-safi[afi-safi-name='ipv6-unicast']/admin-state = 'enable') or (../afi-safi[afi-safi-name='ipv6-unicast']/admin-state = 'enable')) or
              ((not(../afi-safi[afi-safi-name='evpn']/admin-state) and ../../afi-safi[afi-safi-name='evpn']/admin-state = 'enable') or (../afi-safi[afi-safi-name='evpn']/admin-state = 'enable')) or
              ((not(../afi-safi[afi-safi-name='l3vpn-ipv4-unicast']/admin-state) and ../../afi-safi[afi-safi-name='l3vpn-ipv4-unicast']/admin-state = 'enable') or (../afi-safi[afi-safi-name='l3vpn-ipv4-unicast']/admin-state = 'enable')) or
              ((not(../afi-safi[afi-safi-name='l3vpn-ipv6-unicast']/admin-state) and ../../afi-safi[afi-safi-name='l3vpn-ipv6-unicast']/admin-state = 'enable') or (../afi-safi[afi-safi-name='l3vpn-ipv6-unicast']/admin-state = 'enable')) or
              ((not(../afi-safi[afi-safi-name='ipv4-labeled-unicast']/admin-state) and ../../afi-safi[afi-safi-name='ipv4-labeled-unicast']/admin-state = 'enable') or (../afi-safi[afi-safi-name='ipv4-labeled-unicast']/admin-state = 'enable')) or
              ((not(../afi-safi[afi-safi-name='ipv6-labeled-unicast']/admin-state) and ../../afi-safi[afi-safi-name='ipv6-labeled-unicast']/admin-state = 'enable') or (../afi-safi[afi-safi-name='ipv6-labeled-unicast']/admin-state = 'enable')) or
              ((not(../afi-safi[afi-safi-name='route-target']/admin-state) and ../../afi-safi[afi-safi-name='route-target']/admin-state = 'enable') or (../afi-safi[afi-safi-name='route-target']/admin-state = 'enable')) or
              ((not(../afi-safi[afi-safi-name='srte-policy-ipv4']/admin-state) and ../../afi-safi[afi-safi-name='srte-policy-ipv4']/admin-state = 'enable') or (../afi-safi[afi-safi-name='srte-policy-ipv4']/admin-state = 'enable')) or
              ((not(../afi-safi[afi-safi-name='srte-policy-ipv6']/admin-state) and ../../afi-safi[afi-safi-name='srte-policy-ipv6']/admin-state = 'enable') or (../afi-safi[afi-safi-name='srte-policy-ipv6']/admin-state = 'enable')) or
              ((not(../afi-safi[afi-safi-name='link-state']/admin-state) and ../../afi-safi[afi-safi-name='link-state']/admin-state = 'enable') or (../afi-safi[afi-safi-name='link-state']/admin-state = 'enable')))" {
          error-message "One of the address families must be enabled.";
        }
        description
          "Administratively enable or disable the peer group

           Disable will tear down all the BGP sessions in the group, even if they are administratively enabled at the neighbor level.";
      }
      leaf description {
        type srl_nokia-comm:description;
        description
          "A user provided description string for the peer group";
      }
      leaf local-preference {
        type uint32;
        description
          "The value of the local-preference attribute that is added to received routes from EBGP peers in the group

           It is also used to encode the local preference attribute for locally generated BGP routes.";
      }
      leaf next-hop-self {
        type boolean;
        default "false";
        description
          "When set to true, the next-hop in all IPv4-unicast, IPv6-unicast, EVPN, VPN-IPv4 and VPN-IPv6 BGP routes advertised to all IBGP peers in the peer-group is set equal to the local-address used on each session (or to the router ID if the NLRI is IPv6 and there is no IPv6 local address to use). This is independent of the route origin (EBGP, IBGP-client, IBGP-non-client or redistributed direct/static/aggregate route).

           When set to false, normal BGP rules from RFC 4271 apply.";
      }
      leaf peer-as {
        srl_nokia-ext:show-importance "high";
        type srl_nokia-comm:as-number;
        description
          "The autonomous system number expected from each peer in the group

           A configured session with a peer does not come up if this value does not match the AS value reported by the peer in its OPEN message.";
      }
      container as-path-options {
        description
          "Options for handling the AS_PATH in received BGP routes";
        leaf allow-own-as {
          type uint8;
          description
            "The maximum number of times the global AS number or a local AS number of the BGP instance can appear in any received AS_PATH before it is considered a loop and considered invalid

             When this value is changed the new value applies only to the routes received after the change is committed.";
        }
        container remove-private-as {
          presence "Configure remove-private-as";
          description
            "Container with options for removing private AS numbers (2-byte and 4-byte) from the advertised AS path towards all peers";
          leaf mode {
            description
              "The method by which private AS numbers are removed from the advertised AS_PATH attribute";
            type enumeration {
              enum disabled {
                description
                  "Do not strip or replace any private AS numbers";
              }
              enum delete {
                description
                  "Delete private AS numbers, shortening the AS path";
              }
              enum replace {
                description
                  "Replace private AS numbers with the local AS number used towards the peer, maintaining the AS path length";
              }
            }
            mandatory true;
          }
          leaf leading-only {
            description
              "If set to true then only delete or replace private AS numbers that appear before the first occurrence of a non-private ASN in the sequence of most recent ASNs in the AS path";
            type boolean;
            default "false";
            must "not(../mode = 'disabled' and . = true())" {
              error-message "mode should not be disabled to set leading-only to true.";
            }
          }
          leaf ignore-peer-as {
            description
              "If set to true then do not delete or replace a private AS number that is the same as the peer AS number";
            type boolean;
            default "false";
            must "not(../mode = 'disabled' and . = true())" {
              error-message "mode should not be disabled to set ignore-peer-as to true.";
            }
          }
        }
        leaf replace-peer-as {
          description
            "If set to true then replace every occurrence of the peer AS number that is present in the advertised AS path with the local AS number used towards the peer";
          type boolean;
        }
      }
      container authentication {
        description
          "Container with authentication options that apply to all peers in this peer-group";
        leaf keychain {
          description
            "Reference to a keychain. The keychain type must be tcp-md5.";
          type leafref {
            path "/srl_nokia-system:system/srl-keychain:authentication/srl-keychain:keychain/srl-keychain:name";
          }
          must '/srl_nokia-system:system/srl-keychain:authentication/srl-keychain:keychain[srl-keychain:name = current()]'
             + '/srl-keychain:type = "tcp-md5"' {
            error-message "Only keychain of type tcp-md5 can be assigned";
          }
        }
        leaf password {
          if-feature "srl_nokia-feat:bgp-auth-password";
          description
            "Configures an MD5 authentication password for use with neighboring devices.";
          type srl_nokia-comm:routing-password;
          must 'boolean(../keychain) = false()' {
            error-message "Can not assign both keychain and password";
          }
        }
      }
      container failure-detection {
        description
          "Options related to methods of detecting BGP session failure";
        leaf enable-bfd {
          if-feature "srl_nokia-feat:bfd";
          type boolean;
          description
            "The true setting enables Bi-directional Forwarding Detection on BGP sessions belonging to the peer group";
        }
        leaf fast-failover {
          type boolean;
          description
            "The true setting causes EBGP and IBGP sessions in the peer group to drop immediately (and not wait for hold timer expiry) when the local interface that they depend upon for neighbor reachability goes down";
        }
      }
      container multihop {
        description
          "Configuration parameters specifying the multihop behaviour for IBGP and EBGP peers in the peer group.";
        leaf admin-state {
          type srl_nokia-comm:admin-state;
          description
            "When enabled, IBGP and EBGP peers in the group are allowed to be indirectly connected by up to N hops, where N is controlled by the maximum-hops parameter. When disabled, only IBGP peers within the peer group support multihop.

             This can be overriden on a per neighbor basis. It is inherited by neighbors in the peer-group only if maximum-hops is also specified.

             By default this is disabled.";
        }
        leaf maximum-hops {
          type uint8 {
            range "1..255";
          }
          description
            "This sets the maximum number of routing hops towards each peer. It determines the IP TTL value in originated BGP TCP/IP packets. By default the TTL is set to 1 towards EBGP peers and 64 towards IBGP peers. This leaf sets a new IP TTL to use towards both EBGP and IBGP peers in the peer group.

             This can be overriden on a per neighbor basis. It is inherited by neighbors in the peer-group only if admin-state is also specified.";
        }
      }
      list afi-safi {
        key "afi-safi-name";
        description
          "List of address families supported by the BGP peer group";
        leaf afi-safi-name {
          type identityref {
            base srl_nokia-comm:bgp-address-family;
          }
          description
            "The name of a BGP address family, which translates to a specific AFI value and a specific SAFI value";
          must "not(. = 'evpn') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "EVPN is not supported in network instances other than default";
          }
          must "not(. = 'l3vpn-ipv4-unicast') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "L3VPN is not supported in network instances other than default";
          }
          must "not(. = 'l3vpn-ipv6-unicast') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "L3VPN is not supported in network instances other than default";
          }
          must "not(. = 'ipv4-labeled-unicast') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "Label-ipv4 is not supported in network instances other than default";
          }
          must "not(. = 'ipv6-labeled-unicast') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "Label-ipv6 is not supported in network instances other than default";
          }
          must "not(. = 'route-target') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "route-target is not supported in network instances other than default";
          }
          must "not(. = 'srte-policy-ipv4') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "srte-policy-ipv4 is not supported in network instances other than default";
          }
          must "not(. = 'srte-policy-ipv6') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "srte-policy-ipv6 is not supported in network instances other than default";
          }
          must "not(. = 'link-state') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "link-state is not supported in network instances other than default";
          }
        }
        leaf admin-state {
          type srl_nokia-comm:admin-state;
          description
            "This leaf indicates whether the AFI-SAFI is enabled for the peer group";
        }
      }
      container local-as {
        description
          "Options related to the local autonomous-system number advertised by this router to its peers";
        leaf as-number {
          type srl_nokia-comm:as-number;
          description
            "The local autonomous system number used to override the global ASN on this group of BGP sessions

             Sets the ASN value that this router sends in its OPEN message towards its peer in the group.";
        }
        leaf prepend-global-as {
          type boolean;
          description
            "When set to true, the global ASN value is prepended to the AS path in outbound routes towards each BGP peer in the group

             If a session is EBGP (peer-as is not equal to the local-as) then the local-as is prepended as the final step, so that the local-as is the first element in the AS_PATH received by the peer.";
          must '../as-number' {
            error-message "must have as-number to set prepend-global-as";
          }
        }
        leaf prepend-local-as {
          type boolean;
          description
            "When set to true, the local AS value is prepended to the AS path of inbound routes from each EBGP peer belonging to the group";
          must '../as-number' {
            error-message "must have as-number to set prepend-local-as";
          }
        }
      }
      leaf route-flap-damping {
        if-feature "srl_nokia-feat:bgp-route-flap-damping";
        description
          "Enable/disable route flap damping procedures for routes received from EBGP peers in the peer group

           This has no effect on routes received from IBGP peers within the peer group.";
        type boolean;
        default "false";
      }
      container route-reflector {
        description
          "Container with route reflection configuration options.";
        leaf client {
          description
            "When this is set to true all configured and dynamic BGP sessions that belong to the peer-group are considered RR clients.";
          type boolean;
        }
        leaf cluster-id {
          description
            "The cluster-id to insert into the CLUSTER_LIST attribute when reflecting routes received by or sent to each client in the peer-group. The default is inherited from instance level configuration.";
          type cluster-id-type;
        }
      }
      container send-community {
        if-feature "not srl_nokia-feat:bgp-send-community-leaflist";
        description
          "Options for controlling the sending of BGP communities to peers in the group";
        leaf standard {
          type boolean;
          description
            "The false setting causes BGP to strip all standard (4 byte) communities from all outbound routes advertised to each peer in the group";
        }
        leaf large {
          type boolean;
          description
            "The false setting causes BGP to strip all large (12 byte) BGP communities from all outbound routes advertised to each peer in the group";
        }
      }
      container send-default-route {
        description
          "Options for controlling the generation of default routes towards group peers";
        leaf ipv4-unicast {
          type boolean;
          default "false";
          description
            "Enables the sending of a synthetically generated default IPv4 route [0/0] to each peer in the group";
        }
        leaf ipv6-unicast {
          type boolean;
          default "false";
          description
            "Enables the sending of a synthetically generated default IPv6 route [::/0] to each peer in the group";
        }
        leaf export-policy {
          type leafref {
            path "/srl-rpol:routing-policy/srl-rpol:policy/srl-rpol:name";
          }
          description
            "The name of a policy that should be applied to the advertised default routes, in order to set their attributes to non-default values

             Only the default-action of this policy is parsed and applied.";
        }
      }
    }
  }

  grouping bgp-neighbor {
    list neighbor {
      description
        "Create a configured BGP session";
      key "peer-address";
      leaf peer-address {
        type srl_nokia-comm:ip-address-with-zone;
        description
          "The transport address of the BGP peer

           The peer-address must be a valid IPv4 unicast address, IPv6 global unicast address or IPv6 link-local address. An IPv6 link-local address requires the interface scope to be identified, using a format such as fe80::1234%ethernet-1/1.1";
      }
      leaf admin-state {
        type srl_nokia-comm:admin-state;
        default "enable";
        description
          "Administratively enable or disable the peer

           Disable will tear down the BGP session (return it to IDLE state).";
        must ". = 'disable' or
              ../afi-safi[afi-safi-name='ipv4-unicast']/admin-state = 'enable' or ../afi-safi[afi-safi-name='ipv6-unicast']/admin-state = 'enable' or ../afi-safi[afi-safi-name='evpn']/admin-state = 'enable' or
              ../afi-safi[afi-safi-name='l3vpn-ipv4-unicast']/admin-state = 'enable' or ../afi-safi[afi-safi-name='l3vpn-ipv6-unicast']/admin-state = 'enable' or
              ../afi-safi[afi-safi-name='ipv4-labeled-unicast']/admin-state = 'enable' or ../afi-safi[afi-safi-name='ipv6-labeled-unicast']/admin-state = 'enable' or
              ../afi-safi[afi-safi-name='evpn']/admin-state = 'enable' or ../afi-safi[afi-safi-name='route-target']/admin-state = 'enable' or
              (not(../afi-safi[afi-safi-name='ipv4-unicast']/admin-state) and (../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='ipv4-unicast']/admin-state = 'enable' or (not(../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='ipv4-unicast']/admin-state) and ../../afi-safi[afi-safi-name='ipv4-unicast']/admin-state = 'enable')))  or
              (not(../afi-safi[afi-safi-name='ipv6-unicast']/admin-state) and (../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='ipv6-unicast']/admin-state = 'enable' or (not(../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='ipv6-unicast']/admin-state) and ../../afi-safi[afi-safi-name='ipv6-unicast']/admin-state = 'enable'))) or
              (not(../afi-safi[afi-safi-name='evpn']/admin-state) and (../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='evpn']/admin-state = 'enable' or (not(../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='evpn']/admin-state) and ../../afi-safi[afi-safi-name='evpn']/admin-state = 'enable'))) or
              (not(../afi-safi[afi-safi-name='l3vpn-ipv4-unicast']/admin-state) and (../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='l3vpn-ipv4-unicast']/admin-state = 'enable' or (not(../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='l3vpn-ipv4-unicast']/admin-state) and ../../afi-safi[afi-safi-name='l3vpn-ipv4-unicast']/admin-state = 'enable'))) or
              (not(../afi-safi[afi-safi-name='l3vpn-ipv6-unicast']/admin-state) and (../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='l3vpn-ipv6-unicast']/admin-state = 'enable' or (not(../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='l3vpn-ipv6-unicast']/admin-state) and ../../afi-safi[afi-safi-name='l3vpn-ipv6-unicast']/admin-state = 'enable'))) or
              (not(../afi-safi[afi-safi-name='ipv4-labeled-unicast']/admin-state) and (../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='ipv4-labeled-unicast']/admin-state = 'enable' or (not(../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='ipv4-labeled-unicast']/admin-state) and ../../afi-safi[afi-safi-name='ipv4-labeled-unicast']/admin-state = 'enable'))) or
              (not(../afi-safi[afi-safi-name='ipv6-labeled-unicast']/admin-state) and (../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='ipv6-labeled-unicast']/admin-state = 'enable' or (not(../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='ipv6-labeled-unicast']/admin-state) and ../../afi-safi[afi-safi-name='ipv6-labeled-unicast']/admin-state = 'enable'))) or
              (not(../afi-safi[afi-safi-name='route-target']/admin-state) and (../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='route-target']/admin-state = 'enable' or (not(../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='route-target']/admin-state) and ../../afi-safi[afi-safi-name='route-target']/admin-state = 'enable'))) or
              (not(../afi-safi[afi-safi-name='srte-policy-ipv4']/admin-state) and (../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='srte-policy-ipv4']/admin-state = 'enable' or (not(../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='srte-policy-ipv4']/admin-state) and ../../afi-safi[afi-safi-name='srte-policy-ipv4']/admin-state = 'enable'))) or
              (not(../afi-safi[afi-safi-name='srte-policy-ipv6']/admin-state) and (../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='srte-policy-ipv6']/admin-state = 'enable' or (not(../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='srte-policy-ipv6']/admin-state) and ../../afi-safi[afi-safi-name='srte-policy-ipv6']/admin-state = 'enable'))) or
              (not(../afi-safi[afi-safi-name='link-state']/admin-state) and (../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='link-state']/admin-state = 'enable' or (not(../../group[group-name = current()/../peer-group]/afi-safi[afi-safi-name='link-state']/admin-state) and ../../afi-safi[afi-safi-name='link-state']/admin-state = 'enable')))" {
          error-message "One of the address families must be enabled.";
        }
      }
      leaf description {
        type srl_nokia-comm:description;
        description
          "A user provided description string for the peer";
      }
      leaf under-maintenance {
        config false;
        type boolean;
        description
          "State field to determine if this bgp neighbor is in maintenance mode.";
      }
      leaf maintenance-group {
        config false;
        type string;
        description
          "State field to display the maintenance group to which this neighbor belongs to.";
      }
      leaf peer-type {
        config false;
        type enumeration {
          enum ibgp {
            description
              "Indicates that the peer is IBGP (local-as == peer-as).";
          }
          enum ebgp {
            description
              "Indicates that the peer is EBGP (local-as != peer-as).";
          }
        }
        description
          "The session type. The type is EBGP when the local AS and peer AS are different, and the type is IBGP when the local AS and peer AS have the same value.";
      }
      leaf local-preference {
        type uint32;
        description
          "The value of the local-preference attribute that is added to received routes from the peer, if it is EBGP

           It is also used to encode the local preference attribute for locally generated BGP routes.";
      }
      leaf next-hop-self {
        type boolean;
        description
          "When set to true, the next-hop in all IPv4-unicast, IPv6-unicast and EVPN BGP routes advertised to the peer, if IBGP, is set equal to the local-address used on this session (or to the router ID if the NLRI is IPv6 and there is no IPv6 local address to use). This is independent of the route origin (EBGP, IBGP-client, IBGP-non-client or redistributed direct/static/aggregate route).

           When set to false, normal BGP rules from RFC 4271 apply.";
      }
      leaf peer-as {
        srl_nokia-ext:show-importance "high";
        type srl_nokia-comm:as-number;
        description
          "The autonomous system number expected from the peer

           A configured session with a peer does not come up if this value does not match the AS value reported by the peer in its OPEN message.";
      }
      leaf peer-group {
        type leafref {
          path "../../group/group-name";
        }
        mandatory true;
        description
          "A reference to the peer-group template to use for this BGP session

           This is not immutable.";
      }
      leaf last-prefix-limit-exceeded {
        config false;
        if-feature "srl_nokia-feat:bgp-prefix-limit-last-exceeded";
        type srl_nokia-comm:date-and-time-delta;
        description
          "Time when the neighbor last violated a configured prefix-limit for any AFI/SAFI

           This value is set/updated when any AFI/SAFI prefix-limit-exceeded leaf transitions from false/unset to true.";
      }
      container as-path-options {
        description
          "Options for handling the AS_PATH in received BGP routes";
        leaf allow-own-as {
          type uint8;
          description
            "The maximum number of times the global AS number or a local AS number of the BGP instance can appear in any received AS_PATH before it is considered a loop and considered invalid";
        }
        container remove-private-as {
          presence "configure remove-private-as";
          description
            "Container with options for removing private AS numbers (2-byte and 4-byte) from the advertised AS path towards all peers";
          leaf mode {
            description
              "The method by which private AS numbers are removed from the advertised AS_PATH attribute";
            type enumeration {
              enum disabled {
                description
                  "Do not strip or replace any private AS numbers";
              }
              enum delete {
                description
                  "Delete private AS numbers, shortening the AS path";
              }
              enum replace {
                description
                  "Replace private AS numbers with the local AS number used towards the peer, maintaining the AS path length";
              }
            }
            mandatory true;
          }
          leaf leading-only {
            description
              "If set to true then only delete or replace private AS numbers that appear before the first occurrence of a non-private ASN in the sequence of most recent ASNs in the AS path";
            type boolean;
            default "false";
            must "not(../mode = 'disabled' and . = true())" {
              error-message "mode should not be disabled to set leading-only to true.";
            }
          }
          leaf ignore-peer-as {
            description
              "If set to true then do not delete or replace a private AS number that is the same as the peer AS number";
            type boolean;
            default "false";
            must "not(../mode = 'disabled' and . = true())" {
              error-message "mode should not be disabled to set ignore-peer-as to true.";
            }
          }
        }
        leaf replace-peer-as {
          description
            "If set to true then replace every occurrence of the peer AS number that is present in the advertised AS path with the local AS number used towards the peer";
          type boolean;
        }
      }
      container authentication {
        description
          "Container with authentication options that apply to this specific peer";
        leaf keychain {
          description
            "Reference to a keychain. The keychain type must be tcp-md5.";
          type leafref {
            path "/srl_nokia-system:system/srl-keychain:authentication/srl-keychain:keychain/srl-keychain:name";
          }
          must '/srl_nokia-system:system/srl-keychain:authentication/srl-keychain:keychain[srl-keychain:name = current()]'
             + '/srl-keychain:type = "tcp-md5"' {
            error-message "Only keychain of type tcp-md5 can be assigned";
          }
        }
        leaf password {
          if-feature "srl_nokia-feat:bgp-auth-password";
          description
            "Configures an MD5 authentication password for use with neighboring devices.";
          type srl_nokia-comm:routing-password;
          must 'boolean(../keychain) = false()' {
            error-message "Can not assign both keychain and password";
          }
        }
        leaf transmit-active {
          config false;
          description
            "Reads true when the TCP segments being sent to the peer have authentication data.";
          type boolean;
        }
      }
      container failure-detection {
        description
          "Options related to methods of detecting BGP session failure";
        leaf enable-bfd {
          if-feature "srl_nokia-feat:bfd";
          type boolean;
          description
            "The true setting enables Bi-directional Forwarding Detection on BGP sessions belonging to the peer group";
        }
        leaf fast-failover {
          type boolean;
          description
            "The true setting the EBGP or IBGP session to drop immediately (and not wait for hold timer expiry) when the local interface that it depends upon for neighbor reachability goes down";
        }
      }
      container graceful-restart {
        description
          "Options related to router behavior as a graceful restart helper";
        leaf admin-state {
          type srl_nokia-comm:admin-state;
          description
            "Administratively enable or disable graceful restart helper for all address families";
        }
        leaf stale-routes-time {
          type uint16 {
            range "1..3600";
          }
          units "seconds";
          description
            "The maximum number of seconds that routes received from a helped peer remain stale until they are deleted

             Routes of AFI/SAFI X received from peer Y are marked stale when peer Y goes down and its previous GR capability included AFI/SAFI X.";
        }
        leaf requested-restart-time {
          if-feature "srl_nokia-feat:bgp-graceful-restart-gaps";
          description
            "The restart time encoded in this router's GR capability.

             If the neighbor honors this request then this is the maximum time allowed for this router to re-establish its TCP connection after a restart. If this time is exceeded, the neighbor is expected to flush stale routes that it was maintaining on behalf of this router.";
          type uint16 {
            range "1..3600";
          }
          units "seconds";
          default "300";
        }
        leaf number-of-restarts {
          config false;
          type uint16;
          description
            "The number of times the peer has restarted";
        }
        leaf last-restart-time {
          config false;
          type srl_nokia-comm:date-and-time-delta;
          description
            "The last time the peer restarted";
        }
        leaf helper-active {
          config false;
          type boolean;
          description
            "Set to true when the router is actively helping the neighbor for at least one address family - i.e. for that address family the peer restarted with F=1 in its capability and the stale-routes-time has not expired yet";
        }
        leaf local-restarting {
          if-feature "srl_nokia-feat:bgp-graceful-restart-state-additions";
          config false;
          description
            "Set to true when session has restarted, the peer is helping and EOR has not been sent for all AFI-SAFI";
          type boolean;
        }
        container neighbor-capability {
          config false;
          description
            "Container for information about the last GR capability received from the neighbor";
          leaf restart-time {
            type uint16;
            description
              "The value of the Restart Time in the neighbor's last GR capability";
          }
          list afi-safi {
            description
              "List of AFI/SAFI TLVs that were contained in the neighbor's last GR capability";
            key "name";
            leaf name {
              type identityref {
                base srl_nokia-comm:bgp-address-family;
              }
            }
            leaf forwarding-preserved {
              type boolean;
              description
                "The F-bit setting in the AFI/SAFI TLV";
            }
          }
        }
        container local-capability {
          if-feature "srl_nokia-feat:bgp-graceful-restart-state-additions";
          config false;
          description
            "Container for information about the last GR capability advertised to the neighbor";
          list afi-safi {
            description
              "List of AFI/SAFI TLVs that were contained in thel ast GR capability sent to the neighbor";
            key "name";
            leaf name {
              type identityref {
                base srl_nokia-comm:bgp-address-family;
              }
            }
          }
        }
      }
      container multihop {
        description
          "Configuration parameters specifying the multihop behaviour for an EBGP peer. This is not applicable to an IBGP peer.";
        leaf admin-state {
          type srl_nokia-comm:admin-state;
          description
            "When enabled, the peer is allowed to be indirectly connected by up to N hops, where N is controlled by the maximum-hops parameter. When disabled, multihop is allowed only if the peer type is IBGP.

             This overrides the group setting for admin-state.";
        }
        leaf maximum-hops {
          type uint8 {
            range "1..255";
          }
          description
            "This sets the maximum number of routing hops towards the peer. It determines the IP TTL value in originated BGP TCP/IP packets. By default the TTL is set to 1 towards an EBGP peer and 64 towards an IBGP peer.

             This overrides the group setting for maximum-hops.";
        }
      }
      list afi-safi {
        key "afi-safi-name";
        description
          "List of address families supported by the BGP neighbor";
        leaf afi-safi-name {
          type identityref {
            base srl_nokia-comm:bgp-address-family;
          }
          description
            "The name of a BGP address family, which translates to a specific AFI value and a specific SAFI value";
          must "not(. = 'evpn') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "EVPN is not supported in network instances other than default";
          }
          must "not(. = 'l3vpn-ipv4-unicast') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "L3VPN is not supported in network instances other than default";
          }
          must "not(. = 'l3vpn-ipv6-unicast') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "L3VPN is not supported in network instances other than default";
          }
          must "not(. = 'ipv4-labeled-unicast') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "Label-ipv4 is not supported in network instances other than default";
          }
          must "not(. = 'ipv6-labeled-unicast') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "Label-ipv6 is not supported in network instances other than default";
          }
          must "not(. = 'route-target') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "route-target is not supported in network instances other than default";
          }
          must "not(. = 'srte-policy-ipv4') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "srte-policy-ipv4 is not supported in network instances other than default";
          }
          must "not(. = 'srte-policy-ipv6') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "srte-policy-ipv6 is not supported in network instances other than default";
          }
          must "not(. = 'link-state') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "link-state is not supported in network instances other than default";
          }
        }
        leaf admin-state {
          type srl_nokia-comm:admin-state;
          description
            "This leaf indicates whether support for the AFI-SAFI is enabled/advertised to the neighbor";
        }
      }
      container local-as {
        description
          "Options related to the local autonomous-system number advertised by this router to the peer";
        leaf as-number {
          type srl_nokia-comm:as-number;
          description
            "The local autonomous system number used to override the global ASN on this session

             Sets the ASN value that this router sends in its OPEN message towards its peer.";
        }
        leaf prepend-global-as {
          type boolean;
          description
            "When set to true, the global ASN value is prepended to the AS path in outbound routes towards the peer

             If a session is EBGP (peer-as is not equal to the local-as) then the local-as is prepended as the final step, so that the local-as is the first element in the AS_PATH received by the peer.";
          must '../as-number' {
            error-message "must have as-number to set prepend-global-as";
          }
        }
        leaf prepend-local-as {
          type boolean;
          description
            "When set to true, the local AS value is prepended to the AS path of inbound routes from the peer";
          must '../as-number' {
            error-message "must have as-number to set prepend-local-as";
          }
        }
      }
      leaf route-flap-damping {
        if-feature "srl_nokia-feat:bgp-route-flap-damping";
        description
          "Enable/disable route flap damping procedures for routes received from this peer if it is an EBGP peer

           If no value is configured, the setting is inherited from the peer-group to which the peer belongs.

           The configured or omherited setting has no effect if the peer is IBGP.";
        type boolean;
      }
      container route-reflector {
        description
          "Container with route reflection configuration options.";
        leaf client {
          description
            "When this is set to true this BGP session is considered an RR client.";
          type boolean;
        }
        leaf cluster-id {
          description
            "The cluster-id to insert into the CLUSTER_LIST attribute when reflecting routes received by or sent to this client. The default is inherited from group or instance level configuration.";
          type cluster-id-type;
        }
      }
      container send-community {
        if-feature "not srl_nokia-feat:bgp-send-community-leaflist";
        description
          "Options for controlling the sending of BGP communities to the peer";
        leaf standard {
          type boolean;
          description
            "The false setting causes BGP to strip all standard (4 byte) communities from all outbound routes advertised to the peer";
        }
        leaf large {
          type boolean;
          description
            "The false setting causes BGP to strip all large (12 byte) BGP communities from all outbound routes advertised to the peer";
        }
      }
      container send-default-route {
        description
          "Options for controlling the generation of default routes towards the peer";
        leaf ipv4-unicast {
          type boolean;
          description
            "Enables the sending of a synthetically generated default IPv4 route [0/0] to the peer";
        }
        leaf ipv6-unicast {
          type boolean;
          description
            "Enables the sending of a synthetically generated default IPv6 route [::/0] to the peer";
        }
        leaf export-policy {
          type leafref {
            path "/srl-rpol:routing-policy/srl-rpol:policy/srl-rpol:name";
          }
          description
            "The name of a policy that should be applied to the advertised default routes, in order to set their attributes to non-default values

             Only the default-action of this policy is parsed and applied.";
        }
      }
      container timers {
        leaf connect-retry {
          type uint16 {
            range "1..65535";
          }
          units "seconds";
          description
            "The time interval in seconds between successive attempts to establish a session with a peer";
        }
        leaf hold-time {
          type uint16 {
            range "0|3..65535";
          }
          units "seconds";
          description
            "The hold-time interval in seconds that the router proposes to the peer in its OPEN message

             The actual in-use hold-time is negotiated to the lowest value proposed by the two peers. A negotiated value of 0 suppresses the sending of keepalives by both peers.";
        }
        leaf keepalive-interval {
          type uint16 {
            range "0..21845";
          }
          units "seconds";
          description
            "The interval in seconds between successive keepalive messages sent to the peer

             The period between one keepalive message and the next is the minimum of this configured (or inherited) value and 1/3 of the negotiated hold-time duration. A value of 0 suppresses the sending of keepalives to the peer.";
        }
        leaf minimum-advertisement-interval {
          type uint16 {
            range "1..255";
          }
          units "seconds";
          description
            "The value assigned to the MinRouteAdvertisementIntervalTimer of RFC 4271, for both EBGP and IBGP sessions

             Each session runs its own independent timer and the timer affects both route advertisements and route withdrawals, regardless of address family. For route withdrawals only, this timer is bypassed if rapid-withdrawal is set to true.";
        }
        leaf prefix-limit-restart-timer {
          if-feature "srl_nokia-feat:bgp-prefix-limit";
          type uint16;
          units "seconds";
          description
            "Time interval in seconds after which the BGP session is re-established after being torn down due to exceeding any prefix limit (of any address family)

             This only applies if prevent-teardown is false.";
        }
        leaf next-connect-retry-time {
          config false;
          type srl_nokia-comm:date-and-time-delta;
          description
            "The time when the next connect retry attempt will occur";
        }
        leaf negotiated-hold-time {
          config false;
          type uint16;
          description
            "The operational hold-time

             It is negotiated to the lowest value proposed by the two peers. A negotiated value of 0 suppresses the sending of keepalives by both peers.";
        }
        leaf negotiated-keepalive-interval {
          config false;
          description
            "The operational keepalive interval

             It is the minimum of the configured value and 1/3 of the negotiated-hold-time. A value of 0 suppresses the sending of keepalives to the peer.";
          type uint16;
        }
      }
      container transport {
        leaf mtu-discovery {
          if-feature "srl_nokia-feat:bgp-mtu-discovery";
          type boolean;
          description
            "Turns path mtu discovery on (true) or off (false)";
        }
        leaf tcp-mss {
          type uint16 {
            range "536..9446";
          }
          units "bytes";
          description
            "The maximum segment size of BGP TCP packets

             The configured value of this leaf is the TCP MSS value advertised to the peer during TCP connection setup (in the TCP MSS option), reduced if necessary to accommodate the outgoing interface IP MTU.
             The state value of this leaf is the operational TCP MSS used in the data transmit direction towards the peer. It may be less than the received TCP MSS option value due to adjustment for TCP options used in the transit direction and/or the path MTU discovery process (if enabled).";
        }
        leaf passive-mode {
          type boolean;
          description
            "The true setting causes BGP to wait for the peer to initiate the TCP connection

             The false setting causes BGP to initiate a TCP connection whenever the BGP session is started or restarted.";
        }
        leaf local-address {
          type union {
            type srl_nokia-comm:ip-address;
            type srl_nokia-comm:subinterface-all;
          }
          description
            "The local TCP endpoint of used for the BGP session

             This also the source address for next-hop-self, if it applies. The local-address can be specified as an IP address that is resolvable to a local interface.

             This address must be the primary address of an interface, otherwise the session will not come up.";
        }
        leaf local-port {
          config false;
          type uint16;
          description
            "Local TCP port used for the TCP connection to the peer";
        }
        leaf remote-port {
          config false;
          type uint16;
          description
            "Remote TCP port used by the peer for its TCP connection to the local router";
        }
      }
    }
  }

  grouping entropy-label {
    container entropy-label {
      if-feature "srl_nokia-feat:entropy-bgp-sr";
      description
        "Options for configuring control and data plane aspects of entropy label";
      leaf transmit {
        description
          "Specify conditions for adding ELI/EL when pushing BGP label";
        type enumeration {
          enum enable;
          enum disable;
        }
        default "disable";
        must ". = 'disable' or current()/../../../../../../srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
          error-message "entropy-label is not supported in network instance other than default";
        }
      }
    }
  }

  grouping color-aware-next-hop-resolution {
    container selection-attributes {
      description
        "Attributes for narrowing the selection of tunnels";
      container tag {
        if-feature "srl_nokia-feat:bgp-next-hop-resolution-tag";
        description
          "Next-hop resolution constraints based on internal tags";
        leaf mandatory {
          description
            "If true, a tunnel can resolve the next-hop only if it has all the same tags as the route

             If false, it is possible to select a tunnel that has none or only some of the same tags as the route.";
          type boolean;
          default "false";
        }
      }
    }
  }

  grouping allowed-tunnel-types-unlabeled {
    leaf-list allowed-tunnel-types {
      description
        "List of allowed tunnel types";
      type identityref {
        base srl_nokia-comm:bgp-next-hop-resolution-tunnel-type;
      }
      must "not(. = 'bgp')" {
        srl_nokia-ext:if-feature "not srl_nokia-feat:bgp-labeled-unicast";
        error-message "unsupported resolving tunnel";
      }
    }
  }

  grouping allowed-tunnel-types-labeled {
    leaf-list allowed-tunnel-types {
      description
        "List of allowed tunnel types";
      type identityref {
        base srl_nokia-comm:bgp-next-hop-resolution-tunnel-type;
      }
      must "not(. = 'bgp')" {
        error-message "unsupported resolving tunnel";
      }
      must "not(. = 'te-policy-sr-mpls-uncolored')" {
        srl_nokia-ext:if-feature "not srl_nokia-feat:bgp-labeled-unicast-over-sr-te";
        error-message "unsupported resolving tunnel";
      }
    }
  }

  grouping next-hop-resolution-labeled {
    container next-hop-resolution {
      description
        "Options for controlling next-hop resolution procedures";
      container ipv4-next-hops {
        description
          "Options related to the resolution of BGP next-hops that are IPv4 addresses";
        container route-resolution {
          description
            "Options related to resolution using IP routes in the FIB";
          leaf admin-state {
            description
              "Enable or disable route resolution if no resolving tunnel is found";
            type srl_nokia-comm:admin-state;
            default "enable";
          }
          leaf ignore-default-routes {
            description
              "Ignore default routes, regardless of route type";
            type boolean;
            default "true";
          }
        }
        container tunnel-resolution {
          description
            "Options related to resolution using tunnels in the tunnel table";
          uses allowed-tunnel-types-labeled;
          uses color-aware-next-hop-resolution {
            if-feature "(srl_nokia-feat:bgp-next-hop-resolution-tag and srl_nokia-feat:bgp-labeled-unicast-over-sr-te) or srl_nokia-feat:isis-flex-algo or srl_nokia-feat:segment-routing-colored-te-policies";
          }
        }
      }
      container ipv6-next-hops {
        description
          "Options related to the resolution of BGP next-hops that are IPv6 addresses";
        container route-resolution {
          description
            "Options related to resolution using IP routes in the FIB";
          leaf admin-state {
            description
              "Enable or disable route resolution if no resolving tunnel is found";
            type srl_nokia-comm:admin-state;
            default "enable";
          }
          leaf ignore-default-routes {
            description
              "Ignore default routes, regardless of route type";
            type boolean;
            default "true";
          }
        }
        container tunnel-resolution {
          description
            "Options related to resolution using tunnels in the tunnel table";
          uses allowed-tunnel-types-labeled;
          uses color-aware-next-hop-resolution {
            if-feature "(srl_nokia-feat:bgp-next-hop-resolution-tag and srl_nokia-feat:bgp-labeled-unicast-over-sr-te) or srl_nokia-feat:isis-flex-algo or srl_nokia-feat:segment-routing-colored-te-policies";
          }
        }
      }
    }
  }

  grouping allowed-tunnel-types-evpn-ipvpn-mpls {
    leaf-list allowed-tunnel-types {
      description
        "List of allowed tunnel types";
      type identityref {
        base srl_nokia-comm:bgp-next-hop-resolution-tunnel-type;
      }
    }
  }

  grouping next-hop-resolution-evpn-ipvpn-mpls {
    container next-hop-resolution {
      description
        "Options for controlling next-hop resolution procedures";
      container ipv4-next-hops {
        description
          "Options related to the resolution of BGP next-hops that are IPv4 addresses";
        container route-resolution {
          description
            "Options related to resolution using IP routes in the FIB";
          leaf admin-state {
            description
              "Enable or disable route resolution if no resolving tunnel is found";
            type srl_nokia-comm:admin-state;
            default "enable";
          }
          leaf ignore-default-routes {
            description
              "Ignore default routes, regardless of route type";
            type boolean;
            default "true";
          }
        }
        container tunnel-resolution {
          description
            "Options related to resolution using tunnels in the tunnel table";
          uses allowed-tunnel-types-evpn-ipvpn-mpls;
          uses color-aware-next-hop-resolution {
            if-feature "srl_nokia-feat:bgp-next-hop-resolution-tag or srl_nokia-feat:isis-flex-algo or srl_nokia-feat:segment-routing-colored-te-policies";
          }
        }
      }
      container ipv6-next-hops {
        description
          "Options related to the resolution of BGP next-hops that are IPv6 addresses";
        container route-resolution {
          description
            "Options related to resolution using IP routes in the FIB";
          leaf admin-state {
            description
              "Enable or disable route resolution if no resolving tunnel is found";
            type srl_nokia-comm:admin-state;
            default "enable";
          }
          leaf ignore-default-routes {
            description
              "Ignore default routes, regardless of route type";
            type boolean;
            default "true";
          }
        }
        container tunnel-resolution {
          description
            "Options related to resolution using tunnels in the tunnel table";
          uses allowed-tunnel-types-evpn-ipvpn-mpls;
          uses color-aware-next-hop-resolution {
            if-feature "srl_nokia-feat:bgp-next-hop-resolution-tag or srl_nokia-feat:isis-flex-algo or srl_nokia-feat:segment-routing-colored-te-policies";
          }
        }
      }
    }
  }

  grouping selective-label-route-optimizations {
    container selective-labeled-unicast-install {
      if-feature "srl_nokia-feat:bgp-labeled-unicast-selective-install";
      presence "Do not install labeled-unicast routes as tunnels in the tunnel-table unless they match the next-hop of a locally installed VPN route";
      must "../../../../../srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
        error-message "selective-labeled-unicast-install is not supported in network instance other than default";
      }
      leaf program-label-swap {
        description
          "When true, program a label swap entry even when the route is not installed as a tunnel";
        type boolean;
        default "false";
        must '. = true() or ../program-route = false()' {
          error-message "If program-label-swap is false then program-route must be false";
        }
      }
      leaf program-route {
        description
          "When true, program IP FIB entry even when the route is not installed as a tunnel";
        type boolean;
        default "false";
      }
    }
  }

  grouping link-bandwidth {
    description
      "Grouping containing the configuration and state for unequal ECMP";
    container link-bandwidth {
      if-feature "srl_nokia-feat:evpn-ifl-unequal-ecmp or srl_nokia-feat:bgp-weighted-ecmp";
      leaf add-next-hop-count-to-received-bgp-routes {
        if-feature "srl_nokia-feat:evpn-ifl-unequal-ecmp";
        must "/srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:ip-vrf'" {
          error-message "Add next-hop count weight is only supported in network instances of type ip-vrf";
        }
        type union {
          type int32 {
            range "1..128";
          }
          type enumeration {
            enum disable {
              value -1;
            }
          }
        }
        description
          "Determines the weight that is internally added to the received PE-CE BGP routes

           The configured weight is added to all received BGP PE-CE routes for the purpose of EVPN unequal ECMP.
           This weight is internal and not added into any link-bandwidth extended community when readvertising
           the received routes to other ipv4 or ipv6 neighbors.";
      }
      leaf aggregate-used-paths {
        if-feature "srl_nokia-feat:bgp-weighted-ecmp";
        description
          "When advertising link-bandwidth to this peer, sum the link bandwidth from all the used multipaths";
        type boolean;
      }
    }
  }


  grouping rib-management {
    container rib-management {
      if-feature "srl_nokia-feat:bgp-labeled-unicast";
      list table {
        must "/srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
          error-message "RIB management not supported in network-instances other than default";
        }
        key "address-family";
        leaf address-family {
          description
            "BGP address family";
          type identityref {
            base srl_nokia-comm:bgp-address-family;
          }
          must ". = 'ipv4-unicast' or . = 'ipv6-unicast' or . = 'ipv4-labeled-unicast' or . = 'ipv6-labeled-unicast'" {
            srl_nokia-ext:if-feature "srl_nokia-feat:bgp-labeled-unicast-future";
            error-message "unsupported address family";
          }
          must ". = 'ipv4-labeled-unicast' or . = 'ipv6-labeled-unicast'" {
            srl_nokia-ext:if-feature "not srl_nokia-feat:bgp-labeled-unicast-future";
            error-message "unsupported address family";
          }
        }
        description
          "List of RIB tables maintained by BGP running in this network-instance";
        leaf route-table-import {
          description
            "Apply a route policy to accept routes that should be installed in the BGP RIB table";
          type leafref {
            path "/srl-rpol:routing-policy/srl-rpol:policy/srl-rpol:name";
          }
        }
      }
    }
  }

  grouping segment-routing {
    container segment-routing-mpls {
      if-feature "srl_nokia-feat:bgp-labeled-unicast-prefix-sid";
      description
        "BGP support for segment routing using MPLS dataplane";
      leaf admin-state {
        description
          "Enable SR-MPLS support within BGP";
        type srl_nokia-comm:admin-state;
        default "disable";
        must ". = 'disable' or ../../../../srl_nokia-sr:segment-routing/srl_nokia-sr:mpls" {
          error-message "To enable, sr-mpls not enabled in the network-instance";
        }
      }
    }
  }

  grouping bgp-top {
    container bgp {
      presence "Configure BGP";
      description
        "Top-level configuration and operational state for Border Gateway Protocol (BGP)";
      must 'not(/srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../srl_nokia-netinst:name]/srl_nokia-netinst:type = "srl_nokia-netinst:mac-vrf")' {
        error-message "BGP configuration is not possible on network-instance of type mac-vrf ";
      }
      must "../../srl_nokia-netinst:type != 'srl_nokia-netinst:host'" {
        error-message "BGP not supported with network-instance of type host";
      }
      leaf admin-state {
        type srl_nokia-comm:admin-state;
        default "enable";
        must " (. = 'disable') or
               (../afi-safi[afi-safi-name='ipv4-unicast']/admin-state = 'enable') or
               (../afi-safi[afi-safi-name='ipv6-unicast']/admin-state = 'enable') or
               (../afi-safi[afi-safi-name='evpn']/admin-state = 'enable') or
               (../afi-safi[afi-safi-name='ipv4-labeled-unicast']/admin-state = 'enable') or
               (../afi-safi[afi-safi-name='ipv6-labeled-unicast']/admin-state = 'enable') or
               (../afi-safi[afi-safi-name='l3vpn-ipv4-unicast']/admin-state = 'enable') or
               (../afi-safi[afi-safi-name='l3vpn-ipv6-unicast']/admin-state = 'enable') or
               (../afi-safi[afi-safi-name='route-target']/admin-state = 'enable') or
               (../afi-safi[afi-safi-name='srte-policy-ipv4']/admin-state = 'enable') or
               (../afi-safi[afi-safi-name='srte-policy-ipv6']/admin-state = 'enable') or
               (../afi-safi[afi-safi-name='link-state']/admin-state = 'enable')" {
          error-message "One of the address families must be enabled.";
        }
        description
          "Administratively enable or disable the entire BGP instance

           Disable causes all BGP sessions to be taken down immediately, even if admin-state at the group or neighbor level of some of these sessions is still set as enable.";
      }
      leaf autonomous-system {
        type srl_nokia-comm:as-number;
        mandatory true;
        description
          "The global AS number of the BGP instance

           Values greater than 65535 must be entered in ASPLAIN format.";
      }
      leaf local-preference {
        type uint32;
        default "100";
        description
          "The value of the local-preference attribute that is added to received routes from EBGP peers

           It is also used to encode the local preference attribute for locally generated BGP routes.";
      }
      leaf router-id {
        type srl_nokia-comm:ip-address;
        mandatory true;
        description
          "The BGP identifier used by this BGP instance in all of its OPEN messages

           Any non-zero value is supported.";
      }
      container as-path-options {
        description
          "Options for handling the AS_PATH in received BGP routes";
        leaf allow-own-as {
          type uint8;
          default "0";
          description
            "The maximum number of times the global AS number or a local AS number of the BGP instance can appear in any received AS_PATH before it is considered a loop and considered invalid";
        }
        container remove-private-as {
          description
            "Container with options for removing private AS numbers (2-byte and 4-byte) from the advertised AS path towards all peers";
          leaf mode {
            description
              "The method by which private AS numbers are removed from the advertised AS_PATH attribute";
            type enumeration {
              enum disabled {
                description
                  "Do not strip or replace any private AS numbers";
              }
              enum delete {
                description
                  "Delete private AS numbers, shortening the AS path";
              }
              enum replace {
                description
                  "Replace private AS numbers with the local AS number used towards the peer, maintaining the AS path length";
              }
            }
            default "disabled";
          }
          leaf leading-only {
            description
              "If set to true then only delete or replace private AS numbers that appear before the first occurrence of a non-private ASN in the sequence of most recent ASNs in the AS path";
            type boolean;
            must "not(../mode = 'disabled' and . = true())" {
              error-message "mode should not be disabled to set leading-only to true.";
            }
            default "false";
          }
          leaf ignore-peer-as {
            description
              "If set to true then do not delete or replace a private AS number that is the same as the peer AS number";
            type boolean;
            must "not(../mode = 'disabled' and . = true())" {
              error-message "mode should not be disabled if ignore-peer-as has to be true.";
            }
            default "false";
          }
        }
      }
      container authentication {
        description
          "Container with authentication options that apply to all peers of the BGP instance";
        leaf keychain {
          description
            "Reference to a keychain. The keychain type must be tcp-md5.";
          type leafref {
            path "/srl_nokia-system:system/srl-keychain:authentication/srl-keychain:keychain/srl-keychain:name";
          }
          must '/srl_nokia-system:system/srl-keychain:authentication/srl-keychain:keychain[srl-keychain:name = current()]'
             + '/srl-keychain:type = "tcp-md5"' {
            error-message "Only keychain of type tcp-md5 can be assigned";
          }
        }
        leaf password {
          if-feature "srl_nokia-feat:bgp-auth-password";
          description
            "Configures an MD5 authentication password for use with neighboring devices.";
          type srl_nokia-comm:routing-password;
          must 'boolean(../keychain) = false()' {
            error-message "Can not assign both keychain and password";
          }
        }
      }
      container ebgp-default-policy {
        description
          "Options for controlling the default policies that apply to EBGP sessions";
        leaf import-reject-all {
          type boolean;
          default "true";
          description
            "When set to true, all inbound routes from any EBGP peer to which no explicit import policy is applied are treated as though they were rejected by policy";
        }
        leaf export-reject-all {
          type boolean;
          default "true";
          description
            "When set to true, all outbound routes towards any EBGP peer to which no explicit export policy is applied are treated as though they were rejected by policy";
        }
      }
      list afi-safi {
        key "afi-safi-name";
        description
          "List of address families supported by the BGP instance";
        leaf afi-safi-name {
          type identityref {
            base srl_nokia-comm:bgp-address-family;
          }
          description
            "The name of a BGP address family, which translates to a specific AFI value and a specific SAFI value";
          must "not(. = 'evpn') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "EVPN is not supported in network instances other than default";
          }
          must "not(. = 'route-target') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "route-target is not supported in network instances other than default";
          }
          must "not(. = 'l3vpn-ipv4-unicast')  or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "L3VPN is not supported in network instances other than default";
          }
          must "not(. = 'l3vpn-ipv6-unicast') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "L3VPN is not supported in network instances other than default";
          }
          must "not(. = 'ipv4-labeled-unicast') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "Label-IPv4 is not supported in network instances other than default";
          }
          must "not(. = 'ipv6-labeled-unicast') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "Label-IPv6 is not supported in network instances other than default";
          }
          must "not(. = 'srte-policy-ipv4') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "srte-policy-ipv4 is not supported in network instances other than default";
          }
          must "not(. = 'srte-policy-ipv6') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "srte-policy-ipv6 is not supported in network instances other than default";
          }
          must "not(. = 'link-state') or /srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../srl_nokia-netinst:name]/srl_nokia-netinst:type = 'srl_nokia-netinst:default'" {
            error-message "link-state is not supported in network instances other than default";
          }
        }
        leaf admin-state {
          type srl_nokia-comm:admin-state;
          default "disable";
          description
            "This leaf indicates whether the AFI-SAFI is enabled for the instance";
        }
      }
      container preference {
        description
          "Options for controlling the route table preference of BGP routes";
        leaf ebgp {
          type uint8 {
            range "1..255";
          }
          default "170";
          description
            "The default route table preference for all EBGP learned routes

             BGP import policies can override this preference value on a route by route basis.";
        }
        leaf ibgp {
          type uint8 {
            range "1..255";
          }
          default "170";
          description
            "The default route table preference for all IBGP learned routes

             BGP import policies can override this preference value on a route by route basis.";
        }
      }
      uses rib-management;
      container route-advertisement {
        description
          "Options for controlling route advertisement behavior";
        leaf rapid-withdrawal {
          type boolean;
          default "false";
          description
            "The true setting enables rapid-withdraw towards BGP peers

             If there is only one BGP route for an NLRI in BGP RIB, and this route is withdrawn or becomes invalid, rapid-withdraw causes BGP to immediately send a withdrawal of the BGP route even if the min-route-advertisement timer has not expired.";
        }
        leaf wait-for-fib-install {
          type boolean;
          default "true";
          description
            "The true setting causes BGP to NOT advertise initial reachability to a prefix, or a change of reachability to a prefix, until it receives acknowledgment from FIB manager that the route change has been applied

             Does not apply to route withdrawals.";
        }
      }
      container route-flap-damping {
        if-feature "srl_nokia-feat:bgp-route-flap-damping";
        description
          "Configuration to control BGP route flap damping procedures";
        leaf half-life {
          description
            "Duration of time for the penalty amount (FOM) to be reduced by half if a route stays stable";
          type uint16 {
            range "1..45";
          }
          default "15";
          units "minutes";
        }
        leaf max-suppress-time {
          description
            "Maximum duration of time that advertisement of a route that has flapped can be suppressed";
          type uint16 {
            range "1..720";
          }
          default "60";
          units "minutes";
        }
        leaf reuse-threshold {
          description
            "A suppressed route can be advertised again after falling below this penalty (FOM) level";
          type uint16 {
            range "1..20000";
          }
          default "750";
        }
        leaf suppress-threshold {
          description
            "A flapping route is suppressed after rising above this penalty (FOM) level";
          type uint16 {
            range "1..20000";
          }
          default "3000";
        }
      }
      container route-reflector {
        description
          "Container with route reflection configuration options.";
        leaf client {
          description
            "When this is set to true all configured and dynamic sessions of the BGP instance are considered RR clients, subject to overrides at more specific levels of configuration.";
          type boolean;
          default "false";
        }
        leaf cluster-id {
          description
            "The cluster-id to insert into the CLUSTER_LIST attribute when reflecting routes received by or sent to clients in this scope of this container. The default is the router-id.";
          type cluster-id-type;
        }
      }
      uses segment-routing;
      container send-community {
        if-feature "not srl_nokia-feat:bgp-send-community-leaflist";
        description
          "Options for controlling the sending of BGP communities to all peers";
        leaf standard {
          type boolean;
          default "true";
          description
            "The false setting causes BGP to strip all standard (4 byte) communities from all outbound routes advertised to peers";
        }
        leaf large {
          type boolean;
          default "true";
          description
            "The false setting causes BGP to strip all large (12 byte) BGP communities from all outbound routes advertised to peers";
        }
      }
      container transport {
        description
          "Options related to the TCP transport of BGP sessions";
        leaf single-hop-connected-check {
          if-feature "srl_nokia-feat:bgp-single-hop-connected-check";
          type boolean;
          default "true";
          description
            "Control whether a single-hop BGP session should be allowed to setup if its 'related interface' is down.

             If single-hop-connected-check is false, a single-hop BGP session (EBGP or IBGP) to any IPv4 or IPv6 neighbor address is permitted to establish if there is ANY valid (IPv6 global unicast, IPv4 link-local, or IPv4 global) route to that neighbor address, regardless of whether the 'related interface' is up or down.

             If single-hop-connected-check is true (default value), a single-hop BGP session (EBGP or IBGP) to any IPv4 or IPv6 neighbor address is only permitted to transition from idle to a higher state if the 'related interface' is up.

             The 'related interface' of a single hop peer is the subinterface associated with the IPv6 link local neighbor address or else the subinterface with a primary or secondary IP address and prefix-length that covers the neighbor address.";
        }
        leaf mtu-discovery {
          if-feature "srl_nokia-feat:bgp-mtu-discovery";
          type boolean;
          description
            "Turns path mtu discovery for BGP TCP sessions on (true) or off (false)

             If this is unconfigured then the setting comes from network-instance/mtu/path-mtu-discovery.

             Changing the value of network-instance/mtu/path-mtu-discovery takes effect only for new connections established after the change";
        }
        leaf tcp-mss {
          type uint16 {
            range "536..9446";
          }
          default "1024";
          description
            "The maximum segment size of BGP TCP packets

             The actual value used in the transmit direction towards a particular peer should be checked at the neighbor level.";
        }
      }
      uses bgp-group;
      uses bgp-neighbor;
    }
  }

  augment "/srl_nokia-netinst:network-instance/srl_nokia-netinst:protocols" {
    uses bgp-top;
  }

  augment "/srl_nokia-system:system/srl_nokia-system-protocols:protocols" {
    container bgp {
      presence "Configure system-wide BGP parameters";
      leaf restart-max-wait {
        description
          "The maximum amount of time that BGP will wait to receive End of RIB markers from all peers and for all address families that were up prior to restart.

           After this time elapses BGP declares that convergence has occurred and sends its own EOR markers to its peers.";
        type uint16 {
          range "0..3600";
        }
        units "seconds";
        default "600";
      }
    }
  }
}
""")
    res.append(r"""module srl_nokia-common {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:general:common";
  prefix srl_nokia-comm;

  import srl_nokia-extensions {
    prefix srl_nokia-ext;
  }
  import srl_nokia-features {
    prefix srl-feat;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "This module contains a set of Internet address related
     types for use in OpenConfig modules.";

  revision 2025-03-31 {
    description
      "SRLinux 2025.3.1";
  }
  revision 2024-10-31 {
    description
      "SRLinux 24.10.1";
  }
  revision 2024-07-31 {
    description
      "SRLinux 24.7.1";
  }
  revision 2024-03-31 {
    description
      "SRLinux 24.3.1";
  }
  revision 2023-10-31 {
    description
      "SRLinux 23.10.1";
  }
  revision 2023-07-31 {
    description
      "SRLinux 23.7.1";
  }
  revision 2023-03-31 {
    description
      "SRLinux 23.3.1";
  }
  revision 2022-11-30 {
    description
      "SRLinux 22.11.1";
  }
  revision 2022-06-30 {
    description
      "SRLinux 22.6.1";
  }
  revision 2022-03-31 {
    description
      "SRLinux 22.3.1";
  }
  revision 2021-11-30 {
    description
      "SRLinux 21.11.1";
  }
  revision 2021-06-30 {
    description
      "SRLinux 21.6.1";
  }
  revision 2021-03-31 {
    description
      "SRLinux 21.3.1";
  }
  revision 2020-06-30 {
    description
      "SRLinux 20.6.1";
  }
  revision 2018-06-06 {
    description
      "SRLinux 19.11.1";
  }

  typedef std-regexp {
    type string;
    description
      "This type definition is a placeholder for a standard
       definition of a regular expression that can be utilised in
       OpenConfig models. Further discussion is required to
       consider the type of regular expressions that are to be
       supported. An initial proposal is POSIX compatible.";
  }

  typedef as-number {
    type uint32 {
      range "1..4294967295";
    }
    description
      "The as-number type represents autonomous system numbers
       which identify an Autonomous System (AS).  An AS is a set
       of routers under a single technical administration, using
       an interior gateway protocol and common metrics to route
       packets within the AS, and using an exterior gateway
       protocol to route packets to other ASes.  IANA maintains
       the AS number space and has delegated large parts to the
       regional registries.

       Autonomous system numbers were originally limited to 16
       bits.  BGP extensions have enlarged the autonomous system
       number space to 32 bits.  This type therefore uses an uint32
       base type without a range restriction in order to support
       a larger autonomous system number space.

       In the value set and its semantics, this type is equivalent
       to the InetAutonomousSystemNumber textual convention of
       the SMIv2.";
    reference
      "RFC 1930: Guidelines for creation, selection, and registration
                 of an Autonomous System (AS)
       RFC 4271: A Border Gateway Protocol 4 (BGP-4)
       RFC 4001: Textual Conventions for Internet Network Addresses
       RFC 6793: BGP Support for Four-Octet Autonomous System (AS)
                 Number Space";
  }

  typedef dotted-quad {
    type string {
      pattern '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
            + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
    }
    description
      "An unsigned 32-bit number expressed in the dotted-quad
       notation, i.e., four octets written as decimal numbers
       and separated with the '.' (full stop) character.";
  }

  typedef dscp {
    description
      "A DiffServ Code Point represented numerically or by a PHB name.";
    type union {
      type dscp-value;
      type dscp-name;
    }
  }

  typedef dscp-value {
    description
      "A DiffServ Code Point represented numerically.";
    type int8 {
      range "0..63";
    }
  }

  typedef interface-ptp {
    description
      "These interfaces are candidates for PTP ports

       These are generally physical ethernet interfaces.
       The sync0 interface designation covers both sync0 and sync0-standby under the PTP port configuration.
       gnss is not included since it does not need to be explicitly configured under ptp.  Simply enabling
       sync/gnss implies it is used as an input to ptp.";
    type interface-name {
      length "3..21";
      pattern '(ethernet-([1-9](\d){0,1}(/m[1-6])?(/[1-9](\d){0,1})?/(([1-9](\d){0,1})|(1[0-1]\d)|(12[0-8])))|'
            + 'gnss|sync0)';
    }
  }

  typedef interface-freq {
    description
      "These interfaces are candidates for input references to the central frequency clock

       These are generally physical ethernet interfaces.
       The sync0 interface designation covers both sync0 and sync0-standby under the configuration.
       The gnss interfaces designation covers both the gnss and gnss-standby under the clock configuration.
       The ptp interface refers to the internal ptp frequency recovery engine.";
    type interface-name {
      length "3..21";
      pattern '(ethernet-([1-9](\d){0,1}(/m[1-6])?(/[1-9](\d){0,1})?/(([1-9](\d){0,1})|(1[0-1]\d)|(12[0-8])))|'
            + 'sync0|'
            + 'gnss|'
            + 'ptp)';
    }
  }

  typedef dscp-name {
    description
      "A DiffServ Code Point represented by PHB name.";
    type enumeration {
      enum CS0 {
        value 0;
      }
      enum LE {
        value 1;
        reference
          "RFC 8622";
      }
      enum CS1 {
        value 8;
      }
      enum AF11 {
        value 10;
      }
      enum AF12 {
        value 12;
      }
      enum AF13 {
        value 14;
      }
      enum CS2 {
        value 16;
      }
      enum AF21 {
        value 18;
      }
      enum AF22 {
        value 20;
      }
      enum AF23 {
        value 22;
      }
      enum CS3 {
        value 24;
      }
      enum AF31 {
        value 26;
      }
      enum AF32 {
        value 28;
      }
      enum AF33 {
        value 30;
      }
      enum CS4 {
        value 32;
      }
      enum AF41 {
        value 34;
      }
      enum AF42 {
        value 36;
      }
      enum AF43 {
        value 38;
      }
      enum CS5 {
        value 40;
      }
      enum EF {
        value 46;
      }
      enum CS6 {
        value 48;
      }
      enum CS7 {
        value 56;
      }
    }
  }

  typedef ipv4 {
    type string {
      pattern '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|'
            + '25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4]'
            + '[0-9]|25[0-5])';
    }
  }

  typedef ipv6 {
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
            + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
            + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
            + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))';
    }
  }

  typedef ipv4-address {
    srl_nokia-ext:generated-class-name "IpAddress";
    srl_nokia-ext:generated-class-variant "v4";
    type ipv4;
    description
      "An IPv4 address in dotted quad notation.";
  }

  typedef ipv6-address {
    srl_nokia-ext:generated-class-name "IpAddress";
    srl_nokia-ext:generated-class-variant "v6";
    type ipv6;
    description
      "An IPv6 address represented as either a full address, shortened or mixed-shortened formats";
  }

  typedef ipv4-address-unicast {
    type ipv4-address {
      pattern '(0|127|22[4-9]|2[3-5][0-9])\..*' {
        modifier "invert-match";
      }
    }
    description
      "A unicast IPv4 address in dotted quad notation";
  }

  typedef ipv6-address-unicast {
    type ipv6-address {
      pattern '[0:]+1?|([fF][fF][0-9a-fA-F][0-9a-fA-F].*)' {
        modifier "invert-match";
      }
    }
    description
      "A unicast IPv6 address represented as either a full address, shortened or mixed-shortened formats";
  }

  typedef ipv6-address-unicast-without-local {
    type ipv6-address-unicast {
      pattern '[fF][eE][89abAB][0-9a-fA-F].*' {
        modifier "invert-match";
      }
    }
    description
      "A unicast IPv6 address represented as either a full address, shortened or mixed-shortened formats. Link-local addresses are not allowed.";
  }

  typedef ipv6-address-link-local-unicast {
    type ipv6-address {
      pattern '[fF][eE][89abAB][0-9a-fA-F].*';
    }
    description
      "A link-local unicast IPv6 address represented as either a full address, shortened or mixed-shortened formats";
  }

  typedef ipv4-address-with-zone {
    srl_nokia-ext:generated-class-name "IpAddressWithZone";
    srl_nokia-ext:generated-class-variant "v4";
    type string {
      pattern '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|'
            + '25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4]'
            + '[0-9]|25[0-5])';
    }
    description
      "The ipv4-address-with-zone type represents an IPv4 address in dotted quad notation (added only for symmetry)";
  }

  typedef ipv6-address-with-zone {
    srl_nokia-ext:generated-class-name "IpAddressWithZone";
    srl_nokia-ext:generated-class-variant "v6";
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
            + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
            + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
            + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
            + '(%.+)?';
      pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
            + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
            + '(%.+)?';
      pattern '([^%]+)(%'
            + '(mgmt0\.0|'
            + 'system0\.0|'
            + 'sync0\.0|'
            + 'lo(0|1[0-9][0-9]|2([0-4][0-9]|5[0-5])|[1-9][0-9]|[1-9])\.(0|[1-9](\d){0,3})|'
            + 'lif-.*\.(0|[1-9](\d){0,3})|'
            + 'vhn-.*\.(0|[1-9](\d){0,3})|'
            + 'enp(0|1[0-9][0-9]|2([0-4][0-9]|5[0-5])|[1-9][0-9]|[1-9])s(0|[1-9]|[1-2][0-9]|3[0-1])f[0-7]\.(0|[1-9](\d){0,3})|'
            + 'ethernet-([1-9](\d){0,1}(/m[1-6])?(/[1-9](\d){0,1})?/(([1-9](\d){0,1})|(1[0-1]\d)|(12[0-8])))\.([0]|[1-9](\d){0,3})|'
            + 'irb(0|1[0-9][0-9]|2([0-4][0-9]|5[0-5])|[1-9][0-9]|[1-9])\.(0|[1-9](\d){0,3})|'
            + 'lag(([1-9](\d){0,2})|(1000))\.(0|[1-9](\d){0,3}))'
            + ')?';
    }
    description
      "The ipv6-address-with-zone type represents an IPv6 address in full, mixed, shortened, and
       shortened-mixed notation.  The IPv6 address may include a zone index, separated by
       a % sign. The zone index is used to disambiguate identical address values.  For link-local
       addresses, the zone index is expected to be the name of a subinterface. An example of
       a link-local address is:

       fe80::1234%ethernet-1/1.1";
    reference
      "RFC 4291: IP Version 6 Addressing Architecture
       RFC 4007: IPv6 Scoped Address Architecture
       RFC 5952: A Recommendation for IPv6 Address Text Representation";
  }

  typedef ipv4-prefix {
    srl_nokia-ext:generated-class-name "IpPrefix";
    srl_nokia-ext:generated-class-variant "v4";
    type string {
      pattern '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|'
            + '25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4]'
            + '[0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))';
    }
    description
      "An IPv4 prefix represented in dotted quad notation followed by a slash and a CIDR mask (0 <= mask <= 32).";
  }

  typedef ipv6-prefix {
    srl_nokia-ext:generated-class-name "IpPrefix";
    srl_nokia-ext:generated-class-variant "v6";
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
            + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
            + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
            + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
            + '(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))';
    }
    description
      "An IPv6 prefix represented in full, shortened, or mixed shortened format followed by a slash and CIDR mask (0 <= mask <=
       128).";
  }

  typedef ipv4-prefix-unicast {
    type ipv4-prefix {
      pattern '(0\.[0-9.]+/([8-9]|[1-3][0-9])|(127|22[4-9]|2[3-5][0-9])\..*)' {
        modifier "invert-match";
      }
    }
    description
      "A unicast IPv4 prefix represented in dotted quad notation followed by a slash and a CIDR mask (0 <= mask <= 32)";
  }

  typedef ipv6-prefix-unicast {
    type ipv6-prefix {
      pattern '[0:]+1?/128|[fF][fF][0-9a-fA-F][0-9a-fA-F].*/([89]|[1-9][0-9]+)' {
        modifier "invert-match";
      }
    }
    description
      "A unicast IPv6 prefix represented in full, shortened, or mixed shortened format followed by a slash and CIDR mask (0 <= mask <= 128)";
  }

  typedef ipv6-prefix-unicast-without-local {
    type ipv6-prefix-unicast {
      pattern '[fF][eE][89abAB][0-9a-fA-F].*/[1-9][0-9]+' {
        modifier "invert-match";
      }
    }
    description
      "A unicast IPv6 prefix represented in full, shortened, or mixed shortened format followed by a slash and CIDR mask (0 <= mask <= 128). Link-local prefixes are not allowed.";
  }

  typedef ip-address {
    type union {
      type ipv4-address;
      type ipv6-address;
    }
    description
      "An IPv4 or IPv6 address with no prefix specified.";
  }

  typedef ip-address-unicast {
    type union {
      type ipv4-address-unicast;
      type ipv6-address-unicast;
    }
    description
      "A unicast IPv4 or IPv6 address with no prefix specified";
  }

  typedef ip-address-unicast-without-local {
    type union {
      type ipv4-address-unicast;
      type ipv6-address-unicast-without-local;
    }
    description
      "A unicast IPv4 or IPv6 address with no prefix specified. Link-local addresses are not allowed.";
  }

  typedef ipv4-address-excluding-all-zero {
    type ipv4-address {
      pattern '.*[1-9].*';
    }
  }

  typedef ipv6-address-excluding-all-zero {
    type ipv6-address {
      pattern '.*[1-9a-fA-F].*';
    }
  }

  typedef ip-address-excluding-all-zero {
    type union {
      type ipv4-address-excluding-all-zero;
      type ipv6-address-excluding-all-zero;
    }
    description
      "An IPv4 or IPv6 address with no prefix specified, excluding all zero addresses";
  }

  typedef ip-address-with-zone {
    type union {
      type ipv4-address-with-zone;
      type ipv6-address-with-zone;
    }
    description
      "An IPv4 or IPv6 address with zone with no prefix specified.";
  }

  typedef ip-prefix {
    type union {
      type ipv4-prefix;
      type ipv6-prefix;
    }
    description
      "An IPv4 or IPv6 prefix.";
  }

  typedef ip-prefix-unicast {
    type union {
      type ipv4-prefix-unicast;
      type ipv6-prefix-unicast;
    }
    description
      "A unicast IPv4 or IPv6 prefix";
  }

  typedef ip-prefix-unicast-without-local {
    type union {
      type ipv4-prefix-unicast;
      type ipv6-prefix-unicast-without-local;
    }
    description
      "A unicast IPv4 or IPv6 prefix. Link-local prefixes are not allowed.";
  }

  typedef ipv4-prefix-with-host-bits {
    srl_nokia-ext:generated-class-variant "v4-with-host-bits";
    type ipv4-prefix;
    description
      "An IPv4 prefix with host bits.";
  }

  typedef ipv6-prefix-with-host-bits {
    srl_nokia-ext:generated-class-variant "v6-with-host-bits";
    type ipv6-prefix;
    description
      "An IPv6 prefix with host bits.";
  }

  typedef ip-prefix-with-host-bits {
    type union {
      type ipv4-prefix-with-host-bits;
      type ipv6-prefix-with-host-bits;
    }
    description
      "An IPv4 or IPv6 prefix with host bits.";
  }

  typedef ipv6-address-type {
    type enumeration {
      enum global-unicast {
        description
          "The IPv6 address is a global unicast address type and must be in the format defined in RFC 4291 section 2.4.";
      }
      enum link-local-unicast {
        description
          "The IPv6 address is a Link-Local unicast address type and must be in the format defined in RFC 4291 section 2.4.";
      }
    }
    description
      "The value represents the type of IPv6 address";
    reference
      "RFC 4291: IP Version 6 Addressing Architecture section 2.5";
  }

  typedef mac-address {
    srl_nokia-ext:generated-class-name "MacAddress";
    type string {
      pattern '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}';
    }
    description
      "The mac-address type represents an IEEE 802 MAC address.
       The canonical representation uses lowercase characters.

       In the value set and its semantics, this type is equivalent
       to the MacAddress textual convention of the SMIv2.";
    reference
      "IEEE 802: IEEE Standard for Local and Metropolitan Area
                 Networks: Overview and Architecture
       RFC 2579: Textual Conventions for SMIv2";
  }

  typedef unicast-mac-address {
    type mac-address {
      pattern '([0-9a-fA-F][02468aceACE])(:[0-9a-fA-F]{2}){5}';
      pattern '.*[1-9a-fA-F].*';
    }
    description
      "A unicast MAC address.

       The least significant bit of a MAC address first octet
       is never set. The value 00:00:00:00:00:00 is not valid.";
  }

  typedef domain-name {
    type string {
      length "1..253";
      pattern '((([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.)*'
            + '([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.?)'
            + '|\.';
    }
    description
      "The domain-name type represents a DNS domain name.  The
       name SHOULD be fully qualified whenever possible.

       Internet domain names are only loosely specified.  Section
       3.5 of RFC 1034 recommends a syntax (modified in Section
       2.1 of RFC 1123).  The pattern above is intended to allow
       for current practice in domain name use, and some possible
       future expansion.  It is designed to hold various types of
       domain names, including names used for A or AAAA records
       (host names) and other records, such as SRV records.  Note
       that Internet host names have a stricter syntax (described
       in RFC 952) than the DNS recommendations in RFCs 1034 and
       1123, and that systems that want to store host names in
       schema nodes using the domain-name type are recommended to
       adhere to this stricter standard to ensure interoperability.

       The encoding of DNS names in the DNS protocol is limited
       to 255 characters.  Since the encoding consists of labels
       prefixed by a length bytes and there is a trailing NULL
       byte, only 253 characters can appear in the textual dotted
       notation.

       The description clause of schema nodes using the domain-name
       type MUST describe when and how these names are resolved to
       IP addresses.  Note that the resolution of a domain-name value
       may require to query multiple DNS records (e.g., A for IPv4
       and AAAA for IPv6).  The order of the resolution process and
       which DNS record takes precedence can either be defined
       explicitly or may depend on the configuration of the
       resolver.

       Domain-name values use the US-ASCII encoding.  Their canonical
       format uses lowercase US-ASCII characters.  Internationalized
       domain names MUST be A-labels as per RFC 5890.";
    reference
      "RFC  952: DoD Internet Host Table Specification
       RFC 1034: Domain Names - Concepts and Facilities
       RFC 1123: Requirements for Internet Hosts -- Application
                 and Support
       RFC 2782: A DNS RR for specifying the location of services
                 (DNS SRV)
       RFC 5890: Internationalized Domain Names in Applications
                 (IDNA): Definitions and Document Framework";
  }

  typedef host {
    type union {
      type ipv4;
      type ipv6;
      type domain-name;
    }
    description
      "The host type represents either an IP address or a DNS domain name.";
  }

  typedef port-number {
    type uint16 {
      range "0..65535";
    }
    description
      "The port-number type represents a 16-bit port number of an
       Internet transport-layer protocol such as UDP, TCP, DCCP, or
       SCTP.  Port numbers are assigned by IANA.  A current list of
       all assignments is available from <http://www.iana.org/>.

       Note that the port number value zero is reserved by IANA.  In
       situations where the value zero does not make sense, it can
       be excluded by subtyping the port-number type.
       In the value set and its semantics, this type is equivalent
       to the InetPortNumber textual convention of the SMIv2.";
    reference
      "RFC  768: User Datagram Protocol
       RFC  793: Transmission Control Protocol
       RFC 4960: Stream Control Transmission Protocol
       RFC 4340: Datagram Congestion Control Protocol (DCCP)
       RFC 4001: Textual Conventions for Internet Network Addresses";
  }

  typedef interface-name {
    srl_nokia-ext:generated-class-name "InterfaceName";
    type string;
  }

  typedef subinterface-name {
    srl_nokia-ext:generated-class-name "SubinterfaceName";
    type string;
  }

  typedef interface-all {
    type interface-name {
      length "3..21";
      pattern '(mgmt0|'
            + 'mgmt0-standby|'
            + 'system0|'
            + 'sync0|'
            + 'lo(0|1[0-9][0-9]|2([0-4][0-9]|5[0-5])|[1-9][0-9]|[1-9])|'
            + 'lif-.*|'
            + 'vhn-.*|'
            + 'enp(0|1[0-9][0-9]|2([0-4][0-9]|5[0-5])|[1-9][0-9]|[1-9])s(0|[1-9]|[1-2][0-9]|3[0-1])f[0-7]|'
            + 'ethernet-([1-9](\d){0,1}(/m[1-6])?(/[1-9](\d){0,1})?/(([1-9](\d){0,1})|(1[0-1]\d)|(12[0-8])))|'
            + 'irb(0|1[0-9][0-9]|2([0-4][0-9]|5[0-5])|[1-9][0-9]|[1-9])|'
            + 'lag(([1-9](\d){0,2})|(1000)))';
    }
  }

  typedef interface-eth-lag {
    type interface-name {
      length "3..21";
      pattern '(ethernet-([1-9](\d){0,1}(/m[1-6])?(/[1-9](\d){0,1})?/(([1-9](\d){0,1})|(1[0-1]\d)|(12[0-8])))|'
            + 'lag(([1-9](\d){0,2})|(1000)))';
    }
  }

  typedef interface-eth {
    type interface-name {
      length "3..21";
      pattern '(ethernet-([1-9](\d){0,1}(/m[1-6])?(/[1-9](\d){0,1})?/(([1-9](\d){0,1})|(1[0-1]\d)|(12[0-8]))))';
    }
  }

  typedef subinterface-all {
    type subinterface-name {
      length "5..26";
      pattern '(mgmt0\.0|'
            + 'system0\.0|'
            + 'sync0\.0|'
            + 'lo(0|1[0-9][0-9]|2([0-4][0-9]|5[0-5])|[1-9][0-9]|[1-9])\.(0|[1-9](\d){0,3})|'
            + 'lif-.*\.(0|[1-9](\d){0,3})|'
            + 'vhn-.*\.(0|[1-9](\d){0,3})|'
            + 'enp(0|1[0-9][0-9]|2([0-4][0-9]|5[0-5])|[1-9][0-9]|[1-9])s(0|[1-9]|[1-2][0-9]|3[0-1])f[0-7]\.(0|[1-9](\d){0,3})|'
            + 'ethernet-([1-9](\d){0,1}(/m[1-6])?(/[1-9](\d){0,1})?/(([1-9](\d){0,1})|(1[0-1]\d)|(12[0-8])))\.([0]|[1-9](\d){0,3})|'
            + 'irb(0|1[0-9][0-9]|2([0-4][0-9]|5[0-5])|[1-9][0-9]|[1-9])\.(0|[1-9](\d){0,3})|'
            + 'lag(([1-9](\d){0,2})|(1000))\.(0|[1-9](\d){0,3}))';
    }
  }

  typedef subinterface-eth-lag {
    type subinterface-name {
      length "5..26";
      pattern '(ethernet-([1-9](\d){0,1}(/m[1-6])?(/[1-9](\d){0,1})?/(([1-9](\d){0,1})|(1[0-1]\d)|(12[0-8])))\.([0]|[1-9](\d){0,3})|lag(([1-9](\d){0,2})|(1000))\.(0|[1-9](\d){0,3}))';
    }
  }

  typedef subinterface-no-mgmt {
    type subinterface-name {
      length "5..26";
      pattern '(system0\.0|'
            + 'sync0\.0|'
            + 'lo(0|1[0-9][0-9]|2([0-4][0-9]|5[0-5])|[1-9][0-9]|[1-9])\.(0|[1-9](\d){0,3})|'
            + 'lif-.*\.(0|[1-9](\d){0,3})|'
            + 'vhn-.*\.(0|[1-9](\d){0,3})|'
            + 'enp(0|1[0-9][0-9]|2([0-4][0-9]|5[0-5])|[1-9][0-9]|[1-9])s(0|[1-9]|[1-2][0-9]|3[0-1])f[0-7]\.(0|[1-9](\d){0,3})|'
            + 'ethernet-([1-9](\d){0,1}(/m[1-6])?(/[1-9](\d){0,1})?/(([1-9](\d){0,1})|(1[0-1]\d)|(12[0-8])))\.([0]|[1-9](\d){0,3})|'
            + 'irb(0|1[0-9][0-9]|2([0-4][0-9]|5[0-5])|[1-9][0-9]|[1-9])\.(0|[1-9](\d){0,3})|'
            + 'lag(([1-9](\d){0,2})|(1000))\.(0|[1-9](\d){0,3}))';
    }
  }

  typedef subinterface-eth {
    type subinterface-name {
      length "5..26";
      pattern '(ethernet-([1-9](\d){0,1}(/m[1-6])?(/[1-9](\d){0,1})?/(([1-9](\d){0,1})|(1[0-1]\d)|(12[0-8])))\.([0]|[1-9](\d){0,3})|lag(([1-9](\d){0,2})|(1000))\.(0|[1-9](\d){0,3}))';
    }
  }

  typedef admin-state {
    type enumeration {
      enum enable {
        value 1;
      }
      enum disable {
        value 2;
      }
    }
    description
      "general admin-state option.";
  }

  typedef oper-state {
    type enumeration {
      enum up {
        value 1;
        description
          "Component or process is operational";
      }
      enum down {
        value 2;
        description
          "Component or process is not operational";
      }
      enum empty {
        value 3;
        description
          "Component slot is empty";
      }
      enum downloading {
        value 4;
        description
          "Component is downloading image into memory";
      }
      enum booting {
        value 5;
        description
          "Component is booting downloaded image";
      }
      enum starting {
        value 6;
        description
          "Component image operational, application processes starting";
      }
      enum failed {
        value 7;
        description
          "Component or process has failed";
      }
      enum synchronizing {
        value 8;
        description
          "Component is currently being synchronized";
      }
      enum upgrading {
        value 9;
        description
          "Component is currently being upgraded";
      }
      enum low-power {
        value 10;
        description
          "Component is offline due to insufficient system power";
      }
      enum degraded {
        value 11;
        description
          "Component or process is in a degraded state";
      }
      enum warm-reboot {
        value 12;
        description
          "Component or process is currently warm rebooting

           This state is set during a warm reboot immediately following initiation of the reboot, continuing after startup until the system has completed audit. In this state the system will not accept configuration changes.";
      }
      enum waiting {
        value 13;
        description
          "Component or process is currently waiting

           This state can be set by event handler when the reinvoke-with-delay action is used, and indicates that the event handler is waiting for the provided delay before reinvoking the instance.";
      }
    }
    description
      "General operational state";
  }

  typedef mpls-label-non-reserved {
    type uint32 {
      range "16..1048575";
    }
  }

  typedef mpls-label-with-explicit-null {
    type union {
      type mpls-label-non-reserved;
      type enumeration {
        enum IPV4_EXPLICIT_NULL {
          value 0;
        }
        enum IPV6_EXPLICIT_NULL {
          value 2;
        }
      }
    }
  }

  typedef mpls-label-with-implicit-and-explicit-null {
    type union {
      type mpls-label-non-reserved;
      type enumeration {
        enum IPV4_EXPLICIT_NULL {
          value 0;
        }
        enum IPV6_EXPLICIT_NULL {
          value 2;
        }
        enum IMPLICIT_NULL {
          value 3;
        }
      }
    }
  }

  typedef isis-system-id {
    description
      "This type defines ISIS system id using pattern. An example of a system ID is 0143.0438.AeF0";
    type string {
      pattern '[0-9A-Fa-f]{4}\.[0-9A-Fa-f]{4}\.[0-9A-Fa-f]{4}';
      length "14";
    }
  }

  typedef isis-lsp-id {
    description
      "This type defines ISIS LSP ID. ISIS LSP ID type should be in the form of xxxx.xxxx.xxxx.xx-xx";
    type string {
      pattern '[0-9A-Fa-f]{4}\.[0-9A-Fa-f]{4}\.[0-9A-Fa-f]{4}\.[0-9A-Fa-f][0-9A-Fa-f]-[0-9A-Fa-f][0-9A-Fa-f]';
      length "20";
    }
  }

  typedef counter32 {
    type uint32;
    description
      "The counter32 type represents a non-negative integer
       that monotonically increases until it reaches a
       maximum value of 2^32-1 (4294967295 decimal), when it
       wraps around and starts increasing again from zero.

       Counters have no defined 'initial' value, and thus, a
       single value of a counter has (in general) no information
       content.  Discontinuities in the monotonically increasing
       value normally occur at re-initialization of the
       management system, and at other times as specified in the
       description of a schema node using this type.  If such
       other times can occur, for example, the creation of
       a schema node of type counter32 at times other than
       re-initialization, then a corresponding schema node
       should be defined, with an appropriate type, to indicate
       the last discontinuity.

       The counter32 type should not be used for configuration
       schema nodes.  A default statement SHOULD NOT be used in
       combination with the type counter32.

       In the value set and its semantics, this type is equivalent
       to the Counter32 type of the SMIv2.";
    reference
      "RFC 2578: Structure of Management Information Version 2
                 (SMIv2)";
  }

  typedef zero-based-counter32 {
    type counter32;
    default "0";
    description
      "The zero-based-counter32 type represents a counter32
       that has the defined 'initial' value zero.

       A schema node of this type will be set to zero (0) on creation
       and will thereafter increase monotonically until it reaches
       a maximum value of 2^32-1 (4294967295 decimal), when it
       wraps around and starts increasing again from zero.

       Provided that an application discovers a new schema node
       of this type within the minimum time to wrap, it can use the
       'initial' value as a delta.  It is important for a management
       station to be aware of this minimum time and the actual time
       between polls, and to discard data if the actual time is too
       long or there is no defined minimum time.

       In the value set and its semantics, this type is equivalent
       to the ZeroBasedCounter32 textual convention of the SMIv2.";
    reference
      "RFC 4502: Remote Network Monitoring Management Information
                 Base Version 2";
  }

  typedef counter64 {
    type uint64;
    description
      "The counter64 type represents a non-negative integer
       that monotonically increases until it reaches a
       maximum value of 2^64-1 (18446744073709551615 decimal),
       when it wraps around and starts increasing again from zero.

       Counters have no defined 'initial' value, and thus, a
       single value of a counter has (in general) no information
       content.  Discontinuities in the monotonically increasing
       value normally occur at re-initialization of the
       management system, and at other times as specified in the
       description of a schema node using this type.  If such
       other times can occur, for example, the creation of
       a schema node of type counter64 at times other than
       re-initialization, then a corresponding schema node
       should be defined, with an appropriate type, to indicate
       the last discontinuity.

       The counter64 type should not be used for configuration
       schema nodes.  A default statement SHOULD NOT be used in
       combination with the type counter64.

       In the value set and its semantics, this type is equivalent
       to the Counter64 type of the SMIv2.";
    reference
      "RFC 2578: Structure of Management Information Version 2
                 (SMIv2)";
  }

  typedef zero-based-counter64 {
    type counter64;
    default "0";
    description
      "The zero-based-counter64 type represents a counter64 that
       has the defined 'initial' value zero.

       A schema node of this type will be set to zero (0) on creation
       and will thereafter increase monotonically until it reaches
       a maximum value of 2^64-1 (18446744073709551615 decimal),
       when it wraps around and starts increasing again from zero.

       Provided that an application discovers a new schema node
       of this type within the minimum time to wrap, it can use the
       'initial' value as a delta.  It is important for a management
       station to be aware of this minimum time and the actual time
       between polls, and to discard data if the actual time is too
       long or there is no defined minimum time.

       In the value set and its semantics, this type is equivalent
       to the ZeroBasedCounter64 textual convention of the SMIv2.";
    reference
      "RFC 2856: Textual Conventions for Additional High Capacity
                 Data Types";
  }

  typedef timeticks64 {
    type uint64;
    description
      "This type is based on the timeticks type defined in
       RFC 6991, but with 64-bit width.  It represents the time,
       modulo 2^64, in hundredths of a second between two epochs.";
    reference
      "RFC 6991: Common YANG Data Types.";
  }

  typedef ieeefloat32 {
    type binary {
      length "4";
    }
    description
      "An IEEE 32-bit floating point number. The format of this number
       is of the form:
        1-bit  sign
        8-bit  exponent
        23-bit fraction
       The floating point value is calculated using:
        (-1)**S * 2**(Exponent-127) * (1+Fraction)";
  }

  typedef gauge32 {
    type uint32;
    description
      "The gauge32 type represents a non-negative integer, which
       may increase or decrease, but shall never exceed a maximum
       value, nor fall below a minimum value.  The maximum value
       cannot be greater than 2^32-1 (4294967295 decimal), and
       the minimum value cannot be smaller than 0.  The value of
       a gauge32 has its maximum value whenever the information
       being modeled is greater than or equal to its maximum
       value, and has its minimum value whenever the information
       being modeled is smaller than or equal to its minimum value.
       If the information being modeled subsequently decreases
       below (increases above) the maximum (minimum) value, the
       gauge32 also decreases (increases).

       In the value set and its semantics, this type is equivalent
       to the Gauge32 type of the SMIv2.";
    reference
      "RFC 2578: Structure of Management Information Version 2
                 (SMIv2)";
  }

  typedef gauge64 {
    type uint64;
    description
      "The gauge64 type represents a non-negative integer, which
       may increase or decrease, but shall never exceed a maximum
       value, nor fall below a minimum value.  The maximum value
       cannot be greater than 2^64-1 (18446744073709551615), and
       the minimum value cannot be smaller than 0.  The value of
       a gauge64 has its maximum value whenever the information
       being modeled is greater than or equal to its maximum
       value, and has its minimum value whenever the information
       being modeled is smaller than or equal to its minimum value.
       If the information being modeled subsequently decreases
       below (increases above) the maximum (minimum) value, the
       gauge64 also decreases (increases).

       In the value set and its semantics, this type is equivalent
       to the CounterBasedGauge64 SMIv2 textual convention defined
       in RFC 2856";
    reference
      "RFC 2856: Textual Conventions for Additional High Capacity
                 Data Types";
  }

  typedef percentage {
    type uint8 {
      range "0..100";
    }
    description
      "Integer indicating a percentage value";
  }

  typedef temperature {
    type int16;
    units "celsius";
    description
      "Integer indicating a temperature, displayed as degrees celsius";
  }

  typedef date-and-time {
    type string {
      pattern '\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?'
            + '(Z|[\+\-]\d{2}:\d{2})';
      length "20..32";
    }
    description
      "The date-and-time type is a profile of the ISO 8601
       standard for representation of dates and times using the
       Gregorian calendar.  The profile is defined by the
       date-time production in Section 5.6 of RFC 3339.

       The date-and-time type is compatible with the dateTime XML
       schema type with the following notable exceptions:

       (a) The date-and-time type does not allow negative years.

       (b) The date-and-time time-offset -00:00 indicates an unknown
           time zone (see RFC 3339) while -00:00 and +00:00 and Z
           all represent the same time zone in dateTime.

       (c) The canonical format (see below) of data-and-time values
           differs from the canonical format used by the dateTime XML
           schema type, which requires all times to be in UTC using
           the time-offset 'Z'.

       This type is not equivalent to the DateAndTime textual
       convention of the SMIv2 since RFC 3339 uses a different
       separator between full-date and full-time and provides
       higher resolution of time-secfrac.

       The canonical format for date-and-time values with a known time
       zone uses a numeric time zone offset that is calculated using
       the device's configured known offset to UTC time.  A change of
       the device's offset to UTC time will cause date-and-time values
       to change accordingly.  Such changes might happen periodically
       in case a server follows automatically daylight saving time
       (DST) time zone offset changes.  The canonical format for
       date-and-time values with an unknown time zone (usually
       referring to the notion of local time) uses the time-offset
       -00:00.";
    reference
      "RFC 3339: Date and Time on the Internet: Timestamps
       RFC 2579: Textual Conventions for SMIv2
       XSD-TYPES: XML Schema Part 2: Datatypes Second Edition";
  }

  typedef date-and-time-delta {
    type date-and-time;
    srl_nokia-ext:output-flavor "timestamp-and-natural-time-delta";
    srl_nokia-ext:preferred-column-width "47";
    description
      "When this type is used to store a date and time, show routines should display it as a delta
       with respect to the current date and time in the format 'dddd:hh:mm:ss ago' (for a past
       event) or 'in dddd:hh:mm:ss' (future event), where dddd is the number of days, hh is the
       number of  hours, mm is the number of  minutes and ss is the number of seconds.";
  }

  typedef alphanumeric {
    type string {
      pattern '[A-Za-z0-9!@#$%^&()|+=`~.,/_:;?-][A-Za-z0-9 !@#$%^&()|+=`~.,/_:;?-]*';
    }
    description
      "A simple, one-line string that does not contain any control characters";
  }

  typedef description {
    type string {
      length "1..255";
    }
    description
      "A user provided description string";
  }

  typedef name {
    type alphanumeric {
      length "1..255";
    }
    description
      "A user provided name";
  }

  typedef name-without-space {
    type name {
      pattern '[A-Za-z0-9!@#$%^&()|+=`~.,/_:;?-][A-Za-z0-9!@#$%^&()|+=`~.,/_:;?-]*';
    }
    description
      "A user provided name without space";
  }

  typedef restricted-name {
    type string {
      pattern '[A-Za-z0-9!@#$%^&()|+=`~.,_:;?-][A-Za-z0-9 !@#$%^&()|+=`~.,_:;?-]*';
      length "1..247";
    }
    description
      "A simple, one-line string that does not contain any control characters, and is Linux-safe.";
  }

  typedef username {
    type name {
      srl_nokia-ext:preferred-column-width "16";
    }
    description
      "Username";
  }

  typedef checkpoint-name {
    type string {
      pattern '[^0-9].*' {
        error-message "Name cannot start with number";
      }
    }
  }

  typedef uuid {
    type string {
      pattern '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-'
            + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}';
    }
    description
      "A Universally Unique IDentifier in the string representation
       defined in RFC 4122.  The canonical representation uses
       lowercase characters.

       The following is an example of a UUID in string representation:
       f81d4fae-7dec-11d0-a765-00a0c91e6bf6
      ";
    reference
      "RFC 4122: A Universally Unique IDentifier (UUID) URN
                 Namespace";
  }

  typedef hex-string {
    type string {
      pattern '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?';
    }
    description
      "A hexadecimal string with octets represented as hex digits
       separated by colons.  The canonical representation uses
       lowercase characters.";
  }

  typedef hex-number {
    type string {
      pattern '0x[0-9a-fA-F]+';
    }
    description
      "A hexadecimal string with leading 0x following by one or more digits with no separation by colons";
  }

  typedef local-file {
    type string {
      pattern '(/[0-9A-Za-z_\-\.]+)+';
    }
    description
      "A regular expression matching a local file";
  }

  typedef local-file-no-path {
    type string {
      pattern '[0-9A-Za-z_\-\.]*';
      length "1..255";
    }
    description
      "A regular expression matching a local file without a path";
  }

  typedef route-distinguisher-type-0 {
    srl_nokia-ext:generated-class-name "RouteDistinguisher";
    type string {
      pattern '(6553[0-5]|655[0-2][0-9]|654[0-9]{2}|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9])'
            + ':'
            + '(429496729[0-5]|42949672[0-8][0-9]|4294967[0-1][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}'
            + '|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[0-1][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{1,8}|[0-9])';
    }
  }

  typedef route-distinguisher-type-1 {
    srl_nokia-ext:generated-class-name "RouteDistinguisher";
    type string {
      pattern '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
            + ':'
            + '(6553[0-5]|655[0-2][0-9]|654[0-9]{2}|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9])';
    }
  }

  typedef route-distinguisher-type-2 {
    srl_nokia-ext:generated-class-name "RouteDistinguisher";
    type string {
      pattern '(429496729[0-5]|42949672[0-8][0-9]|4294967[0-1][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}'
            + '|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[0-1][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{1,8}|[0-9])'
            + ':'
            + '(6553[0-5]|655[0-2][0-9]|654[0-9]{2}|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9])';
    }
  }

  typedef route-distinguisher-type-2b {
    srl_nokia-ext:generated-class-name "RouteDistinguisher";
    type string {
      pattern '(6553[0-5]|655[0-2][0-9]|654[0-9]{2}|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9])'
            + '.'
            + '(6553[0-5]|655[0-2][0-9]|654[0-9]{2}|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9])'
            + ':'
            + '(6553[0-5]|655[0-2][0-9]|654[0-9]{2}|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9])';
    }
  }

  typedef route-distinguisher {
    type union {
      type route-distinguisher-type-0;
      type route-distinguisher-type-1;
      type route-distinguisher-type-2;
      type route-distinguisher-type-2b;
    }
    description
      "A route distinguisher value";
    reference
      "RFC4364";
  }

  typedef next-hop-type {
    type union {
      type enumeration {
        enum use-system-ipv4-address {
          value 0;
        }
      }
      type srl_nokia-comm:ip-address;
    }
  }

  identity ip-route-type {
    description
      "Base type for the types of entries that can be installed in the IP FIB.";
  }

  typedef l2cp-oper-rule-state {
    type enumeration {
      enum trap-to-cpu-untagged;
      enum drop-tagged-and-untagged;
      enum tunnel-tagged-and-untagged;
      enum tunnel-tagged-drop-untagged {
        if-feature "srl-feat:fpcx";
      }
      enum tunnel-tagged-trap-to-cpu-untagged {
        if-feature "srl-feat:fpcx";
      }
      enum trap-to-cpu-tagged-and-untagged;
    }
  }

  identity mpls-label-entry-type {
    description
      "Base type for the types of entries that can be installed in the MPLS label FIB.";
  }

  identity tunnel-type {
    description
      "Base type for the types of tunnels that can be installed in the tunnel table.";
  }

  identity bgp-next-hop-resolution-tunnel-type {
    description
      "Base type for the types of tunnels that can be used by BGP for next-hop resolution";
  }

  identity routing-policy-protocol-match-type {
    description
      "Base type for the types of routes and tunnels that can be matched by a route policy statement";
  }

  identity table-connection-protocol {
    description
      "Base type for protocols that can be used in table connections";
  }

  identity aggregate {
    base ip-route-type;
    base routing-policy-protocol-match-type;
    description
      "Locally configured aggregate route";
  }

  identity arp-nd {
    base ip-route-type;
    base routing-policy-protocol-match-type;
    description
      "IP route added by ARP ND.";
  }

  identity bgp {
    base ip-route-type;
    base mpls-label-entry-type;
    base tunnel-type;
    base bgp-next-hop-resolution-tunnel-type;
    base routing-policy-protocol-match-type;
    base table-connection-protocol;
    description
      "Border Gateway Protocol version 4";
    reference
      "RFC 4271";
  }

  identity bgp-evpn {
    base ip-route-type;
    base routing-policy-protocol-match-type;
    description
      "BGP Ethernet VPN (EVPN) Interface-less";
  }

  identity bgp-evpn-ifl-host {
    base ip-route-type;
    base routing-policy-protocol-match-type;
    description
      "BGP Ethernet VPN (EVPN) Interface-less Host";
  }

  identity bgp-ipvpn {
    if-feature "srl-feat:ipvpn";
    base ip-route-type;
    base routing-policy-protocol-match-type;
    description
      "BGP IP VPN";
  }

  identity bgp-label {
    base ip-route-type;
    base routing-policy-protocol-match-type;
    description
      "BGP labeled-unicast";
  }

  identity dhcp {
    base ip-route-type;
    base routing-policy-protocol-match-type;
    description
      "IP (default) route added by DHCP.";
  }

  identity esi {
    base mpls-label-entry-type;
    description
      "ESI mpls label entry, used by BGP-EVPN";
  }

  identity pseudowire {
    base mpls-label-entry-type;
    description
      "Pseudowire mpls label entry";
  }

  identity gribi {
    base ip-route-type;
    description
      "A gRIBI route";
  }

  identity host {
    base ip-route-type;
    base routing-policy-protocol-match-type;
    description
      "A host route";
  }

  identity ip-in-ip {
    base tunnel-type;
    description
      "Tunnels with IP-in-IP encapsulation";
  }

  identity gre {
    base tunnel-type;
    description
      "Tunnels with GRE encapsulation";
  }

  identity isis {
    base ip-route-type;
    base routing-policy-protocol-match-type;
    base table-connection-protocol;
    description
      "IS-IS";
    reference
      "ISO/IEC 10589";
  }

  identity local {
    base ip-route-type;
    base routing-policy-protocol-match-type;
    base table-connection-protocol;
    description
      "A directly connected route";
  }

  identity ldp {
    base mpls-label-entry-type;
    base tunnel-type;
    base bgp-next-hop-resolution-tunnel-type;
    description
      "Label distribution protocol";
  }

  identity linux {
    base ip-route-type;
    description
      "IP route added by the linux kernel.";
  }

  identity ndk1 {
    base ip-route-type;
    description
      "Route added by an agent application using the NDK";
  }

  identity ndk2 {
    base ip-route-type;
    description
      "Route added by an agent application using the NDK";
  }

  identity network-instance {
    base mpls-label-entry-type;
    description
      "Network Instance mpls label entry, used by EVPN or IP-VPN";
  }

  identity ospfv2 {
    base ip-route-type;
    base routing-policy-protocol-match-type;
    description
      "OSPFv2";
    reference
      "RFC 2328";
  }

  identity ospfv3 {
    base ip-route-type;
    base routing-policy-protocol-match-type;
    description
      "OSPFv3";
    reference
      "RFC 5340";
  }

  identity sr-isis {
    base tunnel-type;
    base bgp-next-hop-resolution-tunnel-type;
    description
      "Segment routing using MPLS dataplane, programmed by IS-IS";
  }

  identity sr-ospfv2 {
    if-feature "srl-feat:future-0-0";
    base tunnel-type;
    description
      "Segment routing using MPLS dataplane, programmed by OSPFv2";
  }

  identity sr-ospfv3 {
    if-feature "srl-feat:future-0-0";
    base tunnel-type;
    description
      "Segment routing using MPLS dataplane, programmed by OSPFv3";
  }

  identity sr-mpls {
    base mpls-label-entry-type;
    description
      "Segment routing using MPLS dataplane, programmed by segment routing manager.";
  }

  identity sr-submgmt {
    if-feature "srl-feat:submgmt-fpcx";
    base ip-route-type;
    base routing-policy-protocol-match-type;
    description
      "Subscriber-management route";
  }

  identity te-policy-sr-mpls-colored {
    if-feature "srl-feat:segment-routing-colored-te-policies";
    base tunnel-type;
    base bgp-next-hop-resolution-tunnel-type;
    base mpls-label-entry-type;
    description
      "Tunnel setup with sr-mpls-colored type TE-Policy. Labeled Traffic Engineering Policy with color";
  }

  identity te-policy-sr-mpls-uncolored {
    if-feature "srl-feat:te-policies";
    base tunnel-type;
    base bgp-next-hop-resolution-tunnel-type;
    base mpls-label-entry-type;
    description
      "Tunnel setup with sr-mpls-uncolored type TE-Policy. Labeled Traffic Engineering Policy with primary and secondary segment-lists.";
  }

  identity static {
    base ip-route-type;
    base routing-policy-protocol-match-type;
    base table-connection-protocol;
    description
      "Locally configured static route";
  }

  identity static-mpls {
    base mpls-label-entry-type;
    description
      "Locally configured static MPLS route.";
  }

  identity vxlan {
    base tunnel-type;
    description
      "Tunnels based on VXLAN encapsulation";
  }

  identity bgp-address-family {
    description
      "Base type for BGP address families.";
  }

  identity ipv4-unicast {
    base bgp-address-family;
    description
      "Unlabeled IPv4 unicast routes (AFI = 1, SAFI = 1)";
  }

  identity ipv6-unicast {
    base bgp-address-family;
    description
      "Unlabeled IPv6 unicast routes (AFI = 2, SAFI = 1)";
  }

  identity l3vpn-ipv4-unicast {
    if-feature "srl-feat:ipvpn";
    base bgp-address-family;
    description
      "VPN-IPv4 unicast address family (AFI = 1, SAFI = 128)";
  }

  identity l3vpn-ipv6-unicast {
    if-feature "srl-feat:ipvpn";
    base bgp-address-family;
    description
      "VPN-IPv6 unicast address family (AFI = 2, SAFI = 128)";
  }

  identity ipv4-labeled-unicast {
    if-feature "srl-feat:bgp-labeled-unicast";
    base bgp-address-family;
    description
      "Labeled IPv4 unicast routes (AFI 1, SAFI 4)";
  }

  identity ipv6-labeled-unicast {
    if-feature "srl-feat:bgp-labeled-unicast";
    base bgp-address-family;
    description
      "Labeled IPv6 unicast routes (AFI 2, SAFI 4)";
  }

  identity evpn {
    base bgp-address-family;
    description
      "EVPN routes (AFI = 25, SAFI = 70)";
  }

  identity route-target {
    if-feature "srl-feat:bgp-rtc";
    base bgp-address-family;
    description
      "Route target constraint routes (AFI 1, SAFI 132)";
  }

  identity srte-policy-ipv4 {
    if-feature "srl-feat:bgp-srte-policy";
    base bgp-address-family;
    description
      "TE Policy Colored SR-MPLS routes (AFI 1, SAFI 73)";
  }

  identity srte-policy-ipv6 {
    if-feature "srl-feat:bgp-srte-policy";
    base bgp-address-family;
    description
      "TE Policy Colored SR-MPLS routes (AFI 2, SAFI 73)";
  }

  identity link-state {
    if-feature "srl-feat:traffic-engineering-bgpls";
    base bgp-address-family;
    description
      "Link State (AFI 16388, SAFI 71)";
  }

  typedef queue-index {
    type uint8 {
      range "0..7";
    }
  }

  typedef mac-type {
    type enumeration {
      enum static {
        value 1;
      }
      enum duplicate {
        value 2;
      }
      enum learnt {
        value 3;
      }
      enum irb-interface {
        value 4;
      }
      enum evpn {
        value 5;
      }
      enum evpn-static {
        value 6;
      }
      enum irb-interface-anycast {
        value 7;
      }
      enum proxy-anti-spoof {
        value 8;
      }
      enum reserved {
        value 9;
      }
      enum eth-cfm {
        value 10;
      }
      enum irb-interface-vrrp {
        value 11;
      }
    }
    description
      "type of mac addresses in the system";
  }

  typedef destination-type {
    type enumeration {
      enum sub-interface {
        value 1;
      }
      enum blackhole {
        value 2;
      }
      enum irb-interface {
        value 3;
      }
      enum vxlan {
        value 4;
      }
      enum reserved {
        value 5;
      }
      enum evpn-mpls {
        value 6;
      }
      enum connection-point {
        value 7;
      }
    }
    description
      "type of destination types in the system";
  }

  typedef esi {
    type string {
      pattern '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){9}';
    }
    description
      "Ethernet Segment Identifier that can be configured or autoderived.
       Its length is always 10 bytes and it is used by BGP-EVPN to identify objects in the control plane that
       belong to the same Ethernet Segment.";
    reference
      "RFC7432";
  }

  typedef multicast-type {
    type enumeration {
      enum none {
        value 1;
      }
      enum BUM {
        value 2;
      }
      enum unknown-unicast {
        value 3;
      }
      enum broadcast-mcast {
        value 4;
      }
    }
    description
      "multicast type of destination in the system";
  }

  typedef user-password {
    type string {
      srl_nokia-ext:generated-class-name "PasswordHash";
    }
    description
      "The password can be supplied either as cleartext or as a hashed value

       If provided as cleartext, the system will hash the value on input, storing only the hashed value.
       If provided as a hashed value, the value should include any '$' characters, for example '$ar2$aOvsuj0ALlU=$r750fMa3ZEA/Di8dIfU2fQ=='.";
  }

  typedef macsec-key-name {
    type string {
      pattern '([0-9a-fA-F][0-9a-fA-F])+';
    }
    description
      "A hexadecimal string of even number of digits with no separation by colons";
  }

  typedef macsec-cak {
    type string {
      pattern '[0-9a-fA-F]+';
    }
    description
      "A hexadecimal string of one or more digits with no separation by colons";
  }

  typedef macsec-password {
    type macsec-cak;
    srl_nokia-ext:generated-class-name "SecretKey";
    description
      "This type is used for passwords that are typically used to authenticate routing protocol messages.

       The system stores these passwords in encrypted form and always returns the encrypted string when
       management server reads a leaf of this type.

       When configuring a leaf of this type, the entered string can be a cleartext password or an
       encrypted/hashed password. An encrypted password is recognized when the string starts with a '$'
       character and has two further '$' characters to separate the encoding of the algorithm and the
       encoding of the salt from the actual encrypted data. Any other text string is interpreted as cleartext.

       The system automatically truncates cleartext passwords to the first 20 characters. Characters beyond
       this length are not used in the encryption process.";
  }

  typedef routing-password {
    type string;
    srl_nokia-ext:generated-class-name "SecretKey";
    description
      "This type is used for passwords that are typically used to authenticate routing protocol messages. The system stores these passwords in encrypted form and always returns the encrypted string when management server reads a leaf of this type.

       When configuring a leaf of this type, the entered string can be a cleartext password or an encrypted/hashed password. An encrypted password is recognized when the string starts with a '$' character and has two further '$' characters to separate the encoding of the algorithm and the encoding of the salt from the actual encrypted data. Any other text string is interpreted as cleartext.

       The system automatically truncates cleartext passwords to the first 20 characters. Characters beyond this length are not used in the encryption process.";
  }

  typedef crypt-password-type {
    type string;
    description
      "A password that is hashed based on the hash algorithm
       indicated by the prefix in the string.  The string
       takes the following form, based on the Unix crypt function:

       $<id>[$<param>=<value>(,<param>=<value>)*][$<salt>[$<hash>]]

       Common hash functions include:

       id  | hash function
        ---+---------------
         1 | MD5
         2a| Blowfish
         2y| Blowfish (correct handling of 8-bit chars)
         5 | SHA-256
         6 | SHA-512

       These may not all be supported by a target device.";
  }

  typedef evi {
    description
      "The supported range of EVPN Instances.";
    type uint32 {
      range "1..65535";
    }
  }

  typedef forwarding-type {
    type enumeration {
      enum unicast {
        value 1;
        description
          "A packet is 'unicast' if the destination address is unicast and it matches an entry in the FIB";
      }
      enum unknown-unicast {
        value 2;
        description
          "A packet is 'unknown-unicast' if the destination address is unicast but it doesn't match any entry in the FIB and is therefore conventionally flooded";
      }
      enum multicast {
        value 3;
        if-feature "srl-feat:trident3 or srl-feat:fpcx";
        description
          "A packet is 'multicast' if the destination address is a multicast address

           On TD3 systems this includes multicast packets with a known destination/group address and multicast packets with an unknown destination/group address. On TD4 systems this only includes known multicast packets";
      }
      enum unknown-multicast {
        value 4;
        if-feature "srl-feat:trident4";
        description
          "Multicast packets with an unknown destination/group address";
      }
      enum broadcast {
        value 5;
        description
          "A packet is 'broadcast' if the destination address is a broadcast address";
      }
    }
  }

  typedef drop-probability {
    description
      "The various drop probability classifications that can be applied to a packet";
    type enumeration {
      enum low {
        value 1;
        description
          "Traffic that should be dropped last when there is congestion. Internally this is traffic that is colored green.";
      }
      enum medium {
        value 2;
        description
          "Traffic that should be dropped before green traffic but after red traffic when there is congestion. Internally this is traffic that is colored yellow.";
      }
      enum high {
        value 3;
        description
          "Traffic that should be dropped first when there is congestion. Internally this is traffic that is colored red.";
      }
    }
  }

  typedef classify-profile {
    description
      "Profile-names for different profiles used during classification";
    type enumeration {
      enum in {
        value 1;
        description
          "Defines packet profile as an input for colour-aware policing at ingress";
      }
      enum out {
        value 2;
        description
          "Defines packet profile as an input for colour-aware policing at ingress";
      }
      enum exceed {
        value 3;
        description
          "Defines packet profile as an input for colour-aware policing at ingress";
      }
      enum in-plus {
        value 4;
        description
          "Defines packet profile as an input for colour-aware policing at ingress";
      }
      enum in-low {
        value 5;
        description
          "Defines packet profile as an input for colour-blind policing at ingress";
      }
      enum out-low {
        value 6;
        description
          "Defines packet profile as an input for colour-blind policing at ingress";
      }
    }
  }

  typedef rewrite-profile {
    description
      "Profile-names for different profiles used during egress re-marking";
    type enumeration {
      enum in {
        value 1;
        description
          "The second level priority profile";
      }
      enum out {
        value 2;
        description
          "The lowest level priotity profile";
      }
      enum exceed {
        value 3;
        description
          "The third level priority profile";
      }
      enum in-plus {
        value 4;
        description
          "The highest priority profile";
      }
    }
  }

  typedef adaptation-rule {
    description
      "Defines how the configured parameter (rate or buffer size) is mapped into HW defined values.";
    default "closest";
    type enumeration {
      enum closest {
        value 1;
        description
          "Closest possible HW value is used.";
      }
      enum lower {
        value 2;
        description
          "The configured values is aligned with closest lower HW value.";
      }
      enum higher {
        value 3;
        description
          "The configured value is aligned with the closest higher HW value.";
      }
    }
  }

  typedef pcr {
    type uint8 {
      range "0..31";
    }
    description
      "Valid index number for a PCR. A TPM2.0 compliant PCR index extends from 0-31.";
  }

  typedef bgp-next-hop-type {
    type union {
      type ip-address;
      type enumeration {
        enum SELF {
          description
            "Special designation for local router's own address, i.e., next-hop-self";
        }
      }
    }
    description
      "Type definition for specifying the BGP next-hop address in policy actions";
  }

  typedef rule-sequence-id {
    type uint32 {
      range "0..128";
    }
    description
      "Valid sequence id for an ACL filter rule or a policy forwarding rule sequence id.";
  }

  typedef packet-link-qualification-id {
    type string {
      pattern "[<>A-Za-z0-9!@#$%^&()|+=`~.,'/_:;?-][<>A-Za-z0-9 !@#$%^&()|+=`~.,'/_:;?-]*";
      length "1..255";
    }
    description
      "Packet link qualification test ID";
  }

  typedef component-name {
    srl_nokia-ext:generated-class-name "ComponentName";
    type string;
  }

  typedef protocol-origin-type {
    type enumeration {
      enum pcep {
        value 10;
        description
          "PCEP used as signalling mechanism for the candidate path";
      }
      enum bgp {
        value 20;
        description
          "BGP used as signalling mechanism for the candidate path";
      }
      enum local {
        value 30;
        description
          "Management interface used for candidate path instantiation";
      }
    }
    description
      "Originating protocol type";
  }

  typedef te-policy-type {
    type enumeration {
      enum sr-mpls-colored {
        if-feature "srl-feat:segment-routing-colored-te-policies";
      }
      enum sr-mpls-uncolored;
    }
  }
}
""")
    res.append(r"""module srl_nokia-extensions {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:general:extensions";
  prefix srl_nokia-ext;

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "YANG module detailing SRLinux extensions";

  revision 2024-10-31 {
    description
      "SRLinux 24.10.1";
  }
  revision 2024-07-31 {
    description
      "SRLinux 24.7.1";
  }
  revision 2024-03-31 {
    description
      "SRLinux 24.3.1";
  }
  revision 2022-06-30 {
    description
      "SRLinux 22.6.1";
  }
  revision 2022-03-31 {
    description
      "SRLinux 22.3.1";
  }
  revision 2021-06-30 {
    description
      "SRLinux 21.6.1";
  }
  revision 2021-03-31 {
    description
      "SRLinux 21.3.1";
  }
  revision 2020-06-30 {
    description
      "SRLinux 20.6.1";
  }
  revision 2018-10-21 {
    description
      "SRLinux 19.11.1";
  }

  extension application-group {
    description
      "Takes as an argument an application group name and optional xpath expression. This application group is used
       to indicate to application manager which applications need to be started.

       For example: app-group-b
                    app-group-c, ./type == 'ip'";
    argument value;
  }

  extension generated-class-name {
    description
      "Takes as an argument a name string. Makes the telemetry code generator use the given name
       as the name of the key or data class used for storing the content of this type

       Currently the only class names supported are:
       InterfaceName, IpAddress, IpAddressWithZone, IpPrefix, MacAddress, PasswordHash, RouteDistinguisher, SecretKey, SubinterfaceName";
    argument name;
  }

  extension generated-class-variant {
    description
      "Takes as an argument a variant string. Makes the telemetry code generator use the given variant
       of the key or data class used for storing the content of this type

       Valid values depend of the generated-class-name extension.";
    argument name;
  }

  extension hash-algorithm {
    description
      "Takes as an argument a value string. Used only when generated-class-name is PasswordHash.
       PasswordHash defaults to Yescrypt hashing (yescrypt).

       Currently the only hash algorithms supported are: ar2, sha1, sha2, yescrypt";
    argument value;
  }

  extension delivery-node-override {
    description
      "Takes as an argument a string value. Makes the container behave as a delivery node if set to 'true'. If set
       to 'false', then behave as normal. Regular delivery nodes are the root, all direct children of root, any lists
       (not leaf-lists), child containers where parent's owning application is different than the child container's
       owning application. When set to the value 'separate-state-request', then only the state request will be launched
       separately for this node (as if the node belonged to another application). This extension is not inherited from
       parent nodes (it is like a tag).

       Currently the only values supported are: true, separate-state-request, false";
    argument value;
  }

  extension unordered-state-list {
    description
      "Takes as an argument a boolean value. If set to 'true', then mgmt_server will not enforce the key order in the
       received state responses from the application. Similar to what ordered-by user does for config lists. Applicable
       only for lists.

       Currently the only values supported are: true, false";
    argument value;
  }

  extension deliver-decrypted {
    description
      "Takes as an argument a boolean value. Decrypts leaf value before delivering it to the application. Applies only
       for applications with config-delivery-format is set to json in their .yml configuration (e.g. NDK apps).";
    argument value;
  }

  extension output-flavor {
    description
      "Takes as an argument a string defining the special formatting of this type with respect to
       the info from state output.  By default the output fields are formatted according to their
       basic yang type.  This flavor specification makes it possible to transform the value as it
       is printed as part of info from state output. Applies to any cli outputs (text/json/table).
       Can be suppressed from cli by doing info detail from state.

       Currently the only values supported are: time-delta, natural-time-delta, with-units, hex, hex-with-colons

       time-delta

           When this flavor is used to display a date and time, info from state will display it as
           a delta with respect to the current date and time in the format 'dddd:hh:mm:ss ago' (for
           a past event) or 'in dddd:hh:mm:ss' (future event), where dddd is the number of days, hh is
           the number of  hours, mm is the number of  minutes and ss is the number of seconds.

       natural-time-delta

           When this flavor is used to display a date and time, info from state will display it as
           a delta with respect to the current date and time in the format 'X ago' (for a past event) or
           'X from now' (future event). Where X is natural sounding description sentence like:
           a moment ago, 15 seconds ago, an hour ago, 5 minutes ago, 3 days from now, 2 hours from now, ...

       timestamp-and-natural-time-delta

           Combination of RFC3389 timestamp and natural-time-delta in parenthesis:
           2023-12-21T12:29:28.386Z (a day ago)

       with-units

           When this flavor is used to display a value then the units text is appended after it. For example
           mtu \"9232 bytes\". Where mtu is a yang typedef of uint16 with units specified as bytes.

       hex

           When this flavor is used to display a numerical value, info from state will display it converted to hex
           value (with leading 0x and using uppercase letters for hex digits). E.g. instead of 168 will show 0xA8.

       hex-with-colons

           When this flavor is used to display a numerical value, info from state will display it converted to hex
           value where every byte is sepated by a colon (using uppercase letters for hex digits).
           E.g. instead of 10010 will show 27:1A.
      ";
    argument flavor-name;
  }

  extension preferred-column-width {
    description
      "Takes as an argument a number defining the preferred width of this type for the tabular output in the cli.";
    argument width;
  }

  extension show-importance {
    description
      "Takes as an argument a string describing the importance of this leaf (and leaves
       underneath it if it is a node) with respect to the info/show outputs. This field makes
       it possible to hide the field by default. Any config field is by default medium.  Any
       state field is low by default. Info displays anything medium and above. Show as table
       displays only high. Inheritance is supported for this extension.

       Currently the only values supported are: low, medium, high";
    argument level;
  }

  extension first-released {
    description
      "Takes as an argument a string describing the first release this leaf appeared in.
       For example 19.11.1, 20.6.1.

       This extension supports inheritance, where unless specified the field is populated with
       the most recent ancestors first-released value.";
    argument release;
  }

  extension stream-mode {
    description
      "Takes as an argument a string describing the default stream mode used when a gNMI client
       specifies TARGET_DEFINED as the stream mode. This mode is inherited on all children of this
       node, unless a more specific default-stream-mode is set on them (following normal YANG
       inheritance).

       Valid options are 'sample', 'sample=<n>', 'on_change'

       sample
          Uses the sample stream mode, which sends updates every 1s

       sample=n
          Uses the sample stream mode, with the specified interval as the sample period

       on_change
          Uses the on_change stream mode, which sends updates immediately as they happen

       The default if not specified is on_change.";
    argument mode;
  }

  extension filtering-support {
    description
      "Takes as an argument a string describing the filtering support of the application.

       Valid options are 'parent', 'none'

       parent
          The application supports filtering conditions between parents, children fields
          and containers within the same application.

       none
          The application does not suport filtering. Limited filtering of children fields
          and containers is supported within same application model by fallback.

       The value is inherited from parents within the same model. The default if not specified or inherited is none.";
    argument mode;
  }

  extension statistics-node {
    description
      "Takes as an argument a boolean value. Explicitely marks the list/container as
       a statistics list/container or a non-statistics one. Without this extension statistics
       nodes are nodes with stream-mode extension set to sampling.  Statitics nodes can be
       omitted from state get responses/streaming when using no-statistics streaming options.";
    argument value;
  }

  extension telemetry-atomic {
    description
      "Takes as an argument a string value. Indicates that all nodes within the subtree are always updated together
       within the data model. For example, all elements under the subtree may be updated as a result of a new alarm
       being raised, or the arrival of a new protocol message. This mode is inherited on all children of this node,
       unless a more specific default-stream-mode is set on them (following normal YANG inheritance).

       Currently the only values supported are: true, false";
    argument value;
  }

  extension no-globbing {
    description
      "Disables globbing for this leaf (useful for fields defining regex patterns)";
  }

  extension no-auto-completion {
    description
      "Disables existing instance based auto-completion for this list";
  }

  extension if-feature {
    description
      "Takes as an argument a string defining the if-feature expression (same format as regular YANG if-feature),
       allows using if-feature under must statements";
    argument expression;
  }
}
""")
    res.append(r"""module srl_nokia-features {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:general:features";
  prefix srl_nokia-feat;

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "YANG module detailing SRLinux features";

  revision 2025-03-31 {
    description
      "SRLinux 2025.3.1";
  }
  revision 2024-10-31 {
    description
      "SRLinux 24.10.1";
  }
  revision 2024-07-31 {
    description
      "SRLinux 24.7.1";
  }
  revision 2024-03-31 {
    description
      "SRLinux 24.3.1";
  }
  revision 2023-10-31 {
    description
      "SRLinux 23.10.1";
  }
  revision 2023-07-31 {
    description
      "SRLinux 23.7.1";
  }
  revision 2023-03-31 {
    description
      "SRLinux 23.3.1";
  }
  revision 2022-11-30 {
    description
      "SRLinux 22.11.1";
  }
  revision 2022-06-30 {
    description
      "SRLinux 22.6.1";
  }
  revision 2022-03-31 {
    description
      "SRLinux 22.3.1";
  }
  revision 2021-11-30 {
    description
      "SRLinux 21.11.1";
  }
  revision 2021-06-30 {
    description
      "SRLinux 21.6.1";
  }
  revision 2021-03-31 {
    description
      "SRLinux 21.3.1";
  }
  revision 2020-06-30 {
    description
      "SRLinux 20.6.1";
  }

  feature future-0-0 {
    description
      "Only true in 0.0 stream, false in other streams. The feature is for an unknown future release.";
  }

  feature aaa-spiffe-id {
    description
      "Support for authentication using spiffe-id";
  }

  feature acl-ip-prefix-list {
    description
      "Support for ACL IP Prefix List";
  }

  feature acl-qos-ip-prefix-list {
    description
      "Support for QOS IP Prefix List";
  }

  feature aaa-superuser {
    description
      "Support for superuser flag for local users and roles";
  }

  feature acl-action-accept-with-log {
    description
      "Support of entry action accept with log";
  }

  feature acl-cpm-filter-match-network-instance {
    description
      "Support for ACL CPM-filter network-istance match criterion";
  }

  feature acl-cpm-filter-type-mac {
    description
      "Support for ACL CPM-filter of type mac";
  }

  feature acl-filter-allowed-on-irb-interfaces {
    description
      "Support for ACL filters on irb interfaces";
  }

  feature acl-filter-allowed-on-l2-interfaces {
    description
      "Support for ACL filters on l2 interfaces";
  }

  feature acl-filter-qos-forwarding-class {
    description
      "Support for ACL filter based assignment of forwarding QOS class";
  }

  feature acl-filter-qos-profile {
    description
      "Support for ACL filter based assignment of QOS profile";
  }

  feature acl-filter-redirect-to-next-hop {
    description
      "Support for ACL based redirection to netx hop";
  }

  feature acl-policer {
    description
      "Support for ACL policers";
  }

  feature acl-pps-policer {
    description
      "Support for ACL PPS policers";
  }

  feature acl-subinterface-entry-statistics {
    description
      "Support for ACL subinterface entry statistics";
  }

  feature admin-user-roles {
    description
      "Support for configurable roles for the admin user";
  }

  feature anycast-gw {
    description
      "Support for bridged feature and anycast-gw configuration on interface";
  }

  feature application-hot-restart {
    description
      "Support for application hot restart";
  }

  feature arp-nd-datapath-programming {
    description
      "Support for datapath programming of arp-nd routes";
  }

  feature backplane-facing-capacity {
    description
      "Support for backplane facing capacity paths";
  }

  feature bfd {
    description
      "Support for BFD";
  }

  feature bgp-accumulated-igp-metric {
    description
      "Support for AIGP metric path attribute";
  }

  feature bgp-add-paths {
    description
      "Support for bgp add path.";
  }

  feature bgp-add-paths-evpn {
    description
      "Support for bgp add path on evpn afi-safi.";
  }

  feature bgp-add-paths-l3vpn {
    description
      "Support for bgp add path on afi-safis l3vpn-ipv4-unicast and l3vpn-ipv6-unicast.";
  }

  feature bgp-add-paths-labeled-unicast {
    description
      "Support for bgp add path on afi-safis ipv4-labeled-unicast and ipv6-labeled-unicast..";
  }

  feature bgp-add-paths-policy-control {
    description
      "Support for bgp add path policy control.";
  }

  feature bgp-afi-safi-policy {
    description
      "Support for import and export policy per afi-safi.";
  }

  feature bgp-afi-safi-default-policy-action {
    description
      "Support for a default import and export policy action per afi-safi";
  }

  feature bgp-auth-password {
    description
      "Provide a BGP TCP MD5 authentication password without defining a keychain";
  }

  feature bgp-backup-path-frr-vpn {
    description
      "BGP support for backup paths using BGP VPN routes. Also known as Edge PIC";
  }

  feature bgp-backup-path-frr-evpn {
    description
      "BGP support for backup paths using BGP-EVPN routes. Also known as Edge PIC";
  }

  feature bgp-backup-path-frr-ip {
    description
      "BGP support for backup paths using IP routes. Also known as Edge PIC";
  }

  feature bgp-backup-path-frr-label-ip {
    description
      "BGP support for backup paths using label-unicast routes. Also known as Edge PIC";
  }

  feature bgp-cfg-afi-safi-list {
    description
      "Support for the AFI-SAFI list based configuration and state model in BGP for instances, groups and neighbors.";
  }

  feature bgp-auto-discovery-using-lldp {
    description
      "Using LLDP to initiate outbound dynamic BGP sessions";
  }

  feature bgp-graceful-restart-gaps {
    description
      "Add missing leafs for graceful-restart";
  }

  feature bgp-graceful-restart-state-additions {
    description
      "Add missing state leafs for graceful restart";
  }

  feature bgp-import-export-policy-leaflist {
    description
      "Change bgp import-policy and export-policy to a leaf-list";
  }

  feature bgp-ipv6-next-hop-tunnel-resolution {
    description
      "Resolve BGP IPv6 next-hops over IPv6 tunnels";
  }

  feature bgp-labeled-unicast {
    description
      "Support for BGP-LU address families";
  }

  feature bgp-labeled-unicast-future {
    description
      "Future (post 24.3) features for BGP-LU address families";
  }

  feature bgp-labeled-unicast-prefix-sid {
    description
      "Support for prefix SID attribute in the context of SR-MPLS";
  }

  feature bgp-labeled-unicast-rfc8950 {
    description
      "Improved support for advertising BGP-LUv4 routes to IPv6 transport peers";
  }

  feature bgp-labeled-unicast-tunnel-statistics {
    description
      "BGP Labeled Prefix statistics";
  }

  feature bgp-labeled-unicast-over-sr-te {
    description
      "Support for BGP-LU next-hop resolving over SR-TE tunnel";
  }

  feature bgp-labeled-unicast-selective-install {
    description
      "Support for BGP-LU selective tunnel installation based on service endpoints";
  }

  feature bgp-local-as-container-iso-list {
    description
      "Change list local-as to container in bgp group and neighbor";
  }

  feature bgp-max-ecmp-hash-buckets {
    description
      "Configuration of maximum hash buckets for weighted ECMP of BGP routes";
  }

  feature bgp-mtu-discovery {
    description
      "Support for BGP path MTU discovery.";
  }

  feature bgp-multipath-maximum-paths {
    description
      "Support for maximum BGP ECMP next-hops configuration.";
  }

  feature bgp-multipath-maximum-paths-limit-128 {
    description
      "Support multipath maximum-paths upper limit 128 depending on platform and afi-safi";
  }

  feature bgp-multipath-maximum-paths-limit-256 {
    description
      "Support multipath maximum-paths upper limit 256 depending on platform and afi-safi";
  }

  feature bgp-next-hop-resolution-tag {
    description
      "Support for BGP next-hop resolution based on tags";
  }

  feature bgp-peertype-maximum-paths {
    description
      "Support for seperate BGP ECMP configuration for each peer-type (EBGP/IBGP)";
  }

  feature bgp-prefix-limit {
    description
      "Support for Bgp Prefix Limit enhancements.";
  }

  feature bgp-prefix-limit-last-exceeded {
    description
      "Support of prefix-limit timestamp";
  }

  feature bgp-prefix-limit-post-policy {
    description
      "Support of prefix-limit-accepted configuration";
  }

  feature bgp-prefix-limit-received {
    description
      "Renaming bgp containers prefix-limit to prefix-limit-received.";
  }

  feature bgp-restart-max-wait {
    description
      "Introduction of system-wide BGP configuration container at /system/protocols/bgp for BGP AWR timer.";
  }

  feature bgp-rib-afi-safi-list {
    description
      "Support for the AFI-SAFI list based model in BGP RIB representation inspired from OC.";
  }

  feature bgp-rib-afi-safi-list-for-evpn {
    description
      "Support for the AFI-SAFI list based model in BGP RIB evpn representation inspired from OC.";
  }

  feature bgp-rib-afi-safi-route {
    description
      "Use list route in stead of list routes in bgp-rib";
  }

  feature bgp-route-flap-damping {
    description
      "Support for BGP route flap damping";
  }

  feature bgp-rtc {
    description
      "Support for BGP route target constraint";
  }

  feature bgp-send-community-leaflist {
    description
      "Use leaf-list send-community-type iso container send-community";
  }

  feature bgp-single-hop-connected-check {
    description
      "Support for Bgp transport Single Hop Connected Check.";
  }

  feature bgp-srte-policy {
    description
      "Support for BGP SR-TE policy address families";
  }

  feature bgp-unnumbered-peers {
    description
      "Support dynamic bgp unnumbered peers.";
  }

  feature bgp-weighted-ecmp {
    description
      "Support for BGP weighted ECMP using link-bandwidth";
  }

  feature breakout-ports-1 {
    description
      "Support for 1 breakout port";
  }

  feature breakout-ports-2 {
    description
      "Support for 2 breakout ports";
  }

  feature breakout-ports-3 {
    description
      "Support for 3 breakout ports";
  }

  feature breakout-ports-4 {
    description
      "Support for 4 breakout ports";
  }

  feature breakout-ports-8 {
    description
      "Support for 8 breakout ports";
  }

  feature breakout-speed-100G {
    description
      "Support for 100G breakout port speed";
  }

  feature breakout-speed-10G {
    description
      "Support for 10G breakout port speed";
  }

  feature breakout-speed-1G {
    description
      "Support for 1G breakout port speed";
  }

  feature breakout-speed-200G {
    description
      "Support for 200G breakout port speed";
  }

  feature breakout-speed-25G {
    description
      "Support for 25G breakout port speed";
  }

  feature breakout-speed-400G {
    description
      "Support for 400G breakout port speed";
  }

  feature breakout-speed-50G {
    description
      "Support for 50G breakout port speed";
  }

  feature bridged {
    description
      "Support for MAC-VRF services";
  }

  feature bt-split-horizon-groups {
    description
      "Support for Bridge-Table split horizon groups";
  }

  feature chassis {
    description
      "The platform is in a chassis configuration";
  }

  feature chassis-vertical-orientation {
    description
      "The platform supports a configurable mount orientation";
  }

  feature cli-plugin-authorization {
    description
      "Support for cli plugin authorization";
  }

  feature combined-bgp-ecmp {
    description
      "Support for ECMP across different BGP owners in an IP-VRF network-instance";
  }

  feature config-l2-mtu-default {
    description
      "Support for system mtu default-l2-mtu config";
  }

  feature config-sub-if-l2-mtu {
    description
      "Support for subinterface l2-mtu config";
  }

  feature configurable-intf-mac-addr {
    description
      "Support for configurable interface mac address";
  }

  feature connection-point {
    description
      "Support for connection points on network-instances";
  }

  feature crc-symbol-monitoring {
    description
      "Support for interface crc and symbol monitoring";
  }

  feature cpm-warm-redundancy {
    description
      "Support for CPM Warm Redundancy";
  }

  feature dac-link-training {
    description
      "Support for configurable interface dac-link-training";
  }

  feature datapath-resource-watermarks {
    description
      "Support for monitoring high-watermark level of datapath resources";
  }

  feature dco-logical-channels {
    description
      "Support for logical channels for digital coherent optics modules";
  }

  feature dco-loopback {
    description
      "Support for loopbacks withing the digital coherent optics modules";
  }

  feature dco-stats-avg-min-max {
    description
      "Support for digital coherent optics average, minimum, maximum statistics";
  }

  feature dhcp-relay-fqdn {
    description
      "Support for dhcp relay fqdn feature";
  }

  feature dhcp-svr-option-121 {
    description
      "Support for dhcp server option 121, Classless Static Route feature";
  }

  feature dhcp-svr-option-26 {
    description
      "Support for dhcp server option 26, Interface Mtu feature";
  }

  feature digital-coherent-optics {
    description
      "Support for digital coherent optics modules";
  }

  feature disabled {
    description
      "Feature flag that is always disabled";
  }

  feature disk-encryption {
    description
      "Support for Disk Encryption";
  }

  feature dot1q-vlan-ranges {
    description
      "Support for configurable dot1q vlan-ranges";
  }

  feature dot1x-authenticator {
    description
      "Support for dot1x authenticator configuration";
  }

  feature dot1x-authenticator-mac-based-authentication {
    description
      "Support for dot1x authenticator mac based authentication";
  }

  feature dot1x-authenticator-multi-host-auth {
    description
      "Support for IEEE 802.1X authenticator multi-host host-mode";
  }

  feature dot1x-interface-stats {
    description
      "Support for dot1x stats per interface";
  }

  feature dot1x-tunnel {
    description
      "Support for dot1x tunneling";
  }

  feature dot1x-tunnel-detail {
    description
      "Support for specific dot1x tunneling

       Some platforms can tunnel with finer granularity of untagged, single-tagged, double-tagged.";
  }

  feature dot1x-tunnel-system-stats {
    description
      "Support for tunneling IEEE 802.1X statistics in the system context";
  }

  feature dynamic-tcam {
    description
      "Support for Dynamic TCAM";
  }

  feature entropy-bgp-sr {
    description
      "Support for Entropy label with BGP and SR-ISIS";
  }

  feature ethcfm {
    description
      "Support for Ethernet CFM";
  }

  feature ethcfm-ingress-squelching {
    description
      "Support for Ethernet CFM ingress squelching";
  }

  feature ethcfm-mp-custom-mac-address {
    description
      "Support for Ethernet CFM Management Point custom MAC address configuration";
  }

  feature ethcfm-mp-mac-address-allocation {
    description
      "Support selectable Ethernet CFM Management Point MAC allocation scheme";
  }

  feature ethcfm-nsr {
    description
      "Support for Ethernet CFM non-stop-routing";
  }

  feature ethcfm-opcode-stats {
    description
      "Support for Ethernet CFM per operational code statistics";
  }

  feature ethcfm-sender-id-tx {
    description
      "Support for Ethernet CFM transmission of sedner id tlv";
  }

  feature ethcfm-subinterface {
    description
      "Support for Ethernet CFM configuration on subinterface";
  }

  feature event-handler {
    description
      "Support for the MicroPython-based event handler";
  }

  feature evpn {
    description
      "Support for EVPN";
  }

  feature evpn-ifl-unequal-ecmp {
    description
      "Support for EVPN unequal ECMP for RT5 IFL routes";
  }

  feature evpn-ifl-host {
    description
      "Support for the advertisement of EVPN-IFL host routes or MAC/IP Advertisement routes with layer-2/layer-3 labels/VNIs and route targets";
  }

  feature evpn-ifl-host-ip-aliasing {
    description
      "Support for the advertisement of IP AD per EVI/ES routes for EVPN-IFL host routes as per draft-ietf-bess-evpn-ip-aliasing";
  }

  feature evpn-iml-label-block {
    description
      "Support for allocation of labels for EVPN IML routes from a seperate label block.";
  }

  feature evpn-mh {
    description
      "Support for EVPN Multi-Homing";
  }

  feature evpn-mh-ip-aliasing {
    description
      "Support for EVPN Multi-Homing IP Aliasing Ethernet Segments";
  }

  feature evpn-mh-virtual-es {
    description
      "Support for virtual ethernet-segments";
  }

  feature evpn-mh-multicast-non-df-tcam-resource {
    description
      "Report TCAM entries used by egress filtering of IP multicast traffic to non-Designated Forwarder subinterfaces";
  }

  feature evpn-mpls {
    description
      "Support for EVPN MPLS";
  }

  feature evpn-mpls-control-word {
    description
      "Support for control-word in evpn-mpls";
  }

  feature evpn-mpls-shg {
    description
      "Support for EVPN MPLS Split-Horizon-Groups";
  }

  feature evpn-route-internal-tags {
    description
      "Support for internal tags associated to evpn routes";
  }

  feature evpn-vxlan-oism {
    description
      "Support for OISM on EVPN VXLAN, as per RFC9625";
  }

  feature evpn-vxlan-oism-peg {
    description
      "Support for OISM PIM to EVPN Gateway functionality on EVPN VXLAN, as per RFC9625";
  }

  feature exponential-port-dampening {
    description
      "Support for exponential port dampening";
  }

  feature factory-reset {
    description
      "Support for gNOI Factory Reset";
  }

  feature fan-avg-speed-show-report {
    description
      "Update fan show command to display average fan speed field";
  }

  feature fib-ilm-programming {
    description
      "Support for ILM FIB programming state";
  }

  feature fib-programming-progress {
    description
      "Support for FIB programming progress per forwarding complex";
  }

  feature fib-tunnel-programming {
    description
      "Support for tunnel FIB programming state";
  }

  feature fixed {
    description
      "The platform is in a fixed configuration, i.e. non-chassis platforms";
  }

  feature flex-algo-common {
    description
      "Support for Common Flexible Algorithm Definition (FAD) and Attributes";
  }

  feature flow-aware-transport-label {
    description
      "Support for Flow-Aware Transport (FAT) label";
  }

  feature flow-aware-transport-label-evpn-mpls-vpws {
    description
      "Support for BGP-EVPN mpls flow aware transport (FAT) label in VPWS network-instances";
  }

  feature forward-error-correction-ethernet {
    description
      "Support for configuring fec in the ethernet context";
  }

  feature forwarding-complex-1 {
    description
      "Support for forwarding-complex 1";
  }

  feature forwarding-complex-pipeline-counters {
    description
      "Support for forwarding-complex drop counters and aggregate CPU extration statistics";
  }

  feature gnmi-extensions {
    description
      "gNMI commit confirmed, depth and config subscription extensions";
  }

  feature gnmi-services {
    description
      "gNMI services";
  }

  feature gnoi-bgp {
    description
      "gNOI Bgp service";
  }

  feature gnoi-export-protos {
    description
      "OpenConfig protos";
  }

  feature gnoi-healthz {
    description
      "gNOI Healthz service";
  }

  feature gnoi-healthz-forwarding-complex {
    description
      "gNOI Healthz service support for forwarding-complex";
  }

  feature gnsi-accounting {
    description
      "gNSI Accounting service";
  }

  feature gnsi-authz {
    description
      "gNSI Authz service";
  }

  feature gnsi-certz {
    description
      "gNSI Certz service";
  }

  feature gnsi-credentialz {
    description
      "gNSI Credentialz service";
  }

  feature gnsi-pathz {
    description
      "gNSI Pathz service";
  }

  feature grpc-server {
    description
      "Unification of gnmi/gribi/p4rt servers into grpc server";
  }

  feature grpc-server-max-concurrent-streams {
    description
      "Configurable gRPC max concurrent streams parameter";
  }

  feature hold-time-fpcx {
    description
      "Support for interface hold-time on fpcx chipset";
  }

  feature host-network-instance {
    description
      "Support for host network-instance type";
  }

  feature icmp-rate-control {
    description
      "System-wide control of ICMP message generation rates";
  }

  feature igmp {
    description
      "Support for IGMP";
  }

  feature igmp-ipvrf {
    description
      "Support for IGMP on ipvrf";
  }

  feature igmp-snooping {
    description
      "Support for IGMP snooping";
  }

  feature ip-mac-binding {
    description
      "Support for fhs ip_mac binding";
  }

  feature egress-subif-policing {
    description
      "Support for egress subinterface policing based on policer-templates";
  }

  feature ingress-subif-policing {
    description
      "Support for ingress subinterface policing based on policer-templates";
  }

  feature interface-evpn-internal-tags {
    description
      "Support for internal tags associated to arp/nd routes advertised in evpn";
  }

  feature interface-references {
    description
      "Support for interface-ref containers under network-instance.";
  }

  feature inter-as-nhsrr-ipvpn {
    description
      "Support for inter-as model B and next hop self route reflector functionality for ipvpn";
  }

  feature ip-acl-dscp-set {
    description
      "Support for IP ACL matching on DSCP sets";
  }

  feature ip-qos-multifield {
    description
      "Support for ingress QoS classification based on multifield classifier policies";
  }

  feature ip-tunnel-decap-groups {
    description
      "Support for IP tunnel decap groups";
  }

  feature ipfix {
    description
      "Support of Flow Sampling feature";
  }

  feature ipv4-unnumbered {
    description
      "Support for IPv4 unnumbered interfaces";
  }

  feature ipvpn {
    description
      "Support for bgp-ipvpn";
  }

  feature ipvpn-route-internal-tags {
    description
      "Support for internal tags associated to ipvpn routes";
  }

  feature isis-adjsid-holdtime {
    description
      "Support for isis adjacency sid holdtime";
  }

  feature isis-dyn-delay {
    description
      "Support for isis dynamic delay advertisement";
  }

  feature isis-flex-algo {
    description
      "Support for ISIS flexible algorithms";
  }

  feature isis-lfa {
    description
      "Support for isis loopfree-alternate protection";
  }

  feature isis-level-passive {
    description
      "Support for isis per level passive configuration";
  }

  feature isis-lsdb {
    description
      "Support for isis link-state-database";
  }

  feature isis-lsdb-te-extensions {
    description
      "Support for isis link-state-database TE extensions";
  }

  feature isis-maint-mode {
    description
      "Support for isis maintainance mode";
  }

  feature isis-mi {
    description
      "Support for isis multi-instance";
  }

  feature isis-mt {
    description
      "Support for isis multi-topology";
  }

  feature isis-nsf {
    description
      "Support for isis non-stop-forwarding";
  }

  feature isis-app-hot-restart {
    description
      "Support for isis non-stop-routing";
  }

  feature isis-rtr-capability {
    description
      "Support for configurable advertise-router-capability";
  }

  feature isis-srv6 {
    description
      "Support for ISIS Segment Routing with SRv6 dataplane";
  }

  feature isis-ucmp {
    description
      "Support for isis weighted ecmp";
  }

  feature keychain {
    description
      "Support for protocol authentication keychains with multiple keys";
  }

  feature l2-proxy-arp {
    description
      "Support for Bridge Table proxy ARP functionality";
  }

  feature l2-proxy-arp-nd-control-flood-on-evpn {
    description
      "Support for controlling snooped arp/nd frames on evpn in mac-vrf network-instances";
  }

  feature l2-proxy-arp-nd-route-internal-tags {
    description
      "Support for internal tags associated to proxy arp/nd evpn routes";
  }

  feature l2-proxy-nd {
    description
      "Support for Bridge Table proxy ND functionality";
  }

  feature l2cp-transparency {
    description
      "Support for Layer-2 Control Protocol transparency or tunneling";
  }

  feature l2cp-transparency-efm-oam {
    description
      "Support for Layer-2 Control Protocol transparency or tunneling for efm-oam frames";
  }

  feature l2cp-transparency-elmi {
    description
      "Support for Layer-2 Control Protocol transparency or tunneling for elmi frames";
  }

  feature l2cp-transparency-esmc {
    description
      "Support for Layer-2 Control Protocol transparency or tunneling for esmc frames";
  }

  feature l2cp-transparency-stats {
    description
      "Support for Layer-2 Control Protocol transparency or tunneling system level statistics";
  }

  feature l2cp-transparency-xstp {
    description
      "Support for Layer-2 Control Protocol transparency or tunneling for xstp frames";
  }

  feature l3-multicast-vpn {
    description
      "Support for l3-multicast-vpn";
  }

  feature l3-multicast-vpn-policy {
    description
      "Support for l3-multicast-vpn";
  }

  feature l3-proxy-arp {
    description
      "Support for layer-3 sub-interface proxy ARP functionality";
  }

  feature l3-proxy-arp-irb {
    description
      "Support for layer-3 sub-interface proxy ARP functionality on IRB interfaces";
  }

  feature l3-proxy-nd {
    description
      "Support for layer-3 sub-interface proxy ND functionality";
  }

  feature l3-proxy-nd-irb {
    description
      "Support for layer-3 sub-interface proxy ND functionality on IRB interfaces";
  }

  feature label-management {
    description
      "Support for mpls label management";
  }

  feature label-range-user-owner {
    description
      "Use 'owner' instead of 'protocol' to refer to the user of an MPLS label-range.";
  }

  feature lacp-fallback {
    description
      "Support for link aggregation control protocol fallback";
  }

  feature lag {
    description
      "Support for link aggregation groups";
  }

  feature lag-forwarding-viable {
    description
      "Support for lag member forwarding-viable option";
  }

  feature lawful-intercept {
    description
      "Support for lawful intercept";
  }

  feature ldp {
    description
      "Support for label distribution protocol";
  }

  feature ldp-bfd {
    description
      "Support for BFD in LDP";
  }

  feature ldp-entropy-label {
    description
      "Support for entropy label with LDP LSPs";
  }

  feature ldp-implicit-null-label {
    description
      "Support for pushing implicit null label (e.g. no label) under LDP global context";
  }

  feature ldp-ipv4-auto-rx-tx-targeted {
    description
      "Support for IPv4 auto-rx and auto-tx T-LDP";
  }

  feature ldp-ipv6 {
    description
      "Support for LDP IPv6 extensions";
  }

  feature ldp-label-wdraw-delay {
    description
      "Support for configuring the LDP label withdrawal delay";
  }

  feature ldp-lfa {
    description
      "Support for LFA in LDP";
  }

  feature ldp-local-lsr-id {
    description
      "Support for local LSR ID in LDP";
  }

  feature ldp-prefix-policies {
    description
      "Support for prefix policies in LDP";
  }

  feature ldp-rlfa {
    description
      "Support for Remote Loop-Free Alternate in LDP";
  }

  feature ldp-static-fec-pop {
    description
      "Support for static FEC pop in LDP";
  }

  feature ldp-targeted {
    description
      "Support for targeted label distribution protocol";
  }

  feature ldp-tunnel-down-damp-time {
    description
      "Support for configuring the LDP tunnel down dampening time";
  }

  feature license {
    description
      "Support for licenses";
  }

  feature linecard-reboot {
    description
      "The this platform supports reboots of line cards.

       Usually only for platforms with discrete IMM";
  }

  feature linecard-locator {
    description
      "The this platform line cards support locator function

       Usually only for platforms with discrete IMM";
  }

  feature link-loss-forwarding {
    description
      "Support for link-loss-forwarding";
  }

  feature link-measurement {
    description
      "Support for dynamic link neasurement";
  }

  feature load-balancing {
    description
      "Support for load-balancing related configuration";
  }

  feature longest-prefix-match {
    description
      "Support show route table for the longest prefix match";
  }

  feature loopback-mode-facility {
    description
      "Support facility option for loopback-mode";
  }

  feature maintenance-mode-improvements {
    description
      "Improvements for maintenance mode";
  }

  feature loopback-mode-terminal {
    description
      "Support terminal option for loopback-mode";
  }

  feature macsec {
    description
      "Support for macsec";
  }

  feature macsec-subinterface {
    description
      "Support for macsec on a subinterface";
  }

  feature per-port-hash-seed {
    description
      "Support for per port ECMP hash seed on selected interfaces";
  }

  feature protection-policies {
    description
      "Support for Protection policies";
  }

  feature mcast-route-policy {
    description
      "Support for multicast handling in route policy";
  }

  feature measured-boot {
    description
      "Support for Measured Boot";
  }

  feature mda {
    description
      "The platform uses discrete MDA components";
  }

  feature mirror-dest-local {
    description
      "Support for local mirror-destination";
  }

  feature mirror-dest-remote {
    description
      "Support for remote mirror-destination";
  }

  feature mirror-dest-remote-tunnel-encap-l2ogre {
    description
      "Support for remote mirror-destination encap l2overgre";
  }

  feature mirror-dest-remote-tunnel-encap-l3ogre {
    description
      "Support for remote mirror-destination encap l3overgre";
  }

  feature mirror-dest-remote-tunnel-encap-mplsogre {
    description
      "Support for remote mirror-destination encap mplsovergre";
  }

  feature mirror-dest-slicing {
    description
      "Support for mirror-destination packet slicing";
  }

  feature mirror-dest-statistics {
    description
      "Support for mirror-destination statistics";
  }

  feature mirror-dest-statistics-egress-pkts {
    description
      "Support for mirror-destination statistics for egress packets count";
  }

  feature mirror-dest-statistics-octets {
    description
      "Support for mirror-destination statistics for total octets";
  }

  feature mirror-source-acl {
    description
      "Support for acl based mirror-source";
  }

  feature mirror-source-intf {
    description
      "Support for interface based mirror-source";
  }

  feature mirror-source-subintf {
    description
      "Support for subinterface based mirror-source";
  }

  feature mirroring {
    description
      "Support for mirroring (SPAN/ERSPAN)";
  }

  feature mirroring-intf-stats {
    description
      "Support for mirroring interface stats";
  }

  feature mirroring-tools-mirror-dest-statistics {
    description
      "Support for tools mirror-dest-statistics";
  }

  feature mld {
    description
      "Support for MLD";
  }

  feature mld-ipvrf {
    description
      "Support for MLD on ipvrf";
  }

  feature mld-snooping {
    description
      "Support for MLD snooping";
  }

  feature mpls {
    description
      "Support for MPLS";
  }

  feature mpls-ndk {
    description
      "Support for NDK static MPLS";
  }

  feature mpls-oam {
    description
      "Support for lsp-ping/trace over MPLS tunnels";
  }

  feature mpls-oam-colored-te-policy {
    description
      "Support for lsp-ping and lsp-trace over SR MPLS colored TE-Policy";
  }

  feature mpls-oam-uncolored-tepolicy {
    description
      "Support for lsp-ping and lsp-trace over SR MPLS uncolored TE-Policy";
  }

  feature msdp {
    if-feature "future-0-0";
    description
      "Support for MSDP";
  }

  feature named-queues-and-named-fcs {
    description
      "Support for named queues and forwarding classes";
  }

  feature ndk-admin-state {
    description
      "Support in YANG to admin-state enable/disable NDK mgr";
  }

  feature ndk-auto-telemetry-state {
    description
      "Support for option to auto update config state for NDK apps";
  }

  feature ndk-disable-caching {
    description
      "Support for disabling caching in NDK mgr";
  }

  feature netconf {
    description
      "Support for NETCONF";
  }

  feature netconf-unix-socket {
    description
      "Support for NETCONF over unix socket";
  }

  feature network-instance-leaked-route-readvertisement {
    description
      "Support for leaked route re-advertisement";
  }

  feature network-instance-mpls {
    description
      "Support for MPLS Services";
  }

  feature network-instance-static-mpls {
    description
      "Support for MPLS Services with static labels";
  }

  feature nhsrr-evpn {
    description
      "Support for next hop self route reflector functionality for evpn";
  }

  feature num-physical-channels {
    description
      "Support for configuring the number of physical channels for interfaces";
  }

  feature oam {
    description
      "Support for OAM";
  }

  feature oam-pm {
    description
      "Support for OAM Performance Monitoring";
  }

  feature oam-pm-ethcfm {
    description
      "Support for Ethernet CFM performance monitoring";
  }

  feature oam-pm-ip {
    description
      "Support for OAM Performance Monitoring IP";
  }

  feature oc-extracted-cpm-traffic-stats {
    description
      "Support for OpenConfig extracted CPM traffic statistics";
  }

  feature openconfig {
    description
      "Support for OpenConfig";
  }

  feature optical-line-system {
    description
      "Support for QFSP-DD-LS Amplifier";
  }

  feature p4rt {
    description
      "Support for P4Runtime";
  }

  feature packet-link-qualification {
    description
      "Support for gNOI Packet Link Qualification";
  }

  feature packet-tracer {
    description
      "Support for oam packet-trace";
  }

  feature password-complexity-sequence {
    description
      "Disallow sequence keys in password";
  }

  feature pcep-pcc {
    description
      "Path Computation Element client functionality";
  }

  feature pcep-pcc-pce-association {
    description
      "Path Computation Element client functionality for pce associations";
  }

  feature pcep-pcc-tls {
    description
      "Path Computation Element client functionality to support TLS";
  }

  feature pim {
    description
      "Support for PIM";
  }

  feature pim-ipvrf {
    description
      "Support for PIM IP VRF";
  }

  feature pim-spt-switchover {
    description
      "Support for PIM SPT switchover";
  }

  feature platform-hash-polynomial-visibility {
    description
      "Support for state showing the hash polynomial used by each hash user";
  }

  feature platform-mdb-profile {
    description
      "Support for managing the allocation of hardware resources according to a Broadcom MDB profile";
  }

  feature policy-based-forwarding-decap-actions {
    description
      "Support for policy-based forwarding decap actions";
  }

  feature policy-based-forwarding-dscp-ip-protocol {
    description
      "Support for policy-based forwarding based on DSCP and/or IP protocol";
  }

  feature policy-based-forwarding-encapsulate-gre {
    description
      "Support for policy-based forwarding action: encapsulate GRE";
  }

  feature policy-based-forwarding-match-ipv6-conditions {
    description
      "Support for policy-based forwarding match IPv6 conditions";
  }

  feature policy-based-forwarding-nh-transport {
    description
      "Support for policy-forwarding to next-hop and network-instance";
  }

  feature port-breakout {
    description
      "Support for ethernet port breakout (port connector)";
  }

  feature port-fec-clause74 {
    description
      "Support for legacy base-r FEC";
  }

  feature port-speed-100G {
    description
      "Support for 100G ethernet port speed";
  }

  feature port-speed-10G {
    description
      "Support for 10G ethernet port speed";
  }

  feature port-speed-100M {
    description
      "Support for 100M ethernet port speed";
  }

  feature port-speed-10M {
    description
      "Support for 10M ethernet port speed";
  }

  feature port-speed-1G {
    description
      "Support for 1G ethernet port speed";
  }

  feature port-speed-1T {
    description
      "Support for 1T port speed";
  }

  feature port-speed-200G {
    description
      "Support for 200G ethernet port speed";
  }

  feature port-speed-25G {
    description
      "Support for 25G ethernet port speed";
  }

  feature port-speed-400G {
    description
      "Support for 400G ethernet port speed";
  }

  feature port-speed-40G {
    description
      "Support for 40G ethernet port speed";
  }

  feature port-speed-50G {
    description
      "Support for 50G ethernet port speed";
  }

  feature port-speed-800G {
    description
      "Support for 800G ethernet port speed";
  }

  feature port-host-if-fec-stats-router {
    description
      "Support for host interface FEC statistics from the router side";
  }

  feature port-host-if-fec-stats-transceiver {
    description
      "Support for host interface FEC statistics from the transceiver side";
  }

  feature power-management {
    description
      "Support for chassis power management";
  }

  feature pseudowire {
    description
      "Support for pseudowires";
  }

  feature pseudowire-in-vpws {
    description
      "Support for pseudowires in vpws network-instances";
  }

  feature pseudowire-redundancy {
    description
      "Support for redundant pseudowires in network-instances";
  }

  feature qinq {
    description
      "Support for qinq subinterfaces";
  }

  feature qos {
    description
      "Support for qos";
  }

  feature qos-classify-profile {
    description
      "Support for qos";
  }

  feature qos-committed-burst-size-table {
    description
      "Support for qos committed burst size";
  }

  feature qos-de-out-profile {
    description
      "Support for qos de out profile";
  }

  feature qos-dot1p-classifier-policy {
    description
      "Support for qos dot1p classifier policy";
  }

  feature qos-dot1p-rewrite-policy {
    description
      "Support for qos dot1p rewrite policy";
  }

  feature qos-drop-probability {
    description
      "Support for qos drop probability";
  }

  feature qos-drop-zones {
    description
      "Support for qos drop zones";
  }

  feature qos-dscp-classifier-policy {
    description
      "Support for qos dscp classifier policy";
  }

  feature qos-dscp-reclassifier-policy {
    description
      "Support for qos dscp reclassifier policy";
  }

  feature qos-dscp-rewrite-policy {
    description
      "Support for qosdscp rewrite policy";
  }

  feature qos-ecn {
    description
      "Support for qos ecn";
  }

  feature qos-ecn-dscp-policy {
    description
      "Support for qos dscp policy";
  }

  feature qos-forwarding-class-index {
    description
      "Support for qos forwarding class index";
  }

  feature qos-forwarding-class-resource-priority {
    description
      "Support for qos forwarding class resource priority";
  }

  feature qos-forwarding-complexes {
    description
      "Support for qos forwarding complexes";
  }

  feature qos-fp-pool-policy {
    description
      "Support for qos forwarding class";
  }

  feature qos-input-class-map {
    description
      "Support for qos input class map";
  }

  feature qos-interface-pool-policy {
    description
      "Support for qos interface pool policy";
  }

  feature qos-ip-rewrite-policy {
    description
      "Support for qos ip rewrite policy";
  }

  feature qos-ipv4-dscp-classifier-policy {
    description
      "Support for qos ipv4 dscp classifier policy";
  }

  feature qos-ipv4-dscp-rewrite-policy {
    description
      "Support for qos ipv4 dscp rewrite policy";
  }

  feature qos-ipv6-dscp-classifier-policy {
    description
      "Support for qos ipv6 dscp classifier policy";
  }

  feature qos-ipv6-dscp-rewrite-policy {
    description
      "Support for qos ipv6 dscp rewrite policy";
  }

  feature qos-irb-subinterface {
    description
      "Support for qos on irb subinterface";
  }

  feature qos-ler-use-dscp {
    description
      "Support for qos ler use dscp";
  }

  feature qos-management-protocols-dscp {
    description
      "Support for qos management protocols dscp";
  }

  feature qos-match-qinq-dot1p {
    description
      "Support for qos match qinq dot1p";
  }

  feature qos-mpls-classifier-policy {
    description
      "Support for qos mpls classifier policy";
  }

  feature qos-mpls-rewrite-policy {
    description
      "Support for qos mpls rewrite policy";
  }

  feature qos-multi-traffic-queue {
    description
      "Support for qos multi traffic queue";
  }

  feature qos-multicast-queue {
    description
      "Support for qos multicast queue";
  }

  feature qos-output-class-map {
    description
      "Support for qos output class map";
  }

  feature qos-pfc {
    description
      "Priority-based Flow Control (PFC) support";
  }

  feature qos-pfc-dnx {
    description
      "Priority-based Flow Control (PFC) support on DNX platforms, 7250 IXR-6e/10e and 7250 IXR-x1b/x3b  variants";
  }

  feature qos-pfc-dynamic-buffer-allocation {
    description
      "Dynamic buffer allocation support for Priority-based Flow Control (PFC)";
  }

  feature qos-pfc-buffer {
    description
      "Pfc buffer usage on on XGS and DNX platforms";
  }

  feature qos-pfc-headroom-buffer {
    description
      "Headroom buffer usage on XGS and DNX paltforms";
  }

  feature qos-pfc-peak-buffer {
    description
      "Peak pfc buffer usage on DNX platforms";
  }

  feature qos-pfc-system-headroom-buffer {
    description
      "Headroom buffer usage on XGS paltforms";
  }

  feature qos-pfc-xgs {
    description
      "Priority-based Flow Control (PFC) support on XGS platforms, 7220 D5/D4 and 7220 H4 variants";
  }

  feature qos-policer-policies {
    description
      "Support for qos policer policies";
  }

  feature qos-pre-classifier {
    description
      "Support for pre-classfication table";
  }

  feature qos-preserve-dscp {
    description
      "Support for qos preserve dscp";
  }

  feature qos-queue-cbs-adaptation-rule {
    description
      "Support for qos cbs adaptation rule";
  }

  feature qos-queue-committed-burst-size {
    description
      "Support for qos queue committed burst size";
  }

  feature qos-queue-depth-sampling {
    description
      "Support for qos queue depth sampling";
  }

  feature qos-queue-ecn-stats {
    description
      "Support for per-forwarding-class per port ECN statistics";
  }

  feature qos-queue-high-threshold {
    description
      "Support for qos queue high threshold";
  }

  feature qos-queue-management-profile {
    description
      "Support for qos queue management profile";
  }

  feature qos-queue-mbs-adaptation-rule {
    description
      "Support for qos queue mbs adaptation rule ";
  }

  feature qos-queue-profile-stats {
    description
      "Support for qos queue profile stats";
  }

  feature qos-queue-scheduling-class {
    description
      "Support for qos queue scheduling class";
  }

  feature qos-queue-scheduling-policy {
    description
      "Support for qos queue scheduling policy";
  }

  feature qos-rewrite-dot1p {
    description
      "Support for qos rewrite dot1p";
  }

  feature qos-rewrite-inner-de {
    description
      "Support for qos rewrite  inner de";
  }

  feature qos-rewrite-inner-dot1p {
    description
      "Support for qos rewrite inner dot1p";
  }

  feature qos-rewrite-outer-de {
    description
      "Support for qos rewrite outer de";
  }

  feature qos-rewrite-outer-dot1p {
    description
      "Support for qos rewrite outer dot1p";
  }

  feature qos-rewrite-profile {
    description
      "Support for qos rewrite profile";
  }

  feature qos-resource-management {
    description
      "Support for qos resource management";
  }

  feature qos-resource-utilization-thresholds {
    description
      "Support for qos resource utilization thresholds";
  }

  feature qos-sched-class-scheduling-policy {
    description
      "Support for qos sched class scheduling policy";
  }

  feature qos-scheduler-output-weight {
    description
      "Support for qos scheduler output weight";
  }

  feature qos-scheduler-policies {
    description
      "Support for scheduler policies";
  }

  feature qos-scheduling-priority-mapping {
    description
      "Support for qos scheduling priority mapping";
  }

  feature qos-slope-policy {
    description
      "Support for qos slope policy";
  }

  feature qos-subinterface-dot1p-rewrite {
    description
      "Support for qos subinterface dot1p rewrite";
  }

  feature qos-subinterface-dscp-rewrite {
    description
      "Support for qos subinterface dscp rewrite";
  }

  feature qos-subinterface-members {
    description
      "Support for per subinterface member instance state";
  }

  feature qos-subinterface-queue-type {
    description
      "Support for qos subinterface queue type";
  }

  feature qos-system-generated-traffic-map {
    description
      "Support for qos system generated traffic map";
  }

  feature qos-tos-rewrite {
    description
      "Support for qos tos rewrite";
  }

  feature qos-unicast-queue {
    description
      "Support for qos unicast queue";
  }

  feature qos-virtual-output-queue {
    description
      "Support for qos virtual output queue";
  }

  feature qos-vxlan-classifier-policy {
    description
      "Support for qos vxlan classifier policy";
  }

  feature qos-vxlan-outer-header-rewrite {
    description
      "Support for qos vxlan outer header rewrite";
  }

  feature qos-wred-traffic-type-tcp {
    description
      "Support for qos wred traffic type tcp/non-tcp";
  }

  feature ra-guard {
    description
      "Support for ra guard";
  }

  feature radius-source-address {
    description
      "Support for configurable source address for radius servers";
  }

  feature radius-tls {
    description
      "Support for exchanging RADIUS messages over a TLS connection";
  }

  feature reload-delay {
    description
      "Support for interface reload-delay timers";
  }

  feature internal-tags {
    description
      "Support for internal tags associated to routes";
  }

  feature route-leaking {
    description
      "Support for inter network-instance route leaking";
  }

  feature routing-policy-bgp-disable-fib {
    description
      "Support for disabling FIB download for BGP routes matched by import policy as a route policy action";
  }

  feature routing-policy-bgp-flex-algo-next-hop-resolution-action {
    description
      "support for set-flex-algo action in route-policy";
  }

  feature routing-policy-bgp-med {
    description
      "Support for MED in BGP and routing policy actions";
  }

  feature routing-policy-bgp-next-hop-resolution-action {
    description
      "Support for modifying the BGP next-hop resolution constraints as a route policy action";
  }

  feature routing-policy-bgp-next-hop-self-action {
    description
      "Support for next-hop self as a policy action";
  }

  feature routing-policy-bgp-next-hop-set-action {
    description
      "Support for modifying the BGP next-hop address as a route policy action";
  }

  feature routing-policy-bgp-srte-policy {
    description
      "Support for match and action specific to BGP SR policy routes";
  }

  feature routing-policy-community-match-set-options {
    description
      "Support for community-set match-set-options: any, all and invert";
  }

  feature routing-policy-enhanced-as-path-set {
    description
      "Support for as-path-member-set-member, character-mode regex and complete match-set-options";
  }

  feature routing-policy-extended-community-actions {
    description
      "Support for extended community actions aligned with OC";
  }

  feature routing-policy-extended-community-sets {
    description
      "Support for extended-community-set construct";
  }

  feature routing-policy-isis-actions {
    description
      "Support for ISIS policy actions";
  }

  feature routing-policy-match-protocol-redefine {
    description
      "Redefine supported match protocols in routing policy";
  }

  feature routing-policy-named-statements {
    description
      "Support for named statements in routing policy";
  }

  feature routing-policy-next-policy {
    description
      "Support for next-policy as a route policy action";
  }

  feature routing-policy-next-statement {
    description
      "Support for next-statement as a route policy action";
  }

  feature routing-policy-ospf-actions {
    description
      "Support for OSPF route policy actions";
  }

  feature routing-policy-preference-action {
    description
      "Support for route policy action to set preference";
  }

  feature routing-policy-subroutines {
    description
      "Support for route policy subroutines";
  }

  feature routing-policy-prefix-set-match-options-any {
    description
      "Support for match-set-options any with prefix-set";
  }

  feature routing-policy-table-connections {
    description
      "Support for network-instance table connections for route redistribution";
  }

  feature routing-policy-standard-community-actions {
    description
      "Support for standard community actions aligned with OC";
  }

  feature routing-policy-standard-community-sets {
    description
      "Support for standard-community-set construct";
  }

  feature routing-policy-tag-set-match-options {
    description
      "Support for match-set-options with tag-sets";
  }

  feature seamless-bfd {
    description
      "Support Seamless BFD for SR segment lists";
  }

  feature secure-boot {
    description
      "Support for Secure Boot";
  }

  feature segment-routing {
    description
      "Support for segment routing using the MPLS dataplane";
  }

  feature segment-routing-adjacency-sid {
    description
      "Support for segment routing adjacency sid";
  }

  feature segment-routing-colored-te-policies {
    description
      "Support for colored segment routing TE policies";
  }

  feature segment-routing-shared-sid {
    description
      "Support for segment routing shared sid";
  }

  feature service-activation-testhead {
    description
      "Support of Service Activation TestHead / Y.1564 feature";
  }

  feature sflow {
    description
      "Support for Sflow";
  }

  feature sflow-collector-dscp {
    description
      "Support for configuring DSCP for Sflow agent";
  }

  feature sflow-interface-sampling {
    description
      "Support for Sflow Egress and Ingress sampling on interface level";
  }

  feature sflow-ipv6-udp-cksum-knob {
    description
      "Support for config knob to set checksum to 0x0 or 0xFFFF in Sflow IPv6 UDP packets";
  }

  feature sflow-lag {
    description
      "Support Sflow for LAG/aggregate type of interfaces";
  }

  feature show-acl-aclfilter {
    description
      "Support for new show acl acl-filter reports";
  }

  feature snmp-counters {
    description
      "Support for SNMP packet counters";
  }

  feature snmp-over-tcp {
    description
      "Support for SNMP over TCP";
  }

  feature snmp-tools-trap {
    description
      "Support for sending SNMP Traps with a tools command";
  }

  feature snmp-traps {
    description
      "Support for SNMP traps";
  }

  feature snmp-v3 {
    description
      "Support for SNMPv3";
  }

  feature stamp {
    description
      "Support for Simple Two-way Active Measurement Protocol STAMP";
  }

  feature special-ptp-ip-timestamping {
    description
      "Support disabling of L3 timestamping";
  }

  feature static-next-hop-group-gre-tunnel {
    description
      "Support GRE tunnel next-hops in static NHGs";
  }

  feature static-next-hop-unnumbered-interface {
    description
      "Support for IP-unnumbered interfaces as next-hops in static NHGs";
  }

  feature static-route-tag-set {
    description
      "Support for association of a static route with a configured tag-set";
  }

  feature static-route-tag-value {
    description
      "Support for association of a static route with a configured tag value";
  }

  feature storm-control {
    description
      "Support for storm control";
  }

  feature storm-control-action {
    description
      "Support for storm control threshold action";
  }

  feature stp {
    description
      "Support for xSTP";
  }

  feature subif-acl-policer {
    description
      "Support for acl based subinterface policer";
  }

  feature subif-detailed-stats-config {
    description
      "Support for configuring subinterface detailed stats";
  }

  feature subif-policer {
    description
      "Support for sub interface policer";
  }

  feature subif-stats-per-ipv4-ipv6-container {
    description
      "Support for sub interface stats in ipv4 and ipv6 containers";
  }

  feature submgmt-fpcx {
    description
      "Subscriber management on fpcx";
  }

  feature sync {
    description
      "Support for PTP, SyncE, BITS, ToD, 1PPSTEST";
  }

  feature sync-one-pps {
    description
      "Support for 1PPS timing port";
  }

  feature sync-gnss {
    description
      "Support for GNSS receiver module";
  }

  feature sync-gnss-redundant {
    description
      "Support for GNSS redundant receivers";
  }

  feature sync-ptp-ip-peers {
    description
      "Support for PTP peers using IP transport and unicast negotitation";
  }

  feature sync-ptp-ip-peers-ipv6 {
    description
      "Support for PTP peers using IPv6 transport and unicast negotitation";
  }

  feature sync0-port {
    description
      "Platform includes a dedicated sync0 port for synce and ptp";
  }

  feature sync-ptp-freq {
    description
      "Support for recovery of frequency from the PTP messages.  Profiles G.8275.2 and G.8265.1";
  }

  feature sync-ptp-ip-port-tracking {
    description
      "Support for tracking of rx/tx ports for ptp over ip";
  }

  feature system-fallback-routing {
    description
      "Support for fallback routing by doing a secondary FIB lookup in default";
  }

  feature system-forwarding-mode {
    description
      "Support for configurable switching mode";
  }

  feature system-fips-mode {
    description
      "Support for fips mode";
  }

  feature system-hash-profile {
    description
      "Support for user-configurable hash profiles that can be applied to selected interfaces";
  }

  feature system-hash-seed-from-mac {
    description
      "Support for auto-generating a hash-seed from the base chassis MAC address";
  }

  feature system-resource-ip-gre-tunnels {
    description
      "Support for system resource ip-gre-tunnels";
  }

  feature system-resource-ip-in-ip-tunnels {
    description
      "Support for system resource ip-in-ip-tunnels";
  }

  feature system-resource-mpls-next-hops {
    description
      "Support for system resource mpls-next-hops";
  }

  feature system-resource-pg-groups {
    description
      "Support for system resource pg-groups";
  }

  feature system-resource-tunnels {
    description
      "Support for system resource tunnels";
  }

  feature system-resource-utilization {
    description
      "Support for system resource utilization";
  }

  feature system-resource-vp-lag-groups {
    description
      "Support for system resource vp-lag-groups";
  }

  feature tacacs-source-address {
    description
      "Support for configurable source address for tacacs servers";
  }

  feature te-policies {
    description
      "Support for SR-TE and segment routing policies using the MPLS dataplane";
  }

  feature te-policy-delay-metric-limit {
    description
      "Support for delay metric limit under TE-Policy";
  }

  feature te-policies-entropy-label {
    description
      "Support for entropy label with SR-TE and segment routing policies";
  }

  feature te-policies-increased-label-stack-fpcx {
    description
      "Support for increased label stack with SR-TE and segment routing policies on 7730 SXR";
  }

  feature te-policy-exclude-srlg {
    description
      "Support for exclude-srlg under TE-Policy";
  }

  feature te-policy-local-cspf-fallback {
    description
      "Support for local CSPF fallback under TE-Policy";
  }

  feature te-policy-pcep-delay-metric-limit {
    description
      "Support for PCEP delay metric limit under TE-Policy";
  }

  feature te-policy-statistics {
    description
      "Support for TE-Policy segment-list or candidate-path statistics";
  }

  feature te-policy-colored-statistics {
    description
      "Support for Colored TE-Policy segment-list statistics";
  }

  feature te-policies-tag-set {
    description
      "Support for tag-set with SR-TE and segment routing policies";
  }

  feature tpm-idevid {
    description
      "Support for TPM IDevID";
  }

  feature tpm-oidevid {
    description
      "Support for TPM OIDevID certificate in tls profile";
  }

  feature tools-force-pwd-change {
    description
      "Support for tools commands to force users to change password";
  }

  feature tpm-attestz {
    description
      "Openconfig Attestz Service";
  }

  feature tpm-enrollz {
    description
      "Openconfig Enrollz Service";
  }

  feature traffic-engineering {
    description
      "Support for TE advertisement by ISIS";
  }

  feature traffic-engineering-bgpls {
    description
      "Support for BGP-LS advertisement of IGP link-state data";
  }

  feature traffic-engineering-bgpls-directly-connected {
    description
      "Support for BGP-LS advertisement of directly connected link-state data";
  }

  feature traffic-engineering-isis-tedb-install {
    description
      "Support for TE DB by ISIS";
  }

  feature traffic-engineering-ospf {
    description
      "Support for TE DB, BGP-LS and TE advertisement by OSPF";
  }

  feature transceiver-link-length-info {
    description
      "Support for transceiver link length info";
  }

  feature transceiver-firmware-version {
    description
      "Support for transceiver firmware version";
  }

  feature twamp {
    description
      "Support for TWAMP";
  }

  feature tx-flow-control {
    description
      "Support for transmitting Ethernet flow control (PAUSE) frames";
  }

  feature unequal-ecmp {
    description
      "Support for unequal Equal Cost Multi Path";
  }

  feature unified-forwarding-tables {
    description
      "Support for UFT resources";
  }

  feature virtual-ip-discovery {
    description
      "Support for arp/nd virtual ip discovery";
  }

  feature vlan-id-any {
    description
      "Support for configurable vlan-id any";
  }

  feature vlan-id-optional {
    description
      "Support for configurable vlan-id optional";
  }

  feature vlan-loopback {
    description
      "Support for configurable vlan loopback with optional mac swap";
  }

  feature vlan-manipulation {
    description
      "Support for configurable vlan manipulation";
  }

  feature vlan-tpid {
    description
      "Support for configurable VLAN Tagging TPID";
  }

  feature vpws {
    description
      "Support for VPWS Services";
  }

  feature vrrp {
    description
      "Support for VRRP";
  }

  feature vxlan {
    description
      "Support for VXLAN";
  }

  feature vxlan-stats {
    description
      "Support for VXLAN statistics";
  }

  feature vxlan-destination-groups {
    description
      "Support for VXLAN destination groups";
  }

  feature warm-reboot {
    description
      "Support for warm reboot";
  }

  feature ztp-boot-mode {
    description
      "Support for ztp-boot mode";
  }

  feature ac5x;

  feature fpcx {
    description
      "FPcx based platforms";
  }

  feature jericho2;

  feature jericho2cp;

  feature jericho3;

  feature qumran2cp;

  feature tomahawk3;

  feature tomahawk4;

  feature tomahawk5;

  feature trident3;

  feature trident4;

  feature platform-7215-a1;

  feature platform-7220-d1;

  feature platform-7220-d2;

  feature platform-7220-d3;

  feature platform-7220-d4;

  feature platform-7220-d5;

  feature platform-7220-h2;

  feature platform-7220-h3;

  feature platform-7220-h4;

  feature platform-7220-h4-32d;

  feature platform-7220-h5-32d;

  feature platform-s96-10-36;

  feature platform-7220-h5-64d;

  feature platform-7220-h5-64o;

  feature platform-sse-t81-64;

  feature platform-7250-ixr;

  feature platform-7250-ixr-e;

  feature platform-7250-ixr-18e;

  feature platform-7250-ixr-x1b;

  feature platform-7250-ixr-x3b;

  feature platform-7250-j2;

  feature platform-7730-sxr-1d-32d;

  feature platform-7730-sxr-1x-44s;

  feature platform-crimson;

  feature platform-imgmt;

  feature platform-vsrl;

  feature ixr-dnx;
}
""")
    res.append(r"""module srl_nokia-if-ip {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:chassis:if-ip";
  prefix srl_nokia-if-ip;

  import srl_nokia-common {
    prefix srl_nokia-comm;
  }
  import srl_nokia-features {
    prefix srl_feat;
  }
  import srl_nokia-extensions {
    prefix srl_nokia-ext;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "Model for managing IP subinterfaces";

  revision 2025-03-31 {
    description
      "SRLinux 2025.3.1";
  }
  revision 2024-10-31 {
    description
      "SRLinux 24.10.1";
  }
  revision 2024-07-31 {
    description
      "SRLinux 24.7.1";
  }
  revision 2024-03-31 {
    description
      "SRLinux 24.3.1";
  }
  revision 2023-07-31 {
    description
      "SRLinux 23.7.1";
  }
  revision 2023-03-31 {
    description
      "SRLinux 23.3.1";
  }
  revision 2021-11-30 {
    description
      "SRLinux 21.11.1";
  }
  revision 2021-06-30 {
    description
      "SRLinux 21.6.1";
  }
  revision 2021-03-31 {
    description
      "SRLinux 21.3.1";
  }
  revision 2020-06-30 {
    description
      "SRLinux 20.6.1";
  }
  revision 2019-11-30 {
    description
      "SRLinux 19.11.1";
  }

  typedef address-origin {
    type enumeration {
      enum other {
        value 1;
      }
      enum static {
        value 2;
      }
      enum dhcp {
        value 3;
      }
      enum link-layer {
        value 4;
      }
      enum random {
        value 5;
      }
    }
    description
      "The origin of the IP address";
  }

  typedef ipv6-address-status {
    type enumeration {
      enum preferred {
        value 1;
      }
      enum deprecated {
        value 2;
      }
      enum invalid {
        value 3;
      }
      enum inaccessible {
        value 4;
      }
      enum unknown {
        value 5;
      }
      enum tentative {
        value 6;
      }
      enum duplicate {
        value 7;
      }
      enum optimistic {
        value 8;
      }
    }
    description
      "The IPv6 address status";
  }

  typedef ipv4-address-status {
    type enumeration {
      enum preferred {
        value 1;
      }
      enum inaccessible {
        value 2;
      }
      enum tentative {
        value 3;
      }
      enum duplicate {
        value 4;
      }
    }
    description
      "The IPv4 address status";
  }

  typedef anycast-gw-mac-origin {
    type enumeration {
      enum configured {
        value 1;
      }
      enum vrid-auto-derived {
        value 2;
      }
    }
    description
      "The origin of the anycast-gw MAC address.";
  }

  grouping ipv4-top {
    description
      "Top-level configuration and state for IPv4 interfaces";
    container ipv4 {
      description
        "IPv4 configuration and state for the subinterface";
      leaf admin-state {
        description
          "Enable/disable IPv4 on the subinterface

           When set to enable, and even before an IPv4 address is configured, the subinterface starts to accept incoming packets with dest-ip 255.255.255.255, which is necessary to support dhcp-client functionality.";
        type srl_nokia-comm:admin-state;
        default "disable";
        must "(. = 'disable' or (../../type != 'bridged' and ../../type != 'local-mirror-dest'))" {
          error-message "ipv4 configuration not allowed on bridged or local-mirror-dest subinterfaces";
        }
      }
      list address {
        max-elements 64;
        key "ip-prefix";
        description
          "The list of  IPv4 addresses assigned to the subinterface.";
        leaf ip-prefix {
          type srl_nokia-comm:ipv4-prefix-with-host-bits;
          description
            "The IPv4 address and prefix length in CIDR notation

             Subnets on the same subinterface are allowed to overlap as long as the host bits are different. When a locally originated unicast packet is destined to a host covered by multiple subnets associated with a subinterface, the source address is chosen to be the numerically lowest IP address among all these subnets. For example, if the addresses 172.16.1.1/12, 172.16.1.2/12, and 172.16.1.3/12 are configured on the same interface, 172.16.1.1 would be used as a local address when you issue a ping 172.16.1.5 command";
          must "not(starts-with(.,'0.') or starts-with(.,'127.') or re-match(.,'22[4-9]\\..*') or re-match(.,'2[3-5][0-9]\\..*'))" {
            error-message "Not a valid IPv4 unicast address prefix";
          }
          must "(../../unnumbered/admin-state != 'enable')" {
            error-message "Assignment of IPv4 addresses is prohibited when the subinterface is unnumbered";
          }
        }
        leaf anycast-gw {
          if-feature "srl_feat:anycast-gw";
          srl_nokia-ext:first-released "20.12.1";
          must "starts-with(../../../../name,'irb')" {
            error-message "Only supported on IRB subinterfaces";
          }
          must ". = false() or (. = true() and ../../../anycast-gw) or not(starts-with(../../../../name,'irb'))" {
            error-message "Only supported if anycast-gw container is configured";
          }
          type boolean;
          description
            "This designates the associated IPv4 address as an anycast-gateway IPv4 address of the subinterface.

             When this parameter is set to true:
             - The IPv4 address is associated with the anycast-gw MAC address in the same subinterface. ARP Requests received for the anycast-gw IPv4 address
               will be replied using this anycast-gw MAC address.
             - The IPv4 address can have duplicate IPv4 addresses in other IRB subinterfaces of routers attached to the same broadcast domain.
               Because of that ARP duplicate-address-detection procedures do not apply to anycast-gw IP addresses.";
        }
        leaf origin {
          config false;
          type address-origin;
          description
            "The origin of the IPv4 address.";
        }
        leaf primary {
          srl_nokia-ext:first-released "20.12.1";
          type empty;
          must "not (starts-with(../../../../name, 'mgmt') or (starts-with(../../../../name, 'system')) or (starts-with(../../../../name, 'sync')))" {
            error-message "primary not supported on mgmt or system subinterfaces";
          }
          description
            "One of the IPv4 prefixes assigned to the subinterface can be explicitly configured as primary by setting this leaf to true. This designates the associated IPv4 address as a primary IPv4 address of the subinterface. By default, the numerically lowest value IPv4 address is selected as the primary address.

             The primary address is used as the source address for locally originated broadcast and multicast packets sent out the subinterface.";
        }
        leaf status {
          config false;
          type ipv4-address-status;
          description
            "The status of an IPv4 address";
        }
      }
      leaf allow-directed-broadcast {
        type boolean;
        default "false";
        description
          "When this is set to true the software is allowed to re-broadcast targeted broadcast IPv4 packets on this subinterface

           Detailed handling of subnet broadcast is as follows:

           If a targeted broadcast packet is received on subinterface X that has the matching subnet then it is delivered to the CPM and CPM will reply to an ICMP echo.

           If a targeted broadcast packet is received on subinterface X but the matching subnet is associated with subinterface Y, and subinterface Y is configured with allow-directed-broadcasts=false then it is delivered to the CPM and CPM replies to an ICMP echo per above, but it does not re-broadcast the packet on subinterface Y.

           If a targeted broadcast packet is received on subinterface X but the matching subnet is associated with subinterface Y, and subinterface Y is configured with allow-directed-broadcasts=true then it is delivered to the CPM and CPM replies to an ICMP echo per above, and CPM also re-broadcasts the packet on subinterface Y.";
      }
      container unnumbered {
        if-feature "srl_feat:ipv4-unnumbered";
        description
          "Top-level container for configuring unnumbered interfaces";
        leaf admin-state {
          type srl_nokia-comm:admin-state;
          default "disable";
          description
            "When enabled, the subinterface should operate in unnumbered mode for IPv4";
          must "(. = 'disable') or (starts-with(../../../../name, 'ethernet')) or (starts-with(../../../../name, 'lag'))" {
            error-message "Unnumbered interfaces must be ethernet or LAG";
          }
          must "(. = 'disable') or not(boolean(../../dhcp-client))" {
            error-message "Assignment of dhcp-client prohibited when the subinterface is unnumbered";
          }
          must "(. = 'disable') or boolean(../interface)" {
            error-message "interface is mandatory when unnumbered admin-state is enable";
          }
        }
        leaf interface {
          type srl_nokia-comm:subinterface-all;
          description
            "Reference to the subinterface with the IPv4 address to be borrowed";
          must "not(starts-with(.,'mgmt'))" {
            error-message "Cannot borrow IPv4 address from management interfaces";
          }
          must "../../../../../interface[name=substring-before(current(), '.')]/subinterface[index=substring-after(current(), '.')]" {
            error-message "Cannot borrow IPv4 address from non-existing subinterface";
          }
          must "(substring-before(current(), '.') != ../../../../name) or (substring-after(current(), '.') != string(../../../index))" {
            error-message "Cannot borrow IPv4 address from same interface/subinterface";
          }
        }
        leaf address {
          config false;
          type srl_nokia-comm:ipv4-address;
          description
            "The operational IPv4 address borrowed from the referenced subinterface";
        }
        leaf unavailable-address-reason {
          config false;
          description
            "The reason why there is no operational IPv4 address to use for this subinterface";
          type enumeration {
            enum not-same-network-instance {
              description
                "The referenced subinterface does not belong to the same network instance as the borrowing subinterface";
            }
            enum referenced-interface-is-down {
              description
                "The referenced subinterface is operationally down";
            }
            enum referenced-interface-ipv4-is-down {
              description
                "The referenced subinterface is not enabled for IPv4";
            }
            enum referenced-interface-has-no-ipv4-addresses {
              description
                "The referenced subinterface has no IPv4 addresses assigned to it";
            }
          }
        }
      }
    }
  }

  grouping ipv6-top {
    description
      "Top-level configuration and state for IPv6 interfaces";
    container ipv6 {
      description
        "IPv6 configuration and state for the subinterface";
      leaf admin-state {
        description
          "Enable/disable IPv6 on the subinterface

           When set to enable, and even before a global unicast IPv6 address is configured, chassis manager assigns an IPv6 link-local address to the subinterface, which will appear as a read-only entry in the address list. At this stage, the subinterface can receive IPv6 packets with any of the following destinations:
           -\tIPv6 link-local address
           -\tsolicited-node multicast address for the link-local address
           -\tff02::1 (all IPv6 devices)
           -\tff02::2 (all IPv6 routers)";
        type srl_nokia-comm:admin-state;
        default "disable";
        must "(. = 'disable' or (../../type != 'bridged' and ../../type != 'local-mirror-dest'))" {
          error-message "ipv6 configuration not allowed on bridged or local-mirror-dest subinterfaces";
        }
      }
      list address {
        max-elements 18;
        key "ip-prefix";
        description
          "The list of IPv6 addresses assigned to the subinterface.";
        leaf ip-prefix {
          type srl_nokia-comm:ipv6-prefix-with-host-bits;
          description
            "The IPv6 address and prefix-length in CIDR notation

             Up to 16 global unicast IPv6 addresses can be assigned to each subinterface. Global unicast IPv6 address subnets on the same subinterface are allowed to overlap as long as the host bits are different. When a locally originated unicast packet is destined to a host covered by multiple subnets associated with a subinterface, the source address is chosen to be the numerically lowest IP address among all these subnets.";
          must "not(.='::/128' or .='::1/128' or starts-with(.,'ff'))" {
            error-message "Not a unicast IPv6 address prefix";
          }
        }
        leaf type {
          type srl_nokia-comm:ipv6-address-type;
          default "global-unicast";
          description
            "Specifies the explicit type of the IPv6 address being assigned to the subinterface

             By default, addresses are assumed to be global unicast.  Where a link-local address is to be explicitly configured, this leaf should be set to link-local.";
          must "not(. = 'global-unicast' and starts-with(../ip-prefix,'fe80'))" {
            error-message "Type is global but address prefix implies link-local";
          }
          must "not(. = 'link-local-unicast' and not(starts-with(../ip-prefix,'fe80')))" {
            error-message "Type is link-local-unicast but address prefix is not link-local";
          }
        }
        leaf anycast-gw {
          if-feature "srl_feat:anycast-gw";
          must "starts-with(../../../../name,'irb')" {
            error-message "Only supported on IRB subinterfaces";
          }
          must ". = false() or (. = true() and ../../../anycast-gw) or not(starts-with(../../../../name,'irb'))" {
            error-message "Only supported if anycast-gw container is configured";
          }
          must "not(starts-with(../ip-prefix,'fe80'))" {
            error-message "not supported on link local address";
          }
          type boolean;
          description
            "This designates the associated IPv6 address as an anycast-gateway IPv6 address of the subinterface.

             When this parameter is set to true:
             - The IPv6 address is associated with the anycast-gw MAC address in the same subinterface. Neighbor Solicitations received for the anycast-gw IPv6 address
               will be replied using this anycast-gw MAC address.
             - The IPv6 address can have duplicate IPv6 addresses in other IRB subinterfaces of routers attached to the same broadcast domain.
               Because of that, ND duplicate-address-detection procedures do not apply to anycast-gw IP addresses.";
        }
        leaf origin {
          config false;
          type address-origin;
          description
            "The origin of the IPv6 address";
        }
        leaf primary {
          srl_nokia-ext:first-released "20.12.1";
          type empty;
          must "not (starts-with(../../../../name, 'mgmt') or (starts-with(../../../../name, 'system')) or (starts-with(../../../../name, 'sync')))" {
            error-message "primary not supported on mgmt or system subinterfaces";
          }
          description
            "One of the IPv6 prefixes assigned to the subinterface can be explicitly configured as primary by setting this leaf to true. This designates the associated IPv6 address as a primary IPv6 address of the subinterface. By default, the numerically lowest value IPv6 address is selected as the primary address.

             The primary address is used as the source address for locally originated broadcast and multicast packets sent out the subinterface.";
        }
        leaf status {
          config false;
          type ipv6-address-status;
          description
            "The status of an IPv6 address";
        }
      }
    }
  }
}
""")
    res.append(r"""module srl_nokia-interfaces-vlans {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:chassis:interfaces-vlans";
  prefix srl_nokia-if-vlan;

  import srl_nokia-extensions {
    prefix srl_nokia-ext;
  }
  import srl_nokia-features {
    prefix srl_nokia-feat;
  }
  import srl_nokia-interfaces {
    prefix srl_nokia-if;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "Model for managing VLANs

     This model describes management of VLAN parameters under SRL Interfaces";

  revision 2025-03-31 {
    description
      "SRLinux 2025.3.1";
  }
  revision 2024-10-31 {
    description
      "SRLinux 24.10.1";
  }
  revision 2024-07-31 {
    description
      "SRLinux 24.7.1";
  }
  revision 2024-03-31 {
    description
      "SRLinux 24.3.1";
  }
  revision 2023-10-31 {
    description
      "SRLinux 23.10.1";
  }
  revision 2023-03-31 {
    description
      "SRLinux 23.3.1";
  }
  revision 2022-11-30 {
    description
      "SRLinux 22.11.1";
  }
  revision 2022-06-30 {
    description
      "SRLinux 22.6.1";
  }
  revision 2022-03-31 {
    description
      "SRLinux 22.3.1";
  }
  revision 2021-11-30 {
    description
      "SRLinux 21.11.1";
  }
  revision 2021-06-30 {
    description
      "SRLinux 21.6.1";
  }
  revision 2021-03-31 {
    description
      "SRLinux 21.3.1";
  }
  revision 2019-11-30 {
    description
      "SRLinux 19.11.1";
  }

  typedef vlan-id {
    type uint16 {
      range "1..4094";
    }
    description
      "Type definition representing a single-tagged VLAN";
  }

    grouping vlan-single-tagged-params {
    description
      "match criteria for a single tag";
    leaf vlan-id {
      type union {
        type vlan-id;
        type enumeration {
          enum optional {
            if-feature "srl_nokia-feat:vlan-id-optional";
          }
          enum any {
            if-feature "srl_nokia-feat:vlan-id-any";
          }
        }
      }
      description
        "VLAN identifier for single-tagged packets";
      must '(../../../../../vlan-tagging = true())' {
        error-message "vlan-id only configurable if vlan-tagging enabled on parent interface";
      }
      must "string(.) != 'optional' or (../../../../srl_nokia-if:type = 'srl_nokia-if:bridged')" {
        error-message "vlan-id optional only configurable on bridged subinterface";
      }
      must "string(.) != 'any' or (../../../../srl_nokia-if:type = 'srl_nokia-if:bridged')" {
        error-message "vlan-id any only configurable on bridged subinterface";
      }
    }
  }

  grouping vlan-match-top {
    description
      "Top-level configuration and state for VLAN parameters";
    container encap {
      description
        "VLAN match parmeters for the associated subinterface";
      container single-tagged {
        presence "Match single-tagged packets with a specific vlan-id.";
        description
          "When present, tagged frames with a specific, non-zero, outer VLAN ID are associated to the subinterface

           The outer VLAN-ID tag is considered service delimiting and it is by default stripped at ingress and restored/added on egress.";
        uses vlan-single-tagged-params;
      }
    }
  }

  grouping vlan-subinterface-top {
    description
      "Top-level configuration and state for VLAN parameters per subinterface";
    container vlan {
      description
        "Parameters for VLAN definition under SRL interfaces";
      uses vlan-match-top;
    }
  }

  grouping vlan-interface-top {
    description
      "Top-level configuration and state for VLAN parameters per port";
    leaf vlan-tagging {
      description
        "When set to true the interface is allowed to accept frames with one or more VLAN tags";
      type boolean;
      must "starts-with(../srl_nokia-if:name, 'ethernet') or starts-with(../srl_nokia-if:name, 'lag') or starts-with(../srl_nokia-if:name, 'lif') or starts-with(../srl_nokia-if:name, 'enp') or starts-with(../srl_nokia-if:name, 'vhn')" {
        error-message "vlan-tagging not configurable on this interface";
      }
      must 'not(../srl_nokia-if:breakout-mode)' {
        error-message "vlan-tagging not configurable when breakout-mode is enabled";
      }
    }
  }

  augment "/srl_nokia-if:interface/srl_nokia-if:subinterface" {
    uses vlan-subinterface-top;
  }

  augment "/srl_nokia-if:interface" {
    uses vlan-interface-top;
  }
}
""")
    res.append(r"""module srl_nokia-interfaces {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:chassis:interfaces";
  prefix srl_nokia-if;

  import srl_nokia-common {
    prefix srl_nokia-comm;
  }
  import srl_nokia-features {
    prefix srl_nokia-feat;
  }
  import srl_nokia-if-ip {
    prefix srl_nokia-if-ip;
  }
  import srl_nokia-extensions {
    prefix srl_nokia-ext;
  }
  import srl_nokia-system {
    prefix srl_nokia-sys;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "Model for managing network interfaces and subinterfaces.

     This model reuses data items defined in the IETF YANG model for
     interfaces described by RFC 7223";

  revision 2025-03-31 {
    description
      "SRLinux 2025.3.1";
  }
  revision 2024-10-31 {
    description
      "SRLinux 24.10.1";
  }
  revision 2024-07-31 {
    description
      "SRLinux 24.7.1";
  }
  revision 2024-03-31 {
    description
      "SRLinux 24.3.1";
  }
  revision 2023-10-31 {
    description
      "SRLinux 23.10.1";
  }
  revision 2023-07-31 {
    description
      "SRLinux 23.7.1";
  }
  revision 2023-03-31 {
    description
      "SRLinux 23.3.1";
  }
  revision 2022-11-30 {
    description
      "SRLinux 22.11.1";
  }
  revision 2022-06-30 {
    description
      "SRLinux 22.6.1";
  }
  revision 2022-03-31 {
    description
      "SRLinux 22.3.1";
  }
  revision 2021-11-30 {
    description
      "SRLinux 21.11.1";
  }
  revision 2021-06-30 {
    description
      "SRLinux 21.6.1";
  }
  revision 2021-03-31 {
    description
      "SRLinux 21.3.1";
  }
  revision 2020-06-30 {
    description
      "SRLinux 20.6.1";
  }
  revision 2019-11-30 {
    description
      "SRLinux 19.11.1";
  }

  identity si-type {
    description
      "Base type for subinterface types";
  }

  identity routed {
    base si-type;
    description
      "Indicates subinterface is used in a routed context";
  }

  identity bridged {
    if-feature "srl_nokia-feat:bridged";
    base si-type;
    description
      "Indicates subinterface is used in a bridged context";
  }

  identity local-mirror-dest {
    if-feature "srl_nokia-feat:mirroring";
    base si-type;
    description
      "Indicates subinterface is used in a mirroring destination SPAN context";
  }

  identity transceiver-functional-type {
    description
      "Base type for transceiver functional types";
  }

  identity standard {
    base transceiver-functional-type;
    description
      "indicates transceiver supports standard optics";
  }

  identity digital-coherent-optics {
    if-feature "srl_nokia-feat:digital-coherent-optics";
    base transceiver-functional-type;
    description
      "Indicates transceiver supports digital coherent optics";
  }

  identity optical-line-system {
    if-feature "srl_nokia-feat:optical-line-system";
    base transceiver-functional-type;
    description
      "Indicates transceiver is a QSFP-DD-LS Amplifier

       These are used to multiplex and amplify coherent optical signals and do not themselves support Ethernet interfaces.";
  }

  typedef oper-fec-type {
    type enumeration {
      enum disabled {
        description
          "No FEC is active on the host interface";
      }
      enum cl74-baser {
        description
          "An early form of FEC used with 25G interfaces

           Not very strong performance - cl108-rs528 is preferred.  cl74-baser should only be used if the far end doesn't support cl108-rs528";
      }
      enum cl108-rs528 {
        description
          "IEEE 802.3 Clause 108 using RS(528,514)

           IEEE defines this as mandatory for 25G interfaces";
      }
      enum cl91-rs528 {
        description
          "IEEE 802.3 Clause 91 using RS(528,514)

           IEEE defines this as an option for 100G interfaces using NRZ";
      }
      enum cl91-rs544 {
        description
          "IEEE 802.3 Clause 91 using RS(544,514)

           IEEE defines this as mandatory for 100G interfaces using PAM4";
      }
      enum cl119-rs544 {
        description
          "IEEE 802.3 Clause 119 using RS(544,514)

           IEEE defines this as mandatory for 200G and 400G interfaces";
      }
      enum cl134-rs544 {
        description
          "IEEE 802.3 Clause 134 using RS(544,514)

           IEEE defines this as mandatory for 50G interfaces";
      }
    }
    description
      "Enumerations of fec options for a STANDARD Ethernet interface

       Only a subset of these are configurable.";
  }

  typedef interface-id {
    type string;
    description
      "User-defined identifier for an interface

       This is generally used to name a interface reference. The id can be arbitrary but a useful convention is to use a combination of base interface name and subinterface index.";
  }

  typedef loopback-mode-type {
    type enumeration {
      enum none {
        description
          "No loopback is applied";
      }
      enum facility {
        if-feature "srl_nokia-feat:loopback-mode-facility";
        description
          "A loopback which directs traffic received from an external source on the port back out the transmit side of the same port.";
      }
      enum terminal {
        if-feature "srl_nokia-feat:loopback-mode-terminal";
        description
          "A loopback which directs traffic normally transmitted on the port back into the switch as if received on the same
           port from an external source

           On some systems this is also called local loopback.";
      }
    }
    description
      "Loopback modes for physical ports";
  }

  typedef ethernet-monitor-report-status {
    type enumeration {
      enum none {
        value 0;
      }
      enum sd-threshold-exceeded {
        value 1;
      }
      enum sf-threshold-exceeded {
        value 2;
      }
    }
  }

  grouping interface-common-config {
    description
      "Configuration data nodes common to physical interfaces and subinterfaces";
    leaf description {
      type srl_nokia-comm:description;
      description
        "A user-configured description of the interface";
      reference
        "RFC 2863: The Interfaces Group MIB - ifAlias";
    }
  }

  grouping interface-phys-config {
    description
      "Configuration data for physical interfaces";
    uses interface-common-config;
    leaf admin-state {
      srl_nokia-ext:show-importance "high";
      type srl_nokia-comm:admin-state;
      default "enable";
      description
        "The configured, desired state of the interface";
      reference
        "RFC 2863: The Interfaces Group MIB - ifAdminStatus";
      must "((. = 'enable') and starts-with(../srl_nokia-if:name, 'system0')) or not(starts-with(../srl_nokia-if:name, 'system0'))" {
        error-message "admin-state must be enable";
      }
    }
    leaf mtu {
      type uint16 {
        range "1450..9500";
      }
      units "bytes";
      description
        "Port MTU in bytes including ethernet overhead but excluding 4-bytes FCS

         If a transmitted packet exceeds this size it is dropped.
         The default value for ethernet-x interfaces is taken from /system/mtu/default-port-mtu. For the mgmt0 and mgmt0-standby interfaces the default is 1514 bytes, but the value can be changed for each interface individually.
         Port MTU is not configurable for loopback interfaces or irb interfaces. For irb interfaces, if the size of the ip packets to be routed to a mac-vrf has to be restricted, the subinterface.ip-mtu should be configured instead.
         The max mtu for the mgmt0 and mgmt0-standby interfaces is 9216.
         The 7220 IXR-D1, 7220 IXR-D2, 7220 IXR-D3, 7220 IXR-D4, 7220 IXR-D5, 7220 IXR-H2, 7220 IXR-H3, and 7220 IXR-H4 systems support a maximum port MTU of 9412 bytes and minimum of 1500 bytes.
         The VSRL system supports a maximum port MTU of 9500 and minimum of 1450 bytes.
         The 7730 SXR systems support a maximum port MTU of 9408 bytes and minimum of 1500 bytes.
         All other systems support a maximum port MTU of 9500 and minimum of 1500 bytes.
         Each 7250 IXR IMM supports a maximum of 8 different port MTU values. 7220 IXR systems do not have any limit on the maximum number of different port MTU values.";
      must 'not(../breakout-mode)' {
        error-message "mtu not configurable when breakout-mode is enabled";
      }
      must 'starts-with(../srl_nokia-if:name, "lif") or starts-with(../srl_nokia-if:name, "vhn") or (. >= 1500)' {
        error-message "minimum mtu is 1500 for this interface type";
      }
      must "(not (starts-with(../srl_nokia-if:name, 'mgmt'))) or (. <= 9216)" {
        error-message "mtu max is 9216 for mgmt interface";
      }
    }
  }

  grouping subinterface-config {
    description
      "Configuration data for subinterfaces";
    uses interface-common-config;
    leaf admin-state {
      srl_nokia-ext:show-importance "high";
      type srl_nokia-comm:admin-state;
      default "enable";
      description
        "The configured, desired state of the subinterface";
      reference
        "RFC 2863: The Interfaces Group MIB - ifAdminStatus";
      must "((. = 'enable') and starts-with(../../srl_nokia-if:name, 'system0')) or not(starts-with(../../srl_nokia-if:name, 'system0'))" {
        error-message "admin-state must be enable";
      }
    }
    leaf ip-mtu {
      type uint16 {
        range "1280..9486";
      }
      units "bytes";
      description
        "IP MTU of the subinterface in bytes.

         Includes the IP header but excludes Ethernet encapsulation.

         IP MTU specifies the maximum sized IPv4 or IPv6 packet that can be transmitted on the subinterface. If an IPv4 or IPv6 packet exceeds this size it is dropped and this may result in the generation of an ICMP error message back to the source.

         The default IP MTU for a subinterface is taken from /system/mtu/default-ip-mtu.  For the mgmt0 and mgmt0-standby subinterfaces the default is the associated interface MTU minus the Ethernet encapsulation overhead.

         The IP MTU is not configurable for subinterfaces of loopback interfaces.

         The 7220 IXR-D1, 7220 IXR-D2, 7220 IXR-D3, 7220 IXR-D4, 7220 IXR-D5, 7220 IXR-H2, 7220 IXR-H3, and 7220 IXR-H4 systems support a maximum IP MTU of 9398 bytes.

         The 7730 SXR systems support a maximum IP MTU of 9394 bytes.

         Each 7250 IXR IMM supports a maximum of 4 different IP MTU values. 7220 IXR systems do not have any limit on the maximum number of different IP MTU values.";
      must "not (starts-with(../../srl_nokia-if:name, 'system') or starts-with(../../srl_nokia-if:name, 'lo'))" {
        error-message "ip-mtu not supported on this interface";
      }
      must "(../type != 'srl_nokia-if:bridged') and (../type != 'srl_nokia-if:local-mirror-dest')" {
        error-message "ip-mtu not allowed with type bridged or type local-mirror-dest";
      }
    }
    leaf l2-mtu {
      if-feature "srl_nokia-feat:config-sub-if-l2-mtu";
      type uint16 {
        range "1450..9500";
      }
      units "bytes";
      description
        "Layer-2 MTU of the subinterface in bytes.

         Includes the Ethernet header and VLAN tags, and excludes 4-bytes FCS.

         L2 MTU specifies the maximum sized Ethernet frame that can be transmitted on the subinterface. If a frame exceeds this size it is discarded. If the l2-mtu of the subinterface exceeds the port-mtu of the associated
         interface, the subinterface will remain operationally down.

         The default value for a subinterface is taken from /system/mtu/default-l2-mtu. The L2 MTU is only configurable for bridged subinterfaces.

         The 7220 IXR-D1, 7220 IXR-D2, 7220 IXR-D3, 7220 IXR-D4, 7220 IXR-D5, 7220 IXR-H2, 7220 IXR-H3, and 7220 IXR-H4 systems support a maximum L2 MTU of 9412 bytes and minimum of 1500 bytes.

         The 7730 SXR systems support a maximum L2 MTU of 9408 bytes.

         The VSRL system supports a maximum L2 MTU of 9500 and minimum of 1450 bytes.

         All other systems support a maximum L2 MTU of 9500 and minimum of 1500 bytes.";
      must "../type = 'srl_nokia-if:bridged'" {
        error-message "l2-mtu only allowed with type bridged";
      }
      must 'starts-with(../../srl_nokia-if:name, "lif") or starts-with(../../srl_nokia-if:name, "vhn") or (. >= 1500)' {
        error-message "minimum l2-mtu is 1500 for this interface type";
      }
    }
    leaf mpls-mtu {
      if-feature "srl_nokia-feat:mpls";
      type uint16 {
        range "1284..9496";
      }
      units "bytes";
      description
        "MPLS MTU of the subinterface in bytes, including the transmitted label stack.

         MPLS MTU specifies the maximum sized MPLS packet that can be transmitted on the subinterface. If an MPLS packet containing any payload exceeds this size then it is dropped. If the payload of the dropped packet is IPv4 or IPv6 then this may also result in the generation of an ICMP error message that is either tunneled or sent back to the source.

         The default MPLS MTU for a subinterface is taken from /system/mtu/default-mpls-mtu.

         The MPLS MTU is not configurable for subinterfaces of loopback interfaces.

         The 7730 SXR systems support a maximum MPLS MTU of 9404 bytes.

         Each 7250 IXR IMM supports a maximum of 4 different MPLS MTU values.";
      must "not (starts-with(../../srl_nokia-if:name, 'system') or starts-with(../../srl_nokia-if:name, 'lo') or starts-with(../../srl_nokia-if:name, 'mgmt'))" {
        error-message "mpls-mtu not supported on this interface";
      }
      must "(../type != 'srl_nokia-if:bridged') and (../type != 'srl_nokia-if:local-mirror-dest')" {
        error-message "mpls-mtu not allowed with type bridged or type local-mirror-dest";
      }
    }
  }

  grouping subinterface-top {
    description
      "Subinterface data for logical interfaces associated with a given interface";
    list subinterface {
      max-elements 4095;
      key "index";
      description
        "The list of subinterfaces (logical interfaces) associated with a physical interface";
      leaf index {
        type uint32 {
          range "0..9999";
        }
        description
          "The index of the subinterface, or logical interface number";
        must "((. = 0) and starts-with(../../srl_nokia-if:name, 'system0')) or not(starts-with(../../srl_nokia-if:name, 'system0'))" {
          error-message "subinterface index must be 0 for system0 interface";
        }
        must "not(starts-with(../../srl_nokia-if:name, 'sync0'))" {
          error-message "subinterfaces not supported on sync0 port";
        }
      }
      leaf type {
        type identityref {
          base si-type;
        }
        description
          "Indicates the context in which the ethernet subinterface will be used";
        must "(starts-with(../../srl_nokia-if:name, 'ethernet') or starts-with(../../srl_nokia-if:name, 'lag') or starts-with(../../srl_nokia-if:name, 'lif') or starts-with(../../srl_nokia-if:name, 'enp') or starts-with(../../srl_nokia-if:name, 'vhn'))" {
          error-message "type not supported on this interface";
        }
        must "(. != 'srl_nokia-if:local-mirror-dest') or (starts-with(../../srl_nokia-if:name, 'ethernet') or starts-with(../../srl_nokia-if:name, 'lag'))" {
          error-message "local-mirror-dest is not supported on this interface";
        }
      }
      uses subinterface-config;
      uses srl_nokia-if-ip:ipv4-top;
      uses srl_nokia-if-ip:ipv6-top;
    }
  }

  grouping interface-top {
    description
      "Top-level grouping for interface configuration and operational state data";
    list interface {
      key "name";
      description
        "The list of named interfaces on the device";
      leaf name {
        type srl_nokia-comm:interface-all;
        description
          "The name of the interface

           Valid options are:
           irb<N>, N=0..255
           lif-<lif_name>
           enp<bus>s<dev>f<fn>, bus=0..255, dev=0..31, fn=0..7
           vhn-<vhn_name>
           lag<N>, N=1..1000 [note1]
           lo<N>, N=0..255
           mgmt0
           mgmt0-standby
           ethernet-<slot>/<port>
           ethernet-<slot>/<connector>/<port>
           ethernet-<slot>/m<mda>/<port>
           ethernet-<slot>/m<mda>/<connector>/<port>
           system0
           sync0

           <lif_name>=Linux interface name
           <vhn_name>=vhost interface name
           <slot>=slot number {1,2,3,..}
           <mda>=mda id {1,2,3,..}
           <connector>=connector id {1,2,3,..}
           <port>=port id {1,2,3,..}

           [note1] The maximum number of LAGs per platform is as follows:
            D1: 32 (N must be 1..32)
            D2-D3: 128 (N must be 1..1000)
            D4-D5: 64 (N must be 1..64)
            H2-H3: 127 (N must be 1..127)
            H4-32D: 127 (N must be 1..127)
            H4: 255 (N must be 1..255)
            IXR: 128 (N must be 1..128)
            SXR-1d-32D: 128 (N must be 1..128)
            SXR-1x-44S: 128 (N must be 1..128)
            vSRL: 8 (N must be 1..8)
            A1: 10 (N must be 1..10)
            IXR-X1b: 512 (N must be 1..512)
            IXR-X3b: 512 (N must be 1..512)";
      }
      uses interface-phys-config;
      uses subinterface-top;
    }
  }

  uses interface-top;
}
""")
    res.append(r"""module srl_nokia-isis-types {
  yang-version 1.1;
  prefix srl_nokia-isis-types;
  namespace "urn:nokia.com:srlinux:general:isis-types";

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "This yang file contains common ISIS types and identities";

  revision 2024-10-31 {
    description
      "SRLinux 24.10.1";
  }

  typedef isis-level {
    description
      "Specifies the IS-IS Level.";
    type enumeration {
      enum L1 {
        description
          "This enum describes ISIS level 1";
      }
      enum L2 {
        description
          "This enum describes ISIS level 2";
      }
      enum L1L2 {
        description
          "This enum describes ISIS level 1-2";
      }
    }
    default "L1L2";
  }

  typedef isis-level-number {
    description
      "This type defines ISIS level number.";
    type uint8 {
      range "1..2";
    }
  }

  typedef isis-metric-type {
    description
      "This type defines ISIS metric type";
    type enumeration {
      enum internal {
        description
          "This enum describes internal route type";
      }
      enum external {
        description
          "This enum describes external route type";
      }
    }
  }

  typedef isis-metric-style {
    description
      "This type defines ISIS metric styles";
    type enumeration {
      enum narrow {
        description
          "This enum describes narrow metric style";
        reference
          "RFC1195";
      }
      enum wide {
        description
          "This enum describes wide metric style";
        reference
          "RFC5305";
      }
    }
  }

  typedef isis-wide-metric {
    description
      "This type defines ISIS wide metric.";
    type uint32 {
      range "0..16777215";
    }
  }

  typedef isis-narrow-metric {
    description
      "This type defines ISIS narrow metric.";
    type uint32 {
      range "1..63";
    }
  }

  typedef isis-tlv-wide-metric {
    description
      "This type defines ISIS wide metric value inside a TLV.";
    type uint32 {
      range "0..16777215";
    }
  }

  typedef isis-tlv-narrow-metric {
    description
      "This type defines ISIS narrow metric value inside a TLV.";
    type uint32 {
      range "0..63";
    }
  }

  typedef isis-hello-padding-type {
    description
      "This type defines ISIS hello padding type";
    type enumeration {
      enum strict {
        description
          "Strict padding option.
           Hello padding is done continuously, regardless of adjacency state or interface type.";
      }
      enum loose {
        description
          "Loose padding option.
           On p2p interfaces hello PDUs are padded from the initial detection of a new neighbor until the adjacency transitions to the INIT state.
           On broadcast interfaces hello padding is done until there is at least one UP adjacency on the interface.";
      }
      enum adaptive {
        description
          "Adaptive padding option.
           On p2p interfaces hello PDUs are padded until the sender declares the adjacency to be UP (based on  3-way handshake or the classic algorithm described in ISO 10589. If the p2p neighbor does not support the adjacency state TLV, then padding continues.
           On broadcast interfaces hello padding is done until there is at least one UP adjacency on the interface.";
      }
      enum disable {
        description
          "This enum disables hello PDU padding";
      }
    }
  }

  typedef isis-ecmp {
    description
      "This type defines the range of IS-IS max-ecmp-paths";
    type uint8 {
      range "1..64";
    }
  }

  typedef isis-net-id {
    description
      "This type defines OSI NET address. A NET should should be in the form xx.yyyy.yyyy.yyyy.00 with up to 9 sets of yyyy.";
    type string {
      pattern '[a-fA-F0-9]{2}(\.[a-fA-F0-9]{4}){3,9}\.[0]{2}';
    }
  }

  typedef isis-area-address {
    description
      "This type defines the ISIS area address.";
    type string {
      pattern '[0-9A-Fa-f]{2}(\.[0-9A-Fa-f]{4}){0,6}';
      length "2..38";
    }
  }

  typedef isis-circuit-type {
    description
      "This type defines ISIS interface types ";
    type enumeration {
      enum point-to-point {
        description
          "This enum describes a point-to-point interface";
      }
      enum broadcast {
        description
          "This enum describes a broadcast interface";
      }
    }
  }

  typedef isis-extended-circuit-id {
    description
      "This type defines interface circuit ID.";
    type uint32;
  }

  typedef isis-routing-topology {
    description
      "isis routing topology.
       native(1) - Indicates standard topology.
       mt(2) - Indicates multi-topology for IPv4/IPv6 unicast/multicast routing.";
    type enumeration {
      enum false {
        value 0;
      }
      enum native {
        value 1;
      }
      enum mt {
        value 2;
      }
    }
  }

  typedef isis-admin-tag {
    description
      "This type defines the range administrative route tags that can be assigned to ISIS routes";
    type uint32 {
      range "1..4294967295";
    }
  }

  typedef isis-level-state {
    description
      "States of the ISIS protocol.";
    type enumeration {
      enum off {
        value 1;
      }
      enum on {
        value 2;
      }
      enum waiting {
        value 3;
      }
    }
  }

  typedef isis-interface-adj-state {
    description
      "This type defines the state of the interface.";
    type enumeration {
      enum up {
        description
          "This state describes that adjacency is established.";
      }
      enum down {
        description
          "This state describes that adjacency is NOT established.";
      }
      enum init {
        description
          "This state describes that adjacency is establishing.";
      }
      enum failed {
        description
          "This state describes that adjacency is failed.";
      }
    }
  }

  typedef isis-adjacency-down-reason {
    type enumeration {
      enum 3-way-handshake-failed;
      enum address-mismatch;
      enum hold-timer-expired;
      enum area-mismatch;
      enum bad-hello;
      enum bfd-session-down;
      enum interface-down;
      enum interface-level-disabled;
      enum level-changed;
      enum level-mismatch;
      enum mt-topology-changed;
      enum mt-topology-mismatch;
      enum remote-system-id-changed;
      enum isis-protocol-disabled;
      enum unknown;
    }
  }

  typedef isis-pdu-type {
    description
      "Type of the ISIS PDU.";
    type enumeration {
      enum LSP {
        description
          "Link State PDU";
      }
      enum IIH {
        description
          "IS-to-IS Hello PDU";
      }
      enum CSNP {
        description
          "Complete Sequence Number PDU";
      }
      enum PSNP {
        description
          "Partial Sequence Number PDU";
      }
      enum Unknown {
        description
          "Unknown PDU type";
      }
    }
  }

  typedef isis-snpa {
    description
      "This type defines Subnetwork Point of Attachment format.";
    type string {
      length "0..20";
    }
  }

  typedef isis-adjacent-neighbor {
    description
      "This type provides the identification of an adjacent neighbor IS.";
    type string {
      pattern '[0-9A-Fa-f]{4}\.[0-9A-Fa-f]{4}\.[0-9A-Fa-f]{4}\.[0-9A-Fa-f]{2}';
      length "17";
    }
  }

  typedef isis-protocols-supported {
    type enumeration {
      enum IPv4 {
        description
          "NLPID 0xCC corresponding to IPv4";
      }
      enum IPv6 {
        description
          "NLPID 0x8E corresponding to IPv6";
      }
      enum CLNS {
        description
          "NLPID 0x81 corresponding to CLNS";
      }
    }
  }

  typedef isis-adj-level {
    description
      "This type defines ISIS level number.";
    type string {
      pattern 'L1|L2|L1L2';
    }
  }

  typedef isis-auth-check-type {
    description
      "Type of the ISIS authentication checks for received frames.";
    type enumeration {
      enum strict {
        description
          "Strict authentication option.
           Reject all packets that do not have an authentication TLV or that do have an authentication TLV that cannot be validated.";
      }
      enum loose {
        description
          "Loose authentication option.
           Accept packets received without an authentication TLV; validate packets received with an authentication TLV and reject those packets that cannot be validated.";
      }
      enum disable {
        description
          "This enum disables athentication checks.
           Do not check authentication TLV (if any) of received PDUs; authentication TLV may still be added self-generated PDUs";
      }
    }
  }

  typedef isis-auth-type {
    description
      "This type defines the type of authentication used by ISIS PDUs";
    type enumeration {
      enum cleartext {
        description
          "The authentication-key is encoded in plaintext.";
      }
      enum hmac-md5 {
        description
          "The authentication-key is used to generate a 16-byte (128 bit) MD5 digest using the HMAC algorithm (RFC 2104).";
      }
      enum hmac-sha-256 {
        description
          "The authentication-key is used to generate a SHA2 digest using the HMAC algorithm (RFC 2104).The SHA-256 variant of SHA2 produces an output of 32 bytes (256 bits).";
      }
    }
  }
}
""")
    res.append(r"""module srl_nokia-isis {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:isis:isis";
  prefix srl_nokia-isis;

  import ietf-yang-types {
    prefix yang;
  }
  import srl_nokia-common {
    prefix srl_nokia-comm;
  }
  import srl_nokia-network-instance {
    prefix srl_nokia-netinst;
  }
  import srl_nokia-interfaces {
    prefix srl_nokia-if;
  }
  import srl_nokia-extensions {
    prefix srl_nokia-ext;
  }
  import srl_nokia-routing-policy {
    prefix srl-rpol;
  }
  import srl_nokia-system {
    prefix srl-system;
  }
  import srl_nokia-keychains {
    prefix srl-keychain;
  }
  import srl_nokia-features {
    prefix srl-feat;
  }
  import srl_nokia-mpls-label-management {
    prefix srl_nokia-mplslbl;
  }
  import srl_nokia-segment-routing {
    prefix srl_nokia-segrt;
  }
  import srl_nokia-isis-types {
    prefix srl_nokia-isis-types;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "This yang file models configuration and state of the IS-IS protocol";

  revision 2025-03-31 {
    description
      "SRLinux 2025.3.1";
  }
  revision 2024-10-31 {
    description
      "SRLinux 24.10.1";
  }
  revision 2024-07-31 {
    description
      "SRLinux 24.7.1";
  }
  revision 2024-03-31 {
    description
      "SRLinux 24.3.1";
  }
  revision 2023-10-31 {
    description
      "SRLinux 23.10.1";
  }
  revision 2023-07-31 {
    description
      "SRLinux 23.7.1";
  }
  revision 2023-03-31 {
    description
      "SRLinux 23.3.1";
  }
  revision 2022-11-30 {
    description
      "SRLinux 22.11.1";
  }
  revision 2022-06-30 {
    description
      "SRLinux 22.6.1";
  }
  revision 2022-03-31 {
    description
      "SRLinux 22.3.1";
  }
  revision 2021-11-30 {
    description
      "SRLinux 21.11.1";
  }
  revision 2021-06-30 {
    description
      "SRLinux 21.6.1";
  }
  revision 2021-03-31 {
    description
      "SRLinux 21.3.1";
  }
  revision 2020-06-30 {
    description
      "SRLinux 20.6.1";
  }

  grouping isis-inst-key {
    leaf name {
      description
        "The name of the IS-IS instance";
      type srl_nokia-comm:name;
    }
  }

  grouping isis-level-key {
    leaf level-number {
      description
        "Specifies the IS-IS protocol level to which these attributes are applied.";
      type srl_nokia-isis-types:isis-level-number;
    }
  }

  grouping isis-interface-key {
    leaf interface-name {
      description
        "Name of the IS-IS interface";
      type srl_nokia-netinst:network-instance-subintf-name;
    }
  }

  grouping isis-summary-prefix-key {
    leaf ip-prefix {
      description
        "Summary ip prefix.";
      type srl_nokia-comm:ip-prefix;
    }
  }

  grouping isis-authentication-pdu-options {
    leaf generate {
      type boolean;
      description
        "When set to true, IS-IS is instructed to add an authentication TLV to every transmitted PDU of the specified type";
      must '(. = false()) or boolean(../../keychain) or boolean(../../key/crypto-algorithm)' {
        error-message "keychain or key must be configured to send authentication TLV with this PDU";
      }
    }
    leaf check-received {
      type srl_nokia-isis-types:isis-auth-check-type;
      description
        "Specifies the type of authentication checks done for received PDUs of the specified type.";
      must "(. = 'disable')  or boolean(../../keychain) or boolean(../../key/crypto-algorithm)" {
        error-message "keychain or key must be configured to check authentication for this PDU";
      }
    }
  }

  grouping isis-instance-level-authentication {
    container authentication {
      description
        "Container for specifying authetication options that apply to the entire IS-IS instance or to an entire level.

         The settings in this container only apply to PDUs without an authentication behavior specified at a more granular level.";
      container csnp-authentication {
        description
          "Container with options to control the authentication of CSNP PDUs";
        uses isis-authentication-pdu-options;
      }
      container psnp-authentication {
        description
          "Container with options to control the authentication of PSNP PDUs";
        uses isis-authentication-pdu-options;
      }
      container hello-authentication {
        description
          "Container with options to control the authentication of Hello PDUs";
        uses isis-authentication-pdu-options;
      }
      container lsp-authentication {
        description
          "Container with options to control the authentication of Link State PDUs";
        uses isis-authentication-pdu-options;
      }
      choice auth-type {
        case keychain {
          leaf keychain {
            description
              "Specifies a keychain to use for the authentication of PDUs when the behavior is controlled at this level of the configuration hierarchy.";
            type leafref {
              path "/srl-system:system/srl-keychain:authentication/srl-keychain:keychain/srl-keychain:name";
            }
            must '/srl-system:system/srl-keychain:authentication/srl-keychain:keychain[srl-keychain:name = current()]'
               + '/srl-keychain:type = "isis"' {
              error-message "Only keychain of type isis can be assigned";
            }
          }
        }
        case direct-key {
          container key {
            description
              "Container to specify the secret key and crypto algorithm to use for the authentication of PDUs when the behavior is controlled at this level of the configuration hierarchy";
            leaf crypto-algorithm {
              description
                "The cryptographic algorithm used with the keying material to secure the messages.";
              type srl_nokia-isis-types:isis-auth-type;
              mandatory true;
            }
            leaf auth-password {
              description
                "The secret key to use for authentication of PDUs";
              type srl_nokia-comm:routing-password;
              mandatory true;
            }
          }
        }
      }
    }
  }

  grouping isis-interface-authentication {
    container authentication {
      description
        "Container for specifying authetication options that apply to the IS-IS instance.";
      container hello-authentication {
        description
          "Container with options to control the authentication of Hello PDUs";
        uses isis-authentication-pdu-options;
      }
      choice auth-type {
        case keychain {
          leaf keychain {
            description
              "Specifies a keychain to use for the authentication of Hello PDUs on this interface.";
            type leafref {
              path "/srl-system:system/srl-keychain:authentication/srl-keychain:keychain/srl-keychain:name";
            }
            must '/srl-system:system/srl-keychain:authentication/srl-keychain:keychain[srl-keychain:name = current()]'
               + '/srl-keychain:type = "isis"' {
              error-message "Only keychain of type isis can be assigned";
            }
          }
        }
        case direct-key {
          container key {
            description
              "Container to specify the secret key and crypto algorithm to use for the authentication of Hello PDUs on this interface";
            leaf crypto-algorithm {
              description
                "The cryptographic algorithm used with the keying material to secure the messages.";
              type srl_nokia-isis-types:isis-auth-type;
              mandatory true;
            }
            leaf auth-password {
              description
                "The secret key to use for authentication of Hello PDUs";
              type srl_nokia-comm:routing-password;
              mandatory true;
            }
          }
        }
      }
    }
  }

  grouping isis-interface-level-config {
    leaf disable {
      description
        "Disable the Level for the interface.";
      type boolean;
      default "false";
    }
    leaf ipv6-unicast-metric {
      description
        "Specifies the interface metric associated with the IPv6-unicast multi-topology.
         The default is based on reference-bandwidth, or else if this is not configured the default is 10.";
      type srl_nokia-isis-types:isis-wide-metric;
    }
    leaf metric {
      description
        "Specifies the interface metric associated with the native routing topology.
         The default is based on reference-bandwidth, or else if this is not configured the default is 10.";
      type srl_nokia-isis-types:isis-wide-metric;
    }
    leaf priority {
      description
        "ISIS neighbor priority for becoming Designated IS (LAN hello PDU only).";
      type uint8 {
        range "0..127";
      }
      default "64";
    }
    leaf passive {
      if-feature "srl-feat:isis-level-passive";
      description
        "When set to true the interface is configured as a passive interface for this level and does not send IIH PDUs or try to form an adjacency with other routers.";
      type boolean;
    }
    uses isis-interface-authentication;
  }

  grouping isis-interface-config {
    container interface-ref {
      if-feature "srl-feat:interface-references";
      description
        "Reference to a subinterface";
      leaf interface {
        type leafref {
          path "/srl_nokia-if:interface/srl_nokia-if:name";
        }
        description
          "Reference to a base interface, for example a port or LAG";
        must '../subinterface >= 0' {
          error-message "subinterface must be configured when interface is set";
        }
      }
      leaf subinterface {
        type leafref {
          path "/srl_nokia-if:interface[srl_nokia-if:name=current()/../interface]/srl_nokia-if:subinterface/srl_nokia-if:index";
        }
        description
          "Reference to a subinterface
           This requires the base interface to be specified using the interface leaf in this container.";
        must '../interface' {
          error-message "interface must be configured when subinterface is set";
        }
      }
    }
    leaf admin-state {
      description
        "Used to administratively enable or disable the IS-IS protocol on a
         routed subinterface";
      type srl_nokia-comm:admin-state;
      default "enable";
    }
    leaf circuit-type {
      description
        "Specifies the circuit type as either point-to-point or broadcast";
      type srl_nokia-isis-types:isis-circuit-type;
    }
    container delay {
      if-feature "srl-feat:isis-dyn-delay";
      description
        "Enter the delay context";
      leaf delay-selection {
        description
          "Delay source advertised by IGP for the interface";
        type enumeration {
          enum static {
            value 1;
          }
          enum dynamic {
            value 2;
          }
          enum static-preferred {
            value 3;
          }
          enum dynamic-preferred {
            value 4;
          }
        }
        default "static-preferred";
      }
      leaf unidirectional-minimum-link-delay {
        config false;
        type uint32;
        units "microseconds";
        description
          "Operational Unidirectional link delay advertised by ISIS";
      }
    }
    leaf hello-padding {
      description
        "Specifies the use of IS-IS Hello PDU padding on the interface";
      type srl_nokia-isis-types:isis-hello-padding-type;
    }
    leaf passive {
      description
        "When set to true the interface is configured as a passive interface and does not send IIH PDUs or try to form an adjacency with other routers.";
      type boolean;
      default "false";
    }
    container ipv4-unicast {
      leaf admin-state {
        description
          "When set to true, the interface and level supports IPv4 unicast routing";
        type srl_nokia-comm:admin-state;
        default "enable";
      }
      leaf enable-bfd {
        if-feature "srl-feat:bfd";
        description
          "Enable BFD for IPv4";
        type boolean;
        default "false";
      }
      leaf include-bfd-tlv {
        if-feature "srl-feat:bfd";
        description
          "Specifies whether a BFD-enabled TLV is included for IPv4 on this IS-IS interface.";
        type boolean;
        default "false";
        must 'not(../enable-bfd = false() and . = true())' {
          error-message "include-bfd-tlv can be set only if enable-bfd is set to true.";
        }
      }
    }
    container ipv6-unicast {
      leaf admin-state {
        description
          "When set to true, the interface and level supports IPv6 unicast routing";
        type srl_nokia-comm:admin-state;
        default "enable";
      }
      leaf enable-bfd {
        if-feature "srl-feat:bfd";
        description
          "Enable BFD for IPv6";
        type boolean;
        default "false";
      }
      leaf include-bfd-tlv {
        if-feature "srl-feat:bfd";
        description
          "Specifies whether a BFD-enabled TLV is included for IPv6 on this IS-IS interface.";
        type boolean;
        default "false";
        must 'not(../enable-bfd = false() and . = true())' {
          error-message "include-bfd-tlv can be set only if enable-bfd is set to true.";
        }
      }
    }
    list level {
      description
        "List of IS-IS levels supported by this interface";
      max-elements 2;
      key "level-number";
      uses isis-level-key;
      uses isis-interface-level-config;
    }
    uses isis-interface-authentication;
  }

  grouping isis-inst-common-config {
    leaf admin-state {
      description
        "Used to administratively enable or disable the IS-IS instance";
      type srl_nokia-comm:admin-state;
      default "disable";
    }
    leaf instance-id {
      if-feature "srl-feat:isis-mi";
      description
        "ISIS instance number";
      type uint32 {
        range "0..127";
      }
      default "0";
    }
    leaf-list net {
      max-elements 1;
      description
        "ISIS network entity title (NET)";
      reference
        "International Organization for Standardization,
         Information technology - Open Systems Interconnection-Network service Definition - ISO/ IEC 8348:2002.";
      type srl_nokia-isis-types:isis-net-id;
    }
    leaf level-capability {
      description
        "The level-capability of the intermediate system (router)";
      type srl_nokia-isis-types:isis-level;
      default "L2";
    }
    leaf max-ecmp-paths {
      description
        "The maximum number of ECMP next-hops to program into the FIB for every IP prefix";
      type srl_nokia-isis-types:isis-ecmp;
      default "1";
      must '. <= 8' {
        error-message "Max ECMP paths cannot be greater than 8 on 7215 A1 platform.";
        srl_nokia-ext:if-feature "srl_nokia-features:platform-7215-a1";
      }
    }
    leaf poi-tlv {
      description
        "When set to true, a TLV is added to purge to record the system ID of the IS generating the purge.";
      reference
        "RFC6232: Purge Originator Identification TLV for IS-IS.  TLV 13.";
      type boolean;
      default "false";
    }
    leaf iid-tlv {
      if-feature "srl-feat:isis-mi";
      description
        "ISIS Instance Identifier TLV. When set to true, IID-TLV identifies
         the unique instance as well as the topology/topologies to which the
         PDU applies.";
      reference
        "RFC6822: IS-IS Multi-Instance. TLV 7";
      type boolean;
      default "false";
    }
    leaf advertise-router-capability {
      if-feature "srl-feat:isis-rtr-capability";
      description
        "Allow router advertisement capabilities";
      type boolean;
      default "true";
    }
    leaf prefix-attributes-tlv {
      if-feature "srl-feat:isis-rtr-capability";
      description
        "Use IS-IS Prefix Attributes TLV to exchange extended IPv4 and IPv6 reachability information";
      type boolean;
      default "true";
    }
    leaf export-policy {
      description
        "Apply an export policy to redistribute non-ISIS routes into ISIS";
      type leafref {
        path "/srl-rpol:routing-policy/srl-rpol:policy/srl-rpol:name";
      }
    }
    leaf hello-padding {
      description
        "Specifies the use of IS-IS Hello PDU padding all interfaces

         This can be overridden by interface configuration.";
      type srl_nokia-isis-types:isis-hello-padding-type;
      default "disable";
    }
    leaf enable-csnp-on-p2p-links {
      description
        "Enable/disable the transmission of periodic CSNP PDUs on point-to-point interfaces

         When this is set to false, CSNP PDUs will only be sent on a P2P interface when the adjacency is initialized. This setting has no effect on broadcast interfaces.";
      type boolean;
      default "true";
    }
    container attached-bit {
      description
        "This container provides option for handling the ATTached bit in L1 LSPs";
      leaf ignore {
        description
          "When set to true, if the attached bit is set on an incoming Level 1 LSP, the local system ignores it.
           In this case the local system does not set a default route to the L1L2 router advertising the PDU with the attached bit set.";
        type boolean;
        default "false";
      }
      leaf suppress {
        description
          "When set to true, if the local IS acts as a L1L2 router, then the attached bit is not advertised in locally generated L1 LSPs.";
        type boolean;
        default "false";
      }
    }
    container transport {
      leaf lsp-mtu-size {
        description
          "Sets the maximum size of LSPs generated by this router";
        type uint16 {
          range "490..9490";
        }
        units "bytes";
        default "1492";
      }
    }
    container ipv4-unicast {
      description
        "Enables/disables IPv4 routing in this ISIS instance.";
      leaf admin-state {
        description
          "When set to true, the IS-IS instance supports IPv4 unicast routing";
        type srl_nokia-comm:admin-state;
        default "enable";
      }
    }
    container ipv6-unicast {
      description
        "Enables/disables IPv6 routing in this ISIS instance.";
      leaf admin-state {
        description
          "When set to true, the IS-IS instance supports IPv6 unicast routing";
        type srl_nokia-comm:admin-state;
        default "enable";
      }
    }
  }

  grouping isis-level-config {
    leaf metric-style {
      description
        "Specifies the metric style to be wide or narrow for the level";
      type srl_nokia-isis-types:isis-metric-style;
      default "wide";
    }
    leaf loopfree-alternate-exclude {
      if-feature "srl-feat:isis-lfa";
      description
        "Enable/disable LFA at ISIS level.";
      type boolean;
      default "false";
      must "(. = false()) or (../../../../../srl_nokia-netinst:type = 'srl_nokia-netinst:default')" {
        error-message "LFA Configuration is supported only in the default network instance";
      }
    }
    container route-preference {
      description
        "Specify the route preference (admin distance) for IP routes asssociated with the level";
      leaf external {
        description
          "Specify the route preference of external routes carried in this level.
           By default the route preference of external L1 routes is 160.
           By default the route preference of external L2 routes is 165.";
        type uint8 {
          range "1..255";
        }
      }
      leaf internal {
        description
          "Specify the route preference of internal routes carried in this level.
           By default the route preference of internal L1 routes is 15.
           By default the route preference of internal L2 routes is 18.";
        type uint8 {
          range "1..255";
        }
      }
    }
    uses isis-instance-level-authentication;
  }

  grouping isis-inst-config {
    uses isis-inst-common-config;
    uses isis-instance-level-authentication;
  }

  grouping isis-top {
    container isis {
      presence "Configure ISIS";
      must "not(../../srl_nokia-netinst:type = 'srl_nokia-netinst:mac-vrf')" {
        error-message "ISIS routing configuration is not possible on network-instance of type mac-vrf";
      }
      must "../../srl_nokia-netinst:type != 'srl_nokia-netinst:host'" {
        error-message "ISIS routing configuration is not possible on network-instance of type host";
      }
      description
        "Top-level configuration and operational state for Intermediate System to Intermediate System (ISIS)";
      list instance {
        description
          "List of IS-IS protocol instances associated with this
           network-instance.
           Only a single instance is supported for now";
        key "name";
        uses isis-inst-key;
        uses isis-inst-config;
        list interface {
          description
            "List of IS-IS interfaces";
          key "interface-name";
          unique "segment-routing/mpls/ipv4-node-sid/index";
          unique "segment-routing/mpls/ipv6-node-sid/index";
          uses isis-interface-key;
          uses isis-interface-config;
        }
        list level {
          description
            "List of IS-IS levels supported by this IS (router)";
          max-elements 2;
          key "level-number";
          uses isis-level-key;
          uses isis-level-config;
          must "(((level-number = 1) and (../level-capability != 'L2')) or
                 ((level-number = 2) and (../level-capability != 'L1')))" {
            error-message "Level configuration must match the instance level-capability";
          }
        }
        container hostnames {
          config false;
          list system-id {
            description
              "List of system IDs that have discovered hostnames.";
            key "host-system-id";
            leaf host-system-id {
              description
                "The system ID";
              type srl_nokia-comm:isis-system-id;
            }
            leaf hostname {
              description
                "The hostname of the system.";
              type string;
            }
          }
        }
      }
    }
  }

  augment "/srl_nokia-netinst:network-instance/srl_nokia-netinst:protocols" {
    uses isis-top;
  }
}
""")
    res.append(r"""module srl_nokia-network-instance {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:net-inst:network-instance";
  prefix srl_nokia-netinst;

  import srl_nokia-common {
    prefix srl_nokia-comm;
  }
  import srl_nokia-interfaces {
    prefix srl_nokia-if;
  }
  import srl_nokia-extensions {
    prefix srl_nokia-ext;
  }
  import srl_nokia-features {
    prefix srl-feat;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "This yang file gives a description of a network-instance. This may be a Layer 3 forwarding construct such as a virtual routing and forwarding (VRF) instance, or a Layer 2 instance such as a virtual switch instance (VSI). Mixed Layer 2 and Layer 3 instances are also supported.";

  revision 2025-03-31 {
    description
      "SRLinux 2025.3.1";
  }
  revision 2024-10-31 {
    description
      "SRLinux 24.10.1";
  }
  revision 2024-07-31 {
    description
      "SRLinux 24.7.1";
  }
  revision 2024-03-31 {
    description
      "SRLinux 24.3.1";
  }
  revision 2023-10-31 {
    description
      "SRLinux 23.10.1";
  }
  revision 2023-07-31 {
    description
      "SRLinux 23.7.1";
  }
  revision 2023-03-31 {
    description
      "SRLinux 23.3.1";
  }
  revision 2022-11-30 {
    description
      "SRLinux 22.11.1";
  }
  revision 2022-06-30 {
    description
      "SRLinux 22.6.1";
  }
  revision 2022-03-31 {
    description
      "SRLinux 22.3.1";
  }
  revision 2021-11-30 {
    description
      "SRLinux 21.11.1";
  }
  revision 2021-06-30 {
    description
      "SRLinux 21.6.1";
  }
  revision 2021-03-31 {
    description
      "SRLinux 21.3.1";
  }
  revision 2020-06-30 {
    description
      "SRLinux 20.6.1";
  }
  revision 2019-11-30 {
    description
      "SRLinux 19.11.1";
  }

  typedef network-instance-subintf-name {
    type string {
      length "1..255";
    }
    description
      "User defined name or reference type to a specific subinterface of the form <interface-name>.<subinterface-index>";
  }

  typedef network-instance-vxlan-if-ref {
    type string {
      length "8..17";
      pattern '(vxlan(0|1[0-9][0-9]|2([0-4][0-9]|5[0-5])|[1-9][0-9]|[1-9])\.(0|[1-9](\d){0,8}))';
    }
    description
      "Reference type to a specific vxlan-interface of the form <tunnel-interface-name>.<vxlan-interface-index>";
  }

  identity ni-type {
    description
      "Base type for network instance types.";
  }

  identity host {
    base ni-type;
    if-feature "srl-feat:host-network-instance";
    description
      "A special routing instances that refers to the hosts network instance (i.e. the network namespace of PID 1)";
  }

  identity default {
    base ni-type;
    description
      "A special routing instance which acts as the 'default' routing instance for a network device.";
  }

  identity ip-vrf {
    base ni-type;
    description
      "A private Layer 3 only routing instance.";
  }

  identity mac-vrf {
    if-feature "srl-feat:bridged";
    base ni-type;
    description
      "A private Layer 2 only switching instance.";
  }

  identity vpws {
    if-feature "srl-feat:vpws";
    base ni-type;
    description
      "A private Layer 2 point-to-point instance.";
  }

  grouping network-instance-top {
    description
      "Top-level grouping containing a list of network instances.";
    list network-instance {
      key "name";
      description
        "Network instances configured on the local system";
      leaf name {
        type srl_nokia-comm:restricted-name;
        description
          "A unique name identifying the network instance";
      }
      leaf type {
        type identityref {
          base ni-type;
        }
        default "default";
        description
          "The type of network instance. The value of this leaf
           indicates the type of forwarding entries that should be
           supported by this network instance";
      }
      leaf admin-state {
        type srl_nokia-comm:admin-state;
        default "enable";
        description
          "This leaf contains the configured, desired state of the
           network instance.";
      }
      leaf description {
        type srl_nokia-comm:description;
        description
          "A user-entered description of this network instance.";
      }
      leaf router-id {
        type srl_nokia-comm:dotted-quad;
        must "(../type = 'srl_nokia-netinst:ip-vrf' or ../type = 'srl_nokia-netinst:default')" {
          error-message "Router-id configuration is not possible on network-instance of types other than ip-vrf or default";
        }
        description
          "A identifier for the local network instance - typically
           used within associated routing protocols or signalling
           routing information in another network instance";
      }

      list interface {
        key "name";
        description
          "List of subinterfaces used by this network-instance";
        must "../type != 'srl_nokia-netinst:host'" {
          error-message "Interfaces cannot be added to a network instance of type host";
        }
        leaf name {
          type srl_nokia-netinst:network-instance-subintf-name;
          description
            "Name of the subinterface bound to this network-instance";
          must "../interface-ref/interface or not(starts-with(.,'lo') and ../../type = 'srl_nokia-netinst:mac-vrf')" {
            error-message "Loopback interfaces cannot be configured on network-instance of type mac-vrf";
          }
          must "../interface-ref/interface or not(starts-with(.,'system') and ../../type != 'srl_nokia-netinst:default')" {
            error-message "System interfaces can only be configured on network-instance of type default";
          }
          must "../interface-ref/interface or /srl_nokia-if:interface[srl_nokia-if:name=substring-before(current(), '.')]/srl_nokia-if:subinterface[srl_nokia-if:index=substring-after(current(), '.')]/srl_nokia-if:type != 'local-mirror-dest'" {
            error-message "subinterface with type local-mirror-dest cannot be configured on network-instance";
          }
          must "../interface-ref/interface or not(starts-with(.,'irb') and ../../bridge-table/proxy-arp)" {
            error-message "IRB interfaces cannot be configured with proxy-arp";
          }
          must "../interface-ref/interface or not(starts-with(.,'irb') and ../../bridge-table/proxy-nd)" {
            error-message "IRB interfaces cannot be configured with proxy-nd";
          }
        }
        container interface-ref {
          if-feature "srl-feat:interface-references";
          description
            "Reference to a subinterface";
          leaf interface {
            type leafref {
              path "/srl_nokia-if:interface/srl_nokia-if:name";
            }
            description
              "Reference to a base interface, for example a port or LAG";
            must '../subinterface >= 0' {
              error-message "subinterface must be configured when interface is set";
            }
            must "not(starts-with(.,'lo') and ../../../type = 'srl_nokia-netinst:mac-vrf')" {
              error-message "Loopback interfaces cannot be configured on network-instance of type mac-vrf";
            }
            must "not(starts-with(.,'system') and ../../../type != 'srl_nokia-netinst:default')" {
              error-message "System interfaces can only be configured on network-instance of type default";
            }
            must "/srl_nokia-if:interface[srl_nokia-if:name=current()]/srl_nokia-if:subinterface[srl_nokia-if:index=current()/../subinterface]/srl_nokia-if:type != 'local-mirror-dest'" {
              error-message "subinterface with type local-mirror-dest cannot be configured on network-instance";
            }
            must "not(starts-with(.,'irb') and ../../../bridge-table/proxy-arp)" {
              error-message "IRB interfaces cannot be configured with proxy-arp";
            }
            must "not(starts-with(.,'irb') and ../../../bridge-table/proxy-nd)" {
              error-message "IRB interfaces cannot be configured with proxy-nd";
            }
          }
          leaf subinterface {
            type leafref {
              path "/srl_nokia-if:interface[srl_nokia-if:name=current()/../interface]/srl_nokia-if:subinterface/srl_nokia-if:index";
            }
            description
              "Reference to a subinterface
               This requires the base interface to be specified using the interface leaf in this container.";
            must '../interface' {
              error-message "interface must be configured when subinterface is set";
            }
          }
        }
      }
      list vxlan-interface {
        if-feature "srl-feat:vxlan";
        key "name";
        max-elements 1;
        must '(/srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/srl_nokia-netinst:name]/srl_nokia-netinst:type != "srl_nokia-netinst:default")' {
          error-message "The bgp-evpn configuration is not possible on network-instance of type default.";
        }
        description
          "List of vxlan-interfaces used by this network-instance";
        leaf name {
          type srl_nokia-netinst:network-instance-vxlan-if-ref;
          must "(starts-with(.,'vxlan'))" {
            error-message "vxlan-interface name must start with the string vxlan";
          }
          must "../../type != 'srl_nokia-netinst:host'" {
            error-message "vxlan-interface cannot be added to a network instance of type host";
          }
          description
            "Identifier of vxlan-interface used in this network-instance";
        }
      }
      container protocols {
        description
          "The routing protocols that are enabled for this
           network-instance.";
        container bgp-evpn {
          if-feature "srl-feat:evpn";
          description
            "Top-level configuration and operational state for BGP Ethernet Virtual Private Networks (EVPN)";
          presence "Configure BGP-EVPN";
          must '(/srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../srl_nokia-netinst:name]/srl_nokia-netinst:type != "srl_nokia-netinst:default")' {
            error-message "The bgp-evpn configuration is not possible on network-instance of type default.";
          }
        }
        container bgp-ipvpn {
          if-feature "srl-feat:ipvpn";
          description
            "Top-level configuration and operational state for BGP IP Virtual Private Networks (IPVPN)";
          presence "Configure BGP-IPVPN";
          must '(/srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../srl_nokia-netinst:name]/srl_nokia-netinst:type = "srl_nokia-netinst:ip-vrf")' {
            error-message "The bgp-ipvpn configuration is only possible on network-instance of type ip-vrf";
          }
        }
        container directly-connected {
          if-feature "srl-feat:traffic-engineering-bgpls-directly-connected";
          description
            "Container for handling directly connected routes as a pseudo-protocol";
        }
      }

    }
  }

  uses network-instance-top;
}
""")
    res.append(r"""module srl_nokia-policy-types {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:general:policy-types";
  prefix srl_nokia-pol-types;

  import srl_nokia-common {
    prefix srl_nokia-comm;
  }
  import srl_nokia-features {
    prefix srl_nokia-feat;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "This module contains general data definitions for use in routing
     policy.  It can be imported by modules that contain protocol-
     specific policy match and actions.";

  revision 2025-03-31 {
    description
      "SRLinux 2025.3.1";
  }
  revision 2024-10-31 {
    description
      "SRLinux 24.10.1";
  }
  revision 2024-07-31 {
    description
      "SRLinux 24.7.1";
  }
  revision 2024-03-31 {
    description
      "SRLinux 24.3.1";
  }
  revision 2023-10-31 {
    description
      "SRLinux 23.10.1";
  }
  revision 2022-11-30 {
    description
      "SRLinux 22.11.1";
  }
  revision 2021-03-31 {
    description
      "SRLinux 21.3.1";
  }
  revision 2019-11-30 {
    description
      "SRLinux 19.11.1";
  }

  typedef tag-type {
    type union {
      type uint32 {
        range "1..4294967295";
      }
      type srl_nokia-comm:hex-string {
        length "1..11";
      }
    }
    description
      "Type for expressing route tags on a local system, including IS-IS and OSPF

       May be expressed as either decimal or hexidecimal integer";
  }

  typedef statement-policy-result {
    type enumeration {
      enum accept {
        description
          "The route is accepted, route property modifications are applied, and evaluation stops immediately";
      }
      enum reject {
        description
          "The route is rejected and evaluation stops immediately";
      }
      enum next-statement {
        if-feature "srl_nokia-feat:routing-policy-next-statement";
        description
          "Route policy modifications are applied and evaluation continues to the next statement";
      }
      enum next-policy {
        if-feature "srl_nokia-feat:routing-policy-next-policy";
        description
          "Route policy modifications are applied and evaluation continues to the next policy";
      }
    }
    description
      "Basic action type for statements";
  }

  typedef default-policy-result {
    type enumeration {
      enum accept {
        description
          "The route is accepted, route property modifications are applied, and evaluation stops immediately";
      }
      enum reject {
        description
          "The route is rejected and evaluation stops immediately";
      }
      enum next-policy {
        if-feature "srl_nokia-feat:routing-policy-next-policy";
        description
          "Route policy modifications are applied and evaluation continues to the next policy";
      }
    }
    description
      "Basic action type for default action";
  }

  typedef comparison-operator-type {
    type enumeration {
      enum eq;
      enum ge;
      enum le;
    }
    description
      "Operators used for comparison";
  }

  typedef bgp-family-type {
    type identityref {
      base srl_nokia-comm:bgp-address-family;
    }
    description
      "BGP address family types";
  }

  typedef as-path-regexp {
    type string {
      pattern '(null)|([0-9$ ()*+,.^{}\[\]\-\|?<>_\\]+)';
    }
    description
      "An AS Path regular expression used by policies";
  }

  typedef as-number {
    type uint32 {
      range "1..4294967295";
    }
    description
      "An autonomous system number";
  }

  typedef bgp-set-community-operation-type {
    type enumeration {
      enum add {
        description
          "Add the specified communities to the existing community attribute";
      }
      enum remove {
        description
          "Remove the specified communities from the existing community attribute";
      }
      enum replace {
        description
          "Replace the existing community attribute with the specified communities

           If an empty set is specified, this removes the community attribute from the route.";
      }
    }
    description
      "Type definition for operations when setting the community attribute in a policy action";
  }

  typedef bgp-next-hop-type {
    type union {
      type srl_nokia-comm:ip-address;
      type enumeration {
        enum self {
          if-feature "srl_nokia-feat:routing-policy-bgp-next-hop-self-action";
          description
            "Special designation for local router's own address, i.e., next-hop-self";
        }
      }
    }
    description
      "Type definition for specifying the BGP next-hop address in policy actions";
  }

  grouping match-set-options {
    leaf match-set-options {
      type enumeration {
        enum any {
          description
            "Match is true if any of the members in the referenced set is present in the route";
        }
        enum all {
          description
            "Match is true if all of the members in the referenced set are present in the route";
        }
        enum invert {
          description
            "Match is true if none of the members in the referenced set are present in the route";
        }
      }
      default "any";
      description
        "Options that determine the matching criteria that applies to the members in the referenced set";
    }
  }

  identity bgp-well-known-community {
    description
      "Reserved communities within the standard community space
       defined by RFC1997. These communities must fall within the
       range 0x00000000 to 0xFFFFFFFF";
    reference
      "RFC1997";
  }

  identity no-export {
    base bgp-well-known-community;
    description
      "Do not export NLRI received carrying this community outside
       the bounds of this autonomous system, or this confederation if
       the local autonomous system is a confederation member AS. This
       community has a value of 0xFFFFFF01.";
    reference
      "RFC1997";
  }

  identity no-advertise {
    base bgp-well-known-community;
    description
      "All NLRI received carrying this community must not be
       advertised to other BGP peers. This community has a value of
       0xFFFFFF02.";
    reference
      "RFC1997";
  }

  identity no-export-subconfed {
    base bgp-well-known-community;
    description
      "All NLRI received carrying this community must not be
       advertised to external BGP peers - including over confederation
       sub-AS boundaries. This community has a value of 0xFFFFFF03.";
    reference
      "RFC1997";
  }

  typedef bgp-std-community-type {
    type string {
      pattern '(6553[0-5]|655[0-2][0-9]|654[0-9]{2}|65[0-4][0-9]{2}'
            + '|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9]):'
            + '(6553[0-5]|655[0-2][0-9]|654[0-9]{2}|65[0-4][0-9]{2}'
            + '|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9])';
    }
    description
      "Type definition for standard commmunity values represented as a string of the form N:M where N and M are integers between 0 and 65535";
    reference
      "RFC 1997 - BGP Communities Attribute";
  }

  typedef bgp-std-community-regexp-type {
    type string {
      pattern '[0-9$()*+,.^{}\[\]\-\|?\\]+:[0-9$()*+,.^{}\[\]\-\|?\\]+';
    }
    description
      "Type definition for legacy regular expressions that match standard BGP communities";
  }

  typedef bgp-std-community-regexp-type2 {
    type string {
      pattern '[0-9$()*+,.\^{}\[\]\-|?:_]+';
    }
    description
      "Type definition for regular expressions that match standard BGP communities";
  }

  typedef bgp-std-community-well-known-type {
    type identityref {
      base bgp-well-known-community;
    }
    description
      "Type definition for well-known BGP standard community values";
    reference
      "IANA Border Gateway Protocol (BGP) Well Known Communities";
  }

  typedef bgp-large-community-type {
    type string {
      pattern '(429496729[0-5]|42949672[0-8][0-9]|4294967[0-1][0-9]{2}'
            + '|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|'
            + '429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[0-1][0-9]{8}|[1-3][0-9]{9}|'
            + '[1-9][0-9]{1,8}|[0-9]):'
            + '(429496729[0-5]|42949672[0-8][0-9]|4294967[0-1][0-9]{2}'
            + '|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|'
            + '429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[0-1][0-9]{8}|[1-3][0-9]{9}|'
            + '[1-9][0-9]{1,8}|[0-9]):'
            + '(429496729[0-5]|42949672[0-8][0-9]|4294967[0-1][0-9]{2}'
            + '|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|'
            + '429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[0-1][0-9]{8}|[1-3][0-9]{9}|'
            + '[1-9][0-9]{1,8}|[0-9])';
    }
    description
      "Type definition for large commmunity values represented as a string of the form A:B:C where A, B and C are integers between 0 and 4294967295";
    reference
      "RFC 8092 - BGP Large Communities Attribute";
  }

  typedef bgp-large-community-regexp-type {
    type string {
      pattern '[0-9$()*+,.^{}\[\]\-\|?\\]+:[0-9$()*+,.^{}\[\]\-\|?\\]+:[0-9$()*+,.^{}\[\]\-\|?\\]+';
    }
    description
      "Type definition for regular expressions that match large BGP communities";
  }

  typedef bgp-ext-community-type {
    type union {
      type string {
        pattern 'target:'
              + '(6553[0-5]|655[0-2][0-9]|654[0-9]{2}|65[0-4][0-9]{2}'
              + '|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9]):'
              + '(429496729[0-5]|42949672[0-8][0-9]|4294967[0-1][0-9]{2}'
              + '|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|'
              + '429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[0-1][0-9]{8}|[1-3][0-9]{9}|'
              + '[1-9][0-9]{1,8}|[0-9])';
      }
      type string {
        pattern 'target:'
              + '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|'
              + '25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|'
              + '2[0-4][0-9]|25[0-5]):'
              + '(6553[0-5]|655[0-2][0-9]|654[0-9]{2}|65[0-4][0-9]{2}'
              + '|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9])';
      }
      type string {
        pattern 'target:'
              + '(429496729[0-5]|42949672[0-8][0-9]|4294967[0-1][0-9]{2}'
              + '|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|'
              + '429[0-3][0-9]{6}|42[0-8][0-9]{7}|'
              + '4[0-1][0-9]{8}|[1-3][0-9]{9}|'
              + '[1-9][0-9]{1,8}|[0-9]):'
              + '(6553[0-5]|655[0-2][0-9]|654[0-9]{2}|65[0-4][0-9]{2}'
              + '|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9])';
      }
      type string {
        pattern 'origin:'
              + '(6553[0-5]|655[0-2][0-9]|654[0-9]{2}|65[0-4][0-9]{2}'
              + '|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9]):'
              + '(429496729[0-5]|42949672[0-8][0-9]|4294967[0-1][0-9]{2}'
              + '|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|'
              + '429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[0-1][0-9]{8}|[1-3][0-9]{9}|'
              + '[1-9][0-9]{1,8}|[0-9])';
      }
      type string {
        pattern 'origin:'
              + '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|'
              + '25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|'
              + '2[0-4][0-9]|25[0-5]):'
              + '(6553[0-5]|655[0-2][0-9]|654[0-9]{2}|65[0-4][0-9]{2}'
              + '|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9])';
      }
      type string {
        pattern 'origin:'
              + '(429496729[0-5]|42949672[0-8][0-9]|4294967[0-1][0-9]{2}'
              + '|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|'
              + '429[0-3][0-9]{6}|42[0-8][0-9]{7}|'
              + '4[0-1][0-9]{8}|[1-3][0-9]{9}|'
              + '[1-9][0-9]{1,8}|[0-9]):'
              + '(6553[0-5]|655[0-2][0-9]|654[0-9]{2}|65[0-4][0-9]{2}'
              + '|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9])';
      }
      type string {
        pattern 'color:'
              + '[0-1]{2}:'
              + '(429496729[0-5]|42949672[0-8][0-9]|4294967[0-1][0-9]{2}'
              + '|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|'
              + '429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[0-1][0-9]{8}|[1-3][0-9]{9}|'
              + '[1-9][0-9]{1,8}|[0-9])';
      }
      type string {
        pattern 'bgp-tunnel-encap:(VXLAN|MPLS)';
      }
    }
    description
      "Type definition for extended community attributes";
  }

  typedef bgp-ext-community-regexp-type {
    type union {
      type string {
        pattern 'target:[0-9$()*+,.^{}\[\]\-\|?\\]+:[0-9$()*+,.^{}\[\]\-\|?\\]+';
      }
      type string {
        pattern 'origin:[0-9$()*+,.^{}\[\]\-\|?\\]+:[0-9$()*+,.^{}\[\]\-\|?\\]+';
      }
    }
    description
      "Type definition for extended community regular expressions

       The format embeds two regular expressions separated by one colon ':' character; the first expression is applied to the as-value of the community string and the second to the local administrative value

       Each regex is a sequence of terms and operators. A term can be:
        - a single digit, such as '4'
        - a range term composed of two elementary terms separated by the '-' character like '2-3'
        - the dot '.' wild-card character which matches any elementary term or ':'
        - a regular expression enclosed in parenthesis '( )'
        - a choice of digits and/or ranges enclosed in square brackets; for example, [51-37] matches digit 5 or any single digit between 1 and 3 or the digit 7

       Supported operators:
       | - match term on the left of the operator or the term on the right of the operator
       * - matches zero or more occurrences of the preceding term
       ? - matches zero or one occurrence of the preceding term
       + - matches one or more occurrences of the preceding term
       {m,n} - matches least m and at most n repetitions of the term
       {m} - matches exactly m repetitions of the term
       {m,} - matches m or more repetitions of the term
       ^ - matches the beginning of the string
       $ - matches the end of the string
       backslash - an escape character to indicate that the following character is a match criteria and not a grouping delimite
       
      ";
  }

  typedef bgp-ext-community-regexp-type2 {
    type union {
      type string {
        pattern '[\^]?link\-bandwidth[0-9$()*+,.^{}\[\]\-|?:_]*[kMGT]?[$]?';
      }
      type string {
        pattern '[\^]?target[0-9$()*+,.^{}\[\]\-|?:_\\]*[$]?';
      }
      type string {
        pattern '[\^]?origin[0-9$()*+,.^{}\[\]\-|?:_\\]*[$]?';
      }
      type string {
        pattern '[\^]?color[0-9$()*+,.^{}\[\]\-|?:_]*[$]?';
      }
      type string {
        pattern 'bgp-tunnel-encap:(VXLAN|MPLS)';
      }
    }
    description
      "Type definition for extended community regular expressions";
  }

  typedef bgp-admin-tag {
    description
      "This type defines the range administrative route tags that can be assigned to BGP routes";
    type uint32 {
      range "0..4294967295";
    }
  }
}
""")
    res.append(r"""module srl_nokia-system-name {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:chassis:system-name";
  prefix srl_nokia-system-name;

  import srl_nokia-system {
    prefix srl-system;
  }
  import srl_nokia-common {
    prefix srl-comm;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "This module defines configuration related to the name of the system";

  revision 2019-11-30 {
    description
      "SRLinux 19.11.1";
  }

  grouping name-config-top {
    container name {
      description
        "Contains configuration and state related to system naming";
      leaf domain-name {
        type srl-comm:domain-name;
        description
          "The system domain name";
      }
      leaf host-name {
        type string {
          length "1..63";
          pattern '(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])';
        }
        description
          "The system host name";
      }
    }
  }

  grouping name-top {
    uses name-config-top;
  }

  augment "/srl-system:system" {
    uses name-top;
  }
}
""")
    res.append(r"""module srl_nokia-system-protocols {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:general:system-protocols";
  prefix srl_nokia-system-protocols;

  import srl_nokia-system {
    prefix srl_nokia-system;
  }
  import srl_nokia-features {
    prefix srl_nokia-feat;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "This yang file models system-wide protocol configuration and state.";

  revision 2025-03-31 {
    description
      "SRLinux 2025.3.1";
  }
  revision 2023-07-31 {
    description
      "SRLinux 23.7.1";
  }

  grouping system-protocols-top {
    description
      "Top-level grouping for system-wide protocol configuration and state.";
    container protocols {
      description
        "The routing protocols that are supported by the system";
    }
  }

  augment "/srl_nokia-system:system" {
    uses system-protocols-top {
      if-feature "not srl_nokia-feat:platform-imgmt";
    }
  }
}
""")
    res.append(r"""module srl_nokia-system {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:general:system";
  prefix srl_nokia-system;

  import srl_nokia-extensions {
    prefix srl-ext;
  }
  import srl_nokia-common {
    prefix srl-comm;
  }
  import srl_nokia-features {
    prefix srl_nokia-feat;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "This module defines configuration and operational state data
     related to system management

     Portions of this model reuse data definitions or structure from
     RFC 7317 - A YANG Data Model for System Management";

  revision 2025-03-31 {
    description
      "SRLinux 2025.3.1";
  }
  revision 2024-03-31 {
    description
      "SRLinux 24.3.1";
  }
  revision 2022-03-31 {
    description
      "SRLinux 22.3.1";
  }
  revision 2020-06-30 {
    description
      "SRLinux 20.6.1";
  }
  revision 2019-11-30 {
    description
      "SRLinux 19.11.1";
  }

  grouping management-top {
    container management {
      description
        "Enclosing container for options relating to management server";
    }
  }

  grouping control-plane-traffic {
    container control-plane-traffic {
      description
        "Container for the control plane traffic.";
      container output {
        description
          "Defines parameters determining the handling of system generated traffic.";
      }
      container input {
        description
          "Defines parameters determining the handling of system generated traffic.";
      }
    }
  }

  container system {
    description
      "Enclosing container for system management";
    leaf-list features {
      srl-ext:first-released "20.6.1";
      config false;
      description
        "Features enabled on this platform";
      type srl-comm:name;
    }
    leaf-list trace-options {
      srl-ext:first-released "19.11.1";
      description
        "Management server trace options";
      type enumeration {
        enum request;
        enum response;
        enum common;
      }
    }
    uses management-top {
      if-feature "not srl_nokia-feat:platform-imgmt";
    }
    uses control-plane-traffic {
      if-feature "not srl_nokia-feat:platform-imgmt";
    }
  }
}
""")
    res.append(r"""module srl_nokia-tunnel-interfaces {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:vxlan:tunnel-interfaces";
  prefix srl_nokia-tunnel-if;

  import srl_nokia-common {
    prefix srl_nokia-comm;
  }
  import srl_nokia-features {
    prefix srl-feat;
  }
  import srl_nokia-extensions {
    prefix srl_nokia-ext;
  }
  import srl_nokia-interfaces {
    prefix srl_nokia-if;
  }
  import srl_nokia-network-instance {
    prefix srl_nokia-netinst;
  }
  import srl_nokia-tunnel {
    prefix srl_nokia-tunnel;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "Model for tunnel-interfaces in SRLinux.";

  revision 2023-10-31 {
    description
      "SRLinux 23.10.1";
  }
  revision 2022-11-30 {
    description
      "SRLinux 22.11.1";
  }
  revision 2021-06-30 {
    description
      "SRLinux 21.6.1";
  }
  revision 2021-03-31 {
    description
      "SRLinux 21.3.1";
  }

  typedef tunnel-interface-all {
    type string {
      length "6..8";
      pattern '(vxlan(0|1[0-9][0-9]|2([0-4][0-9]|5[0-5])|[1-9][0-9]|[1-9]))';
    }
    description
      "The type of the tunnel-interface.";
  }

  typedef vlan-id {
    type uint16 {
      range "1..4094";
    }
    description
      "Type definition representing a single-tagged VLAN ID";
  }

  grouping tunnel-interface-top {
    description
      "Top-level configuration and state for tunnel interfaces.";
    list tunnel-interface {
      if-feature "srl-feat:vxlan";
      key "name";
      srl_nokia-ext:first-released "21.3.1";
      description
        "In the case that the interface is logical tunnel
         interface, the parameters for the tunnel are
         specified within this subtree. Tunnel interfaces
         have only a single logical subinterface associated
         with them.";
      leaf name {
        type tunnel-interface-all;
        description
          "The name of the tunnel-interface.

           Valid options are:
           vxlan<N>, N=0..255";
      }
      uses vxlan-interface-top;
    }
  }

  grouping vxlan-interface-top {
    description
      "Vxlan-interface grouping.";
    list vxlan-interface {
      max-elements 16384;
      key "index";
      srl_nokia-ext:first-released "21.3.1";
      description
        "The list of vxlan-interfaces.";
      leaf index {
        type uint32 {
          range "0..99999999";
        }
        description
          "The index of the vxlan-tunnel.";
      }
      leaf type {
        mandatory true;
        type identityref {
          base srl_nokia-if:si-type;
        }
        description
          "The value of this leaf indicates the context in which the
           vxlan-interface will be used in.";
        must ".='srl_nokia-if:bridged' or .='srl_nokia-if:routed'" {
          error-message "unsupported type.";
        }
      }
      container ingress {
        leaf vni {
          type uint32 {
            range "1..16777215";
          }
          mandatory true;
          description
            "Ingress VXLAN Network Identifier of the VXLAN subinterface.

             The egress VNI is determined by the static egress-vni configured in the associated destination
             or by the dynamic egress-vni learned from the control plane.";
        }
      }
    }
  }

  uses tunnel-interface-top;
}
""")
    res.append(r"""module srl_nokia-tunnel {
  yang-version 1.1;
  namespace "urn:nokia.com:srlinux:vxlan:tunnel";
  prefix srl_nokia-tunnel;

  import srl_nokia-common {
    prefix srl_nokia-comm;
  }
  import srl_nokia-features {
    prefix srl-feat;
  }
  import srl_nokia-extensions {
    prefix srl_nokia-ext;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";
  description
    "Model for tunnels in SRLinux.";

  revision 2024-07-31 {
    description
      "SRLinux 24.7.1";
  }
  revision 2024-03-31 {
    description
      "SRLinux 24.3.1";
  }
  revision 2021-03-31 {
    description
      "SRLinux 21.3.1";
  }

  grouping tunnel-top {
    description
      "Top-level configuration and state for the tunnel table.";
    container tunnel {
      if-feature "srl-feat:vxlan or srl-feat:pseudowire";
      srl_nokia-ext:first-released "20.10.1";
      description
        "This model collects all config and state aspects of the tunnel table
         in SRLinux.";
    }
  }

  uses tunnel-top;
}
""")
    return res


class srl_nokia_tunnel__tunnel(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'urn:nokia.com:srlinux:vxlan:tunnel'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, ns='urn:nokia.com:srlinux:vxlan:tunnel', module='srl_nokia-tunnel')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_tunnel__tunnel:
        if n is not None:
            return srl_nokia_tunnel__tunnel()
        return srl_nokia_tunnel__tunnel()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_tunnel__tunnel.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /tunnel')
            res.append('{self_name} = srl_nokia_tunnel__tunnel()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /tunnel'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-tunnel:tunnel'])


mut def from_xml_srl_nokia_tunnel__tunnel(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, ns='urn:nokia.com:srlinux:vxlan:tunnel', module='srl_nokia-tunnel')

mut def from_data_srl_nokia_system__system__trace_options(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('enumeration', val)

class srl_nokia_system__system__management(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'urn:nokia.com:srlinux:general:system'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_system__system__management:
        if n is not None:
            return srl_nokia_system__system__management()
        return srl_nokia_system__system__management()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_system__system__management.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /system/management')
            res.append('{self_name} = srl_nokia_system__system__management()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /system/management'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-system:system', 'management'])


mut def from_xml_srl_nokia_system__system__management(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

class srl_nokia_system__system__control_plane_traffic__output(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'urn:nokia.com:srlinux:general:system'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_system__system__control_plane_traffic__output:
        if n is not None:
            return srl_nokia_system__system__control_plane_traffic__output()
        return srl_nokia_system__system__control_plane_traffic__output()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_system__system__control_plane_traffic__output.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /system/control-plane-traffic/output')
            res.append('{self_name} = srl_nokia_system__system__control_plane_traffic__output()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /system/control-plane-traffic/output'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-system:system', 'control-plane-traffic', 'output'])


mut def from_xml_srl_nokia_system__system__control_plane_traffic__output(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

class srl_nokia_system__system__control_plane_traffic__input(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'urn:nokia.com:srlinux:general:system'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_system__system__control_plane_traffic__input:
        if n is not None:
            return srl_nokia_system__system__control_plane_traffic__input()
        return srl_nokia_system__system__control_plane_traffic__input()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_system__system__control_plane_traffic__input.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /system/control-plane-traffic/input')
            res.append('{self_name} = srl_nokia_system__system__control_plane_traffic__input()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /system/control-plane-traffic/input'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-system:system', 'control-plane-traffic', 'input'])


mut def from_xml_srl_nokia_system__system__control_plane_traffic__input(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

class srl_nokia_system__system__control_plane_traffic(yang.adata.MNode):
    output: srl_nokia_system__system__control_plane_traffic__output
    input: srl_nokia_system__system__control_plane_traffic__input

    mut def __init__(self, output: ?srl_nokia_system__system__control_plane_traffic__output=None, input: ?srl_nokia_system__system__control_plane_traffic__input=None):
        self._ns = 'urn:nokia.com:srlinux:general:system'
        self.output = output if output is not None else srl_nokia_system__system__control_plane_traffic__output()
        self.input = input if input is not None else srl_nokia_system__system__control_plane_traffic__input()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _output = self.output
        if _output is not None:
            children['output'] = _output.to_gdata()
        _input = self.input
        if _input is not None:
            children['input'] = _input.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_system__system__control_plane_traffic:
        if n is not None:
            return srl_nokia_system__system__control_plane_traffic(output=srl_nokia_system__system__control_plane_traffic__output.from_gdata(n.get_opt_cnt('output')), input=srl_nokia_system__system__control_plane_traffic__input.from_gdata(n.get_opt_cnt('input')))
        return srl_nokia_system__system__control_plane_traffic()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_system__system__control_plane_traffic.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /system/control-plane-traffic')
            res.append('{self_name} = srl_nokia_system__system__control_plane_traffic()')
        leaves = []
        _output = self.output
        if _output is not None:
            res.extend(_output.prsrc('{self_name}.output', False).splitlines())
        _input = self.input
        if _input is not None:
            res.extend(_input.prsrc('{self_name}.input', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /system/control-plane-traffic'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-system:system', 'control-plane-traffic'])


mut def from_xml_srl_nokia_system__system__control_plane_traffic(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_output = yang.gdata.from_xml_opt_cnt(node, 'output')
    yang.gdata.maybe_add(children, 'output', from_xml_srl_nokia_system__system__control_plane_traffic__output, child_output)
    child_input = yang.gdata.from_xml_opt_cnt(node, 'input')
    yang.gdata.maybe_add(children, 'input', from_xml_srl_nokia_system__system__control_plane_traffic__input, child_input)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_system__system__protocols__bgp__restart_max_wait(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class srl_nokia_system__system__protocols__bgp(yang.adata.MNode):
    restart_max_wait: ?int

    mut def __init__(self, restart_max_wait: ?int):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.restart_max_wait = restart_max_wait

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _restart_max_wait = self.restart_max_wait
        if _restart_max_wait is not None:
            children['restart-max-wait'] = yang.gdata.Leaf('uint16', _restart_max_wait)
        return yang.gdata.Container(children, presence=True, ns='urn:nokia.com:srlinux:bgp:bgp', module='srl_nokia-bgp')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?srl_nokia_system__system__protocols__bgp:
        if n is not None:
            return srl_nokia_system__system__protocols__bgp(restart_max_wait=n.get_opt_int('restart-max-wait'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = srl_nokia_system__system__protocols__bgp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in srl_nokia_system__system__protocols__bgp.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /system/protocols/bgp')
            res.append('{self_name} = srl_nokia_system__system__protocols__bgp()')
        leaves = []
        _restart_max_wait = self.restart_max_wait
        if _restart_max_wait is not None:
            leaves.append('{self_name}.restart_max_wait = {repr(_restart_max_wait)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /system/protocols/bgp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-system:system', 'srl_nokia-system-protocols:protocols', 'srl_nokia-bgp:bgp'])


mut def from_xml_srl_nokia_system__system__protocols__bgp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_restart_max_wait = yang.gdata.from_xml_opt_int(node, 'restart-max-wait')
    yang.gdata.maybe_add(children, 'restart-max-wait', from_data_srl_nokia_system__system__protocols__bgp__restart_max_wait, child_restart_max_wait)
    return yang.gdata.Container(children, presence=True, ns='urn:nokia.com:srlinux:bgp:bgp', module='srl_nokia-bgp')

class srl_nokia_system__system__protocols(yang.adata.MNode):
    bgp: ?srl_nokia_system__system__protocols__bgp

    mut def __init__(self, bgp: ?srl_nokia_system__system__protocols__bgp=None):
        self._ns = 'urn:nokia.com:srlinux:general:system-protocols'
        self.bgp = bgp

    mut def create_bgp(self):
        existing = self.bgp
        if existing is not None:
            return existing
        res = srl_nokia_system__system__protocols__bgp()
        self.bgp = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _bgp = self.bgp
        if _bgp is not None:
            children['bgp'] = _bgp.to_gdata()
        return yang.gdata.Container(children, ns='urn:nokia.com:srlinux:general:system-protocols', module='srl_nokia-system-protocols')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_system__system__protocols:
        if n is not None:
            return srl_nokia_system__system__protocols(bgp=srl_nokia_system__system__protocols__bgp.from_gdata(n.get_opt_cnt('bgp')))
        return srl_nokia_system__system__protocols()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_system__system__protocols.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /system/protocols')
            res.append('{self_name} = srl_nokia_system__system__protocols()')
        leaves = []
        _bgp = self.bgp
        if _bgp is not None:
            res.append('')
            res.append('# P-container: /system/protocols/bgp')
            res.append('bgp = {self_name}.create_bgp()')
            res.extend(_bgp.prsrc('bgp', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /system/protocols'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-system:system', 'srl_nokia-system-protocols:protocols'])


mut def from_xml_srl_nokia_system__system__protocols(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_bgp = yang.gdata.from_xml_opt_cnt(node, 'bgp', 'urn:nokia.com:srlinux:bgp:bgp')
    yang.gdata.maybe_add(children, 'bgp', from_xml_srl_nokia_system__system__protocols__bgp, child_bgp)
    return yang.gdata.Container(children, ns='urn:nokia.com:srlinux:general:system-protocols', module='srl_nokia-system-protocols')

mut def from_data_srl_nokia_system__system__name__domain_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_system__system__name__host_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class srl_nokia_system__system__name(yang.adata.MNode):
    domain_name: ?str
    host_name: ?str

    mut def __init__(self, domain_name: ?str, host_name: ?str):
        self._ns = 'urn:nokia.com:srlinux:chassis:system-name'
        self.domain_name = domain_name
        self.host_name = host_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _domain_name = self.domain_name
        if _domain_name is not None:
            children['domain-name'] = yang.gdata.Leaf('string', _domain_name)
        _host_name = self.host_name
        if _host_name is not None:
            children['host-name'] = yang.gdata.Leaf('string', _host_name)
        return yang.gdata.Container(children, ns='urn:nokia.com:srlinux:chassis:system-name', module='srl_nokia-system-name')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_system__system__name:
        if n is not None:
            return srl_nokia_system__system__name(domain_name=n.get_opt_str('domain-name'), host_name=n.get_opt_str('host-name'))
        return srl_nokia_system__system__name()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_system__system__name.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /system/name')
            res.append('{self_name} = srl_nokia_system__system__name()')
        leaves = []
        _domain_name = self.domain_name
        if _domain_name is not None:
            leaves.append('{self_name}.domain_name = {repr(_domain_name)}')
        _host_name = self.host_name
        if _host_name is not None:
            leaves.append('{self_name}.host_name = {repr(_host_name)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /system/name'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-system:system', 'srl_nokia-system-name:name'])


mut def from_xml_srl_nokia_system__system__name(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_domain_name = yang.gdata.from_xml_opt_str(node, 'domain-name')
    yang.gdata.maybe_add(children, 'domain-name', from_data_srl_nokia_system__system__name__domain_name, child_domain_name)
    child_host_name = yang.gdata.from_xml_opt_str(node, 'host-name')
    yang.gdata.maybe_add(children, 'host-name', from_data_srl_nokia_system__system__name__host_name, child_host_name)
    return yang.gdata.Container(children, ns='urn:nokia.com:srlinux:chassis:system-name', module='srl_nokia-system-name')

class srl_nokia_system__system(yang.adata.MNode):
    trace_options: list[str]
    management: srl_nokia_system__system__management
    control_plane_traffic: srl_nokia_system__system__control_plane_traffic
    protocols: srl_nokia_system__system__protocols
    name: srl_nokia_system__system__name

    mut def __init__(self, trace_options: ?list[str]=None, management: ?srl_nokia_system__system__management=None, control_plane_traffic: ?srl_nokia_system__system__control_plane_traffic=None, protocols: ?srl_nokia_system__system__protocols=None, name: ?srl_nokia_system__system__name=None):
        self._ns = 'urn:nokia.com:srlinux:general:system'
        self.trace_options = trace_options if trace_options is not None else []
        self.management = management if management is not None else srl_nokia_system__system__management()
        self.control_plane_traffic = control_plane_traffic if control_plane_traffic is not None else srl_nokia_system__system__control_plane_traffic()
        self.protocols = protocols if protocols is not None else srl_nokia_system__system__protocols()
        self.name = name if name is not None else srl_nokia_system__system__name()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _trace_options = self.trace_options
        if _trace_options is not None:
            children['trace-options'] = yang.gdata.LeafList('enumeration', _trace_options)
        _management = self.management
        if _management is not None:
            children['management'] = _management.to_gdata()
        _control_plane_traffic = self.control_plane_traffic
        if _control_plane_traffic is not None:
            children['control-plane-traffic'] = _control_plane_traffic.to_gdata()
        _protocols = self.protocols
        if _protocols is not None:
            children['protocols'] = _protocols.to_gdata()
        _name = self.name
        if _name is not None:
            children['name'] = _name.to_gdata()
        return yang.gdata.Container(children, ns='urn:nokia.com:srlinux:general:system', module='srl_nokia-system')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_system__system:
        if n is not None:
            return srl_nokia_system__system(trace_options=n.get_opt_strs('trace-options'), management=srl_nokia_system__system__management.from_gdata(n.get_opt_cnt('management')), control_plane_traffic=srl_nokia_system__system__control_plane_traffic.from_gdata(n.get_opt_cnt('control-plane-traffic')), protocols=srl_nokia_system__system__protocols.from_gdata(n.get_opt_cnt('protocols')), name=srl_nokia_system__system__name.from_gdata(n.get_opt_cnt('name')))
        return srl_nokia_system__system()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_system__system.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /system')
            res.append('{self_name} = srl_nokia_system__system()')
        leaves = []
        _trace_options = self.trace_options
        if len(_trace_options) != 0:
            leaves.append('{self_name}.trace_options = {repr(_trace_options)}')
        _management = self.management
        if _management is not None:
            res.extend(_management.prsrc('{self_name}.management', False).splitlines())
        _control_plane_traffic = self.control_plane_traffic
        if _control_plane_traffic is not None:
            res.extend(_control_plane_traffic.prsrc('{self_name}.control_plane_traffic', False).splitlines())
        _protocols = self.protocols
        if _protocols is not None:
            res.extend(_protocols.prsrc('{self_name}.protocols', False).splitlines())
        _name = self.name
        if _name is not None:
            res.extend(_name.prsrc('{self_name}.name', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /system'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-system:system'])


mut def from_xml_srl_nokia_system__system(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_trace_options = yang.gdata.from_xml_opt_strs(node, 'trace-options')
    yang.gdata.maybe_add(children, 'trace-options', from_data_srl_nokia_system__system__trace_options, child_trace_options)
    child_management = yang.gdata.from_xml_opt_cnt(node, 'management')
    yang.gdata.maybe_add(children, 'management', from_xml_srl_nokia_system__system__management, child_management)
    child_control_plane_traffic = yang.gdata.from_xml_opt_cnt(node, 'control-plane-traffic')
    yang.gdata.maybe_add(children, 'control-plane-traffic', from_xml_srl_nokia_system__system__control_plane_traffic, child_control_plane_traffic)
    child_protocols = yang.gdata.from_xml_opt_cnt(node, 'protocols', 'urn:nokia.com:srlinux:general:system-protocols')
    yang.gdata.maybe_add(children, 'protocols', from_xml_srl_nokia_system__system__protocols, child_protocols)
    child_name = yang.gdata.from_xml_opt_cnt(node, 'name', 'urn:nokia.com:srlinux:chassis:system-name')
    yang.gdata.maybe_add(children, 'name', from_xml_srl_nokia_system__system__name, child_name)
    return yang.gdata.Container(children, ns='urn:nokia.com:srlinux:general:system', module='srl_nokia-system')

mut def from_data_srl_nokia_interfaces__interface__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_interfaces__interface__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_interfaces__interface__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_interfaces__interface__mtu(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__index(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__type(val: value) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['srl_nokia-if:si-type'], 'srl_nokia-interfaces')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_data_srl_nokia_interfaces__interface__subinterface__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__ip_mtu(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__l2_mtu(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__mpls_mtu(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__ipv4__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__ipv4__address__ip_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__ipv4__address__anycast_gw(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__ipv4__address__primary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

class srl_nokia_interfaces__interface__subinterface__ipv4__address_entry(yang.adata.MNode):
    ip_prefix: str
    anycast_gw: ?bool
    primary: ?bool

    mut def __init__(self, ip_prefix: str, anycast_gw: ?bool, primary: ?bool):
        self._ns = 'urn:nokia.com:srlinux:chassis:interfaces'
        self.ip_prefix = ip_prefix
        self.anycast_gw = anycast_gw
        self.primary = primary

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ip_prefix = self.ip_prefix
        if _ip_prefix is not None:
            children['ip-prefix'] = yang.gdata.Leaf('string', _ip_prefix)
        _anycast_gw = self.anycast_gw
        if _anycast_gw is not None:
            children['anycast-gw'] = yang.gdata.Leaf('boolean', _anycast_gw)
        _primary = self.primary
        if _primary is not None:
            children['primary'] = yang.gdata.Leaf('empty', _primary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_interfaces__interface__subinterface__ipv4__address_entry:
        return srl_nokia_interfaces__interface__subinterface__ipv4__address_entry(ip_prefix=n.get_str('ip-prefix'), anycast_gw=n.get_opt_bool('anycast-gw'), primary=n.get_opt_empty('primary'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_interfaces__interface__subinterface__ipv4__address_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interface/subinterface/ipv4/address')
            res.append('{self_name} = srl_nokia_interfaces__interface__subinterface__ipv4__address({repr(self.ip_prefix)})')
        leaves = []
        _anycast_gw = self.anycast_gw
        if _anycast_gw is not None:
            leaves.append('{self_name}.anycast_gw = {repr(_anycast_gw)}')
        _primary = self.primary
        if _primary is not None:
            leaves.append('{self_name}.primary = {repr(_primary)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /interface/subinterface/ipv4/address'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-interfaces:interface', 'subinterface', 'ipv4', 'address'])

class srl_nokia_interfaces__interface__subinterface__ipv4__address(yang.adata.MNode):
    elements: list[srl_nokia_interfaces__interface__subinterface__ipv4__address_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:chassis:interfaces'
        self._name = 'address'
        self.elements = elements

    mut def create(self, ip_prefix):
        for e in self:
            match = True
            if e.ip_prefix != ip_prefix:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_interfaces__interface__subinterface__ipv4__address_entry(ip_prefix)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['ip-prefix'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_interfaces__interface__subinterface__ipv4__address_entry]:
        if n is not None:
            return [srl_nokia_interfaces__interface__subinterface__ipv4__address_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_interfaces__interface__subinterface__ipv4__address(elements=copied_elements)

extension srl_nokia_interfaces__interface__subinterface__ipv4__address(Iterable[srl_nokia_interfaces__interface__subinterface__ipv4__address_entry]):
    def __iter__(self) -> Iterator[srl_nokia_interfaces__interface__subinterface__ipv4__address_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_interfaces__interface__subinterface__ipv4__address_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_ip_prefix = yang.gdata.from_xml_str(node, 'ip-prefix')
    yang.gdata.maybe_add(children, 'ip-prefix', from_data_srl_nokia_interfaces__interface__subinterface__ipv4__address__ip_prefix, child_ip_prefix)
    child_anycast_gw = yang.gdata.from_xml_opt_bool(node, 'anycast-gw')
    yang.gdata.maybe_add(children, 'anycast-gw', from_data_srl_nokia_interfaces__interface__subinterface__ipv4__address__anycast_gw, child_anycast_gw)
    child_primary = yang.gdata.from_xml_opt_empty(node, 'primary')
    yang.gdata.maybe_add(children, 'primary', from_data_srl_nokia_interfaces__interface__subinterface__ipv4__address__primary, child_primary)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_interfaces__interface__subinterface__ipv4__address(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_interfaces__interface__subinterface__ipv4__address_element(e) for e in nodes]
    return yang.gdata.List(keys=['ip-prefix'], elements=elements)

mut def from_data_srl_nokia_interfaces__interface__subinterface__ipv4__allow_directed_broadcast(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered__interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered(yang.adata.MNode):
    admin_state: ?str
    interface: ?str

    mut def __init__(self, admin_state: ?str, interface: ?str):
        self._ns = 'urn:nokia.com:srlinux:chassis:interfaces'
        self.admin_state = admin_state
        self.interface = interface

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _interface = self.interface
        if _interface is not None:
            children['interface'] = yang.gdata.Leaf('string', _interface)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered:
        if n is not None:
            return srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered(admin_state=n.get_opt_str('admin-state'), interface=n.get_opt_str('interface'))
        return srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interface/subinterface/ipv4/unnumbered')
            res.append('{self_name} = srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered()')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _interface = self.interface
        if _interface is not None:
            leaves.append('{self_name}.interface = {repr(_interface)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /interface/subinterface/ipv4/unnumbered'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-interfaces:interface', 'subinterface', 'ipv4', 'unnumbered'])


mut def from_xml_srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered__admin_state, child_admin_state)
    child_interface = yang.gdata.from_xml_opt_str(node, 'interface')
    yang.gdata.maybe_add(children, 'interface', from_data_srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered__interface, child_interface)
    return yang.gdata.Container(children)

class srl_nokia_interfaces__interface__subinterface__ipv4(yang.adata.MNode):
    admin_state: ?str
    address: srl_nokia_interfaces__interface__subinterface__ipv4__address
    allow_directed_broadcast: ?bool
    unnumbered: srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered

    mut def __init__(self, admin_state: ?str, address: list[srl_nokia_interfaces__interface__subinterface__ipv4__address_entry]=[], allow_directed_broadcast: ?bool, unnumbered: ?srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered=None):
        self._ns = 'urn:nokia.com:srlinux:chassis:interfaces'
        self.admin_state = admin_state
        self.address = srl_nokia_interfaces__interface__subinterface__ipv4__address(elements=address)
        self.allow_directed_broadcast = allow_directed_broadcast
        self.unnumbered = unnumbered if unnumbered is not None else srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _address = self.address
        if _address is not None:
            children['address'] = _address.to_gdata()
        _allow_directed_broadcast = self.allow_directed_broadcast
        if _allow_directed_broadcast is not None:
            children['allow-directed-broadcast'] = yang.gdata.Leaf('boolean', _allow_directed_broadcast)
        _unnumbered = self.unnumbered
        if _unnumbered is not None:
            children['unnumbered'] = _unnumbered.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_interfaces__interface__subinterface__ipv4:
        if n is not None:
            return srl_nokia_interfaces__interface__subinterface__ipv4(admin_state=n.get_opt_str('admin-state'), address=srl_nokia_interfaces__interface__subinterface__ipv4__address.from_gdata(n.get_opt_list('address')), allow_directed_broadcast=n.get_opt_bool('allow-directed-broadcast'), unnumbered=srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered.from_gdata(n.get_opt_cnt('unnumbered')))
        return srl_nokia_interfaces__interface__subinterface__ipv4()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_interfaces__interface__subinterface__ipv4.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interface/subinterface/ipv4')
            res.append('{self_name} = srl_nokia_interfaces__interface__subinterface__ipv4()')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _address = self.address
        for _element in _address:
            res.append('')
            res.append("# List /interface/subinterface/ipv4/address element: {_element.to_gdata().key_str(['ip-prefix'])}")
            list_elem = 'address_element = {self_name}.address.create({repr(_element.ip_prefix)})'
            res.append(list_elem)
            res.extend(_element.prsrc('address_element', False, list_element=True).splitlines())
        _allow_directed_broadcast = self.allow_directed_broadcast
        if _allow_directed_broadcast is not None:
            leaves.append('{self_name}.allow_directed_broadcast = {repr(_allow_directed_broadcast)}')
        _unnumbered = self.unnumbered
        if _unnumbered is not None:
            res.extend(_unnumbered.prsrc('{self_name}.unnumbered', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /interface/subinterface/ipv4'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-interfaces:interface', 'subinterface', 'ipv4'])


mut def from_xml_srl_nokia_interfaces__interface__subinterface__ipv4(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_interfaces__interface__subinterface__ipv4__admin_state, child_admin_state)
    child_address = yang.gdata.from_xml_opt_list(node, 'address')
    yang.gdata.maybe_add(children, 'address', from_xml_srl_nokia_interfaces__interface__subinterface__ipv4__address, child_address)
    child_allow_directed_broadcast = yang.gdata.from_xml_opt_bool(node, 'allow-directed-broadcast')
    yang.gdata.maybe_add(children, 'allow-directed-broadcast', from_data_srl_nokia_interfaces__interface__subinterface__ipv4__allow_directed_broadcast, child_allow_directed_broadcast)
    child_unnumbered = yang.gdata.from_xml_opt_cnt(node, 'unnumbered')
    yang.gdata.maybe_add(children, 'unnumbered', from_xml_srl_nokia_interfaces__interface__subinterface__ipv4__unnumbered, child_unnumbered)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_interfaces__interface__subinterface__ipv6__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__ipv6__address__ip_prefix(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__ipv6__address__type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__ipv6__address__anycast_gw(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_interfaces__interface__subinterface__ipv6__address__primary(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('empty', val)

class srl_nokia_interfaces__interface__subinterface__ipv6__address_entry(yang.adata.MNode):
    ip_prefix: str
    type: ?str
    anycast_gw: ?bool
    primary: ?bool

    mut def __init__(self, ip_prefix: str, type: ?str, anycast_gw: ?bool, primary: ?bool):
        self._ns = 'urn:nokia.com:srlinux:chassis:interfaces'
        self.ip_prefix = ip_prefix
        self.type = type
        self.anycast_gw = anycast_gw
        self.primary = primary

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ip_prefix = self.ip_prefix
        if _ip_prefix is not None:
            children['ip-prefix'] = yang.gdata.Leaf('string', _ip_prefix)
        _type = self.type
        if _type is not None:
            children['type'] = yang.gdata.Leaf('enumeration', _type)
        _anycast_gw = self.anycast_gw
        if _anycast_gw is not None:
            children['anycast-gw'] = yang.gdata.Leaf('boolean', _anycast_gw)
        _primary = self.primary
        if _primary is not None:
            children['primary'] = yang.gdata.Leaf('empty', _primary)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_interfaces__interface__subinterface__ipv6__address_entry:
        return srl_nokia_interfaces__interface__subinterface__ipv6__address_entry(ip_prefix=n.get_str('ip-prefix'), type=n.get_opt_str('type'), anycast_gw=n.get_opt_bool('anycast-gw'), primary=n.get_opt_empty('primary'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_interfaces__interface__subinterface__ipv6__address_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interface/subinterface/ipv6/address')
            res.append('{self_name} = srl_nokia_interfaces__interface__subinterface__ipv6__address({repr(self.ip_prefix)})')
        leaves = []
        _type = self.type
        if _type is not None:
            leaves.append('{self_name}.type = {repr(_type)}')
        _anycast_gw = self.anycast_gw
        if _anycast_gw is not None:
            leaves.append('{self_name}.anycast_gw = {repr(_anycast_gw)}')
        _primary = self.primary
        if _primary is not None:
            leaves.append('{self_name}.primary = {repr(_primary)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /interface/subinterface/ipv6/address'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-interfaces:interface', 'subinterface', 'ipv6', 'address'])

class srl_nokia_interfaces__interface__subinterface__ipv6__address(yang.adata.MNode):
    elements: list[srl_nokia_interfaces__interface__subinterface__ipv6__address_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:chassis:interfaces'
        self._name = 'address'
        self.elements = elements

    mut def create(self, ip_prefix):
        for e in self:
            match = True
            if e.ip_prefix != ip_prefix:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_interfaces__interface__subinterface__ipv6__address_entry(ip_prefix)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['ip-prefix'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_interfaces__interface__subinterface__ipv6__address_entry]:
        if n is not None:
            return [srl_nokia_interfaces__interface__subinterface__ipv6__address_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_interfaces__interface__subinterface__ipv6__address(elements=copied_elements)

extension srl_nokia_interfaces__interface__subinterface__ipv6__address(Iterable[srl_nokia_interfaces__interface__subinterface__ipv6__address_entry]):
    def __iter__(self) -> Iterator[srl_nokia_interfaces__interface__subinterface__ipv6__address_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_interfaces__interface__subinterface__ipv6__address_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_ip_prefix = yang.gdata.from_xml_str(node, 'ip-prefix')
    yang.gdata.maybe_add(children, 'ip-prefix', from_data_srl_nokia_interfaces__interface__subinterface__ipv6__address__ip_prefix, child_ip_prefix)
    child_type = yang.gdata.from_xml_opt_str(node, 'type')
    yang.gdata.maybe_add(children, 'type', from_data_srl_nokia_interfaces__interface__subinterface__ipv6__address__type, child_type)
    child_anycast_gw = yang.gdata.from_xml_opt_bool(node, 'anycast-gw')
    yang.gdata.maybe_add(children, 'anycast-gw', from_data_srl_nokia_interfaces__interface__subinterface__ipv6__address__anycast_gw, child_anycast_gw)
    child_primary = yang.gdata.from_xml_opt_empty(node, 'primary')
    yang.gdata.maybe_add(children, 'primary', from_data_srl_nokia_interfaces__interface__subinterface__ipv6__address__primary, child_primary)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_interfaces__interface__subinterface__ipv6__address(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_interfaces__interface__subinterface__ipv6__address_element(e) for e in nodes]
    return yang.gdata.List(keys=['ip-prefix'], elements=elements)

class srl_nokia_interfaces__interface__subinterface__ipv6(yang.adata.MNode):
    admin_state: ?str
    address: srl_nokia_interfaces__interface__subinterface__ipv6__address

    mut def __init__(self, admin_state: ?str, address: list[srl_nokia_interfaces__interface__subinterface__ipv6__address_entry]=[]):
        self._ns = 'urn:nokia.com:srlinux:chassis:interfaces'
        self.admin_state = admin_state
        self.address = srl_nokia_interfaces__interface__subinterface__ipv6__address(elements=address)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _address = self.address
        if _address is not None:
            children['address'] = _address.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_interfaces__interface__subinterface__ipv6:
        if n is not None:
            return srl_nokia_interfaces__interface__subinterface__ipv6(admin_state=n.get_opt_str('admin-state'), address=srl_nokia_interfaces__interface__subinterface__ipv6__address.from_gdata(n.get_opt_list('address')))
        return srl_nokia_interfaces__interface__subinterface__ipv6()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_interfaces__interface__subinterface__ipv6.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interface/subinterface/ipv6')
            res.append('{self_name} = srl_nokia_interfaces__interface__subinterface__ipv6()')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _address = self.address
        for _element in _address:
            res.append('')
            res.append("# List /interface/subinterface/ipv6/address element: {_element.to_gdata().key_str(['ip-prefix'])}")
            list_elem = 'address_element = {self_name}.address.create({repr(_element.ip_prefix)})'
            res.append(list_elem)
            res.extend(_element.prsrc('address_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /interface/subinterface/ipv6'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-interfaces:interface', 'subinterface', 'ipv6'])


mut def from_xml_srl_nokia_interfaces__interface__subinterface__ipv6(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_interfaces__interface__subinterface__ipv6__admin_state, child_admin_state)
    child_address = yang.gdata.from_xml_opt_list(node, 'address')
    yang.gdata.maybe_add(children, 'address', from_xml_srl_nokia_interfaces__interface__subinterface__ipv6__address, child_address)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_interfaces__interface__subinterface__vlan__encap__single_tagged__vlan_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class srl_nokia_interfaces__interface__subinterface__vlan__encap__single_tagged(yang.adata.MNode):
    vlan_id: ?value

    mut def __init__(self, vlan_id: ?value):
        self._ns = 'urn:nokia.com:srlinux:chassis:interfaces-vlans'
        self.vlan_id = vlan_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vlan_id = self.vlan_id
        if _vlan_id is not None:
            children['vlan-id'] = yang.gdata.Leaf('union', _vlan_id)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?srl_nokia_interfaces__interface__subinterface__vlan__encap__single_tagged:
        if n is not None:
            return srl_nokia_interfaces__interface__subinterface__vlan__encap__single_tagged(vlan_id=n.get_opt_value('vlan-id'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = srl_nokia_interfaces__interface__subinterface__vlan__encap__single_tagged.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in srl_nokia_interfaces__interface__subinterface__vlan__encap__single_tagged.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interface/subinterface/vlan/encap/single-tagged')
            res.append('{self_name} = srl_nokia_interfaces__interface__subinterface__vlan__encap__single_tagged()')
        leaves = []
        _vlan_id = self.vlan_id
        if _vlan_id is not None:
            leaves.append('{self_name}.vlan_id = {repr(_vlan_id)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /interface/subinterface/vlan/encap/single-tagged'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-interfaces:interface', 'subinterface', 'srl_nokia-interfaces-vlans:vlan', 'encap', 'single-tagged'])


mut def from_xml_srl_nokia_interfaces__interface__subinterface__vlan__encap__single_tagged(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_vlan_id = yang.gdata.from_xml_opt_value(node, 'vlan-id')
    yang.gdata.maybe_add(children, 'vlan-id', from_data_srl_nokia_interfaces__interface__subinterface__vlan__encap__single_tagged__vlan_id, child_vlan_id)
    return yang.gdata.Container(children, presence=True)

class srl_nokia_interfaces__interface__subinterface__vlan__encap(yang.adata.MNode):
    single_tagged: ?srl_nokia_interfaces__interface__subinterface__vlan__encap__single_tagged

    mut def __init__(self, single_tagged: ?srl_nokia_interfaces__interface__subinterface__vlan__encap__single_tagged=None):
        self._ns = 'urn:nokia.com:srlinux:chassis:interfaces-vlans'
        self.single_tagged = single_tagged

    mut def create_single_tagged(self):
        existing = self.single_tagged
        if existing is not None:
            return existing
        res = srl_nokia_interfaces__interface__subinterface__vlan__encap__single_tagged()
        self.single_tagged = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _single_tagged = self.single_tagged
        if _single_tagged is not None:
            children['single-tagged'] = _single_tagged.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_interfaces__interface__subinterface__vlan__encap:
        if n is not None:
            return srl_nokia_interfaces__interface__subinterface__vlan__encap(single_tagged=srl_nokia_interfaces__interface__subinterface__vlan__encap__single_tagged.from_gdata(n.get_opt_cnt('single-tagged')))
        return srl_nokia_interfaces__interface__subinterface__vlan__encap()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_interfaces__interface__subinterface__vlan__encap.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interface/subinterface/vlan/encap')
            res.append('{self_name} = srl_nokia_interfaces__interface__subinterface__vlan__encap()')
        leaves = []
        _single_tagged = self.single_tagged
        if _single_tagged is not None:
            res.append('')
            res.append('# P-container: /interface/subinterface/vlan/encap/single-tagged')
            res.append('single_tagged = {self_name}.create_single_tagged()')
            res.extend(_single_tagged.prsrc('single_tagged', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /interface/subinterface/vlan/encap'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-interfaces:interface', 'subinterface', 'srl_nokia-interfaces-vlans:vlan', 'encap'])


mut def from_xml_srl_nokia_interfaces__interface__subinterface__vlan__encap(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_single_tagged = yang.gdata.from_xml_opt_cnt(node, 'single-tagged')
    yang.gdata.maybe_add(children, 'single-tagged', from_xml_srl_nokia_interfaces__interface__subinterface__vlan__encap__single_tagged, child_single_tagged)
    return yang.gdata.Container(children)

class srl_nokia_interfaces__interface__subinterface__vlan(yang.adata.MNode):
    encap: srl_nokia_interfaces__interface__subinterface__vlan__encap

    mut def __init__(self, encap: ?srl_nokia_interfaces__interface__subinterface__vlan__encap=None):
        self._ns = 'urn:nokia.com:srlinux:chassis:interfaces-vlans'
        self.encap = encap if encap is not None else srl_nokia_interfaces__interface__subinterface__vlan__encap()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _encap = self.encap
        if _encap is not None:
            children['encap'] = _encap.to_gdata()
        return yang.gdata.Container(children, ns='urn:nokia.com:srlinux:chassis:interfaces-vlans', module='srl_nokia-interfaces-vlans')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_interfaces__interface__subinterface__vlan:
        if n is not None:
            return srl_nokia_interfaces__interface__subinterface__vlan(encap=srl_nokia_interfaces__interface__subinterface__vlan__encap.from_gdata(n.get_opt_cnt('encap')))
        return srl_nokia_interfaces__interface__subinterface__vlan()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_interfaces__interface__subinterface__vlan.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interface/subinterface/vlan')
            res.append('{self_name} = srl_nokia_interfaces__interface__subinterface__vlan()')
        leaves = []
        _encap = self.encap
        if _encap is not None:
            res.extend(_encap.prsrc('{self_name}.encap', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /interface/subinterface/vlan'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-interfaces:interface', 'subinterface', 'srl_nokia-interfaces-vlans:vlan'])


mut def from_xml_srl_nokia_interfaces__interface__subinterface__vlan(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_encap = yang.gdata.from_xml_opt_cnt(node, 'encap')
    yang.gdata.maybe_add(children, 'encap', from_xml_srl_nokia_interfaces__interface__subinterface__vlan__encap, child_encap)
    return yang.gdata.Container(children, ns='urn:nokia.com:srlinux:chassis:interfaces-vlans', module='srl_nokia-interfaces-vlans')

class srl_nokia_interfaces__interface__subinterface_entry(yang.adata.MNode):
    index: int
    type: ?Identityref
    description: ?str
    admin_state: ?str
    ip_mtu: ?int
    l2_mtu: ?int
    mpls_mtu: ?int
    ipv4: srl_nokia_interfaces__interface__subinterface__ipv4
    ipv6: srl_nokia_interfaces__interface__subinterface__ipv6
    vlan: srl_nokia_interfaces__interface__subinterface__vlan

    mut def __init__(self, index: int, type: ?Identityref, description: ?str, admin_state: ?str, ip_mtu: ?int, l2_mtu: ?int, mpls_mtu: ?int, ipv4: ?srl_nokia_interfaces__interface__subinterface__ipv4=None, ipv6: ?srl_nokia_interfaces__interface__subinterface__ipv6=None, vlan: ?srl_nokia_interfaces__interface__subinterface__vlan=None):
        self._ns = 'urn:nokia.com:srlinux:chassis:interfaces'
        self.index = index
        self.type = type
        self.description = description
        self.admin_state = admin_state
        self.ip_mtu = ip_mtu
        self.l2_mtu = l2_mtu
        self.mpls_mtu = mpls_mtu
        self.ipv4 = ipv4 if ipv4 is not None else srl_nokia_interfaces__interface__subinterface__ipv4()
        self.ipv6 = ipv6 if ipv6 is not None else srl_nokia_interfaces__interface__subinterface__ipv6()
        self.vlan = vlan if vlan is not None else srl_nokia_interfaces__interface__subinterface__vlan()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _index = self.index
        if _index is not None:
            children['index'] = yang.gdata.Leaf('uint32', _index)
        _type = self.type
        if _type is not None:
            _identityref_type, error = complete_and_validate_identityref(_type, _identities, ['srl_nokia-if:si-type'], 'srl_nokia-interfaces')
            if _identityref_type is not None:
                _type = _identityref_type
            else:
                raise ValueError('Invalid value for identityref leaf type: {error}')
            children['type'] = yang.gdata.Leaf('identityref', _type)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _ip_mtu = self.ip_mtu
        if _ip_mtu is not None:
            children['ip-mtu'] = yang.gdata.Leaf('uint16', _ip_mtu)
        _l2_mtu = self.l2_mtu
        if _l2_mtu is not None:
            children['l2-mtu'] = yang.gdata.Leaf('uint16', _l2_mtu)
        _mpls_mtu = self.mpls_mtu
        if _mpls_mtu is not None:
            children['mpls-mtu'] = yang.gdata.Leaf('uint16', _mpls_mtu)
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            children['ipv4'] = _ipv4.to_gdata()
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            children['ipv6'] = _ipv6.to_gdata()
        _vlan = self.vlan
        if _vlan is not None:
            children['vlan'] = _vlan.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_interfaces__interface__subinterface_entry:
        return srl_nokia_interfaces__interface__subinterface_entry(index=n.get_int('index'), type=n.get_opt_Identityref('type'), description=n.get_opt_str('description'), admin_state=n.get_opt_str('admin-state'), ip_mtu=n.get_opt_int('ip-mtu'), l2_mtu=n.get_opt_int('l2-mtu'), mpls_mtu=n.get_opt_int('mpls-mtu'), ipv4=srl_nokia_interfaces__interface__subinterface__ipv4.from_gdata(n.get_opt_cnt('ipv4')), ipv6=srl_nokia_interfaces__interface__subinterface__ipv6.from_gdata(n.get_opt_cnt('ipv6')), vlan=srl_nokia_interfaces__interface__subinterface__vlan.from_gdata(n.get_opt_cnt('vlan')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_interfaces__interface__subinterface_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interface/subinterface')
            res.append('{self_name} = srl_nokia_interfaces__interface__subinterface({repr(self.index)})')
        leaves = []
        _type = self.type
        if _type is not None:
            leaves.append('{self_name}.type = {repr(_type)}')
        _description = self.description
        if _description is not None:
            leaves.append('{self_name}.description = {repr(_description)}')
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _ip_mtu = self.ip_mtu
        if _ip_mtu is not None:
            leaves.append('{self_name}.ip_mtu = {repr(_ip_mtu)}')
        _l2_mtu = self.l2_mtu
        if _l2_mtu is not None:
            leaves.append('{self_name}.l2_mtu = {repr(_l2_mtu)}')
        _mpls_mtu = self.mpls_mtu
        if _mpls_mtu is not None:
            leaves.append('{self_name}.mpls_mtu = {repr(_mpls_mtu)}')
        _ipv4 = self.ipv4
        if _ipv4 is not None:
            res.extend(_ipv4.prsrc('{self_name}.ipv4', False).splitlines())
        _ipv6 = self.ipv6
        if _ipv6 is not None:
            res.extend(_ipv6.prsrc('{self_name}.ipv6', False).splitlines())
        _vlan = self.vlan
        if _vlan is not None:
            res.extend(_vlan.prsrc('{self_name}.vlan', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /interface/subinterface'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-interfaces:interface', 'subinterface'])

class srl_nokia_interfaces__interface__subinterface(yang.adata.MNode):
    elements: list[srl_nokia_interfaces__interface__subinterface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:chassis:interfaces'
        self._name = 'subinterface'
        self.elements = elements

    mut def create(self, index):
        for e in self:
            match = True
            if e.index != index:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_interfaces__interface__subinterface_entry(index)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['index'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_interfaces__interface__subinterface_entry]:
        if n is not None:
            return [srl_nokia_interfaces__interface__subinterface_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_interfaces__interface__subinterface(elements=copied_elements)

extension srl_nokia_interfaces__interface__subinterface(Iterable[srl_nokia_interfaces__interface__subinterface_entry]):
    def __iter__(self) -> Iterator[srl_nokia_interfaces__interface__subinterface_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_interfaces__interface__subinterface_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_index = yang.gdata.from_xml_int(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_data_srl_nokia_interfaces__interface__subinterface__index, child_index)
    child_type = yang.gdata.from_xml_opt_Identityref(node, 'type')
    yang.gdata.maybe_add(children, 'type', from_data_srl_nokia_interfaces__interface__subinterface__type, child_type)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_data_srl_nokia_interfaces__interface__subinterface__description, child_description)
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_interfaces__interface__subinterface__admin_state, child_admin_state)
    child_ip_mtu = yang.gdata.from_xml_opt_int(node, 'ip-mtu')
    yang.gdata.maybe_add(children, 'ip-mtu', from_data_srl_nokia_interfaces__interface__subinterface__ip_mtu, child_ip_mtu)
    child_l2_mtu = yang.gdata.from_xml_opt_int(node, 'l2-mtu')
    yang.gdata.maybe_add(children, 'l2-mtu', from_data_srl_nokia_interfaces__interface__subinterface__l2_mtu, child_l2_mtu)
    child_mpls_mtu = yang.gdata.from_xml_opt_int(node, 'mpls-mtu')
    yang.gdata.maybe_add(children, 'mpls-mtu', from_data_srl_nokia_interfaces__interface__subinterface__mpls_mtu, child_mpls_mtu)
    child_ipv4 = yang.gdata.from_xml_opt_cnt(node, 'ipv4')
    yang.gdata.maybe_add(children, 'ipv4', from_xml_srl_nokia_interfaces__interface__subinterface__ipv4, child_ipv4)
    child_ipv6 = yang.gdata.from_xml_opt_cnt(node, 'ipv6')
    yang.gdata.maybe_add(children, 'ipv6', from_xml_srl_nokia_interfaces__interface__subinterface__ipv6, child_ipv6)
    child_vlan = yang.gdata.from_xml_opt_cnt(node, 'vlan', 'urn:nokia.com:srlinux:chassis:interfaces-vlans')
    yang.gdata.maybe_add(children, 'vlan', from_xml_srl_nokia_interfaces__interface__subinterface__vlan, child_vlan)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_interfaces__interface__subinterface(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_interfaces__interface__subinterface_element(e) for e in nodes]
    return yang.gdata.List(keys=['index'], elements=elements)

mut def from_data_srl_nokia_interfaces__interface__vlan_tagging(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val, ns='urn:nokia.com:srlinux:chassis:interfaces-vlans', module='srl_nokia-interfaces-vlans')

class srl_nokia_interfaces__interface_entry(yang.adata.MNode):
    name: str
    description: ?str
    admin_state: ?str
    mtu: ?int
    subinterface: srl_nokia_interfaces__interface__subinterface
    vlan_tagging: ?bool

    mut def __init__(self, name: str, description: ?str, admin_state: ?str, mtu: ?int, subinterface: list[srl_nokia_interfaces__interface__subinterface_entry]=[], vlan_tagging: ?bool):
        self._ns = 'urn:nokia.com:srlinux:chassis:interfaces'
        self.name = name
        self.description = description
        self.admin_state = admin_state
        self.mtu = mtu
        self.subinterface = srl_nokia_interfaces__interface__subinterface(elements=subinterface)
        self.vlan_tagging = vlan_tagging

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _mtu = self.mtu
        if _mtu is not None:
            children['mtu'] = yang.gdata.Leaf('uint16', _mtu)
        _subinterface = self.subinterface
        if _subinterface is not None:
            children['subinterface'] = _subinterface.to_gdata()
        _vlan_tagging = self.vlan_tagging
        if _vlan_tagging is not None:
            children['vlan-tagging'] = yang.gdata.Leaf('boolean', _vlan_tagging, ns='urn:nokia.com:srlinux:chassis:interfaces-vlans', module='srl_nokia-interfaces-vlans')
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_interfaces__interface_entry:
        return srl_nokia_interfaces__interface_entry(name=n.get_str('name'), description=n.get_opt_str('description'), admin_state=n.get_opt_str('admin-state'), mtu=n.get_opt_int('mtu'), subinterface=srl_nokia_interfaces__interface__subinterface.from_gdata(n.get_opt_list('subinterface')), vlan_tagging=n.get_opt_bool('vlan-tagging'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_interfaces__interface_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /interface')
            res.append('{self_name} = srl_nokia_interfaces__interface({repr(self.name)})')
        leaves = []
        _description = self.description
        if _description is not None:
            leaves.append('{self_name}.description = {repr(_description)}')
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _mtu = self.mtu
        if _mtu is not None:
            leaves.append('{self_name}.mtu = {repr(_mtu)}')
        _subinterface = self.subinterface
        for _element in _subinterface:
            res.append('')
            res.append("# List /interface/subinterface element: {_element.to_gdata().key_str(['index'])}")
            list_elem = 'subinterface_element = {self_name}.subinterface.create({repr(_element.index)})'
            res.append(list_elem)
            res.extend(_element.prsrc('subinterface_element', False, list_element=True).splitlines())
        _vlan_tagging = self.vlan_tagging
        if _vlan_tagging is not None:
            leaves.append('{self_name}.vlan_tagging = {repr(_vlan_tagging)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /interface'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-interfaces:interface'])

class srl_nokia_interfaces__interface(yang.adata.MNode):
    elements: list[srl_nokia_interfaces__interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:chassis:interfaces'
        self._name = 'interface'
        self.elements = elements

    mut def create(self, name):
        for e in self:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_interfaces__interface_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements, ns='urn:nokia.com:srlinux:chassis:interfaces', module='srl_nokia-interfaces')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_interfaces__interface_entry]:
        if n is not None:
            return [srl_nokia_interfaces__interface_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_interfaces__interface(elements=copied_elements)

extension srl_nokia_interfaces__interface(Iterable[srl_nokia_interfaces__interface_entry]):
    def __iter__(self) -> Iterator[srl_nokia_interfaces__interface_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_interfaces__interface_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_data_srl_nokia_interfaces__interface__name, child_name)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_data_srl_nokia_interfaces__interface__description, child_description)
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_interfaces__interface__admin_state, child_admin_state)
    child_mtu = yang.gdata.from_xml_opt_int(node, 'mtu')
    yang.gdata.maybe_add(children, 'mtu', from_data_srl_nokia_interfaces__interface__mtu, child_mtu)
    child_subinterface = yang.gdata.from_xml_opt_list(node, 'subinterface')
    yang.gdata.maybe_add(children, 'subinterface', from_xml_srl_nokia_interfaces__interface__subinterface, child_subinterface)
    child_vlan_tagging = yang.gdata.from_xml_opt_bool(node, 'vlan-tagging', 'urn:nokia.com:srlinux:chassis:interfaces-vlans')
    yang.gdata.maybe_add(children, 'vlan-tagging', from_data_srl_nokia_interfaces__interface__vlan_tagging, child_vlan_tagging)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_interfaces__interface(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_interfaces__interface_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements, ns='urn:nokia.com:srlinux:chassis:interfaces', module='srl_nokia-interfaces')

mut def from_data_srl_nokia_network_instance__network_instance__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_network_instance__network_instance__type(val: value) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['srl_nokia-netinst:ni-type'], 'srl_nokia-network-instance')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_data_srl_nokia_network_instance__network_instance__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_network_instance__network_instance__router_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_network_instance__network_instance__interface__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_network_instance__network_instance__interface__interface_ref__interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_data_srl_nokia_network_instance__network_instance__interface__interface_ref__subinterface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

class srl_nokia_network_instance__network_instance__interface__interface_ref(yang.adata.MNode):
    interface: ?str
    subinterface: ?str

    mut def __init__(self, interface: ?str, subinterface: ?str):
        self._ns = 'urn:nokia.com:srlinux:net-inst:network-instance'
        self.interface = interface
        self.subinterface = subinterface

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _interface = self.interface
        if _interface is not None:
            children['interface'] = yang.gdata.Leaf('leafref', _interface)
        _subinterface = self.subinterface
        if _subinterface is not None:
            children['subinterface'] = yang.gdata.Leaf('leafref', _subinterface)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__interface__interface_ref:
        if n is not None:
            return srl_nokia_network_instance__network_instance__interface__interface_ref(interface=n.get_opt_str('interface'), subinterface=n.get_opt_str('subinterface'))
        return srl_nokia_network_instance__network_instance__interface__interface_ref()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__interface__interface_ref.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/interface/interface-ref')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__interface__interface_ref()')
        leaves = []
        _interface = self.interface
        if _interface is not None:
            leaves.append('{self_name}.interface = {repr(_interface)}')
        _subinterface = self.subinterface
        if _subinterface is not None:
            leaves.append('{self_name}.subinterface = {repr(_subinterface)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/interface/interface-ref'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'interface', 'interface-ref'])


mut def from_xml_srl_nokia_network_instance__network_instance__interface__interface_ref(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_interface = yang.gdata.from_xml_opt_str(node, 'interface')
    yang.gdata.maybe_add(children, 'interface', from_data_srl_nokia_network_instance__network_instance__interface__interface_ref__interface, child_interface)
    child_subinterface = yang.gdata.from_xml_opt_str(node, 'subinterface')
    yang.gdata.maybe_add(children, 'subinterface', from_data_srl_nokia_network_instance__network_instance__interface__interface_ref__subinterface, child_subinterface)
    return yang.gdata.Container(children)

class srl_nokia_network_instance__network_instance__interface_entry(yang.adata.MNode):
    name: str
    interface_ref: srl_nokia_network_instance__network_instance__interface__interface_ref

    mut def __init__(self, name: str, interface_ref: ?srl_nokia_network_instance__network_instance__interface__interface_ref=None):
        self._ns = 'urn:nokia.com:srlinux:net-inst:network-instance'
        self.name = name
        self.interface_ref = interface_ref if interface_ref is not None else srl_nokia_network_instance__network_instance__interface__interface_ref()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _interface_ref = self.interface_ref
        if _interface_ref is not None:
            children['interface-ref'] = _interface_ref.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_network_instance__network_instance__interface_entry:
        return srl_nokia_network_instance__network_instance__interface_entry(name=n.get_str('name'), interface_ref=srl_nokia_network_instance__network_instance__interface__interface_ref.from_gdata(n.get_opt_cnt('interface-ref')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__interface_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/interface')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__interface({repr(self.name)})')
        leaves = []
        _interface_ref = self.interface_ref
        if _interface_ref is not None:
            res.extend(_interface_ref.prsrc('{self_name}.interface_ref', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/interface'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'interface'])

class srl_nokia_network_instance__network_instance__interface(yang.adata.MNode):
    elements: list[srl_nokia_network_instance__network_instance__interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:net-inst:network-instance'
        self._name = 'interface'
        self.elements = elements

    mut def create(self, name):
        for e in self:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_network_instance__network_instance__interface_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_network_instance__network_instance__interface_entry]:
        if n is not None:
            return [srl_nokia_network_instance__network_instance__interface_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_network_instance__network_instance__interface(elements=copied_elements)

extension srl_nokia_network_instance__network_instance__interface(Iterable[srl_nokia_network_instance__network_instance__interface_entry]):
    def __iter__(self) -> Iterator[srl_nokia_network_instance__network_instance__interface_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_network_instance__network_instance__interface_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_data_srl_nokia_network_instance__network_instance__interface__name, child_name)
    child_interface_ref = yang.gdata.from_xml_opt_cnt(node, 'interface-ref')
    yang.gdata.maybe_add(children, 'interface-ref', from_xml_srl_nokia_network_instance__network_instance__interface__interface_ref, child_interface_ref)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_network_instance__network_instance__interface(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_network_instance__network_instance__interface_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_data_srl_nokia_network_instance__network_instance__vxlan_interface__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class srl_nokia_network_instance__network_instance__vxlan_interface_entry(yang.adata.MNode):
    name: str

    mut def __init__(self, name: str):
        self._ns = 'urn:nokia.com:srlinux:net-inst:network-instance'
        self.name = name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_network_instance__network_instance__vxlan_interface_entry:
        return srl_nokia_network_instance__network_instance__vxlan_interface_entry(name=n.get_str('name'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__vxlan_interface_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/vxlan-interface')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__vxlan_interface({repr(self.name)})')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/vxlan-interface'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'vxlan-interface'])

class srl_nokia_network_instance__network_instance__vxlan_interface(yang.adata.MNode):
    elements: list[srl_nokia_network_instance__network_instance__vxlan_interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:net-inst:network-instance'
        self._name = 'vxlan-interface'
        self.elements = elements

    mut def create(self, name):
        for e in self:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_network_instance__network_instance__vxlan_interface_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_network_instance__network_instance__vxlan_interface_entry]:
        if n is not None:
            return [srl_nokia_network_instance__network_instance__vxlan_interface_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_network_instance__network_instance__vxlan_interface(elements=copied_elements)

extension srl_nokia_network_instance__network_instance__vxlan_interface(Iterable[srl_nokia_network_instance__network_instance__vxlan_interface_entry]):
    def __iter__(self) -> Iterator[srl_nokia_network_instance__network_instance__vxlan_interface_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_network_instance__network_instance__vxlan_interface_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_data_srl_nokia_network_instance__network_instance__vxlan_interface__name, child_name)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_network_instance__network_instance__vxlan_interface(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_network_instance__network_instance__vxlan_interface_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance__vxlan_interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance__evi(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance_entry(yang.adata.MNode):
    id: int
    admin_state: ?str
    vxlan_interface: ?str
    evi: ?int

    mut def __init__(self, id: int, admin_state: ?str, vxlan_interface: ?str, evi: ?int):
        self._ns = 'urn:nokia.com:srlinux:net-inst:bgp-evpn'
        self.id = id
        self.admin_state = admin_state
        self.vxlan_interface = vxlan_interface
        self.evi = evi

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint8', _id)
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _vxlan_interface = self.vxlan_interface
        if _vxlan_interface is not None:
            children['vxlan-interface'] = yang.gdata.Leaf('leafref', _vxlan_interface)
        _evi = self.evi
        if _evi is not None:
            children['evi'] = yang.gdata.Leaf('uint32', _evi)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance_entry:
        return srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance_entry(id=n.get_int('id'), admin_state=n.get_opt_str('admin-state'), vxlan_interface=n.get_opt_str('vxlan-interface'), evi=n.get_opt_int('evi'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp-evpn/bgp-instance')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance({repr(self.id)})')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _vxlan_interface = self.vxlan_interface
        if _vxlan_interface is not None:
            leaves.append('{self_name}.vxlan_interface = {repr(_vxlan_interface)}')
        _evi = self.evi
        if _evi is not None:
            leaves.append('{self_name}.evi = {repr(_evi)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp-evpn/bgp-instance'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'bgp-evpn', 'srl_nokia-bgp-evpn:bgp-instance'])

class srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance(yang.adata.MNode):
    elements: list[srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:net-inst:bgp-evpn'
        self._name = 'bgp-instance'
        self.elements = elements

    mut def create(self, id, evi):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance_entry(id, evi)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements, ns='urn:nokia.com:srlinux:net-inst:bgp-evpn', module='srl_nokia-bgp-evpn')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance_entry]:
        if n is not None:
            return [srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance(elements=copied_elements)

extension srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance(Iterable[srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance_entry]):
    def __iter__(self) -> Iterator[srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_int(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_data_srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance__id, child_id)
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance__admin_state, child_admin_state)
    child_vxlan_interface = yang.gdata.from_xml_opt_str(node, 'vxlan-interface')
    yang.gdata.maybe_add(children, 'vxlan-interface', from_data_srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance__vxlan_interface, child_vxlan_interface)
    child_evi = yang.gdata.from_xml_opt_int(node, 'evi')
    yang.gdata.maybe_add(children, 'evi', from_data_srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance__evi, child_evi)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements, ns='urn:nokia.com:srlinux:net-inst:bgp-evpn', module='srl_nokia-bgp-evpn')

class srl_nokia_network_instance__network_instance__protocols__bgp_evpn(yang.adata.MNode):
    bgp_instance: srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance

    mut def __init__(self, bgp_instance: list[srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance_entry]=[]):
        self._ns = 'urn:nokia.com:srlinux:net-inst:network-instance'
        self.bgp_instance = srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance(elements=bgp_instance)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _bgp_instance = self.bgp_instance
        if _bgp_instance is not None:
            children['bgp-instance'] = _bgp_instance.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?srl_nokia_network_instance__network_instance__protocols__bgp_evpn:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp_evpn(bgp_instance=srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance.from_gdata(n.get_opt_list('bgp-instance')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = srl_nokia_network_instance__network_instance__protocols__bgp_evpn.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in srl_nokia_network_instance__network_instance__protocols__bgp_evpn.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp-evpn')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp_evpn()')
        leaves = []
        _bgp_instance = self.bgp_instance
        for _element in _bgp_instance:
            res.append('')
            res.append("# List /network-instance/protocols/bgp-evpn/bgp-instance element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'bgp_instance_element = {self_name}.bgp_instance.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('bgp_instance_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp-evpn'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'bgp-evpn'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_evpn(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_bgp_instance = yang.gdata.from_xml_opt_list(node, 'bgp-instance', 'urn:nokia.com:srlinux:net-inst:bgp-evpn')
    yang.gdata.maybe_add(children, 'bgp-instance', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_evpn__bgp_instance, child_bgp_instance)
    return yang.gdata.Container(children, presence=True)

class srl_nokia_network_instance__network_instance__protocols__bgp_ipvpn(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'urn:nokia.com:srlinux:net-inst:network-instance'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?srl_nokia_network_instance__network_instance__protocols__bgp_ipvpn:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp_ipvpn()
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = srl_nokia_network_instance__network_instance__protocols__bgp_ipvpn.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in srl_nokia_network_instance__network_instance__protocols__bgp_ipvpn.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp-ipvpn')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp_ipvpn()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp-ipvpn'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'bgp-ipvpn'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_ipvpn(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children, presence=True)

class srl_nokia_network_instance__network_instance__protocols__directly_connected(yang.adata.MNode):

    mut def __init__(self):
        self._ns = 'urn:nokia.com:srlinux:net-inst:network-instance'
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__directly_connected:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__directly_connected()
        return srl_nokia_network_instance__network_instance__protocols__directly_connected()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__directly_connected.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/directly-connected')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__directly_connected()')
        leaves = []
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/directly-connected'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'directly-connected'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__directly_connected(node: xml.Node) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__instance_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__net(val: list[value]) -> yang.gdata.LeafList:
    return yang.gdata.LeafList('string', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level_capability(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__max_ecmp_paths(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__poi_tlv(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__iid_tlv(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__advertise_router_capability(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__prefix_attributes_tlv(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__export_policy(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__hello_padding(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__enable_csnp_on_p2p_links(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit__ignore(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit__suppress(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit(yang.adata.MNode):
    ignore: ?bool
    suppress: ?bool

    mut def __init__(self, ignore: ?bool, suppress: ?bool):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.ignore = ignore
        self.suppress = suppress

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ignore = self.ignore
        if _ignore is not None:
            children['ignore'] = yang.gdata.Leaf('boolean', _ignore)
        _suppress = self.suppress
        if _suppress is not None:
            children['suppress'] = yang.gdata.Leaf('boolean', _suppress)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit(ignore=n.get_opt_bool('ignore'), suppress=n.get_opt_bool('suppress'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/attached-bit')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit()')
        leaves = []
        _ignore = self.ignore
        if _ignore is not None:
            leaves.append('{self_name}.ignore = {repr(_ignore)}')
        _suppress = self.suppress
        if _suppress is not None:
            leaves.append('{self_name}.suppress = {repr(_suppress)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/attached-bit'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'attached-bit'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ignore = yang.gdata.from_xml_opt_bool(node, 'ignore')
    yang.gdata.maybe_add(children, 'ignore', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit__ignore, child_ignore)
    child_suppress = yang.gdata.from_xml_opt_bool(node, 'suppress')
    yang.gdata.maybe_add(children, 'suppress', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit__suppress, child_suppress)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__transport__lsp_mtu_size(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__transport(yang.adata.MNode):
    lsp_mtu_size: ?int

    mut def __init__(self, lsp_mtu_size: ?int):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.lsp_mtu_size = lsp_mtu_size

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _lsp_mtu_size = self.lsp_mtu_size
        if _lsp_mtu_size is not None:
            children['lsp-mtu-size'] = yang.gdata.Leaf('uint16', _lsp_mtu_size)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__transport:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__transport(lsp_mtu_size=n.get_opt_int('lsp-mtu-size'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__transport()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__transport.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/transport')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__transport()')
        leaves = []
        _lsp_mtu_size = self.lsp_mtu_size
        if _lsp_mtu_size is not None:
            leaves.append('{self_name}.lsp_mtu_size = {repr(_lsp_mtu_size)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/transport'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'transport'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__transport(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_lsp_mtu_size = yang.gdata.from_xml_opt_int(node, 'lsp-mtu-size')
    yang.gdata.maybe_add(children, 'lsp-mtu-size', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__transport__lsp_mtu_size, child_lsp_mtu_size)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv4_unicast__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv4_unicast(yang.adata.MNode):
    admin_state: ?str

    mut def __init__(self, admin_state: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.admin_state = admin_state

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv4_unicast:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv4_unicast(admin_state=n.get_opt_str('admin-state'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv4_unicast()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv4_unicast.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/ipv4-unicast')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv4_unicast()')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/ipv4-unicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'ipv4-unicast'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv4_unicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv4_unicast__admin_state, child_admin_state)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv6_unicast__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv6_unicast(yang.adata.MNode):
    admin_state: ?str

    mut def __init__(self, admin_state: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.admin_state = admin_state

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv6_unicast:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv6_unicast(admin_state=n.get_opt_str('admin-state'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv6_unicast()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv6_unicast.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/ipv6-unicast')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv6_unicast()')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/ipv6-unicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'ipv6-unicast'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv6_unicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv6_unicast__admin_state, child_admin_state)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication__generate(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication__check_received(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication(yang.adata.MNode):
    generate: ?bool
    check_received: ?str

    mut def __init__(self, generate: ?bool, check_received: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.generate = generate
        self.check_received = check_received

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _generate = self.generate
        if _generate is not None:
            children['generate'] = yang.gdata.Leaf('boolean', _generate)
        _check_received = self.check_received
        if _check_received is not None:
            children['check-received'] = yang.gdata.Leaf('enumeration', _check_received)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication(generate=n.get_opt_bool('generate'), check_received=n.get_opt_str('check-received'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/authentication/csnp-authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication()')
        leaves = []
        _generate = self.generate
        if _generate is not None:
            leaves.append('{self_name}.generate = {repr(_generate)}')
        _check_received = self.check_received
        if _check_received is not None:
            leaves.append('{self_name}.check_received = {repr(_check_received)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/authentication/csnp-authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'authentication', 'csnp-authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_generate = yang.gdata.from_xml_opt_bool(node, 'generate')
    yang.gdata.maybe_add(children, 'generate', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication__generate, child_generate)
    child_check_received = yang.gdata.from_xml_opt_str(node, 'check-received')
    yang.gdata.maybe_add(children, 'check-received', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication__check_received, child_check_received)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication__generate(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication__check_received(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication(yang.adata.MNode):
    generate: ?bool
    check_received: ?str

    mut def __init__(self, generate: ?bool, check_received: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.generate = generate
        self.check_received = check_received

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _generate = self.generate
        if _generate is not None:
            children['generate'] = yang.gdata.Leaf('boolean', _generate)
        _check_received = self.check_received
        if _check_received is not None:
            children['check-received'] = yang.gdata.Leaf('enumeration', _check_received)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication(generate=n.get_opt_bool('generate'), check_received=n.get_opt_str('check-received'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/authentication/psnp-authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication()')
        leaves = []
        _generate = self.generate
        if _generate is not None:
            leaves.append('{self_name}.generate = {repr(_generate)}')
        _check_received = self.check_received
        if _check_received is not None:
            leaves.append('{self_name}.check_received = {repr(_check_received)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/authentication/psnp-authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'authentication', 'psnp-authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_generate = yang.gdata.from_xml_opt_bool(node, 'generate')
    yang.gdata.maybe_add(children, 'generate', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication__generate, child_generate)
    child_check_received = yang.gdata.from_xml_opt_str(node, 'check-received')
    yang.gdata.maybe_add(children, 'check-received', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication__check_received, child_check_received)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication__generate(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication__check_received(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication(yang.adata.MNode):
    generate: ?bool
    check_received: ?str

    mut def __init__(self, generate: ?bool, check_received: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.generate = generate
        self.check_received = check_received

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _generate = self.generate
        if _generate is not None:
            children['generate'] = yang.gdata.Leaf('boolean', _generate)
        _check_received = self.check_received
        if _check_received is not None:
            children['check-received'] = yang.gdata.Leaf('enumeration', _check_received)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication(generate=n.get_opt_bool('generate'), check_received=n.get_opt_str('check-received'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/authentication/hello-authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication()')
        leaves = []
        _generate = self.generate
        if _generate is not None:
            leaves.append('{self_name}.generate = {repr(_generate)}')
        _check_received = self.check_received
        if _check_received is not None:
            leaves.append('{self_name}.check_received = {repr(_check_received)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/authentication/hello-authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'authentication', 'hello-authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_generate = yang.gdata.from_xml_opt_bool(node, 'generate')
    yang.gdata.maybe_add(children, 'generate', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication__generate, child_generate)
    child_check_received = yang.gdata.from_xml_opt_str(node, 'check-received')
    yang.gdata.maybe_add(children, 'check-received', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication__check_received, child_check_received)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication__generate(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication__check_received(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication(yang.adata.MNode):
    generate: ?bool
    check_received: ?str

    mut def __init__(self, generate: ?bool, check_received: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.generate = generate
        self.check_received = check_received

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _generate = self.generate
        if _generate is not None:
            children['generate'] = yang.gdata.Leaf('boolean', _generate)
        _check_received = self.check_received
        if _check_received is not None:
            children['check-received'] = yang.gdata.Leaf('enumeration', _check_received)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication(generate=n.get_opt_bool('generate'), check_received=n.get_opt_str('check-received'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/authentication/lsp-authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication()')
        leaves = []
        _generate = self.generate
        if _generate is not None:
            leaves.append('{self_name}.generate = {repr(_generate)}')
        _check_received = self.check_received
        if _check_received is not None:
            leaves.append('{self_name}.check_received = {repr(_check_received)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/authentication/lsp-authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'authentication', 'lsp-authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_generate = yang.gdata.from_xml_opt_bool(node, 'generate')
    yang.gdata.maybe_add(children, 'generate', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication__generate, child_generate)
    child_check_received = yang.gdata.from_xml_opt_str(node, 'check-received')
    yang.gdata.maybe_add(children, 'check-received', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication__check_received, child_check_received)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__keychain(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key__crypto_algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key__auth_password(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key(yang.adata.MNode):
    crypto_algorithm: ?str
    auth_password: ?str

    mut def __init__(self, crypto_algorithm: ?str, auth_password: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.crypto_algorithm = crypto_algorithm
        self.auth_password = auth_password

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _crypto_algorithm = self.crypto_algorithm
        if _crypto_algorithm is not None:
            children['crypto-algorithm'] = yang.gdata.Leaf('enumeration', _crypto_algorithm)
        _auth_password = self.auth_password
        if _auth_password is not None:
            children['auth-password'] = yang.gdata.Leaf('string', _auth_password)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key(crypto_algorithm=n.get_opt_str('crypto-algorithm'), auth_password=n.get_opt_str('auth-password'))
        raise ValueError('Missing required subtree srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key')

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/authentication/key')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key()')
        leaves = []
        _crypto_algorithm = self.crypto_algorithm
        if _crypto_algorithm is not None:
            leaves.append('{self_name}.crypto_algorithm = {repr(_crypto_algorithm)}')
        _auth_password = self.auth_password
        if _auth_password is not None:
            leaves.append('{self_name}.auth_password = {repr(_auth_password)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/authentication/key'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'authentication', 'key'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_crypto_algorithm = yang.gdata.from_xml_opt_str(node, 'crypto-algorithm')
    yang.gdata.maybe_add(children, 'crypto-algorithm', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key__crypto_algorithm, child_crypto_algorithm)
    child_auth_password = yang.gdata.from_xml_opt_str(node, 'auth-password')
    yang.gdata.maybe_add(children, 'auth-password', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key__auth_password, child_auth_password)
    return yang.gdata.Container(children)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication(yang.adata.MNode):
    csnp_authentication: srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication
    psnp_authentication: srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication
    hello_authentication: srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication
    lsp_authentication: srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication
    keychain: ?str
    key: srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key

    mut def __init__(self, csnp_authentication: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication=None, psnp_authentication: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication=None, hello_authentication: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication=None, lsp_authentication: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication=None, keychain: ?str, key: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key=None):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.csnp_authentication = csnp_authentication if csnp_authentication is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication()
        self.psnp_authentication = psnp_authentication if psnp_authentication is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication()
        self.hello_authentication = hello_authentication if hello_authentication is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication()
        self.lsp_authentication = lsp_authentication if lsp_authentication is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication()
        self.keychain = keychain
        self.key = key if key is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _csnp_authentication = self.csnp_authentication
        if _csnp_authentication is not None:
            children['csnp-authentication'] = _csnp_authentication.to_gdata()
        _psnp_authentication = self.psnp_authentication
        if _psnp_authentication is not None:
            children['psnp-authentication'] = _psnp_authentication.to_gdata()
        _hello_authentication = self.hello_authentication
        if _hello_authentication is not None:
            children['hello-authentication'] = _hello_authentication.to_gdata()
        _lsp_authentication = self.lsp_authentication
        if _lsp_authentication is not None:
            children['lsp-authentication'] = _lsp_authentication.to_gdata()
        _keychain = self.keychain
        if _keychain is not None:
            children['keychain'] = yang.gdata.Leaf('leafref', _keychain)
        _key = self.key
        if _key is not None:
            children['key'] = _key.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication(csnp_authentication=srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication.from_gdata(n.get_opt_cnt('csnp-authentication')), psnp_authentication=srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication.from_gdata(n.get_opt_cnt('psnp-authentication')), hello_authentication=srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication.from_gdata(n.get_opt_cnt('hello-authentication')), lsp_authentication=srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication.from_gdata(n.get_opt_cnt('lsp-authentication')), keychain=n.get_opt_str('keychain'), key=srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key.from_gdata(n.get_opt_cnt('key')))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication()')
        leaves = []
        _csnp_authentication = self.csnp_authentication
        if _csnp_authentication is not None:
            res.extend(_csnp_authentication.prsrc('{self_name}.csnp_authentication', False).splitlines())
        _psnp_authentication = self.psnp_authentication
        if _psnp_authentication is not None:
            res.extend(_psnp_authentication.prsrc('{self_name}.psnp_authentication', False).splitlines())
        _hello_authentication = self.hello_authentication
        if _hello_authentication is not None:
            res.extend(_hello_authentication.prsrc('{self_name}.hello_authentication', False).splitlines())
        _lsp_authentication = self.lsp_authentication
        if _lsp_authentication is not None:
            res.extend(_lsp_authentication.prsrc('{self_name}.lsp_authentication', False).splitlines())
        _keychain = self.keychain
        if _keychain is not None:
            leaves.append('{self_name}.keychain = {repr(_keychain)}')
        _key = self.key
        if _key is not None:
            res.extend(_key.prsrc('{self_name}.key', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_csnp_authentication = yang.gdata.from_xml_opt_cnt(node, 'csnp-authentication')
    yang.gdata.maybe_add(children, 'csnp-authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__csnp_authentication, child_csnp_authentication)
    child_psnp_authentication = yang.gdata.from_xml_opt_cnt(node, 'psnp-authentication')
    yang.gdata.maybe_add(children, 'psnp-authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__psnp_authentication, child_psnp_authentication)
    child_hello_authentication = yang.gdata.from_xml_opt_cnt(node, 'hello-authentication')
    yang.gdata.maybe_add(children, 'hello-authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__hello_authentication, child_hello_authentication)
    child_lsp_authentication = yang.gdata.from_xml_opt_cnt(node, 'lsp-authentication')
    yang.gdata.maybe_add(children, 'lsp-authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__lsp_authentication, child_lsp_authentication)
    child_keychain = yang.gdata.from_xml_opt_str(node, 'keychain')
    yang.gdata.maybe_add(children, 'keychain', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__keychain, child_keychain)
    child_key = yang.gdata.from_xml_opt_cnt(node, 'key')
    yang.gdata.maybe_add(children, 'key', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication__key, child_key)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref__interface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref__subinterface(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref(yang.adata.MNode):
    interface: ?str
    subinterface: ?str

    mut def __init__(self, interface: ?str, subinterface: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.interface = interface
        self.subinterface = subinterface

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _interface = self.interface
        if _interface is not None:
            children['interface'] = yang.gdata.Leaf('leafref', _interface)
        _subinterface = self.subinterface
        if _subinterface is not None:
            children['subinterface'] = yang.gdata.Leaf('leafref', _subinterface)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref(interface=n.get_opt_str('interface'), subinterface=n.get_opt_str('subinterface'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/interface/interface-ref')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref()')
        leaves = []
        _interface = self.interface
        if _interface is not None:
            leaves.append('{self_name}.interface = {repr(_interface)}')
        _subinterface = self.subinterface
        if _subinterface is not None:
            leaves.append('{self_name}.subinterface = {repr(_subinterface)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/interface/interface-ref'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'interface', 'interface-ref'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_interface = yang.gdata.from_xml_opt_str(node, 'interface')
    yang.gdata.maybe_add(children, 'interface', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref__interface, child_interface)
    child_subinterface = yang.gdata.from_xml_opt_str(node, 'subinterface')
    yang.gdata.maybe_add(children, 'subinterface', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref__subinterface, child_subinterface)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__circuit_type(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__delay__delay_selection(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__delay(yang.adata.MNode):
    delay_selection: ?str

    mut def __init__(self, delay_selection: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.delay_selection = delay_selection

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _delay_selection = self.delay_selection
        if _delay_selection is not None:
            children['delay-selection'] = yang.gdata.Leaf('enumeration', _delay_selection)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__delay:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__delay(delay_selection=n.get_opt_str('delay-selection'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__delay()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__delay.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/interface/delay')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__delay()')
        leaves = []
        _delay_selection = self.delay_selection
        if _delay_selection is not None:
            leaves.append('{self_name}.delay_selection = {repr(_delay_selection)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/interface/delay'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'interface', 'delay'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__delay(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_delay_selection = yang.gdata.from_xml_opt_str(node, 'delay-selection')
    yang.gdata.maybe_add(children, 'delay-selection', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__delay__delay_selection, child_delay_selection)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__hello_padding(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__passive(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast__enable_bfd(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast__include_bfd_tlv(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast(yang.adata.MNode):
    admin_state: ?str
    enable_bfd: ?bool
    include_bfd_tlv: ?bool

    mut def __init__(self, admin_state: ?str, enable_bfd: ?bool, include_bfd_tlv: ?bool):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.admin_state = admin_state
        self.enable_bfd = enable_bfd
        self.include_bfd_tlv = include_bfd_tlv

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _enable_bfd = self.enable_bfd
        if _enable_bfd is not None:
            children['enable-bfd'] = yang.gdata.Leaf('boolean', _enable_bfd)
        _include_bfd_tlv = self.include_bfd_tlv
        if _include_bfd_tlv is not None:
            children['include-bfd-tlv'] = yang.gdata.Leaf('boolean', _include_bfd_tlv)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast(admin_state=n.get_opt_str('admin-state'), enable_bfd=n.get_opt_bool('enable-bfd'), include_bfd_tlv=n.get_opt_bool('include-bfd-tlv'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/interface/ipv4-unicast')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast()')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _enable_bfd = self.enable_bfd
        if _enable_bfd is not None:
            leaves.append('{self_name}.enable_bfd = {repr(_enable_bfd)}')
        _include_bfd_tlv = self.include_bfd_tlv
        if _include_bfd_tlv is not None:
            leaves.append('{self_name}.include_bfd_tlv = {repr(_include_bfd_tlv)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/interface/ipv4-unicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'interface', 'ipv4-unicast'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast__admin_state, child_admin_state)
    child_enable_bfd = yang.gdata.from_xml_opt_bool(node, 'enable-bfd')
    yang.gdata.maybe_add(children, 'enable-bfd', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast__enable_bfd, child_enable_bfd)
    child_include_bfd_tlv = yang.gdata.from_xml_opt_bool(node, 'include-bfd-tlv')
    yang.gdata.maybe_add(children, 'include-bfd-tlv', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast__include_bfd_tlv, child_include_bfd_tlv)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast__enable_bfd(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast__include_bfd_tlv(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast(yang.adata.MNode):
    admin_state: ?str
    enable_bfd: ?bool
    include_bfd_tlv: ?bool

    mut def __init__(self, admin_state: ?str, enable_bfd: ?bool, include_bfd_tlv: ?bool):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.admin_state = admin_state
        self.enable_bfd = enable_bfd
        self.include_bfd_tlv = include_bfd_tlv

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _enable_bfd = self.enable_bfd
        if _enable_bfd is not None:
            children['enable-bfd'] = yang.gdata.Leaf('boolean', _enable_bfd)
        _include_bfd_tlv = self.include_bfd_tlv
        if _include_bfd_tlv is not None:
            children['include-bfd-tlv'] = yang.gdata.Leaf('boolean', _include_bfd_tlv)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast(admin_state=n.get_opt_str('admin-state'), enable_bfd=n.get_opt_bool('enable-bfd'), include_bfd_tlv=n.get_opt_bool('include-bfd-tlv'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/interface/ipv6-unicast')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast()')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _enable_bfd = self.enable_bfd
        if _enable_bfd is not None:
            leaves.append('{self_name}.enable_bfd = {repr(_enable_bfd)}')
        _include_bfd_tlv = self.include_bfd_tlv
        if _include_bfd_tlv is not None:
            leaves.append('{self_name}.include_bfd_tlv = {repr(_include_bfd_tlv)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/interface/ipv6-unicast'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'interface', 'ipv6-unicast'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast__admin_state, child_admin_state)
    child_enable_bfd = yang.gdata.from_xml_opt_bool(node, 'enable-bfd')
    yang.gdata.maybe_add(children, 'enable-bfd', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast__enable_bfd, child_enable_bfd)
    child_include_bfd_tlv = yang.gdata.from_xml_opt_bool(node, 'include-bfd-tlv')
    yang.gdata.maybe_add(children, 'include-bfd-tlv', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast__include_bfd_tlv, child_include_bfd_tlv)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__level_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__disable(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__ipv6_unicast_metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__metric(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__priority(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__passive(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication__generate(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication__check_received(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication(yang.adata.MNode):
    generate: ?bool
    check_received: ?str

    mut def __init__(self, generate: ?bool, check_received: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.generate = generate
        self.check_received = check_received

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _generate = self.generate
        if _generate is not None:
            children['generate'] = yang.gdata.Leaf('boolean', _generate)
        _check_received = self.check_received
        if _check_received is not None:
            children['check-received'] = yang.gdata.Leaf('enumeration', _check_received)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication(generate=n.get_opt_bool('generate'), check_received=n.get_opt_str('check-received'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/interface/level/authentication/hello-authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication()')
        leaves = []
        _generate = self.generate
        if _generate is not None:
            leaves.append('{self_name}.generate = {repr(_generate)}')
        _check_received = self.check_received
        if _check_received is not None:
            leaves.append('{self_name}.check_received = {repr(_check_received)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/interface/level/authentication/hello-authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'interface', 'level', 'authentication', 'hello-authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_generate = yang.gdata.from_xml_opt_bool(node, 'generate')
    yang.gdata.maybe_add(children, 'generate', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication__generate, child_generate)
    child_check_received = yang.gdata.from_xml_opt_str(node, 'check-received')
    yang.gdata.maybe_add(children, 'check-received', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication__check_received, child_check_received)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__keychain(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key__crypto_algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key__auth_password(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key(yang.adata.MNode):
    crypto_algorithm: ?str
    auth_password: ?str

    mut def __init__(self, crypto_algorithm: ?str, auth_password: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.crypto_algorithm = crypto_algorithm
        self.auth_password = auth_password

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _crypto_algorithm = self.crypto_algorithm
        if _crypto_algorithm is not None:
            children['crypto-algorithm'] = yang.gdata.Leaf('enumeration', _crypto_algorithm)
        _auth_password = self.auth_password
        if _auth_password is not None:
            children['auth-password'] = yang.gdata.Leaf('string', _auth_password)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key(crypto_algorithm=n.get_opt_str('crypto-algorithm'), auth_password=n.get_opt_str('auth-password'))
        raise ValueError('Missing required subtree srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key')

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/interface/level/authentication/key')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key()')
        leaves = []
        _crypto_algorithm = self.crypto_algorithm
        if _crypto_algorithm is not None:
            leaves.append('{self_name}.crypto_algorithm = {repr(_crypto_algorithm)}')
        _auth_password = self.auth_password
        if _auth_password is not None:
            leaves.append('{self_name}.auth_password = {repr(_auth_password)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/interface/level/authentication/key'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'interface', 'level', 'authentication', 'key'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_crypto_algorithm = yang.gdata.from_xml_opt_str(node, 'crypto-algorithm')
    yang.gdata.maybe_add(children, 'crypto-algorithm', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key__crypto_algorithm, child_crypto_algorithm)
    child_auth_password = yang.gdata.from_xml_opt_str(node, 'auth-password')
    yang.gdata.maybe_add(children, 'auth-password', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key__auth_password, child_auth_password)
    return yang.gdata.Container(children)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication(yang.adata.MNode):
    hello_authentication: srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication
    keychain: ?str
    key: srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key

    mut def __init__(self, hello_authentication: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication=None, keychain: ?str, key: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key=None):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.hello_authentication = hello_authentication if hello_authentication is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication()
        self.keychain = keychain
        self.key = key if key is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _hello_authentication = self.hello_authentication
        if _hello_authentication is not None:
            children['hello-authentication'] = _hello_authentication.to_gdata()
        _keychain = self.keychain
        if _keychain is not None:
            children['keychain'] = yang.gdata.Leaf('leafref', _keychain)
        _key = self.key
        if _key is not None:
            children['key'] = _key.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication(hello_authentication=srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication.from_gdata(n.get_opt_cnt('hello-authentication')), keychain=n.get_opt_str('keychain'), key=srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key.from_gdata(n.get_opt_cnt('key')))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/interface/level/authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication()')
        leaves = []
        _hello_authentication = self.hello_authentication
        if _hello_authentication is not None:
            res.extend(_hello_authentication.prsrc('{self_name}.hello_authentication', False).splitlines())
        _keychain = self.keychain
        if _keychain is not None:
            leaves.append('{self_name}.keychain = {repr(_keychain)}')
        _key = self.key
        if _key is not None:
            res.extend(_key.prsrc('{self_name}.key', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/interface/level/authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'interface', 'level', 'authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_hello_authentication = yang.gdata.from_xml_opt_cnt(node, 'hello-authentication')
    yang.gdata.maybe_add(children, 'hello-authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__hello_authentication, child_hello_authentication)
    child_keychain = yang.gdata.from_xml_opt_str(node, 'keychain')
    yang.gdata.maybe_add(children, 'keychain', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__keychain, child_keychain)
    child_key = yang.gdata.from_xml_opt_cnt(node, 'key')
    yang.gdata.maybe_add(children, 'key', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication__key, child_key)
    return yang.gdata.Container(children)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level_entry(yang.adata.MNode):
    level_number: int
    disable: ?bool
    ipv6_unicast_metric: ?int
    metric: ?int
    priority: ?int
    passive: ?bool
    authentication: srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication

    mut def __init__(self, level_number: int, disable: ?bool, ipv6_unicast_metric: ?int, metric: ?int, priority: ?int, passive: ?bool, authentication: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication=None):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.level_number = level_number
        self.disable = disable
        self.ipv6_unicast_metric = ipv6_unicast_metric
        self.metric = metric
        self.priority = priority
        self.passive = passive
        self.authentication = authentication if authentication is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _level_number = self.level_number
        if _level_number is not None:
            children['level-number'] = yang.gdata.Leaf('uint8', _level_number)
        _disable = self.disable
        if _disable is not None:
            children['disable'] = yang.gdata.Leaf('boolean', _disable)
        _ipv6_unicast_metric = self.ipv6_unicast_metric
        if _ipv6_unicast_metric is not None:
            children['ipv6-unicast-metric'] = yang.gdata.Leaf('uint32', _ipv6_unicast_metric)
        _metric = self.metric
        if _metric is not None:
            children['metric'] = yang.gdata.Leaf('uint32', _metric)
        _priority = self.priority
        if _priority is not None:
            children['priority'] = yang.gdata.Leaf('uint8', _priority)
        _passive = self.passive
        if _passive is not None:
            children['passive'] = yang.gdata.Leaf('boolean', _passive)
        _authentication = self.authentication
        if _authentication is not None:
            children['authentication'] = _authentication.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level_entry:
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level_entry(level_number=n.get_int('level-number'), disable=n.get_opt_bool('disable'), ipv6_unicast_metric=n.get_opt_int('ipv6-unicast-metric'), metric=n.get_opt_int('metric'), priority=n.get_opt_int('priority'), passive=n.get_opt_bool('passive'), authentication=srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication.from_gdata(n.get_opt_cnt('authentication')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/interface/level')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level({repr(self.level_number)})')
        leaves = []
        _disable = self.disable
        if _disable is not None:
            leaves.append('{self_name}.disable = {repr(_disable)}')
        _ipv6_unicast_metric = self.ipv6_unicast_metric
        if _ipv6_unicast_metric is not None:
            leaves.append('{self_name}.ipv6_unicast_metric = {repr(_ipv6_unicast_metric)}')
        _metric = self.metric
        if _metric is not None:
            leaves.append('{self_name}.metric = {repr(_metric)}')
        _priority = self.priority
        if _priority is not None:
            leaves.append('{self_name}.priority = {repr(_priority)}')
        _passive = self.passive
        if _passive is not None:
            leaves.append('{self_name}.passive = {repr(_passive)}')
        _authentication = self.authentication
        if _authentication is not None:
            res.extend(_authentication.prsrc('{self_name}.authentication', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/interface/level'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'interface', 'level'])

class srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level(yang.adata.MNode):
    elements: list[srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self._name = 'level'
        self.elements = elements

    mut def create(self, level_number):
        for e in self:
            match = True
            if e.level_number != level_number:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level_entry(level_number)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['level-number'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level_entry]:
        if n is not None:
            return [srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level(elements=copied_elements)

extension srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level(Iterable[srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level_entry]):
    def __iter__(self) -> Iterator[srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_level_number = yang.gdata.from_xml_int(node, 'level-number')
    yang.gdata.maybe_add(children, 'level-number', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__level_number, child_level_number)
    child_disable = yang.gdata.from_xml_opt_bool(node, 'disable')
    yang.gdata.maybe_add(children, 'disable', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__disable, child_disable)
    child_ipv6_unicast_metric = yang.gdata.from_xml_opt_int(node, 'ipv6-unicast-metric')
    yang.gdata.maybe_add(children, 'ipv6-unicast-metric', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__ipv6_unicast_metric, child_ipv6_unicast_metric)
    child_metric = yang.gdata.from_xml_opt_int(node, 'metric')
    yang.gdata.maybe_add(children, 'metric', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__metric, child_metric)
    child_priority = yang.gdata.from_xml_opt_int(node, 'priority')
    yang.gdata.maybe_add(children, 'priority', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__priority, child_priority)
    child_passive = yang.gdata.from_xml_opt_bool(node, 'passive')
    yang.gdata.maybe_add(children, 'passive', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__passive, child_passive)
    child_authentication = yang.gdata.from_xml_opt_cnt(node, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level__authentication, child_authentication)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level_element(e) for e in nodes]
    return yang.gdata.List(keys=['level-number'], elements=elements)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication__generate(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication__check_received(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication(yang.adata.MNode):
    generate: ?bool
    check_received: ?str

    mut def __init__(self, generate: ?bool, check_received: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.generate = generate
        self.check_received = check_received

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _generate = self.generate
        if _generate is not None:
            children['generate'] = yang.gdata.Leaf('boolean', _generate)
        _check_received = self.check_received
        if _check_received is not None:
            children['check-received'] = yang.gdata.Leaf('enumeration', _check_received)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication(generate=n.get_opt_bool('generate'), check_received=n.get_opt_str('check-received'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/interface/authentication/hello-authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication()')
        leaves = []
        _generate = self.generate
        if _generate is not None:
            leaves.append('{self_name}.generate = {repr(_generate)}')
        _check_received = self.check_received
        if _check_received is not None:
            leaves.append('{self_name}.check_received = {repr(_check_received)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/interface/authentication/hello-authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'interface', 'authentication', 'hello-authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_generate = yang.gdata.from_xml_opt_bool(node, 'generate')
    yang.gdata.maybe_add(children, 'generate', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication__generate, child_generate)
    child_check_received = yang.gdata.from_xml_opt_str(node, 'check-received')
    yang.gdata.maybe_add(children, 'check-received', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication__check_received, child_check_received)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__keychain(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key__crypto_algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key__auth_password(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key(yang.adata.MNode):
    crypto_algorithm: ?str
    auth_password: ?str

    mut def __init__(self, crypto_algorithm: ?str, auth_password: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.crypto_algorithm = crypto_algorithm
        self.auth_password = auth_password

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _crypto_algorithm = self.crypto_algorithm
        if _crypto_algorithm is not None:
            children['crypto-algorithm'] = yang.gdata.Leaf('enumeration', _crypto_algorithm)
        _auth_password = self.auth_password
        if _auth_password is not None:
            children['auth-password'] = yang.gdata.Leaf('string', _auth_password)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key(crypto_algorithm=n.get_opt_str('crypto-algorithm'), auth_password=n.get_opt_str('auth-password'))
        raise ValueError('Missing required subtree srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key')

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/interface/authentication/key')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key()')
        leaves = []
        _crypto_algorithm = self.crypto_algorithm
        if _crypto_algorithm is not None:
            leaves.append('{self_name}.crypto_algorithm = {repr(_crypto_algorithm)}')
        _auth_password = self.auth_password
        if _auth_password is not None:
            leaves.append('{self_name}.auth_password = {repr(_auth_password)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/interface/authentication/key'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'interface', 'authentication', 'key'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_crypto_algorithm = yang.gdata.from_xml_opt_str(node, 'crypto-algorithm')
    yang.gdata.maybe_add(children, 'crypto-algorithm', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key__crypto_algorithm, child_crypto_algorithm)
    child_auth_password = yang.gdata.from_xml_opt_str(node, 'auth-password')
    yang.gdata.maybe_add(children, 'auth-password', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key__auth_password, child_auth_password)
    return yang.gdata.Container(children)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication(yang.adata.MNode):
    hello_authentication: srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication
    keychain: ?str
    key: srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key

    mut def __init__(self, hello_authentication: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication=None, keychain: ?str, key: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key=None):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.hello_authentication = hello_authentication if hello_authentication is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication()
        self.keychain = keychain
        self.key = key if key is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _hello_authentication = self.hello_authentication
        if _hello_authentication is not None:
            children['hello-authentication'] = _hello_authentication.to_gdata()
        _keychain = self.keychain
        if _keychain is not None:
            children['keychain'] = yang.gdata.Leaf('leafref', _keychain)
        _key = self.key
        if _key is not None:
            children['key'] = _key.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication(hello_authentication=srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication.from_gdata(n.get_opt_cnt('hello-authentication')), keychain=n.get_opt_str('keychain'), key=srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key.from_gdata(n.get_opt_cnt('key')))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/interface/authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication()')
        leaves = []
        _hello_authentication = self.hello_authentication
        if _hello_authentication is not None:
            res.extend(_hello_authentication.prsrc('{self_name}.hello_authentication', False).splitlines())
        _keychain = self.keychain
        if _keychain is not None:
            leaves.append('{self_name}.keychain = {repr(_keychain)}')
        _key = self.key
        if _key is not None:
            res.extend(_key.prsrc('{self_name}.key', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/interface/authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'interface', 'authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_hello_authentication = yang.gdata.from_xml_opt_cnt(node, 'hello-authentication')
    yang.gdata.maybe_add(children, 'hello-authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__hello_authentication, child_hello_authentication)
    child_keychain = yang.gdata.from_xml_opt_str(node, 'keychain')
    yang.gdata.maybe_add(children, 'keychain', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__keychain, child_keychain)
    child_key = yang.gdata.from_xml_opt_cnt(node, 'key')
    yang.gdata.maybe_add(children, 'key', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication__key, child_key)
    return yang.gdata.Container(children)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__interface_entry(yang.adata.MNode):
    interface_name: str
    interface_ref: srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref
    admin_state: ?str
    circuit_type: ?str
    delay: srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__delay
    hello_padding: ?str
    passive: ?bool
    ipv4_unicast: srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast
    ipv6_unicast: srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast
    level: srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level
    authentication: srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication

    mut def __init__(self, interface_name: str, interface_ref: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref=None, admin_state: ?str, circuit_type: ?str, delay: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__delay=None, hello_padding: ?str, passive: ?bool, ipv4_unicast: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast=None, ipv6_unicast: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast=None, level: list[srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level_entry]=[], authentication: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication=None):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.interface_name = interface_name
        self.interface_ref = interface_ref if interface_ref is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref()
        self.admin_state = admin_state
        self.circuit_type = circuit_type
        self.delay = delay if delay is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__delay()
        self.hello_padding = hello_padding
        self.passive = passive
        self.ipv4_unicast = ipv4_unicast if ipv4_unicast is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast()
        self.ipv6_unicast = ipv6_unicast if ipv6_unicast is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast()
        self.level = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level(elements=level)
        self.authentication = authentication if authentication is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _interface_name = self.interface_name
        if _interface_name is not None:
            children['interface-name'] = yang.gdata.Leaf('string', _interface_name)
        _interface_ref = self.interface_ref
        if _interface_ref is not None:
            children['interface-ref'] = _interface_ref.to_gdata()
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _circuit_type = self.circuit_type
        if _circuit_type is not None:
            children['circuit-type'] = yang.gdata.Leaf('enumeration', _circuit_type)
        _delay = self.delay
        if _delay is not None:
            children['delay'] = _delay.to_gdata()
        _hello_padding = self.hello_padding
        if _hello_padding is not None:
            children['hello-padding'] = yang.gdata.Leaf('enumeration', _hello_padding)
        _passive = self.passive
        if _passive is not None:
            children['passive'] = yang.gdata.Leaf('boolean', _passive)
        _ipv4_unicast = self.ipv4_unicast
        if _ipv4_unicast is not None:
            children['ipv4-unicast'] = _ipv4_unicast.to_gdata()
        _ipv6_unicast = self.ipv6_unicast
        if _ipv6_unicast is not None:
            children['ipv6-unicast'] = _ipv6_unicast.to_gdata()
        _level = self.level
        if _level is not None:
            children['level'] = _level.to_gdata()
        _authentication = self.authentication
        if _authentication is not None:
            children['authentication'] = _authentication.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__interface_entry:
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface_entry(interface_name=n.get_str('interface-name'), interface_ref=srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref.from_gdata(n.get_opt_cnt('interface-ref')), admin_state=n.get_opt_str('admin-state'), circuit_type=n.get_opt_str('circuit-type'), delay=srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__delay.from_gdata(n.get_opt_cnt('delay')), hello_padding=n.get_opt_str('hello-padding'), passive=n.get_opt_bool('passive'), ipv4_unicast=srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast.from_gdata(n.get_opt_cnt('ipv4-unicast')), ipv6_unicast=srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast.from_gdata(n.get_opt_cnt('ipv6-unicast')), level=srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level.from_gdata(n.get_opt_list('level')), authentication=srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication.from_gdata(n.get_opt_cnt('authentication')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/interface')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface({repr(self.interface_name)})')
        leaves = []
        _interface_ref = self.interface_ref
        if _interface_ref is not None:
            res.extend(_interface_ref.prsrc('{self_name}.interface_ref', False).splitlines())
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _circuit_type = self.circuit_type
        if _circuit_type is not None:
            leaves.append('{self_name}.circuit_type = {repr(_circuit_type)}')
        _delay = self.delay
        if _delay is not None:
            res.extend(_delay.prsrc('{self_name}.delay', False).splitlines())
        _hello_padding = self.hello_padding
        if _hello_padding is not None:
            leaves.append('{self_name}.hello_padding = {repr(_hello_padding)}')
        _passive = self.passive
        if _passive is not None:
            leaves.append('{self_name}.passive = {repr(_passive)}')
        _ipv4_unicast = self.ipv4_unicast
        if _ipv4_unicast is not None:
            res.extend(_ipv4_unicast.prsrc('{self_name}.ipv4_unicast', False).splitlines())
        _ipv6_unicast = self.ipv6_unicast
        if _ipv6_unicast is not None:
            res.extend(_ipv6_unicast.prsrc('{self_name}.ipv6_unicast', False).splitlines())
        _level = self.level
        for _element in _level:
            res.append('')
            res.append("# List /network-instance/protocols/isis/instance/interface/level element: {_element.to_gdata().key_str(['level-number'])}")
            list_elem = 'level_element = {self_name}.level.create({repr(_element.level_number)})'
            res.append(list_elem)
            res.extend(_element.prsrc('level_element', False, list_element=True).splitlines())
        _authentication = self.authentication
        if _authentication is not None:
            res.extend(_authentication.prsrc('{self_name}.authentication', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/interface'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'interface'])

class srl_nokia_network_instance__network_instance__protocols__isis__instance__interface(yang.adata.MNode):
    elements: list[srl_nokia_network_instance__network_instance__protocols__isis__instance__interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self._name = 'interface'
        self.elements = elements

    mut def create(self, interface_name):
        for e in self:
            match = True
            if e.interface_name != interface_name:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface_entry(interface_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['interface-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_network_instance__network_instance__protocols__isis__instance__interface_entry]:
        if n is not None:
            return [srl_nokia_network_instance__network_instance__protocols__isis__instance__interface_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__interface(elements=copied_elements)

extension srl_nokia_network_instance__network_instance__protocols__isis__instance__interface(Iterable[srl_nokia_network_instance__network_instance__protocols__isis__instance__interface_entry]):
    def __iter__(self) -> Iterator[srl_nokia_network_instance__network_instance__protocols__isis__instance__interface_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_interface_name = yang.gdata.from_xml_str(node, 'interface-name')
    yang.gdata.maybe_add(children, 'interface-name', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_name, child_interface_name)
    child_interface_ref = yang.gdata.from_xml_opt_cnt(node, 'interface-ref')
    yang.gdata.maybe_add(children, 'interface-ref', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__interface_ref, child_interface_ref)
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__admin_state, child_admin_state)
    child_circuit_type = yang.gdata.from_xml_opt_str(node, 'circuit-type')
    yang.gdata.maybe_add(children, 'circuit-type', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__circuit_type, child_circuit_type)
    child_delay = yang.gdata.from_xml_opt_cnt(node, 'delay')
    yang.gdata.maybe_add(children, 'delay', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__delay, child_delay)
    child_hello_padding = yang.gdata.from_xml_opt_str(node, 'hello-padding')
    yang.gdata.maybe_add(children, 'hello-padding', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__hello_padding, child_hello_padding)
    child_passive = yang.gdata.from_xml_opt_bool(node, 'passive')
    yang.gdata.maybe_add(children, 'passive', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__passive, child_passive)
    child_ipv4_unicast = yang.gdata.from_xml_opt_cnt(node, 'ipv4-unicast')
    yang.gdata.maybe_add(children, 'ipv4-unicast', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv4_unicast, child_ipv4_unicast)
    child_ipv6_unicast = yang.gdata.from_xml_opt_cnt(node, 'ipv6-unicast')
    yang.gdata.maybe_add(children, 'ipv6-unicast', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__ipv6_unicast, child_ipv6_unicast)
    child_level = yang.gdata.from_xml_opt_list(node, 'level')
    yang.gdata.maybe_add(children, 'level', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__level, child_level)
    child_authentication = yang.gdata.from_xml_opt_cnt(node, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface__authentication, child_authentication)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface_element(e) for e in nodes]
    return yang.gdata.List(keys=['interface-name'], elements=elements)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__level_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__metric_style(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__loopfree_alternate_exclude(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference__external(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference__internal(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference(yang.adata.MNode):
    external: ?int
    internal: ?int

    mut def __init__(self, external: ?int, internal: ?int):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.external = external
        self.internal = internal

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _external = self.external
        if _external is not None:
            children['external'] = yang.gdata.Leaf('uint8', _external)
        _internal = self.internal
        if _internal is not None:
            children['internal'] = yang.gdata.Leaf('uint8', _internal)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference(external=n.get_opt_int('external'), internal=n.get_opt_int('internal'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/level/route-preference')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference()')
        leaves = []
        _external = self.external
        if _external is not None:
            leaves.append('{self_name}.external = {repr(_external)}')
        _internal = self.internal
        if _internal is not None:
            leaves.append('{self_name}.internal = {repr(_internal)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/level/route-preference'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'level', 'route-preference'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_external = yang.gdata.from_xml_opt_int(node, 'external')
    yang.gdata.maybe_add(children, 'external', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference__external, child_external)
    child_internal = yang.gdata.from_xml_opt_int(node, 'internal')
    yang.gdata.maybe_add(children, 'internal', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference__internal, child_internal)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication__generate(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication__check_received(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication(yang.adata.MNode):
    generate: ?bool
    check_received: ?str

    mut def __init__(self, generate: ?bool, check_received: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.generate = generate
        self.check_received = check_received

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _generate = self.generate
        if _generate is not None:
            children['generate'] = yang.gdata.Leaf('boolean', _generate)
        _check_received = self.check_received
        if _check_received is not None:
            children['check-received'] = yang.gdata.Leaf('enumeration', _check_received)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication(generate=n.get_opt_bool('generate'), check_received=n.get_opt_str('check-received'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/level/authentication/csnp-authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication()')
        leaves = []
        _generate = self.generate
        if _generate is not None:
            leaves.append('{self_name}.generate = {repr(_generate)}')
        _check_received = self.check_received
        if _check_received is not None:
            leaves.append('{self_name}.check_received = {repr(_check_received)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/level/authentication/csnp-authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'level', 'authentication', 'csnp-authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_generate = yang.gdata.from_xml_opt_bool(node, 'generate')
    yang.gdata.maybe_add(children, 'generate', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication__generate, child_generate)
    child_check_received = yang.gdata.from_xml_opt_str(node, 'check-received')
    yang.gdata.maybe_add(children, 'check-received', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication__check_received, child_check_received)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication__generate(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication__check_received(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication(yang.adata.MNode):
    generate: ?bool
    check_received: ?str

    mut def __init__(self, generate: ?bool, check_received: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.generate = generate
        self.check_received = check_received

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _generate = self.generate
        if _generate is not None:
            children['generate'] = yang.gdata.Leaf('boolean', _generate)
        _check_received = self.check_received
        if _check_received is not None:
            children['check-received'] = yang.gdata.Leaf('enumeration', _check_received)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication(generate=n.get_opt_bool('generate'), check_received=n.get_opt_str('check-received'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/level/authentication/psnp-authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication()')
        leaves = []
        _generate = self.generate
        if _generate is not None:
            leaves.append('{self_name}.generate = {repr(_generate)}')
        _check_received = self.check_received
        if _check_received is not None:
            leaves.append('{self_name}.check_received = {repr(_check_received)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/level/authentication/psnp-authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'level', 'authentication', 'psnp-authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_generate = yang.gdata.from_xml_opt_bool(node, 'generate')
    yang.gdata.maybe_add(children, 'generate', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication__generate, child_generate)
    child_check_received = yang.gdata.from_xml_opt_str(node, 'check-received')
    yang.gdata.maybe_add(children, 'check-received', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication__check_received, child_check_received)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication__generate(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication__check_received(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication(yang.adata.MNode):
    generate: ?bool
    check_received: ?str

    mut def __init__(self, generate: ?bool, check_received: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.generate = generate
        self.check_received = check_received

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _generate = self.generate
        if _generate is not None:
            children['generate'] = yang.gdata.Leaf('boolean', _generate)
        _check_received = self.check_received
        if _check_received is not None:
            children['check-received'] = yang.gdata.Leaf('enumeration', _check_received)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication(generate=n.get_opt_bool('generate'), check_received=n.get_opt_str('check-received'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/level/authentication/hello-authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication()')
        leaves = []
        _generate = self.generate
        if _generate is not None:
            leaves.append('{self_name}.generate = {repr(_generate)}')
        _check_received = self.check_received
        if _check_received is not None:
            leaves.append('{self_name}.check_received = {repr(_check_received)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/level/authentication/hello-authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'level', 'authentication', 'hello-authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_generate = yang.gdata.from_xml_opt_bool(node, 'generate')
    yang.gdata.maybe_add(children, 'generate', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication__generate, child_generate)
    child_check_received = yang.gdata.from_xml_opt_str(node, 'check-received')
    yang.gdata.maybe_add(children, 'check-received', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication__check_received, child_check_received)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication__generate(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication__check_received(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication(yang.adata.MNode):
    generate: ?bool
    check_received: ?str

    mut def __init__(self, generate: ?bool, check_received: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.generate = generate
        self.check_received = check_received

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _generate = self.generate
        if _generate is not None:
            children['generate'] = yang.gdata.Leaf('boolean', _generate)
        _check_received = self.check_received
        if _check_received is not None:
            children['check-received'] = yang.gdata.Leaf('enumeration', _check_received)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication(generate=n.get_opt_bool('generate'), check_received=n.get_opt_str('check-received'))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/level/authentication/lsp-authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication()')
        leaves = []
        _generate = self.generate
        if _generate is not None:
            leaves.append('{self_name}.generate = {repr(_generate)}')
        _check_received = self.check_received
        if _check_received is not None:
            leaves.append('{self_name}.check_received = {repr(_check_received)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/level/authentication/lsp-authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'level', 'authentication', 'lsp-authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_generate = yang.gdata.from_xml_opt_bool(node, 'generate')
    yang.gdata.maybe_add(children, 'generate', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication__generate, child_generate)
    child_check_received = yang.gdata.from_xml_opt_str(node, 'check-received')
    yang.gdata.maybe_add(children, 'check-received', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication__check_received, child_check_received)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__keychain(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key__crypto_algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key__auth_password(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key(yang.adata.MNode):
    crypto_algorithm: ?str
    auth_password: ?str

    mut def __init__(self, crypto_algorithm: ?str, auth_password: ?str):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.crypto_algorithm = crypto_algorithm
        self.auth_password = auth_password

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _crypto_algorithm = self.crypto_algorithm
        if _crypto_algorithm is not None:
            children['crypto-algorithm'] = yang.gdata.Leaf('enumeration', _crypto_algorithm)
        _auth_password = self.auth_password
        if _auth_password is not None:
            children['auth-password'] = yang.gdata.Leaf('string', _auth_password)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key(crypto_algorithm=n.get_opt_str('crypto-algorithm'), auth_password=n.get_opt_str('auth-password'))
        raise ValueError('Missing required subtree srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key')

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/level/authentication/key')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key()')
        leaves = []
        _crypto_algorithm = self.crypto_algorithm
        if _crypto_algorithm is not None:
            leaves.append('{self_name}.crypto_algorithm = {repr(_crypto_algorithm)}')
        _auth_password = self.auth_password
        if _auth_password is not None:
            leaves.append('{self_name}.auth_password = {repr(_auth_password)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/level/authentication/key'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'level', 'authentication', 'key'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_crypto_algorithm = yang.gdata.from_xml_opt_str(node, 'crypto-algorithm')
    yang.gdata.maybe_add(children, 'crypto-algorithm', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key__crypto_algorithm, child_crypto_algorithm)
    child_auth_password = yang.gdata.from_xml_opt_str(node, 'auth-password')
    yang.gdata.maybe_add(children, 'auth-password', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key__auth_password, child_auth_password)
    return yang.gdata.Container(children)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication(yang.adata.MNode):
    csnp_authentication: srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication
    psnp_authentication: srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication
    hello_authentication: srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication
    lsp_authentication: srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication
    keychain: ?str
    key: srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key

    mut def __init__(self, csnp_authentication: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication=None, psnp_authentication: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication=None, hello_authentication: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication=None, lsp_authentication: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication=None, keychain: ?str, key: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key=None):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.csnp_authentication = csnp_authentication if csnp_authentication is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication()
        self.psnp_authentication = psnp_authentication if psnp_authentication is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication()
        self.hello_authentication = hello_authentication if hello_authentication is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication()
        self.lsp_authentication = lsp_authentication if lsp_authentication is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication()
        self.keychain = keychain
        self.key = key if key is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _csnp_authentication = self.csnp_authentication
        if _csnp_authentication is not None:
            children['csnp-authentication'] = _csnp_authentication.to_gdata()
        _psnp_authentication = self.psnp_authentication
        if _psnp_authentication is not None:
            children['psnp-authentication'] = _psnp_authentication.to_gdata()
        _hello_authentication = self.hello_authentication
        if _hello_authentication is not None:
            children['hello-authentication'] = _hello_authentication.to_gdata()
        _lsp_authentication = self.lsp_authentication
        if _lsp_authentication is not None:
            children['lsp-authentication'] = _lsp_authentication.to_gdata()
        _keychain = self.keychain
        if _keychain is not None:
            children['keychain'] = yang.gdata.Leaf('leafref', _keychain)
        _key = self.key
        if _key is not None:
            children['key'] = _key.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication(csnp_authentication=srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication.from_gdata(n.get_opt_cnt('csnp-authentication')), psnp_authentication=srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication.from_gdata(n.get_opt_cnt('psnp-authentication')), hello_authentication=srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication.from_gdata(n.get_opt_cnt('hello-authentication')), lsp_authentication=srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication.from_gdata(n.get_opt_cnt('lsp-authentication')), keychain=n.get_opt_str('keychain'), key=srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key.from_gdata(n.get_opt_cnt('key')))
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/level/authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication()')
        leaves = []
        _csnp_authentication = self.csnp_authentication
        if _csnp_authentication is not None:
            res.extend(_csnp_authentication.prsrc('{self_name}.csnp_authentication', False).splitlines())
        _psnp_authentication = self.psnp_authentication
        if _psnp_authentication is not None:
            res.extend(_psnp_authentication.prsrc('{self_name}.psnp_authentication', False).splitlines())
        _hello_authentication = self.hello_authentication
        if _hello_authentication is not None:
            res.extend(_hello_authentication.prsrc('{self_name}.hello_authentication', False).splitlines())
        _lsp_authentication = self.lsp_authentication
        if _lsp_authentication is not None:
            res.extend(_lsp_authentication.prsrc('{self_name}.lsp_authentication', False).splitlines())
        _keychain = self.keychain
        if _keychain is not None:
            leaves.append('{self_name}.keychain = {repr(_keychain)}')
        _key = self.key
        if _key is not None:
            res.extend(_key.prsrc('{self_name}.key', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/level/authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'level', 'authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_csnp_authentication = yang.gdata.from_xml_opt_cnt(node, 'csnp-authentication')
    yang.gdata.maybe_add(children, 'csnp-authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__csnp_authentication, child_csnp_authentication)
    child_psnp_authentication = yang.gdata.from_xml_opt_cnt(node, 'psnp-authentication')
    yang.gdata.maybe_add(children, 'psnp-authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__psnp_authentication, child_psnp_authentication)
    child_hello_authentication = yang.gdata.from_xml_opt_cnt(node, 'hello-authentication')
    yang.gdata.maybe_add(children, 'hello-authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__hello_authentication, child_hello_authentication)
    child_lsp_authentication = yang.gdata.from_xml_opt_cnt(node, 'lsp-authentication')
    yang.gdata.maybe_add(children, 'lsp-authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__lsp_authentication, child_lsp_authentication)
    child_keychain = yang.gdata.from_xml_opt_str(node, 'keychain')
    yang.gdata.maybe_add(children, 'keychain', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__keychain, child_keychain)
    child_key = yang.gdata.from_xml_opt_cnt(node, 'key')
    yang.gdata.maybe_add(children, 'key', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication__key, child_key)
    return yang.gdata.Container(children)

class srl_nokia_network_instance__network_instance__protocols__isis__instance__level_entry(yang.adata.MNode):
    level_number: int
    metric_style: ?str
    loopfree_alternate_exclude: ?bool
    route_preference: srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference
    authentication: srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication

    mut def __init__(self, level_number: int, metric_style: ?str, loopfree_alternate_exclude: ?bool, route_preference: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference=None, authentication: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication=None):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.level_number = level_number
        self.metric_style = metric_style
        self.loopfree_alternate_exclude = loopfree_alternate_exclude
        self.route_preference = route_preference if route_preference is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference()
        self.authentication = authentication if authentication is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _level_number = self.level_number
        if _level_number is not None:
            children['level-number'] = yang.gdata.Leaf('uint8', _level_number)
        _metric_style = self.metric_style
        if _metric_style is not None:
            children['metric-style'] = yang.gdata.Leaf('enumeration', _metric_style)
        _loopfree_alternate_exclude = self.loopfree_alternate_exclude
        if _loopfree_alternate_exclude is not None:
            children['loopfree-alternate-exclude'] = yang.gdata.Leaf('boolean', _loopfree_alternate_exclude)
        _route_preference = self.route_preference
        if _route_preference is not None:
            children['route-preference'] = _route_preference.to_gdata()
        _authentication = self.authentication
        if _authentication is not None:
            children['authentication'] = _authentication.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance__level_entry:
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level_entry(level_number=n.get_int('level-number'), metric_style=n.get_opt_str('metric-style'), loopfree_alternate_exclude=n.get_opt_bool('loopfree-alternate-exclude'), route_preference=srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference.from_gdata(n.get_opt_cnt('route-preference')), authentication=srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication.from_gdata(n.get_opt_cnt('authentication')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance/level')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance__level({repr(self.level_number)})')
        leaves = []
        _metric_style = self.metric_style
        if _metric_style is not None:
            leaves.append('{self_name}.metric_style = {repr(_metric_style)}')
        _loopfree_alternate_exclude = self.loopfree_alternate_exclude
        if _loopfree_alternate_exclude is not None:
            leaves.append('{self_name}.loopfree_alternate_exclude = {repr(_loopfree_alternate_exclude)}')
        _route_preference = self.route_preference
        if _route_preference is not None:
            res.extend(_route_preference.prsrc('{self_name}.route_preference', False).splitlines())
        _authentication = self.authentication
        if _authentication is not None:
            res.extend(_authentication.prsrc('{self_name}.authentication', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance/level'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance', 'level'])

class srl_nokia_network_instance__network_instance__protocols__isis__instance__level(yang.adata.MNode):
    elements: list[srl_nokia_network_instance__network_instance__protocols__isis__instance__level_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self._name = 'level'
        self.elements = elements

    mut def create(self, level_number):
        for e in self:
            match = True
            if e.level_number != level_number:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_network_instance__network_instance__protocols__isis__instance__level_entry(level_number)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['level-number'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_network_instance__network_instance__protocols__isis__instance__level_entry]:
        if n is not None:
            return [srl_nokia_network_instance__network_instance__protocols__isis__instance__level_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_network_instance__network_instance__protocols__isis__instance__level(elements=copied_elements)

extension srl_nokia_network_instance__network_instance__protocols__isis__instance__level(Iterable[srl_nokia_network_instance__network_instance__protocols__isis__instance__level_entry]):
    def __iter__(self) -> Iterator[srl_nokia_network_instance__network_instance__protocols__isis__instance__level_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_level_number = yang.gdata.from_xml_int(node, 'level-number')
    yang.gdata.maybe_add(children, 'level-number', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__level_number, child_level_number)
    child_metric_style = yang.gdata.from_xml_opt_str(node, 'metric-style')
    yang.gdata.maybe_add(children, 'metric-style', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__metric_style, child_metric_style)
    child_loopfree_alternate_exclude = yang.gdata.from_xml_opt_bool(node, 'loopfree-alternate-exclude')
    yang.gdata.maybe_add(children, 'loopfree-alternate-exclude', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__loopfree_alternate_exclude, child_loopfree_alternate_exclude)
    child_route_preference = yang.gdata.from_xml_opt_cnt(node, 'route-preference')
    yang.gdata.maybe_add(children, 'route-preference', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__route_preference, child_route_preference)
    child_authentication = yang.gdata.from_xml_opt_cnt(node, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level__authentication, child_authentication)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level_element(e) for e in nodes]
    return yang.gdata.List(keys=['level-number'], elements=elements)

class srl_nokia_network_instance__network_instance__protocols__isis__instance_entry(yang.adata.MNode):
    name: str
    admin_state: ?str
    instance_id: ?int
    net: list[str]
    level_capability: ?str
    max_ecmp_paths: ?int
    poi_tlv: ?bool
    iid_tlv: ?bool
    advertise_router_capability: ?bool
    prefix_attributes_tlv: ?bool
    export_policy: ?str
    hello_padding: ?str
    enable_csnp_on_p2p_links: ?bool
    attached_bit: srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit
    transport: srl_nokia_network_instance__network_instance__protocols__isis__instance__transport
    ipv4_unicast: srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv4_unicast
    ipv6_unicast: srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv6_unicast
    authentication: srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication
    interface: srl_nokia_network_instance__network_instance__protocols__isis__instance__interface
    level: srl_nokia_network_instance__network_instance__protocols__isis__instance__level

    mut def __init__(self, name: str, admin_state: ?str, instance_id: ?int, net: ?list[str]=None, level_capability: ?str, max_ecmp_paths: ?int, poi_tlv: ?bool, iid_tlv: ?bool, advertise_router_capability: ?bool, prefix_attributes_tlv: ?bool, export_policy: ?str, hello_padding: ?str, enable_csnp_on_p2p_links: ?bool, attached_bit: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit=None, transport: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__transport=None, ipv4_unicast: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv4_unicast=None, ipv6_unicast: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv6_unicast=None, authentication: ?srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication=None, interface: list[srl_nokia_network_instance__network_instance__protocols__isis__instance__interface_entry]=[], level: list[srl_nokia_network_instance__network_instance__protocols__isis__instance__level_entry]=[]):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.name = name
        self.admin_state = admin_state
        self.instance_id = instance_id
        self.net = net if net is not None else []
        self.level_capability = level_capability
        self.max_ecmp_paths = max_ecmp_paths
        self.poi_tlv = poi_tlv
        self.iid_tlv = iid_tlv
        self.advertise_router_capability = advertise_router_capability
        self.prefix_attributes_tlv = prefix_attributes_tlv
        self.export_policy = export_policy
        self.hello_padding = hello_padding
        self.enable_csnp_on_p2p_links = enable_csnp_on_p2p_links
        self.attached_bit = attached_bit if attached_bit is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit()
        self.transport = transport if transport is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__transport()
        self.ipv4_unicast = ipv4_unicast if ipv4_unicast is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv4_unicast()
        self.ipv6_unicast = ipv6_unicast if ipv6_unicast is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv6_unicast()
        self.authentication = authentication if authentication is not None else srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication()
        self.interface = srl_nokia_network_instance__network_instance__protocols__isis__instance__interface(elements=interface)
        self.level = srl_nokia_network_instance__network_instance__protocols__isis__instance__level(elements=level)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _instance_id = self.instance_id
        if _instance_id is not None:
            children['instance-id'] = yang.gdata.Leaf('uint32', _instance_id)
        _net = self.net
        if _net is not None:
            children['net'] = yang.gdata.LeafList('string', _net)
        _level_capability = self.level_capability
        if _level_capability is not None:
            children['level-capability'] = yang.gdata.Leaf('enumeration', _level_capability)
        _max_ecmp_paths = self.max_ecmp_paths
        if _max_ecmp_paths is not None:
            children['max-ecmp-paths'] = yang.gdata.Leaf('uint8', _max_ecmp_paths)
        _poi_tlv = self.poi_tlv
        if _poi_tlv is not None:
            children['poi-tlv'] = yang.gdata.Leaf('boolean', _poi_tlv)
        _iid_tlv = self.iid_tlv
        if _iid_tlv is not None:
            children['iid-tlv'] = yang.gdata.Leaf('boolean', _iid_tlv)
        _advertise_router_capability = self.advertise_router_capability
        if _advertise_router_capability is not None:
            children['advertise-router-capability'] = yang.gdata.Leaf('boolean', _advertise_router_capability)
        _prefix_attributes_tlv = self.prefix_attributes_tlv
        if _prefix_attributes_tlv is not None:
            children['prefix-attributes-tlv'] = yang.gdata.Leaf('boolean', _prefix_attributes_tlv)
        _export_policy = self.export_policy
        if _export_policy is not None:
            children['export-policy'] = yang.gdata.Leaf('leafref', _export_policy)
        _hello_padding = self.hello_padding
        if _hello_padding is not None:
            children['hello-padding'] = yang.gdata.Leaf('enumeration', _hello_padding)
        _enable_csnp_on_p2p_links = self.enable_csnp_on_p2p_links
        if _enable_csnp_on_p2p_links is not None:
            children['enable-csnp-on-p2p-links'] = yang.gdata.Leaf('boolean', _enable_csnp_on_p2p_links)
        _attached_bit = self.attached_bit
        if _attached_bit is not None:
            children['attached-bit'] = _attached_bit.to_gdata()
        _transport = self.transport
        if _transport is not None:
            children['transport'] = _transport.to_gdata()
        _ipv4_unicast = self.ipv4_unicast
        if _ipv4_unicast is not None:
            children['ipv4-unicast'] = _ipv4_unicast.to_gdata()
        _ipv6_unicast = self.ipv6_unicast
        if _ipv6_unicast is not None:
            children['ipv6-unicast'] = _ipv6_unicast.to_gdata()
        _authentication = self.authentication
        if _authentication is not None:
            children['authentication'] = _authentication.to_gdata()
        _interface = self.interface
        if _interface is not None:
            children['interface'] = _interface.to_gdata()
        _level = self.level
        if _level is not None:
            children['level'] = _level.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__isis__instance_entry:
        return srl_nokia_network_instance__network_instance__protocols__isis__instance_entry(name=n.get_str('name'), admin_state=n.get_opt_str('admin-state'), instance_id=n.get_opt_int('instance-id'), net=n.get_opt_strs('net'), level_capability=n.get_opt_str('level-capability'), max_ecmp_paths=n.get_opt_int('max-ecmp-paths'), poi_tlv=n.get_opt_bool('poi-tlv'), iid_tlv=n.get_opt_bool('iid-tlv'), advertise_router_capability=n.get_opt_bool('advertise-router-capability'), prefix_attributes_tlv=n.get_opt_bool('prefix-attributes-tlv'), export_policy=n.get_opt_str('export-policy'), hello_padding=n.get_opt_str('hello-padding'), enable_csnp_on_p2p_links=n.get_opt_bool('enable-csnp-on-p2p-links'), attached_bit=srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit.from_gdata(n.get_opt_cnt('attached-bit')), transport=srl_nokia_network_instance__network_instance__protocols__isis__instance__transport.from_gdata(n.get_opt_cnt('transport')), ipv4_unicast=srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv4_unicast.from_gdata(n.get_opt_cnt('ipv4-unicast')), ipv6_unicast=srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv6_unicast.from_gdata(n.get_opt_cnt('ipv6-unicast')), authentication=srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication.from_gdata(n.get_opt_cnt('authentication')), interface=srl_nokia_network_instance__network_instance__protocols__isis__instance__interface.from_gdata(n.get_opt_list('interface')), level=srl_nokia_network_instance__network_instance__protocols__isis__instance__level.from_gdata(n.get_opt_list('level')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__isis__instance_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis/instance')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis__instance({repr(self.name)})')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _instance_id = self.instance_id
        if _instance_id is not None:
            leaves.append('{self_name}.instance_id = {repr(_instance_id)}')
        _net = self.net
        if len(_net) != 0:
            leaves.append('{self_name}.net = {repr(_net)}')
        _level_capability = self.level_capability
        if _level_capability is not None:
            leaves.append('{self_name}.level_capability = {repr(_level_capability)}')
        _max_ecmp_paths = self.max_ecmp_paths
        if _max_ecmp_paths is not None:
            leaves.append('{self_name}.max_ecmp_paths = {repr(_max_ecmp_paths)}')
        _poi_tlv = self.poi_tlv
        if _poi_tlv is not None:
            leaves.append('{self_name}.poi_tlv = {repr(_poi_tlv)}')
        _iid_tlv = self.iid_tlv
        if _iid_tlv is not None:
            leaves.append('{self_name}.iid_tlv = {repr(_iid_tlv)}')
        _advertise_router_capability = self.advertise_router_capability
        if _advertise_router_capability is not None:
            leaves.append('{self_name}.advertise_router_capability = {repr(_advertise_router_capability)}')
        _prefix_attributes_tlv = self.prefix_attributes_tlv
        if _prefix_attributes_tlv is not None:
            leaves.append('{self_name}.prefix_attributes_tlv = {repr(_prefix_attributes_tlv)}')
        _export_policy = self.export_policy
        if _export_policy is not None:
            leaves.append('{self_name}.export_policy = {repr(_export_policy)}')
        _hello_padding = self.hello_padding
        if _hello_padding is not None:
            leaves.append('{self_name}.hello_padding = {repr(_hello_padding)}')
        _enable_csnp_on_p2p_links = self.enable_csnp_on_p2p_links
        if _enable_csnp_on_p2p_links is not None:
            leaves.append('{self_name}.enable_csnp_on_p2p_links = {repr(_enable_csnp_on_p2p_links)}')
        _attached_bit = self.attached_bit
        if _attached_bit is not None:
            res.extend(_attached_bit.prsrc('{self_name}.attached_bit', False).splitlines())
        _transport = self.transport
        if _transport is not None:
            res.extend(_transport.prsrc('{self_name}.transport', False).splitlines())
        _ipv4_unicast = self.ipv4_unicast
        if _ipv4_unicast is not None:
            res.extend(_ipv4_unicast.prsrc('{self_name}.ipv4_unicast', False).splitlines())
        _ipv6_unicast = self.ipv6_unicast
        if _ipv6_unicast is not None:
            res.extend(_ipv6_unicast.prsrc('{self_name}.ipv6_unicast', False).splitlines())
        _authentication = self.authentication
        if _authentication is not None:
            res.extend(_authentication.prsrc('{self_name}.authentication', False).splitlines())
        _interface = self.interface
        for _element in _interface:
            res.append('')
            res.append("# List /network-instance/protocols/isis/instance/interface element: {_element.to_gdata().key_str(['interface-name'])}")
            list_elem = 'interface_element = {self_name}.interface.create({repr(_element.interface_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('interface_element', False, list_element=True).splitlines())
        _level = self.level
        for _element in _level:
            res.append('')
            res.append("# List /network-instance/protocols/isis/instance/level element: {_element.to_gdata().key_str(['level-number'])}")
            list_elem = 'level_element = {self_name}.level.create({repr(_element.level_number)})'
            res.append(list_elem)
            res.extend(_element.prsrc('level_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis/instance'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis', 'instance'])

class srl_nokia_network_instance__network_instance__protocols__isis__instance(yang.adata.MNode):
    elements: list[srl_nokia_network_instance__network_instance__protocols__isis__instance_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self._name = 'instance'
        self.elements = elements

    mut def create(self, name):
        for e in self:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_network_instance__network_instance__protocols__isis__instance_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_network_instance__network_instance__protocols__isis__instance_entry]:
        if n is not None:
            return [srl_nokia_network_instance__network_instance__protocols__isis__instance_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_network_instance__network_instance__protocols__isis__instance(elements=copied_elements)

extension srl_nokia_network_instance__network_instance__protocols__isis__instance(Iterable[srl_nokia_network_instance__network_instance__protocols__isis__instance_entry]):
    def __iter__(self) -> Iterator[srl_nokia_network_instance__network_instance__protocols__isis__instance_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__name, child_name)
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__admin_state, child_admin_state)
    child_instance_id = yang.gdata.from_xml_opt_int(node, 'instance-id')
    yang.gdata.maybe_add(children, 'instance-id', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__instance_id, child_instance_id)
    child_net = yang.gdata.from_xml_opt_strs(node, 'net')
    yang.gdata.maybe_add(children, 'net', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__net, child_net)
    child_level_capability = yang.gdata.from_xml_opt_str(node, 'level-capability')
    yang.gdata.maybe_add(children, 'level-capability', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__level_capability, child_level_capability)
    child_max_ecmp_paths = yang.gdata.from_xml_opt_int(node, 'max-ecmp-paths')
    yang.gdata.maybe_add(children, 'max-ecmp-paths', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__max_ecmp_paths, child_max_ecmp_paths)
    child_poi_tlv = yang.gdata.from_xml_opt_bool(node, 'poi-tlv')
    yang.gdata.maybe_add(children, 'poi-tlv', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__poi_tlv, child_poi_tlv)
    child_iid_tlv = yang.gdata.from_xml_opt_bool(node, 'iid-tlv')
    yang.gdata.maybe_add(children, 'iid-tlv', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__iid_tlv, child_iid_tlv)
    child_advertise_router_capability = yang.gdata.from_xml_opt_bool(node, 'advertise-router-capability')
    yang.gdata.maybe_add(children, 'advertise-router-capability', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__advertise_router_capability, child_advertise_router_capability)
    child_prefix_attributes_tlv = yang.gdata.from_xml_opt_bool(node, 'prefix-attributes-tlv')
    yang.gdata.maybe_add(children, 'prefix-attributes-tlv', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__prefix_attributes_tlv, child_prefix_attributes_tlv)
    child_export_policy = yang.gdata.from_xml_opt_str(node, 'export-policy')
    yang.gdata.maybe_add(children, 'export-policy', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__export_policy, child_export_policy)
    child_hello_padding = yang.gdata.from_xml_opt_str(node, 'hello-padding')
    yang.gdata.maybe_add(children, 'hello-padding', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__hello_padding, child_hello_padding)
    child_enable_csnp_on_p2p_links = yang.gdata.from_xml_opt_bool(node, 'enable-csnp-on-p2p-links')
    yang.gdata.maybe_add(children, 'enable-csnp-on-p2p-links', from_data_srl_nokia_network_instance__network_instance__protocols__isis__instance__enable_csnp_on_p2p_links, child_enable_csnp_on_p2p_links)
    child_attached_bit = yang.gdata.from_xml_opt_cnt(node, 'attached-bit')
    yang.gdata.maybe_add(children, 'attached-bit', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__attached_bit, child_attached_bit)
    child_transport = yang.gdata.from_xml_opt_cnt(node, 'transport')
    yang.gdata.maybe_add(children, 'transport', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__transport, child_transport)
    child_ipv4_unicast = yang.gdata.from_xml_opt_cnt(node, 'ipv4-unicast')
    yang.gdata.maybe_add(children, 'ipv4-unicast', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv4_unicast, child_ipv4_unicast)
    child_ipv6_unicast = yang.gdata.from_xml_opt_cnt(node, 'ipv6-unicast')
    yang.gdata.maybe_add(children, 'ipv6-unicast', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__ipv6_unicast, child_ipv6_unicast)
    child_authentication = yang.gdata.from_xml_opt_cnt(node, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__authentication, child_authentication)
    child_interface = yang.gdata.from_xml_opt_list(node, 'interface')
    yang.gdata.maybe_add(children, 'interface', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__interface, child_interface)
    child_level = yang.gdata.from_xml_opt_list(node, 'level')
    yang.gdata.maybe_add(children, 'level', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance__level, child_level)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements)

class srl_nokia_network_instance__network_instance__protocols__isis(yang.adata.MNode):
    instance: srl_nokia_network_instance__network_instance__protocols__isis__instance

    mut def __init__(self, instance: list[srl_nokia_network_instance__network_instance__protocols__isis__instance_entry]=[]):
        self._ns = 'urn:nokia.com:srlinux:isis:isis'
        self.instance = srl_nokia_network_instance__network_instance__protocols__isis__instance(elements=instance)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _instance = self.instance
        if _instance is not None:
            children['instance'] = _instance.to_gdata()
        return yang.gdata.Container(children, presence=True, ns='urn:nokia.com:srlinux:isis:isis', module='srl_nokia-isis')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?srl_nokia_network_instance__network_instance__protocols__isis:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__isis(instance=srl_nokia_network_instance__network_instance__protocols__isis__instance.from_gdata(n.get_opt_list('instance')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = srl_nokia_network_instance__network_instance__protocols__isis.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in srl_nokia_network_instance__network_instance__protocols__isis.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/isis')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__isis()')
        leaves = []
        _instance = self.instance
        for _element in _instance:
            res.append('')
            res.append("# List /network-instance/protocols/isis/instance element: {_element.to_gdata().key_str(['name'])}")
            list_elem = 'instance_element = {self_name}.instance.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('instance_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/isis'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-isis:isis'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__isis(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_instance = yang.gdata.from_xml_opt_list(node, 'instance')
    yang.gdata.maybe_add(children, 'instance', from_xml_srl_nokia_network_instance__network_instance__protocols__isis__instance, child_instance)
    return yang.gdata.Container(children, presence=True, ns='urn:nokia.com:srlinux:isis:isis', module='srl_nokia-isis')

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__autonomous_system(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__local_preference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__router_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__allow_own_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as__mode(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as__leading_only(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as__ignore_peer_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as(yang.adata.MNode):
    mode: ?str
    leading_only: ?bool
    ignore_peer_as: ?bool

    mut def __init__(self, mode: ?str, leading_only: ?bool, ignore_peer_as: ?bool):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.mode = mode
        self.leading_only = leading_only
        self.ignore_peer_as = ignore_peer_as

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _mode = self.mode
        if _mode is not None:
            children['mode'] = yang.gdata.Leaf('enumeration', _mode)
        _leading_only = self.leading_only
        if _leading_only is not None:
            children['leading-only'] = yang.gdata.Leaf('boolean', _leading_only)
        _ignore_peer_as = self.ignore_peer_as
        if _ignore_peer_as is not None:
            children['ignore-peer-as'] = yang.gdata.Leaf('boolean', _ignore_peer_as)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as(mode=n.get_opt_str('mode'), leading_only=n.get_opt_bool('leading-only'), ignore_peer_as=n.get_opt_bool('ignore-peer-as'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/as-path-options/remove-private-as')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as()')
        leaves = []
        _mode = self.mode
        if _mode is not None:
            leaves.append('{self_name}.mode = {repr(_mode)}')
        _leading_only = self.leading_only
        if _leading_only is not None:
            leaves.append('{self_name}.leading_only = {repr(_leading_only)}')
        _ignore_peer_as = self.ignore_peer_as
        if _ignore_peer_as is not None:
            leaves.append('{self_name}.ignore_peer_as = {repr(_ignore_peer_as)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/as-path-options/remove-private-as'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'as-path-options', 'remove-private-as'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_mode = yang.gdata.from_xml_opt_str(node, 'mode')
    yang.gdata.maybe_add(children, 'mode', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as__mode, child_mode)
    child_leading_only = yang.gdata.from_xml_opt_bool(node, 'leading-only')
    yang.gdata.maybe_add(children, 'leading-only', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as__leading_only, child_leading_only)
    child_ignore_peer_as = yang.gdata.from_xml_opt_bool(node, 'ignore-peer-as')
    yang.gdata.maybe_add(children, 'ignore-peer-as', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as__ignore_peer_as, child_ignore_peer_as)
    return yang.gdata.Container(children)

class srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options(yang.adata.MNode):
    allow_own_as: ?int
    remove_private_as: srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as

    mut def __init__(self, allow_own_as: ?int, remove_private_as: ?srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as=None):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.allow_own_as = allow_own_as
        self.remove_private_as = remove_private_as if remove_private_as is not None else srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _allow_own_as = self.allow_own_as
        if _allow_own_as is not None:
            children['allow-own-as'] = yang.gdata.Leaf('uint8', _allow_own_as)
        _remove_private_as = self.remove_private_as
        if _remove_private_as is not None:
            children['remove-private-as'] = _remove_private_as.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options(allow_own_as=n.get_opt_int('allow-own-as'), remove_private_as=srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as.from_gdata(n.get_opt_cnt('remove-private-as')))
        return srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/as-path-options')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options()')
        leaves = []
        _allow_own_as = self.allow_own_as
        if _allow_own_as is not None:
            leaves.append('{self_name}.allow_own_as = {repr(_allow_own_as)}')
        _remove_private_as = self.remove_private_as
        if _remove_private_as is not None:
            res.extend(_remove_private_as.prsrc('{self_name}.remove_private_as', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/as-path-options'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'as-path-options'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_allow_own_as = yang.gdata.from_xml_opt_int(node, 'allow-own-as')
    yang.gdata.maybe_add(children, 'allow-own-as', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__allow_own_as, child_allow_own_as)
    child_remove_private_as = yang.gdata.from_xml_opt_cnt(node, 'remove-private-as')
    yang.gdata.maybe_add(children, 'remove-private-as', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options__remove_private_as, child_remove_private_as)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__authentication__keychain(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__authentication__password(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__authentication(yang.adata.MNode):
    keychain: ?str
    password: ?str

    mut def __init__(self, keychain: ?str, password: ?str):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.keychain = keychain
        self.password = password

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _keychain = self.keychain
        if _keychain is not None:
            children['keychain'] = yang.gdata.Leaf('leafref', _keychain)
        _password = self.password
        if _password is not None:
            children['password'] = yang.gdata.Leaf('string', _password)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__authentication(keychain=n.get_opt_str('keychain'), password=n.get_opt_str('password'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__authentication()')
        leaves = []
        _keychain = self.keychain
        if _keychain is not None:
            leaves.append('{self_name}.keychain = {repr(_keychain)}')
        _password = self.password
        if _password is not None:
            leaves.append('{self_name}.password = {repr(_password)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_keychain = yang.gdata.from_xml_opt_str(node, 'keychain')
    yang.gdata.maybe_add(children, 'keychain', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__authentication__keychain, child_keychain)
    child_password = yang.gdata.from_xml_opt_str(node, 'password')
    yang.gdata.maybe_add(children, 'password', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__authentication__password, child_password)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy__import_reject_all(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy__export_reject_all(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy(yang.adata.MNode):
    import_reject_all: ?bool
    export_reject_all: ?bool

    mut def __init__(self, import_reject_all: ?bool, export_reject_all: ?bool):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.import_reject_all = import_reject_all
        self.export_reject_all = export_reject_all

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _import_reject_all = self.import_reject_all
        if _import_reject_all is not None:
            children['import-reject-all'] = yang.gdata.Leaf('boolean', _import_reject_all)
        _export_reject_all = self.export_reject_all
        if _export_reject_all is not None:
            children['export-reject-all'] = yang.gdata.Leaf('boolean', _export_reject_all)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy(import_reject_all=n.get_opt_bool('import-reject-all'), export_reject_all=n.get_opt_bool('export-reject-all'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/ebgp-default-policy')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy()')
        leaves = []
        _import_reject_all = self.import_reject_all
        if _import_reject_all is not None:
            leaves.append('{self_name}.import_reject_all = {repr(_import_reject_all)}')
        _export_reject_all = self.export_reject_all
        if _export_reject_all is not None:
            leaves.append('{self_name}.export_reject_all = {repr(_export_reject_all)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/ebgp-default-policy'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'ebgp-default-policy'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_import_reject_all = yang.gdata.from_xml_opt_bool(node, 'import-reject-all')
    yang.gdata.maybe_add(children, 'import-reject-all', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy__import_reject_all, child_import_reject_all)
    child_export_reject_all = yang.gdata.from_xml_opt_bool(node, 'export-reject-all')
    yang.gdata.maybe_add(children, 'export-reject-all', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy__export_reject_all, child_export_reject_all)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi__afi_safi_name(val: value) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['srl_nokia-comm:bgp-address-family'], 'srl_nokia-bgp')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf afi-safi-name: {error}')

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi_entry(yang.adata.MNode):
    afi_safi_name: Identityref
    admin_state: ?str

    mut def __init__(self, afi_safi_name: Identityref, admin_state: ?str):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.afi_safi_name = afi_safi_name
        self.admin_state = admin_state

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _afi_safi_name = self.afi_safi_name
        if _afi_safi_name is not None:
            _identityref_afi_safi_name, error = complete_and_validate_identityref(_afi_safi_name, _identities, ['srl_nokia-comm:bgp-address-family'], 'srl_nokia-bgp')
            if _identityref_afi_safi_name is not None:
                _afi_safi_name = _identityref_afi_safi_name
            else:
                raise ValueError('Invalid value for identityref leaf afi-safi-name: {error}')
            children['afi-safi-name'] = yang.gdata.Leaf('identityref', _afi_safi_name)
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi_entry:
        return srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi_entry(afi_safi_name=n.get_Identityref('afi-safi-name'), admin_state=n.get_opt_str('admin-state'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/afi-safi')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi({repr(self.afi_safi_name)})')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/afi-safi'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'afi-safi'])

class srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi(yang.adata.MNode):
    elements: list[srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self._name = 'afi-safi'
        self.elements = elements

    mut def create(self, afi_safi_name):
        for e in self:
            match = True
            if e.afi_safi_name != afi_safi_name:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi_entry(afi_safi_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['afi-safi-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi_entry]:
        if n is not None:
            return [srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi(elements=copied_elements)

extension srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi(Iterable[srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi_entry]):
    def __iter__(self) -> Iterator[srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_afi_safi_name = yang.gdata.from_xml_Identityref(node, 'afi-safi-name')
    yang.gdata.maybe_add(children, 'afi-safi-name', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi__afi_safi_name, child_afi_safi_name)
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi__admin_state, child_admin_state)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi_element(e) for e in nodes]
    return yang.gdata.List(keys=['afi-safi-name'], elements=elements)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__preference__ebgp(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__preference__ibgp(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__preference(yang.adata.MNode):
    ebgp: ?int
    ibgp: ?int

    mut def __init__(self, ebgp: ?int, ibgp: ?int):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.ebgp = ebgp
        self.ibgp = ibgp

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ebgp = self.ebgp
        if _ebgp is not None:
            children['ebgp'] = yang.gdata.Leaf('uint8', _ebgp)
        _ibgp = self.ibgp
        if _ibgp is not None:
            children['ibgp'] = yang.gdata.Leaf('uint8', _ibgp)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__preference:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__preference(ebgp=n.get_opt_int('ebgp'), ibgp=n.get_opt_int('ibgp'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__preference()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__preference.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/preference')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__preference()')
        leaves = []
        _ebgp = self.ebgp
        if _ebgp is not None:
            leaves.append('{self_name}.ebgp = {repr(_ebgp)}')
        _ibgp = self.ibgp
        if _ibgp is not None:
            leaves.append('{self_name}.ibgp = {repr(_ibgp)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/preference'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'preference'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__preference(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ebgp = yang.gdata.from_xml_opt_int(node, 'ebgp')
    yang.gdata.maybe_add(children, 'ebgp', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__preference__ebgp, child_ebgp)
    child_ibgp = yang.gdata.from_xml_opt_int(node, 'ibgp')
    yang.gdata.maybe_add(children, 'ibgp', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__preference__ibgp, child_ibgp)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table__address_family(val: value) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['srl_nokia-comm:bgp-address-family'], 'srl_nokia-bgp')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf address-family: {error}')

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table__route_table_import(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table_entry(yang.adata.MNode):
    address_family: Identityref
    route_table_import: ?str

    mut def __init__(self, address_family: Identityref, route_table_import: ?str):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.address_family = address_family
        self.route_table_import = route_table_import

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address_family = self.address_family
        if _address_family is not None:
            _identityref_address_family, error = complete_and_validate_identityref(_address_family, _identities, ['srl_nokia-comm:bgp-address-family'], 'srl_nokia-bgp')
            if _identityref_address_family is not None:
                _address_family = _identityref_address_family
            else:
                raise ValueError('Invalid value for identityref leaf address-family: {error}')
            children['address-family'] = yang.gdata.Leaf('identityref', _address_family)
        _route_table_import = self.route_table_import
        if _route_table_import is not None:
            children['route-table-import'] = yang.gdata.Leaf('leafref', _route_table_import)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table_entry:
        return srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table_entry(address_family=n.get_Identityref('address-family'), route_table_import=n.get_opt_str('route-table-import'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/rib-management/table')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table({repr(self.address_family)})')
        leaves = []
        _route_table_import = self.route_table_import
        if _route_table_import is not None:
            leaves.append('{self_name}.route_table_import = {repr(_route_table_import)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/rib-management/table'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'rib-management', 'table'])

class srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table(yang.adata.MNode):
    elements: list[srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self._name = 'table'
        self.elements = elements

    mut def create(self, address_family):
        for e in self:
            match = True
            if e.address_family != address_family:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table_entry(address_family)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['address-family'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table_entry]:
        if n is not None:
            return [srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table(elements=copied_elements)

extension srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table(Iterable[srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table_entry]):
    def __iter__(self) -> Iterator[srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_address_family = yang.gdata.from_xml_Identityref(node, 'address-family')
    yang.gdata.maybe_add(children, 'address-family', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table__address_family, child_address_family)
    child_route_table_import = yang.gdata.from_xml_opt_str(node, 'route-table-import')
    yang.gdata.maybe_add(children, 'route-table-import', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table__route_table_import, child_route_table_import)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table_element(e) for e in nodes]
    return yang.gdata.List(keys=['address-family'], elements=elements)

class srl_nokia_network_instance__network_instance__protocols__bgp__rib_management(yang.adata.MNode):
    table: srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table

    mut def __init__(self, table: list[srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table_entry]=[]):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.table = srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table(elements=table)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _table = self.table
        if _table is not None:
            children['table'] = _table.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__rib_management:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__rib_management(table=srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table.from_gdata(n.get_opt_list('table')))
        return srl_nokia_network_instance__network_instance__protocols__bgp__rib_management()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__rib_management.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/rib-management')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__rib_management()')
        leaves = []
        _table = self.table
        for _element in _table:
            res.append('')
            res.append("# List /network-instance/protocols/bgp/rib-management/table element: {_element.to_gdata().key_str(['address-family'])}")
            list_elem = 'table_element = {self_name}.table.create({repr(_element.address_family)})'
            res.append(list_elem)
            res.extend(_element.prsrc('table_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/rib-management'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'rib-management'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__rib_management(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_table = yang.gdata.from_xml_opt_list(node, 'table')
    yang.gdata.maybe_add(children, 'table', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__rib_management__table, child_table)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement__rapid_withdrawal(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement__wait_for_fib_install(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement(yang.adata.MNode):
    rapid_withdrawal: ?bool
    wait_for_fib_install: ?bool

    mut def __init__(self, rapid_withdrawal: ?bool, wait_for_fib_install: ?bool):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.rapid_withdrawal = rapid_withdrawal
        self.wait_for_fib_install = wait_for_fib_install

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rapid_withdrawal = self.rapid_withdrawal
        if _rapid_withdrawal is not None:
            children['rapid-withdrawal'] = yang.gdata.Leaf('boolean', _rapid_withdrawal)
        _wait_for_fib_install = self.wait_for_fib_install
        if _wait_for_fib_install is not None:
            children['wait-for-fib-install'] = yang.gdata.Leaf('boolean', _wait_for_fib_install)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement(rapid_withdrawal=n.get_opt_bool('rapid-withdrawal'), wait_for_fib_install=n.get_opt_bool('wait-for-fib-install'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/route-advertisement')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement()')
        leaves = []
        _rapid_withdrawal = self.rapid_withdrawal
        if _rapid_withdrawal is not None:
            leaves.append('{self_name}.rapid_withdrawal = {repr(_rapid_withdrawal)}')
        _wait_for_fib_install = self.wait_for_fib_install
        if _wait_for_fib_install is not None:
            leaves.append('{self_name}.wait_for_fib_install = {repr(_wait_for_fib_install)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/route-advertisement'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'route-advertisement'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_rapid_withdrawal = yang.gdata.from_xml_opt_bool(node, 'rapid-withdrawal')
    yang.gdata.maybe_add(children, 'rapid-withdrawal', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement__rapid_withdrawal, child_rapid_withdrawal)
    child_wait_for_fib_install = yang.gdata.from_xml_opt_bool(node, 'wait-for-fib-install')
    yang.gdata.maybe_add(children, 'wait-for-fib-install', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement__wait_for_fib_install, child_wait_for_fib_install)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping__half_life(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping__max_suppress_time(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping__reuse_threshold(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping__suppress_threshold(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping(yang.adata.MNode):
    half_life: ?int
    max_suppress_time: ?int
    reuse_threshold: ?int
    suppress_threshold: ?int

    mut def __init__(self, half_life: ?int, max_suppress_time: ?int, reuse_threshold: ?int, suppress_threshold: ?int):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.half_life = half_life
        self.max_suppress_time = max_suppress_time
        self.reuse_threshold = reuse_threshold
        self.suppress_threshold = suppress_threshold

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _half_life = self.half_life
        if _half_life is not None:
            children['half-life'] = yang.gdata.Leaf('uint16', _half_life)
        _max_suppress_time = self.max_suppress_time
        if _max_suppress_time is not None:
            children['max-suppress-time'] = yang.gdata.Leaf('uint16', _max_suppress_time)
        _reuse_threshold = self.reuse_threshold
        if _reuse_threshold is not None:
            children['reuse-threshold'] = yang.gdata.Leaf('uint16', _reuse_threshold)
        _suppress_threshold = self.suppress_threshold
        if _suppress_threshold is not None:
            children['suppress-threshold'] = yang.gdata.Leaf('uint16', _suppress_threshold)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping(half_life=n.get_opt_int('half-life'), max_suppress_time=n.get_opt_int('max-suppress-time'), reuse_threshold=n.get_opt_int('reuse-threshold'), suppress_threshold=n.get_opt_int('suppress-threshold'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/route-flap-damping')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping()')
        leaves = []
        _half_life = self.half_life
        if _half_life is not None:
            leaves.append('{self_name}.half_life = {repr(_half_life)}')
        _max_suppress_time = self.max_suppress_time
        if _max_suppress_time is not None:
            leaves.append('{self_name}.max_suppress_time = {repr(_max_suppress_time)}')
        _reuse_threshold = self.reuse_threshold
        if _reuse_threshold is not None:
            leaves.append('{self_name}.reuse_threshold = {repr(_reuse_threshold)}')
        _suppress_threshold = self.suppress_threshold
        if _suppress_threshold is not None:
            leaves.append('{self_name}.suppress_threshold = {repr(_suppress_threshold)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/route-flap-damping'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'route-flap-damping'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_half_life = yang.gdata.from_xml_opt_int(node, 'half-life')
    yang.gdata.maybe_add(children, 'half-life', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping__half_life, child_half_life)
    child_max_suppress_time = yang.gdata.from_xml_opt_int(node, 'max-suppress-time')
    yang.gdata.maybe_add(children, 'max-suppress-time', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping__max_suppress_time, child_max_suppress_time)
    child_reuse_threshold = yang.gdata.from_xml_opt_int(node, 'reuse-threshold')
    yang.gdata.maybe_add(children, 'reuse-threshold', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping__reuse_threshold, child_reuse_threshold)
    child_suppress_threshold = yang.gdata.from_xml_opt_int(node, 'suppress-threshold')
    yang.gdata.maybe_add(children, 'suppress-threshold', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping__suppress_threshold, child_suppress_threshold)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector__client(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector__cluster_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector(yang.adata.MNode):
    client: ?bool
    cluster_id: ?value

    mut def __init__(self, client: ?bool, cluster_id: ?value):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.client = client
        self.cluster_id = cluster_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _client = self.client
        if _client is not None:
            children['client'] = yang.gdata.Leaf('boolean', _client)
        _cluster_id = self.cluster_id
        if _cluster_id is not None:
            children['cluster-id'] = yang.gdata.Leaf('union', _cluster_id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector(client=n.get_opt_bool('client'), cluster_id=n.get_opt_value('cluster-id'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/route-reflector')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector()')
        leaves = []
        _client = self.client
        if _client is not None:
            leaves.append('{self_name}.client = {repr(_client)}')
        _cluster_id = self.cluster_id
        if _cluster_id is not None:
            leaves.append('{self_name}.cluster_id = {repr(_cluster_id)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/route-reflector'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'route-reflector'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_client = yang.gdata.from_xml_opt_bool(node, 'client')
    yang.gdata.maybe_add(children, 'client', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector__client, child_client)
    child_cluster_id = yang.gdata.from_xml_opt_value(node, 'cluster-id')
    yang.gdata.maybe_add(children, 'cluster-id', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector__cluster_id, child_cluster_id)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__segment_routing_mpls__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__segment_routing_mpls(yang.adata.MNode):
    admin_state: ?str

    mut def __init__(self, admin_state: ?str):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.admin_state = admin_state

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__segment_routing_mpls:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__segment_routing_mpls(admin_state=n.get_opt_str('admin-state'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__segment_routing_mpls()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__segment_routing_mpls.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/segment-routing-mpls')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__segment_routing_mpls()')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/segment-routing-mpls'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'segment-routing-mpls'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__segment_routing_mpls(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__segment_routing_mpls__admin_state, child_admin_state)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__send_community__standard(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__send_community__large(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__send_community(yang.adata.MNode):
    standard: ?bool
    large: ?bool

    mut def __init__(self, standard: ?bool, large: ?bool):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.standard = standard
        self.large = large

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _standard = self.standard
        if _standard is not None:
            children['standard'] = yang.gdata.Leaf('boolean', _standard)
        _large = self.large
        if _large is not None:
            children['large'] = yang.gdata.Leaf('boolean', _large)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__send_community:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__send_community(standard=n.get_opt_bool('standard'), large=n.get_opt_bool('large'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__send_community()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__send_community.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/send-community')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__send_community()')
        leaves = []
        _standard = self.standard
        if _standard is not None:
            leaves.append('{self_name}.standard = {repr(_standard)}')
        _large = self.large
        if _large is not None:
            leaves.append('{self_name}.large = {repr(_large)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/send-community'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'send-community'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__send_community(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_standard = yang.gdata.from_xml_opt_bool(node, 'standard')
    yang.gdata.maybe_add(children, 'standard', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__send_community__standard, child_standard)
    child_large = yang.gdata.from_xml_opt_bool(node, 'large')
    yang.gdata.maybe_add(children, 'large', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__send_community__large, child_large)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__transport__single_hop_connected_check(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__transport__mtu_discovery(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__transport__tcp_mss(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__transport(yang.adata.MNode):
    single_hop_connected_check: ?bool
    mtu_discovery: ?bool
    tcp_mss: ?int

    mut def __init__(self, single_hop_connected_check: ?bool, mtu_discovery: ?bool, tcp_mss: ?int):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.single_hop_connected_check = single_hop_connected_check
        self.mtu_discovery = mtu_discovery
        self.tcp_mss = tcp_mss

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _single_hop_connected_check = self.single_hop_connected_check
        if _single_hop_connected_check is not None:
            children['single-hop-connected-check'] = yang.gdata.Leaf('boolean', _single_hop_connected_check)
        _mtu_discovery = self.mtu_discovery
        if _mtu_discovery is not None:
            children['mtu-discovery'] = yang.gdata.Leaf('boolean', _mtu_discovery)
        _tcp_mss = self.tcp_mss
        if _tcp_mss is not None:
            children['tcp-mss'] = yang.gdata.Leaf('uint16', _tcp_mss)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__transport:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__transport(single_hop_connected_check=n.get_opt_bool('single-hop-connected-check'), mtu_discovery=n.get_opt_bool('mtu-discovery'), tcp_mss=n.get_opt_int('tcp-mss'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__transport()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__transport.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/transport')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__transport()')
        leaves = []
        _single_hop_connected_check = self.single_hop_connected_check
        if _single_hop_connected_check is not None:
            leaves.append('{self_name}.single_hop_connected_check = {repr(_single_hop_connected_check)}')
        _mtu_discovery = self.mtu_discovery
        if _mtu_discovery is not None:
            leaves.append('{self_name}.mtu_discovery = {repr(_mtu_discovery)}')
        _tcp_mss = self.tcp_mss
        if _tcp_mss is not None:
            leaves.append('{self_name}.tcp_mss = {repr(_tcp_mss)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/transport'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'transport'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__transport(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_single_hop_connected_check = yang.gdata.from_xml_opt_bool(node, 'single-hop-connected-check')
    yang.gdata.maybe_add(children, 'single-hop-connected-check', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__transport__single_hop_connected_check, child_single_hop_connected_check)
    child_mtu_discovery = yang.gdata.from_xml_opt_bool(node, 'mtu-discovery')
    yang.gdata.maybe_add(children, 'mtu-discovery', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__transport__mtu_discovery, child_mtu_discovery)
    child_tcp_mss = yang.gdata.from_xml_opt_int(node, 'tcp-mss')
    yang.gdata.maybe_add(children, 'tcp-mss', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__transport__tcp_mss, child_tcp_mss)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__group_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__local_preference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__next_hop_self(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__peer_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__allow_own_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as__mode(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as__leading_only(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as__ignore_peer_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as(yang.adata.MNode):
    mode: ?str
    leading_only: ?bool
    ignore_peer_as: ?bool

    mut def __init__(self, mode: ?str, leading_only: ?bool, ignore_peer_as: ?bool):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.mode = mode
        self.leading_only = leading_only
        self.ignore_peer_as = ignore_peer_as

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _mode = self.mode
        if _mode is not None:
            children['mode'] = yang.gdata.Leaf('enumeration', _mode)
        _leading_only = self.leading_only
        if _leading_only is not None:
            children['leading-only'] = yang.gdata.Leaf('boolean', _leading_only)
        _ignore_peer_as = self.ignore_peer_as
        if _ignore_peer_as is not None:
            children['ignore-peer-as'] = yang.gdata.Leaf('boolean', _ignore_peer_as)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as(mode=n.get_opt_str('mode'), leading_only=n.get_opt_bool('leading-only'), ignore_peer_as=n.get_opt_bool('ignore-peer-as'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/group/as-path-options/remove-private-as')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as()')
        leaves = []
        _mode = self.mode
        if _mode is not None:
            leaves.append('{self_name}.mode = {repr(_mode)}')
        _leading_only = self.leading_only
        if _leading_only is not None:
            leaves.append('{self_name}.leading_only = {repr(_leading_only)}')
        _ignore_peer_as = self.ignore_peer_as
        if _ignore_peer_as is not None:
            leaves.append('{self_name}.ignore_peer_as = {repr(_ignore_peer_as)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/group/as-path-options/remove-private-as'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'group', 'as-path-options', 'remove-private-as'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_mode = yang.gdata.from_xml_opt_str(node, 'mode')
    yang.gdata.maybe_add(children, 'mode', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as__mode, child_mode)
    child_leading_only = yang.gdata.from_xml_opt_bool(node, 'leading-only')
    yang.gdata.maybe_add(children, 'leading-only', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as__leading_only, child_leading_only)
    child_ignore_peer_as = yang.gdata.from_xml_opt_bool(node, 'ignore-peer-as')
    yang.gdata.maybe_add(children, 'ignore-peer-as', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as__ignore_peer_as, child_ignore_peer_as)
    return yang.gdata.Container(children, presence=True)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__replace_peer_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options(yang.adata.MNode):
    allow_own_as: ?int
    remove_private_as: ?srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as
    replace_peer_as: ?bool

    mut def __init__(self, allow_own_as: ?int, remove_private_as: ?srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as=None, replace_peer_as: ?bool):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.allow_own_as = allow_own_as
        self.remove_private_as = remove_private_as
        self.replace_peer_as = replace_peer_as

    mut def create_remove_private_as(self, mode):
        existing = self.remove_private_as
        if existing is not None:
            return existing
        res = srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as(mode)
        self.remove_private_as = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _allow_own_as = self.allow_own_as
        if _allow_own_as is not None:
            children['allow-own-as'] = yang.gdata.Leaf('uint8', _allow_own_as)
        _remove_private_as = self.remove_private_as
        if _remove_private_as is not None:
            children['remove-private-as'] = _remove_private_as.to_gdata()
        _replace_peer_as = self.replace_peer_as
        if _replace_peer_as is not None:
            children['replace-peer-as'] = yang.gdata.Leaf('boolean', _replace_peer_as)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options(allow_own_as=n.get_opt_int('allow-own-as'), remove_private_as=srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as.from_gdata(n.get_opt_cnt('remove-private-as')), replace_peer_as=n.get_opt_bool('replace-peer-as'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/group/as-path-options')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options()')
        leaves = []
        _allow_own_as = self.allow_own_as
        if _allow_own_as is not None:
            leaves.append('{self_name}.allow_own_as = {repr(_allow_own_as)}')
        _remove_private_as = self.remove_private_as
        if _remove_private_as is not None:
            res.append('')
            res.append('# P-container: /network-instance/protocols/bgp/group/as-path-options/remove-private-as')
            res.append('remove_private_as = {self_name}.create_remove_private_as()')
            res.extend(_remove_private_as.prsrc('remove_private_as', False).splitlines())
        _replace_peer_as = self.replace_peer_as
        if _replace_peer_as is not None:
            leaves.append('{self_name}.replace_peer_as = {repr(_replace_peer_as)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/group/as-path-options'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'group', 'as-path-options'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_allow_own_as = yang.gdata.from_xml_opt_int(node, 'allow-own-as')
    yang.gdata.maybe_add(children, 'allow-own-as', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__allow_own_as, child_allow_own_as)
    child_remove_private_as = yang.gdata.from_xml_opt_cnt(node, 'remove-private-as')
    yang.gdata.maybe_add(children, 'remove-private-as', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__remove_private_as, child_remove_private_as)
    child_replace_peer_as = yang.gdata.from_xml_opt_bool(node, 'replace-peer-as')
    yang.gdata.maybe_add(children, 'replace-peer-as', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options__replace_peer_as, child_replace_peer_as)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication__keychain(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication__password(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication(yang.adata.MNode):
    keychain: ?str
    password: ?str

    mut def __init__(self, keychain: ?str, password: ?str):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.keychain = keychain
        self.password = password

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _keychain = self.keychain
        if _keychain is not None:
            children['keychain'] = yang.gdata.Leaf('leafref', _keychain)
        _password = self.password
        if _password is not None:
            children['password'] = yang.gdata.Leaf('string', _password)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication(keychain=n.get_opt_str('keychain'), password=n.get_opt_str('password'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/group/authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication()')
        leaves = []
        _keychain = self.keychain
        if _keychain is not None:
            leaves.append('{self_name}.keychain = {repr(_keychain)}')
        _password = self.password
        if _password is not None:
            leaves.append('{self_name}.password = {repr(_password)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/group/authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'group', 'authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_keychain = yang.gdata.from_xml_opt_str(node, 'keychain')
    yang.gdata.maybe_add(children, 'keychain', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication__keychain, child_keychain)
    child_password = yang.gdata.from_xml_opt_str(node, 'password')
    yang.gdata.maybe_add(children, 'password', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication__password, child_password)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection__enable_bfd(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection__fast_failover(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection(yang.adata.MNode):
    enable_bfd: ?bool
    fast_failover: ?bool

    mut def __init__(self, enable_bfd: ?bool, fast_failover: ?bool):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.enable_bfd = enable_bfd
        self.fast_failover = fast_failover

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enable_bfd = self.enable_bfd
        if _enable_bfd is not None:
            children['enable-bfd'] = yang.gdata.Leaf('boolean', _enable_bfd)
        _fast_failover = self.fast_failover
        if _fast_failover is not None:
            children['fast-failover'] = yang.gdata.Leaf('boolean', _fast_failover)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection(enable_bfd=n.get_opt_bool('enable-bfd'), fast_failover=n.get_opt_bool('fast-failover'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/group/failure-detection')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection()')
        leaves = []
        _enable_bfd = self.enable_bfd
        if _enable_bfd is not None:
            leaves.append('{self_name}.enable_bfd = {repr(_enable_bfd)}')
        _fast_failover = self.fast_failover
        if _fast_failover is not None:
            leaves.append('{self_name}.fast_failover = {repr(_fast_failover)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/group/failure-detection'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'group', 'failure-detection'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enable_bfd = yang.gdata.from_xml_opt_bool(node, 'enable-bfd')
    yang.gdata.maybe_add(children, 'enable-bfd', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection__enable_bfd, child_enable_bfd)
    child_fast_failover = yang.gdata.from_xml_opt_bool(node, 'fast-failover')
    yang.gdata.maybe_add(children, 'fast-failover', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection__fast_failover, child_fast_failover)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop__maximum_hops(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop(yang.adata.MNode):
    admin_state: ?str
    maximum_hops: ?int

    mut def __init__(self, admin_state: ?str, maximum_hops: ?int):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.admin_state = admin_state
        self.maximum_hops = maximum_hops

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _maximum_hops = self.maximum_hops
        if _maximum_hops is not None:
            children['maximum-hops'] = yang.gdata.Leaf('uint8', _maximum_hops)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop(admin_state=n.get_opt_str('admin-state'), maximum_hops=n.get_opt_int('maximum-hops'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/group/multihop')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop()')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _maximum_hops = self.maximum_hops
        if _maximum_hops is not None:
            leaves.append('{self_name}.maximum_hops = {repr(_maximum_hops)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/group/multihop'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'group', 'multihop'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop__admin_state, child_admin_state)
    child_maximum_hops = yang.gdata.from_xml_opt_int(node, 'maximum-hops')
    yang.gdata.maybe_add(children, 'maximum-hops', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop__maximum_hops, child_maximum_hops)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi__afi_safi_name(val: value) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['srl_nokia-comm:bgp-address-family'], 'srl_nokia-bgp')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf afi-safi-name: {error}')

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi_entry(yang.adata.MNode):
    afi_safi_name: Identityref
    admin_state: ?str

    mut def __init__(self, afi_safi_name: Identityref, admin_state: ?str):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.afi_safi_name = afi_safi_name
        self.admin_state = admin_state

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _afi_safi_name = self.afi_safi_name
        if _afi_safi_name is not None:
            _identityref_afi_safi_name, error = complete_and_validate_identityref(_afi_safi_name, _identities, ['srl_nokia-comm:bgp-address-family'], 'srl_nokia-bgp')
            if _identityref_afi_safi_name is not None:
                _afi_safi_name = _identityref_afi_safi_name
            else:
                raise ValueError('Invalid value for identityref leaf afi-safi-name: {error}')
            children['afi-safi-name'] = yang.gdata.Leaf('identityref', _afi_safi_name)
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi_entry:
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi_entry(afi_safi_name=n.get_Identityref('afi-safi-name'), admin_state=n.get_opt_str('admin-state'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/group/afi-safi')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi({repr(self.afi_safi_name)})')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/group/afi-safi'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'group', 'afi-safi'])

class srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi(yang.adata.MNode):
    elements: list[srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self._name = 'afi-safi'
        self.elements = elements

    mut def create(self, afi_safi_name):
        for e in self:
            match = True
            if e.afi_safi_name != afi_safi_name:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi_entry(afi_safi_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['afi-safi-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi_entry]:
        if n is not None:
            return [srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi(elements=copied_elements)

extension srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi(Iterable[srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi_entry]):
    def __iter__(self) -> Iterator[srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_afi_safi_name = yang.gdata.from_xml_Identityref(node, 'afi-safi-name')
    yang.gdata.maybe_add(children, 'afi-safi-name', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi__afi_safi_name, child_afi_safi_name)
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi__admin_state, child_admin_state)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi_element(e) for e in nodes]
    return yang.gdata.List(keys=['afi-safi-name'], elements=elements)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as__as_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as__prepend_global_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as__prepend_local_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as(yang.adata.MNode):
    as_number: ?int
    prepend_global_as: ?bool
    prepend_local_as: ?bool

    mut def __init__(self, as_number: ?int, prepend_global_as: ?bool, prepend_local_as: ?bool):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.as_number = as_number
        self.prepend_global_as = prepend_global_as
        self.prepend_local_as = prepend_local_as

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _as_number = self.as_number
        if _as_number is not None:
            children['as-number'] = yang.gdata.Leaf('uint32', _as_number)
        _prepend_global_as = self.prepend_global_as
        if _prepend_global_as is not None:
            children['prepend-global-as'] = yang.gdata.Leaf('boolean', _prepend_global_as)
        _prepend_local_as = self.prepend_local_as
        if _prepend_local_as is not None:
            children['prepend-local-as'] = yang.gdata.Leaf('boolean', _prepend_local_as)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as(as_number=n.get_opt_int('as-number'), prepend_global_as=n.get_opt_bool('prepend-global-as'), prepend_local_as=n.get_opt_bool('prepend-local-as'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/group/local-as')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as()')
        leaves = []
        _as_number = self.as_number
        if _as_number is not None:
            leaves.append('{self_name}.as_number = {repr(_as_number)}')
        _prepend_global_as = self.prepend_global_as
        if _prepend_global_as is not None:
            leaves.append('{self_name}.prepend_global_as = {repr(_prepend_global_as)}')
        _prepend_local_as = self.prepend_local_as
        if _prepend_local_as is not None:
            leaves.append('{self_name}.prepend_local_as = {repr(_prepend_local_as)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/group/local-as'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'group', 'local-as'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_as_number = yang.gdata.from_xml_opt_int(node, 'as-number')
    yang.gdata.maybe_add(children, 'as-number', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as__as_number, child_as_number)
    child_prepend_global_as = yang.gdata.from_xml_opt_bool(node, 'prepend-global-as')
    yang.gdata.maybe_add(children, 'prepend-global-as', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as__prepend_global_as, child_prepend_global_as)
    child_prepend_local_as = yang.gdata.from_xml_opt_bool(node, 'prepend-local-as')
    yang.gdata.maybe_add(children, 'prepend-local-as', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as__prepend_local_as, child_prepend_local_as)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__route_flap_damping(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector__client(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector__cluster_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector(yang.adata.MNode):
    client: ?bool
    cluster_id: ?value

    mut def __init__(self, client: ?bool, cluster_id: ?value):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.client = client
        self.cluster_id = cluster_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _client = self.client
        if _client is not None:
            children['client'] = yang.gdata.Leaf('boolean', _client)
        _cluster_id = self.cluster_id
        if _cluster_id is not None:
            children['cluster-id'] = yang.gdata.Leaf('union', _cluster_id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector(client=n.get_opt_bool('client'), cluster_id=n.get_opt_value('cluster-id'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/group/route-reflector')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector()')
        leaves = []
        _client = self.client
        if _client is not None:
            leaves.append('{self_name}.client = {repr(_client)}')
        _cluster_id = self.cluster_id
        if _cluster_id is not None:
            leaves.append('{self_name}.cluster_id = {repr(_cluster_id)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/group/route-reflector'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'group', 'route-reflector'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_client = yang.gdata.from_xml_opt_bool(node, 'client')
    yang.gdata.maybe_add(children, 'client', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector__client, child_client)
    child_cluster_id = yang.gdata.from_xml_opt_value(node, 'cluster-id')
    yang.gdata.maybe_add(children, 'cluster-id', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector__cluster_id, child_cluster_id)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community__standard(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community__large(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community(yang.adata.MNode):
    standard: ?bool
    large: ?bool

    mut def __init__(self, standard: ?bool, large: ?bool):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.standard = standard
        self.large = large

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _standard = self.standard
        if _standard is not None:
            children['standard'] = yang.gdata.Leaf('boolean', _standard)
        _large = self.large
        if _large is not None:
            children['large'] = yang.gdata.Leaf('boolean', _large)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community(standard=n.get_opt_bool('standard'), large=n.get_opt_bool('large'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/group/send-community')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community()')
        leaves = []
        _standard = self.standard
        if _standard is not None:
            leaves.append('{self_name}.standard = {repr(_standard)}')
        _large = self.large
        if _large is not None:
            leaves.append('{self_name}.large = {repr(_large)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/group/send-community'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'group', 'send-community'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_standard = yang.gdata.from_xml_opt_bool(node, 'standard')
    yang.gdata.maybe_add(children, 'standard', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community__standard, child_standard)
    child_large = yang.gdata.from_xml_opt_bool(node, 'large')
    yang.gdata.maybe_add(children, 'large', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community__large, child_large)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route__ipv4_unicast(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route__ipv6_unicast(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route__export_policy(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route(yang.adata.MNode):
    ipv4_unicast: ?bool
    ipv6_unicast: ?bool
    export_policy: ?str

    mut def __init__(self, ipv4_unicast: ?bool, ipv6_unicast: ?bool, export_policy: ?str):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.ipv4_unicast = ipv4_unicast
        self.ipv6_unicast = ipv6_unicast
        self.export_policy = export_policy

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4_unicast = self.ipv4_unicast
        if _ipv4_unicast is not None:
            children['ipv4-unicast'] = yang.gdata.Leaf('boolean', _ipv4_unicast)
        _ipv6_unicast = self.ipv6_unicast
        if _ipv6_unicast is not None:
            children['ipv6-unicast'] = yang.gdata.Leaf('boolean', _ipv6_unicast)
        _export_policy = self.export_policy
        if _export_policy is not None:
            children['export-policy'] = yang.gdata.Leaf('leafref', _export_policy)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route(ipv4_unicast=n.get_opt_bool('ipv4-unicast'), ipv6_unicast=n.get_opt_bool('ipv6-unicast'), export_policy=n.get_opt_str('export-policy'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/group/send-default-route')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route()')
        leaves = []
        _ipv4_unicast = self.ipv4_unicast
        if _ipv4_unicast is not None:
            leaves.append('{self_name}.ipv4_unicast = {repr(_ipv4_unicast)}')
        _ipv6_unicast = self.ipv6_unicast
        if _ipv6_unicast is not None:
            leaves.append('{self_name}.ipv6_unicast = {repr(_ipv6_unicast)}')
        _export_policy = self.export_policy
        if _export_policy is not None:
            leaves.append('{self_name}.export_policy = {repr(_export_policy)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/group/send-default-route'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'group', 'send-default-route'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4_unicast = yang.gdata.from_xml_opt_bool(node, 'ipv4-unicast')
    yang.gdata.maybe_add(children, 'ipv4-unicast', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route__ipv4_unicast, child_ipv4_unicast)
    child_ipv6_unicast = yang.gdata.from_xml_opt_bool(node, 'ipv6-unicast')
    yang.gdata.maybe_add(children, 'ipv6-unicast', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route__ipv6_unicast, child_ipv6_unicast)
    child_export_policy = yang.gdata.from_xml_opt_str(node, 'export-policy')
    yang.gdata.maybe_add(children, 'export-policy', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route__export_policy, child_export_policy)
    return yang.gdata.Container(children)

class srl_nokia_network_instance__network_instance__protocols__bgp__group_entry(yang.adata.MNode):
    group_name: str
    admin_state: ?str
    description: ?str
    local_preference: ?int
    next_hop_self: ?bool
    peer_as: ?int
    as_path_options: srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options
    authentication: srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication
    failure_detection: srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection
    multihop: srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop
    afi_safi: srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi
    local_as: srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as
    route_flap_damping: ?bool
    route_reflector: srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector
    send_community: srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community
    send_default_route: srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route

    mut def __init__(self, group_name: str, admin_state: ?str, description: ?str, local_preference: ?int, next_hop_self: ?bool, peer_as: ?int, as_path_options: ?srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options=None, authentication: ?srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication=None, failure_detection: ?srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection=None, multihop: ?srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop=None, afi_safi: list[srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi_entry]=[], local_as: ?srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as=None, route_flap_damping: ?bool, route_reflector: ?srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector=None, send_community: ?srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community=None, send_default_route: ?srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route=None):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.group_name = group_name
        self.admin_state = admin_state
        self.description = description
        self.local_preference = local_preference
        self.next_hop_self = next_hop_self
        self.peer_as = peer_as
        self.as_path_options = as_path_options if as_path_options is not None else srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options()
        self.authentication = authentication if authentication is not None else srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication()
        self.failure_detection = failure_detection if failure_detection is not None else srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection()
        self.multihop = multihop if multihop is not None else srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop()
        self.afi_safi = srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi(elements=afi_safi)
        self.local_as = local_as if local_as is not None else srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as()
        self.route_flap_damping = route_flap_damping
        self.route_reflector = route_reflector if route_reflector is not None else srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector()
        self.send_community = send_community if send_community is not None else srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community()
        self.send_default_route = send_default_route if send_default_route is not None else srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _group_name = self.group_name
        if _group_name is not None:
            children['group-name'] = yang.gdata.Leaf('string', _group_name)
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        _local_preference = self.local_preference
        if _local_preference is not None:
            children['local-preference'] = yang.gdata.Leaf('uint32', _local_preference)
        _next_hop_self = self.next_hop_self
        if _next_hop_self is not None:
            children['next-hop-self'] = yang.gdata.Leaf('boolean', _next_hop_self)
        _peer_as = self.peer_as
        if _peer_as is not None:
            children['peer-as'] = yang.gdata.Leaf('uint32', _peer_as)
        _as_path_options = self.as_path_options
        if _as_path_options is not None:
            children['as-path-options'] = _as_path_options.to_gdata()
        _authentication = self.authentication
        if _authentication is not None:
            children['authentication'] = _authentication.to_gdata()
        _failure_detection = self.failure_detection
        if _failure_detection is not None:
            children['failure-detection'] = _failure_detection.to_gdata()
        _multihop = self.multihop
        if _multihop is not None:
            children['multihop'] = _multihop.to_gdata()
        _afi_safi = self.afi_safi
        if _afi_safi is not None:
            children['afi-safi'] = _afi_safi.to_gdata()
        _local_as = self.local_as
        if _local_as is not None:
            children['local-as'] = _local_as.to_gdata()
        _route_flap_damping = self.route_flap_damping
        if _route_flap_damping is not None:
            children['route-flap-damping'] = yang.gdata.Leaf('boolean', _route_flap_damping)
        _route_reflector = self.route_reflector
        if _route_reflector is not None:
            children['route-reflector'] = _route_reflector.to_gdata()
        _send_community = self.send_community
        if _send_community is not None:
            children['send-community'] = _send_community.to_gdata()
        _send_default_route = self.send_default_route
        if _send_default_route is not None:
            children['send-default-route'] = _send_default_route.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__group_entry:
        return srl_nokia_network_instance__network_instance__protocols__bgp__group_entry(group_name=n.get_str('group-name'), admin_state=n.get_opt_str('admin-state'), description=n.get_opt_str('description'), local_preference=n.get_opt_int('local-preference'), next_hop_self=n.get_opt_bool('next-hop-self'), peer_as=n.get_opt_int('peer-as'), as_path_options=srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options.from_gdata(n.get_opt_cnt('as-path-options')), authentication=srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication.from_gdata(n.get_opt_cnt('authentication')), failure_detection=srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection.from_gdata(n.get_opt_cnt('failure-detection')), multihop=srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop.from_gdata(n.get_opt_cnt('multihop')), afi_safi=srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi.from_gdata(n.get_opt_list('afi-safi')), local_as=srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as.from_gdata(n.get_opt_cnt('local-as')), route_flap_damping=n.get_opt_bool('route-flap-damping'), route_reflector=srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector.from_gdata(n.get_opt_cnt('route-reflector')), send_community=srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community.from_gdata(n.get_opt_cnt('send-community')), send_default_route=srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route.from_gdata(n.get_opt_cnt('send-default-route')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__group_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/group')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__group({repr(self.group_name)})')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _description = self.description
        if _description is not None:
            leaves.append('{self_name}.description = {repr(_description)}')
        _local_preference = self.local_preference
        if _local_preference is not None:
            leaves.append('{self_name}.local_preference = {repr(_local_preference)}')
        _next_hop_self = self.next_hop_self
        if _next_hop_self is not None:
            leaves.append('{self_name}.next_hop_self = {repr(_next_hop_self)}')
        _peer_as = self.peer_as
        if _peer_as is not None:
            leaves.append('{self_name}.peer_as = {repr(_peer_as)}')
        _as_path_options = self.as_path_options
        if _as_path_options is not None:
            res.extend(_as_path_options.prsrc('{self_name}.as_path_options', False).splitlines())
        _authentication = self.authentication
        if _authentication is not None:
            res.extend(_authentication.prsrc('{self_name}.authentication', False).splitlines())
        _failure_detection = self.failure_detection
        if _failure_detection is not None:
            res.extend(_failure_detection.prsrc('{self_name}.failure_detection', False).splitlines())
        _multihop = self.multihop
        if _multihop is not None:
            res.extend(_multihop.prsrc('{self_name}.multihop', False).splitlines())
        _afi_safi = self.afi_safi
        for _element in _afi_safi:
            res.append('')
            res.append("# List /network-instance/protocols/bgp/group/afi-safi element: {_element.to_gdata().key_str(['afi-safi-name'])}")
            list_elem = 'afi_safi_element = {self_name}.afi_safi.create({repr(_element.afi_safi_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('afi_safi_element', False, list_element=True).splitlines())
        _local_as = self.local_as
        if _local_as is not None:
            res.extend(_local_as.prsrc('{self_name}.local_as', False).splitlines())
        _route_flap_damping = self.route_flap_damping
        if _route_flap_damping is not None:
            leaves.append('{self_name}.route_flap_damping = {repr(_route_flap_damping)}')
        _route_reflector = self.route_reflector
        if _route_reflector is not None:
            res.extend(_route_reflector.prsrc('{self_name}.route_reflector', False).splitlines())
        _send_community = self.send_community
        if _send_community is not None:
            res.extend(_send_community.prsrc('{self_name}.send_community', False).splitlines())
        _send_default_route = self.send_default_route
        if _send_default_route is not None:
            res.extend(_send_default_route.prsrc('{self_name}.send_default_route', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/group'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'group'])

class srl_nokia_network_instance__network_instance__protocols__bgp__group(yang.adata.MNode):
    elements: list[srl_nokia_network_instance__network_instance__protocols__bgp__group_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self._name = 'group'
        self.elements = elements

    mut def create(self, group_name):
        for e in self:
            match = True
            if e.group_name != group_name:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_network_instance__network_instance__protocols__bgp__group_entry(group_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['group-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_network_instance__network_instance__protocols__bgp__group_entry]:
        if n is not None:
            return [srl_nokia_network_instance__network_instance__protocols__bgp__group_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_network_instance__network_instance__protocols__bgp__group(elements=copied_elements)

extension srl_nokia_network_instance__network_instance__protocols__bgp__group(Iterable[srl_nokia_network_instance__network_instance__protocols__bgp__group_entry]):
    def __iter__(self) -> Iterator[srl_nokia_network_instance__network_instance__protocols__bgp__group_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_group_name = yang.gdata.from_xml_str(node, 'group-name')
    yang.gdata.maybe_add(children, 'group-name', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__group_name, child_group_name)
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__admin_state, child_admin_state)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__description, child_description)
    child_local_preference = yang.gdata.from_xml_opt_int(node, 'local-preference')
    yang.gdata.maybe_add(children, 'local-preference', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__local_preference, child_local_preference)
    child_next_hop_self = yang.gdata.from_xml_opt_bool(node, 'next-hop-self')
    yang.gdata.maybe_add(children, 'next-hop-self', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__next_hop_self, child_next_hop_self)
    child_peer_as = yang.gdata.from_xml_opt_int(node, 'peer-as')
    yang.gdata.maybe_add(children, 'peer-as', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__peer_as, child_peer_as)
    child_as_path_options = yang.gdata.from_xml_opt_cnt(node, 'as-path-options')
    yang.gdata.maybe_add(children, 'as-path-options', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__as_path_options, child_as_path_options)
    child_authentication = yang.gdata.from_xml_opt_cnt(node, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__authentication, child_authentication)
    child_failure_detection = yang.gdata.from_xml_opt_cnt(node, 'failure-detection')
    yang.gdata.maybe_add(children, 'failure-detection', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__failure_detection, child_failure_detection)
    child_multihop = yang.gdata.from_xml_opt_cnt(node, 'multihop')
    yang.gdata.maybe_add(children, 'multihop', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__multihop, child_multihop)
    child_afi_safi = yang.gdata.from_xml_opt_list(node, 'afi-safi')
    yang.gdata.maybe_add(children, 'afi-safi', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__afi_safi, child_afi_safi)
    child_local_as = yang.gdata.from_xml_opt_cnt(node, 'local-as')
    yang.gdata.maybe_add(children, 'local-as', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__local_as, child_local_as)
    child_route_flap_damping = yang.gdata.from_xml_opt_bool(node, 'route-flap-damping')
    yang.gdata.maybe_add(children, 'route-flap-damping', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__group__route_flap_damping, child_route_flap_damping)
    child_route_reflector = yang.gdata.from_xml_opt_cnt(node, 'route-reflector')
    yang.gdata.maybe_add(children, 'route-reflector', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__route_reflector, child_route_reflector)
    child_send_community = yang.gdata.from_xml_opt_cnt(node, 'send-community')
    yang.gdata.maybe_add(children, 'send-community', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__send_community, child_send_community)
    child_send_default_route = yang.gdata.from_xml_opt_cnt(node, 'send-default-route')
    yang.gdata.maybe_add(children, 'send-default-route', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group__send_default_route, child_send_default_route)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group_element(e) for e in nodes]
    return yang.gdata.List(keys=['group-name'], elements=elements)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__peer_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_preference(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__next_hop_self(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__peer_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__peer_group(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__allow_own_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as__mode(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as__leading_only(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as__ignore_peer_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as(yang.adata.MNode):
    mode: ?str
    leading_only: ?bool
    ignore_peer_as: ?bool

    mut def __init__(self, mode: ?str, leading_only: ?bool, ignore_peer_as: ?bool):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.mode = mode
        self.leading_only = leading_only
        self.ignore_peer_as = ignore_peer_as

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _mode = self.mode
        if _mode is not None:
            children['mode'] = yang.gdata.Leaf('enumeration', _mode)
        _leading_only = self.leading_only
        if _leading_only is not None:
            children['leading-only'] = yang.gdata.Leaf('boolean', _leading_only)
        _ignore_peer_as = self.ignore_peer_as
        if _ignore_peer_as is not None:
            children['ignore-peer-as'] = yang.gdata.Leaf('boolean', _ignore_peer_as)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as(mode=n.get_opt_str('mode'), leading_only=n.get_opt_bool('leading-only'), ignore_peer_as=n.get_opt_bool('ignore-peer-as'))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/neighbor/as-path-options/remove-private-as')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as()')
        leaves = []
        _mode = self.mode
        if _mode is not None:
            leaves.append('{self_name}.mode = {repr(_mode)}')
        _leading_only = self.leading_only
        if _leading_only is not None:
            leaves.append('{self_name}.leading_only = {repr(_leading_only)}')
        _ignore_peer_as = self.ignore_peer_as
        if _ignore_peer_as is not None:
            leaves.append('{self_name}.ignore_peer_as = {repr(_ignore_peer_as)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/neighbor/as-path-options/remove-private-as'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'neighbor', 'as-path-options', 'remove-private-as'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_mode = yang.gdata.from_xml_opt_str(node, 'mode')
    yang.gdata.maybe_add(children, 'mode', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as__mode, child_mode)
    child_leading_only = yang.gdata.from_xml_opt_bool(node, 'leading-only')
    yang.gdata.maybe_add(children, 'leading-only', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as__leading_only, child_leading_only)
    child_ignore_peer_as = yang.gdata.from_xml_opt_bool(node, 'ignore-peer-as')
    yang.gdata.maybe_add(children, 'ignore-peer-as', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as__ignore_peer_as, child_ignore_peer_as)
    return yang.gdata.Container(children, presence=True)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__replace_peer_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options(yang.adata.MNode):
    allow_own_as: ?int
    remove_private_as: ?srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as
    replace_peer_as: ?bool

    mut def __init__(self, allow_own_as: ?int, remove_private_as: ?srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as=None, replace_peer_as: ?bool):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.allow_own_as = allow_own_as
        self.remove_private_as = remove_private_as
        self.replace_peer_as = replace_peer_as

    mut def create_remove_private_as(self, mode):
        existing = self.remove_private_as
        if existing is not None:
            return existing
        res = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as(mode)
        self.remove_private_as = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _allow_own_as = self.allow_own_as
        if _allow_own_as is not None:
            children['allow-own-as'] = yang.gdata.Leaf('uint8', _allow_own_as)
        _remove_private_as = self.remove_private_as
        if _remove_private_as is not None:
            children['remove-private-as'] = _remove_private_as.to_gdata()
        _replace_peer_as = self.replace_peer_as
        if _replace_peer_as is not None:
            children['replace-peer-as'] = yang.gdata.Leaf('boolean', _replace_peer_as)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options(allow_own_as=n.get_opt_int('allow-own-as'), remove_private_as=srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as.from_gdata(n.get_opt_cnt('remove-private-as')), replace_peer_as=n.get_opt_bool('replace-peer-as'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/neighbor/as-path-options')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options()')
        leaves = []
        _allow_own_as = self.allow_own_as
        if _allow_own_as is not None:
            leaves.append('{self_name}.allow_own_as = {repr(_allow_own_as)}')
        _remove_private_as = self.remove_private_as
        if _remove_private_as is not None:
            res.append('')
            res.append('# P-container: /network-instance/protocols/bgp/neighbor/as-path-options/remove-private-as')
            res.append('remove_private_as = {self_name}.create_remove_private_as()')
            res.extend(_remove_private_as.prsrc('remove_private_as', False).splitlines())
        _replace_peer_as = self.replace_peer_as
        if _replace_peer_as is not None:
            leaves.append('{self_name}.replace_peer_as = {repr(_replace_peer_as)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/neighbor/as-path-options'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'neighbor', 'as-path-options'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_allow_own_as = yang.gdata.from_xml_opt_int(node, 'allow-own-as')
    yang.gdata.maybe_add(children, 'allow-own-as', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__allow_own_as, child_allow_own_as)
    child_remove_private_as = yang.gdata.from_xml_opt_cnt(node, 'remove-private-as')
    yang.gdata.maybe_add(children, 'remove-private-as', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__remove_private_as, child_remove_private_as)
    child_replace_peer_as = yang.gdata.from_xml_opt_bool(node, 'replace-peer-as')
    yang.gdata.maybe_add(children, 'replace-peer-as', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options__replace_peer_as, child_replace_peer_as)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication__keychain(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication__password(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication(yang.adata.MNode):
    keychain: ?str
    password: ?str

    mut def __init__(self, keychain: ?str, password: ?str):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.keychain = keychain
        self.password = password

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _keychain = self.keychain
        if _keychain is not None:
            children['keychain'] = yang.gdata.Leaf('leafref', _keychain)
        _password = self.password
        if _password is not None:
            children['password'] = yang.gdata.Leaf('string', _password)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication(keychain=n.get_opt_str('keychain'), password=n.get_opt_str('password'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/neighbor/authentication')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication()')
        leaves = []
        _keychain = self.keychain
        if _keychain is not None:
            leaves.append('{self_name}.keychain = {repr(_keychain)}')
        _password = self.password
        if _password is not None:
            leaves.append('{self_name}.password = {repr(_password)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/neighbor/authentication'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'neighbor', 'authentication'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_keychain = yang.gdata.from_xml_opt_str(node, 'keychain')
    yang.gdata.maybe_add(children, 'keychain', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication__keychain, child_keychain)
    child_password = yang.gdata.from_xml_opt_str(node, 'password')
    yang.gdata.maybe_add(children, 'password', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication__password, child_password)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection__enable_bfd(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection__fast_failover(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection(yang.adata.MNode):
    enable_bfd: ?bool
    fast_failover: ?bool

    mut def __init__(self, enable_bfd: ?bool, fast_failover: ?bool):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.enable_bfd = enable_bfd
        self.fast_failover = fast_failover

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _enable_bfd = self.enable_bfd
        if _enable_bfd is not None:
            children['enable-bfd'] = yang.gdata.Leaf('boolean', _enable_bfd)
        _fast_failover = self.fast_failover
        if _fast_failover is not None:
            children['fast-failover'] = yang.gdata.Leaf('boolean', _fast_failover)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection(enable_bfd=n.get_opt_bool('enable-bfd'), fast_failover=n.get_opt_bool('fast-failover'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/neighbor/failure-detection')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection()')
        leaves = []
        _enable_bfd = self.enable_bfd
        if _enable_bfd is not None:
            leaves.append('{self_name}.enable_bfd = {repr(_enable_bfd)}')
        _fast_failover = self.fast_failover
        if _fast_failover is not None:
            leaves.append('{self_name}.fast_failover = {repr(_fast_failover)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/neighbor/failure-detection'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'neighbor', 'failure-detection'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_enable_bfd = yang.gdata.from_xml_opt_bool(node, 'enable-bfd')
    yang.gdata.maybe_add(children, 'enable-bfd', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection__enable_bfd, child_enable_bfd)
    child_fast_failover = yang.gdata.from_xml_opt_bool(node, 'fast-failover')
    yang.gdata.maybe_add(children, 'fast-failover', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection__fast_failover, child_fast_failover)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart__stale_routes_time(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart__requested_restart_time(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart(yang.adata.MNode):
    admin_state: ?str
    stale_routes_time: ?int
    requested_restart_time: ?int

    mut def __init__(self, admin_state: ?str, stale_routes_time: ?int, requested_restart_time: ?int):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.admin_state = admin_state
        self.stale_routes_time = stale_routes_time
        self.requested_restart_time = requested_restart_time

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _stale_routes_time = self.stale_routes_time
        if _stale_routes_time is not None:
            children['stale-routes-time'] = yang.gdata.Leaf('uint16', _stale_routes_time)
        _requested_restart_time = self.requested_restart_time
        if _requested_restart_time is not None:
            children['requested-restart-time'] = yang.gdata.Leaf('uint16', _requested_restart_time)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart(admin_state=n.get_opt_str('admin-state'), stale_routes_time=n.get_opt_int('stale-routes-time'), requested_restart_time=n.get_opt_int('requested-restart-time'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/neighbor/graceful-restart')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart()')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _stale_routes_time = self.stale_routes_time
        if _stale_routes_time is not None:
            leaves.append('{self_name}.stale_routes_time = {repr(_stale_routes_time)}')
        _requested_restart_time = self.requested_restart_time
        if _requested_restart_time is not None:
            leaves.append('{self_name}.requested_restart_time = {repr(_requested_restart_time)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/neighbor/graceful-restart'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'neighbor', 'graceful-restart'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart__admin_state, child_admin_state)
    child_stale_routes_time = yang.gdata.from_xml_opt_int(node, 'stale-routes-time')
    yang.gdata.maybe_add(children, 'stale-routes-time', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart__stale_routes_time, child_stale_routes_time)
    child_requested_restart_time = yang.gdata.from_xml_opt_int(node, 'requested-restart-time')
    yang.gdata.maybe_add(children, 'requested-restart-time', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart__requested_restart_time, child_requested_restart_time)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop__maximum_hops(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop(yang.adata.MNode):
    admin_state: ?str
    maximum_hops: ?int

    mut def __init__(self, admin_state: ?str, maximum_hops: ?int):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.admin_state = admin_state
        self.maximum_hops = maximum_hops

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _maximum_hops = self.maximum_hops
        if _maximum_hops is not None:
            children['maximum-hops'] = yang.gdata.Leaf('uint8', _maximum_hops)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop(admin_state=n.get_opt_str('admin-state'), maximum_hops=n.get_opt_int('maximum-hops'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/neighbor/multihop')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop()')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _maximum_hops = self.maximum_hops
        if _maximum_hops is not None:
            leaves.append('{self_name}.maximum_hops = {repr(_maximum_hops)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/neighbor/multihop'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'neighbor', 'multihop'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop__admin_state, child_admin_state)
    child_maximum_hops = yang.gdata.from_xml_opt_int(node, 'maximum-hops')
    yang.gdata.maybe_add(children, 'maximum-hops', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop__maximum_hops, child_maximum_hops)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi__afi_safi_name(val: value) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['srl_nokia-comm:bgp-address-family'], 'srl_nokia-bgp')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf afi-safi-name: {error}')

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi__admin_state(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('enumeration', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi_entry(yang.adata.MNode):
    afi_safi_name: Identityref
    admin_state: ?str

    mut def __init__(self, afi_safi_name: Identityref, admin_state: ?str):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.afi_safi_name = afi_safi_name
        self.admin_state = admin_state

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _afi_safi_name = self.afi_safi_name
        if _afi_safi_name is not None:
            _identityref_afi_safi_name, error = complete_and_validate_identityref(_afi_safi_name, _identities, ['srl_nokia-comm:bgp-address-family'], 'srl_nokia-bgp')
            if _identityref_afi_safi_name is not None:
                _afi_safi_name = _identityref_afi_safi_name
            else:
                raise ValueError('Invalid value for identityref leaf afi-safi-name: {error}')
            children['afi-safi-name'] = yang.gdata.Leaf('identityref', _afi_safi_name)
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi_entry:
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi_entry(afi_safi_name=n.get_Identityref('afi-safi-name'), admin_state=n.get_opt_str('admin-state'))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/neighbor/afi-safi')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi({repr(self.afi_safi_name)})')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/neighbor/afi-safi'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'neighbor', 'afi-safi'])

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi(yang.adata.MNode):
    elements: list[srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self._name = 'afi-safi'
        self.elements = elements

    mut def create(self, afi_safi_name):
        for e in self:
            match = True
            if e.afi_safi_name != afi_safi_name:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi_entry(afi_safi_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['afi-safi-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi_entry]:
        if n is not None:
            return [srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi(elements=copied_elements)

extension srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi(Iterable[srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi_entry]):
    def __iter__(self) -> Iterator[srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_afi_safi_name = yang.gdata.from_xml_Identityref(node, 'afi-safi-name')
    yang.gdata.maybe_add(children, 'afi-safi-name', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi__afi_safi_name, child_afi_safi_name)
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi__admin_state, child_admin_state)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi_element(e) for e in nodes]
    return yang.gdata.List(keys=['afi-safi-name'], elements=elements)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as__as_number(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as__prepend_global_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as__prepend_local_as(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as(yang.adata.MNode):
    as_number: ?int
    prepend_global_as: ?bool
    prepend_local_as: ?bool

    mut def __init__(self, as_number: ?int, prepend_global_as: ?bool, prepend_local_as: ?bool):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.as_number = as_number
        self.prepend_global_as = prepend_global_as
        self.prepend_local_as = prepend_local_as

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _as_number = self.as_number
        if _as_number is not None:
            children['as-number'] = yang.gdata.Leaf('uint32', _as_number)
        _prepend_global_as = self.prepend_global_as
        if _prepend_global_as is not None:
            children['prepend-global-as'] = yang.gdata.Leaf('boolean', _prepend_global_as)
        _prepend_local_as = self.prepend_local_as
        if _prepend_local_as is not None:
            children['prepend-local-as'] = yang.gdata.Leaf('boolean', _prepend_local_as)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as(as_number=n.get_opt_int('as-number'), prepend_global_as=n.get_opt_bool('prepend-global-as'), prepend_local_as=n.get_opt_bool('prepend-local-as'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/neighbor/local-as')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as()')
        leaves = []
        _as_number = self.as_number
        if _as_number is not None:
            leaves.append('{self_name}.as_number = {repr(_as_number)}')
        _prepend_global_as = self.prepend_global_as
        if _prepend_global_as is not None:
            leaves.append('{self_name}.prepend_global_as = {repr(_prepend_global_as)}')
        _prepend_local_as = self.prepend_local_as
        if _prepend_local_as is not None:
            leaves.append('{self_name}.prepend_local_as = {repr(_prepend_local_as)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/neighbor/local-as'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'neighbor', 'local-as'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_as_number = yang.gdata.from_xml_opt_int(node, 'as-number')
    yang.gdata.maybe_add(children, 'as-number', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as__as_number, child_as_number)
    child_prepend_global_as = yang.gdata.from_xml_opt_bool(node, 'prepend-global-as')
    yang.gdata.maybe_add(children, 'prepend-global-as', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as__prepend_global_as, child_prepend_global_as)
    child_prepend_local_as = yang.gdata.from_xml_opt_bool(node, 'prepend-local-as')
    yang.gdata.maybe_add(children, 'prepend-local-as', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as__prepend_local_as, child_prepend_local_as)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_flap_damping(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector__client(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector__cluster_id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector(yang.adata.MNode):
    client: ?bool
    cluster_id: ?value

    mut def __init__(self, client: ?bool, cluster_id: ?value):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.client = client
        self.cluster_id = cluster_id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _client = self.client
        if _client is not None:
            children['client'] = yang.gdata.Leaf('boolean', _client)
        _cluster_id = self.cluster_id
        if _cluster_id is not None:
            children['cluster-id'] = yang.gdata.Leaf('union', _cluster_id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector(client=n.get_opt_bool('client'), cluster_id=n.get_opt_value('cluster-id'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/neighbor/route-reflector')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector()')
        leaves = []
        _client = self.client
        if _client is not None:
            leaves.append('{self_name}.client = {repr(_client)}')
        _cluster_id = self.cluster_id
        if _cluster_id is not None:
            leaves.append('{self_name}.cluster_id = {repr(_cluster_id)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/neighbor/route-reflector'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'neighbor', 'route-reflector'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_client = yang.gdata.from_xml_opt_bool(node, 'client')
    yang.gdata.maybe_add(children, 'client', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector__client, child_client)
    child_cluster_id = yang.gdata.from_xml_opt_value(node, 'cluster-id')
    yang.gdata.maybe_add(children, 'cluster-id', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector__cluster_id, child_cluster_id)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community__standard(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community__large(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community(yang.adata.MNode):
    standard: ?bool
    large: ?bool

    mut def __init__(self, standard: ?bool, large: ?bool):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.standard = standard
        self.large = large

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _standard = self.standard
        if _standard is not None:
            children['standard'] = yang.gdata.Leaf('boolean', _standard)
        _large = self.large
        if _large is not None:
            children['large'] = yang.gdata.Leaf('boolean', _large)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community(standard=n.get_opt_bool('standard'), large=n.get_opt_bool('large'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/neighbor/send-community')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community()')
        leaves = []
        _standard = self.standard
        if _standard is not None:
            leaves.append('{self_name}.standard = {repr(_standard)}')
        _large = self.large
        if _large is not None:
            leaves.append('{self_name}.large = {repr(_large)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/neighbor/send-community'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'neighbor', 'send-community'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_standard = yang.gdata.from_xml_opt_bool(node, 'standard')
    yang.gdata.maybe_add(children, 'standard', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community__standard, child_standard)
    child_large = yang.gdata.from_xml_opt_bool(node, 'large')
    yang.gdata.maybe_add(children, 'large', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community__large, child_large)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route__ipv4_unicast(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route__ipv6_unicast(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route__export_policy(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('leafref', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route(yang.adata.MNode):
    ipv4_unicast: ?bool
    ipv6_unicast: ?bool
    export_policy: ?str

    mut def __init__(self, ipv4_unicast: ?bool, ipv6_unicast: ?bool, export_policy: ?str):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.ipv4_unicast = ipv4_unicast
        self.ipv6_unicast = ipv6_unicast
        self.export_policy = export_policy

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4_unicast = self.ipv4_unicast
        if _ipv4_unicast is not None:
            children['ipv4-unicast'] = yang.gdata.Leaf('boolean', _ipv4_unicast)
        _ipv6_unicast = self.ipv6_unicast
        if _ipv6_unicast is not None:
            children['ipv6-unicast'] = yang.gdata.Leaf('boolean', _ipv6_unicast)
        _export_policy = self.export_policy
        if _export_policy is not None:
            children['export-policy'] = yang.gdata.Leaf('leafref', _export_policy)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route(ipv4_unicast=n.get_opt_bool('ipv4-unicast'), ipv6_unicast=n.get_opt_bool('ipv6-unicast'), export_policy=n.get_opt_str('export-policy'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/neighbor/send-default-route')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route()')
        leaves = []
        _ipv4_unicast = self.ipv4_unicast
        if _ipv4_unicast is not None:
            leaves.append('{self_name}.ipv4_unicast = {repr(_ipv4_unicast)}')
        _ipv6_unicast = self.ipv6_unicast
        if _ipv6_unicast is not None:
            leaves.append('{self_name}.ipv6_unicast = {repr(_ipv6_unicast)}')
        _export_policy = self.export_policy
        if _export_policy is not None:
            leaves.append('{self_name}.export_policy = {repr(_export_policy)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/neighbor/send-default-route'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'neighbor', 'send-default-route'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_ipv4_unicast = yang.gdata.from_xml_opt_bool(node, 'ipv4-unicast')
    yang.gdata.maybe_add(children, 'ipv4-unicast', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route__ipv4_unicast, child_ipv4_unicast)
    child_ipv6_unicast = yang.gdata.from_xml_opt_bool(node, 'ipv6-unicast')
    yang.gdata.maybe_add(children, 'ipv6-unicast', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route__ipv6_unicast, child_ipv6_unicast)
    child_export_policy = yang.gdata.from_xml_opt_str(node, 'export-policy')
    yang.gdata.maybe_add(children, 'export-policy', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route__export_policy, child_export_policy)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers__connect_retry(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers__hold_time(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers__keepalive_interval(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers__minimum_advertisement_interval(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers__prefix_limit_restart_timer(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers(yang.adata.MNode):
    connect_retry: ?int
    hold_time: ?int
    keepalive_interval: ?int
    minimum_advertisement_interval: ?int
    prefix_limit_restart_timer: ?int

    mut def __init__(self, connect_retry: ?int, hold_time: ?int, keepalive_interval: ?int, minimum_advertisement_interval: ?int, prefix_limit_restart_timer: ?int):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.connect_retry = connect_retry
        self.hold_time = hold_time
        self.keepalive_interval = keepalive_interval
        self.minimum_advertisement_interval = minimum_advertisement_interval
        self.prefix_limit_restart_timer = prefix_limit_restart_timer

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _connect_retry = self.connect_retry
        if _connect_retry is not None:
            children['connect-retry'] = yang.gdata.Leaf('uint16', _connect_retry)
        _hold_time = self.hold_time
        if _hold_time is not None:
            children['hold-time'] = yang.gdata.Leaf('uint16', _hold_time)
        _keepalive_interval = self.keepalive_interval
        if _keepalive_interval is not None:
            children['keepalive-interval'] = yang.gdata.Leaf('uint16', _keepalive_interval)
        _minimum_advertisement_interval = self.minimum_advertisement_interval
        if _minimum_advertisement_interval is not None:
            children['minimum-advertisement-interval'] = yang.gdata.Leaf('uint16', _minimum_advertisement_interval)
        _prefix_limit_restart_timer = self.prefix_limit_restart_timer
        if _prefix_limit_restart_timer is not None:
            children['prefix-limit-restart-timer'] = yang.gdata.Leaf('uint16', _prefix_limit_restart_timer)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers(connect_retry=n.get_opt_int('connect-retry'), hold_time=n.get_opt_int('hold-time'), keepalive_interval=n.get_opt_int('keepalive-interval'), minimum_advertisement_interval=n.get_opt_int('minimum-advertisement-interval'), prefix_limit_restart_timer=n.get_opt_int('prefix-limit-restart-timer'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/neighbor/timers')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers()')
        leaves = []
        _connect_retry = self.connect_retry
        if _connect_retry is not None:
            leaves.append('{self_name}.connect_retry = {repr(_connect_retry)}')
        _hold_time = self.hold_time
        if _hold_time is not None:
            leaves.append('{self_name}.hold_time = {repr(_hold_time)}')
        _keepalive_interval = self.keepalive_interval
        if _keepalive_interval is not None:
            leaves.append('{self_name}.keepalive_interval = {repr(_keepalive_interval)}')
        _minimum_advertisement_interval = self.minimum_advertisement_interval
        if _minimum_advertisement_interval is not None:
            leaves.append('{self_name}.minimum_advertisement_interval = {repr(_minimum_advertisement_interval)}')
        _prefix_limit_restart_timer = self.prefix_limit_restart_timer
        if _prefix_limit_restart_timer is not None:
            leaves.append('{self_name}.prefix_limit_restart_timer = {repr(_prefix_limit_restart_timer)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/neighbor/timers'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'neighbor', 'timers'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_connect_retry = yang.gdata.from_xml_opt_int(node, 'connect-retry')
    yang.gdata.maybe_add(children, 'connect-retry', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers__connect_retry, child_connect_retry)
    child_hold_time = yang.gdata.from_xml_opt_int(node, 'hold-time')
    yang.gdata.maybe_add(children, 'hold-time', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers__hold_time, child_hold_time)
    child_keepalive_interval = yang.gdata.from_xml_opt_int(node, 'keepalive-interval')
    yang.gdata.maybe_add(children, 'keepalive-interval', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers__keepalive_interval, child_keepalive_interval)
    child_minimum_advertisement_interval = yang.gdata.from_xml_opt_int(node, 'minimum-advertisement-interval')
    yang.gdata.maybe_add(children, 'minimum-advertisement-interval', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers__minimum_advertisement_interval, child_minimum_advertisement_interval)
    child_prefix_limit_restart_timer = yang.gdata.from_xml_opt_int(node, 'prefix-limit-restart-timer')
    yang.gdata.maybe_add(children, 'prefix-limit-restart-timer', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers__prefix_limit_restart_timer, child_prefix_limit_restart_timer)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport__mtu_discovery(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport__tcp_mss(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint16', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport__passive_mode(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('boolean', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport__local_address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport(yang.adata.MNode):
    mtu_discovery: ?bool
    tcp_mss: ?int
    passive_mode: ?bool
    local_address: ?str

    mut def __init__(self, mtu_discovery: ?bool, tcp_mss: ?int, passive_mode: ?bool, local_address: ?str):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.mtu_discovery = mtu_discovery
        self.tcp_mss = tcp_mss
        self.passive_mode = passive_mode
        self.local_address = local_address

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _mtu_discovery = self.mtu_discovery
        if _mtu_discovery is not None:
            children['mtu-discovery'] = yang.gdata.Leaf('boolean', _mtu_discovery)
        _tcp_mss = self.tcp_mss
        if _tcp_mss is not None:
            children['tcp-mss'] = yang.gdata.Leaf('uint16', _tcp_mss)
        _passive_mode = self.passive_mode
        if _passive_mode is not None:
            children['passive-mode'] = yang.gdata.Leaf('boolean', _passive_mode)
        _local_address = self.local_address
        if _local_address is not None:
            children['local-address'] = yang.gdata.Leaf('union', _local_address)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport(mtu_discovery=n.get_opt_bool('mtu-discovery'), tcp_mss=n.get_opt_int('tcp-mss'), passive_mode=n.get_opt_bool('passive-mode'), local_address=n.get_opt_str('local-address'))
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/neighbor/transport')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport()')
        leaves = []
        _mtu_discovery = self.mtu_discovery
        if _mtu_discovery is not None:
            leaves.append('{self_name}.mtu_discovery = {repr(_mtu_discovery)}')
        _tcp_mss = self.tcp_mss
        if _tcp_mss is not None:
            leaves.append('{self_name}.tcp_mss = {repr(_tcp_mss)}')
        _passive_mode = self.passive_mode
        if _passive_mode is not None:
            leaves.append('{self_name}.passive_mode = {repr(_passive_mode)}')
        _local_address = self.local_address
        if _local_address is not None:
            leaves.append('{self_name}.local_address = {repr(_local_address)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/neighbor/transport'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'neighbor', 'transport'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_mtu_discovery = yang.gdata.from_xml_opt_bool(node, 'mtu-discovery')
    yang.gdata.maybe_add(children, 'mtu-discovery', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport__mtu_discovery, child_mtu_discovery)
    child_tcp_mss = yang.gdata.from_xml_opt_int(node, 'tcp-mss')
    yang.gdata.maybe_add(children, 'tcp-mss', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport__tcp_mss, child_tcp_mss)
    child_passive_mode = yang.gdata.from_xml_opt_bool(node, 'passive-mode')
    yang.gdata.maybe_add(children, 'passive-mode', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport__passive_mode, child_passive_mode)
    child_local_address = yang.gdata.from_xml_opt_str(node, 'local-address')
    yang.gdata.maybe_add(children, 'local-address', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport__local_address, child_local_address)
    return yang.gdata.Container(children)

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor_entry(yang.adata.MNode):
    peer_address: str
    admin_state: ?str
    description: ?str
    local_preference: ?int
    next_hop_self: ?bool
    peer_as: ?int
    peer_group: ?str
    as_path_options: srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options
    authentication: srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication
    failure_detection: srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection
    graceful_restart: srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart
    multihop: srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop
    afi_safi: srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi
    local_as: srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as
    route_flap_damping: ?bool
    route_reflector: srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector
    send_community: srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community
    send_default_route: srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route
    timers: srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers
    transport: srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport

    mut def __init__(self, peer_address: str, admin_state: ?str, description: ?str, local_preference: ?int, next_hop_self: ?bool, peer_as: ?int, peer_group: ?str, as_path_options: ?srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options=None, authentication: ?srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication=None, failure_detection: ?srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection=None, graceful_restart: ?srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart=None, multihop: ?srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop=None, afi_safi: list[srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi_entry]=[], local_as: ?srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as=None, route_flap_damping: ?bool, route_reflector: ?srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector=None, send_community: ?srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community=None, send_default_route: ?srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route=None, timers: ?srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers=None, transport: ?srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport=None):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.peer_address = peer_address
        self.admin_state = admin_state
        self.description = description
        self.local_preference = local_preference
        self.next_hop_self = next_hop_self
        self.peer_as = peer_as
        self.peer_group = peer_group
        self.as_path_options = as_path_options if as_path_options is not None else srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options()
        self.authentication = authentication if authentication is not None else srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication()
        self.failure_detection = failure_detection if failure_detection is not None else srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection()
        self.graceful_restart = graceful_restart if graceful_restart is not None else srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart()
        self.multihop = multihop if multihop is not None else srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop()
        self.afi_safi = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi(elements=afi_safi)
        self.local_as = local_as if local_as is not None else srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as()
        self.route_flap_damping = route_flap_damping
        self.route_reflector = route_reflector if route_reflector is not None else srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector()
        self.send_community = send_community if send_community is not None else srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community()
        self.send_default_route = send_default_route if send_default_route is not None else srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route()
        self.timers = timers if timers is not None else srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers()
        self.transport = transport if transport is not None else srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _peer_address = self.peer_address
        if _peer_address is not None:
            children['peer-address'] = yang.gdata.Leaf('union', _peer_address)
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        _local_preference = self.local_preference
        if _local_preference is not None:
            children['local-preference'] = yang.gdata.Leaf('uint32', _local_preference)
        _next_hop_self = self.next_hop_self
        if _next_hop_self is not None:
            children['next-hop-self'] = yang.gdata.Leaf('boolean', _next_hop_self)
        _peer_as = self.peer_as
        if _peer_as is not None:
            children['peer-as'] = yang.gdata.Leaf('uint32', _peer_as)
        _peer_group = self.peer_group
        if _peer_group is not None:
            children['peer-group'] = yang.gdata.Leaf('leafref', _peer_group)
        _as_path_options = self.as_path_options
        if _as_path_options is not None:
            children['as-path-options'] = _as_path_options.to_gdata()
        _authentication = self.authentication
        if _authentication is not None:
            children['authentication'] = _authentication.to_gdata()
        _failure_detection = self.failure_detection
        if _failure_detection is not None:
            children['failure-detection'] = _failure_detection.to_gdata()
        _graceful_restart = self.graceful_restart
        if _graceful_restart is not None:
            children['graceful-restart'] = _graceful_restart.to_gdata()
        _multihop = self.multihop
        if _multihop is not None:
            children['multihop'] = _multihop.to_gdata()
        _afi_safi = self.afi_safi
        if _afi_safi is not None:
            children['afi-safi'] = _afi_safi.to_gdata()
        _local_as = self.local_as
        if _local_as is not None:
            children['local-as'] = _local_as.to_gdata()
        _route_flap_damping = self.route_flap_damping
        if _route_flap_damping is not None:
            children['route-flap-damping'] = yang.gdata.Leaf('boolean', _route_flap_damping)
        _route_reflector = self.route_reflector
        if _route_reflector is not None:
            children['route-reflector'] = _route_reflector.to_gdata()
        _send_community = self.send_community
        if _send_community is not None:
            children['send-community'] = _send_community.to_gdata()
        _send_default_route = self.send_default_route
        if _send_default_route is not None:
            children['send-default-route'] = _send_default_route.to_gdata()
        _timers = self.timers
        if _timers is not None:
            children['timers'] = _timers.to_gdata()
        _transport = self.transport
        if _transport is not None:
            children['transport'] = _transport.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp__neighbor_entry:
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor_entry(peer_address=n.get_str('peer-address'), admin_state=n.get_opt_str('admin-state'), description=n.get_opt_str('description'), local_preference=n.get_opt_int('local-preference'), next_hop_self=n.get_opt_bool('next-hop-self'), peer_as=n.get_opt_int('peer-as'), peer_group=n.get_opt_str('peer-group'), as_path_options=srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options.from_gdata(n.get_opt_cnt('as-path-options')), authentication=srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication.from_gdata(n.get_opt_cnt('authentication')), failure_detection=srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection.from_gdata(n.get_opt_cnt('failure-detection')), graceful_restart=srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart.from_gdata(n.get_opt_cnt('graceful-restart')), multihop=srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop.from_gdata(n.get_opt_cnt('multihop')), afi_safi=srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi.from_gdata(n.get_opt_list('afi-safi')), local_as=srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as.from_gdata(n.get_opt_cnt('local-as')), route_flap_damping=n.get_opt_bool('route-flap-damping'), route_reflector=srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector.from_gdata(n.get_opt_cnt('route-reflector')), send_community=srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community.from_gdata(n.get_opt_cnt('send-community')), send_default_route=srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route.from_gdata(n.get_opt_cnt('send-default-route')), timers=srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers.from_gdata(n.get_opt_cnt('timers')), transport=srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport.from_gdata(n.get_opt_cnt('transport')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp/neighbor')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor({repr(self.peer_address)})')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _description = self.description
        if _description is not None:
            leaves.append('{self_name}.description = {repr(_description)}')
        _local_preference = self.local_preference
        if _local_preference is not None:
            leaves.append('{self_name}.local_preference = {repr(_local_preference)}')
        _next_hop_self = self.next_hop_self
        if _next_hop_self is not None:
            leaves.append('{self_name}.next_hop_self = {repr(_next_hop_self)}')
        _peer_as = self.peer_as
        if _peer_as is not None:
            leaves.append('{self_name}.peer_as = {repr(_peer_as)}')
        _peer_group = self.peer_group
        if _peer_group is not None:
            leaves.append('{self_name}.peer_group = {repr(_peer_group)}')
        _as_path_options = self.as_path_options
        if _as_path_options is not None:
            res.extend(_as_path_options.prsrc('{self_name}.as_path_options', False).splitlines())
        _authentication = self.authentication
        if _authentication is not None:
            res.extend(_authentication.prsrc('{self_name}.authentication', False).splitlines())
        _failure_detection = self.failure_detection
        if _failure_detection is not None:
            res.extend(_failure_detection.prsrc('{self_name}.failure_detection', False).splitlines())
        _graceful_restart = self.graceful_restart
        if _graceful_restart is not None:
            res.extend(_graceful_restart.prsrc('{self_name}.graceful_restart', False).splitlines())
        _multihop = self.multihop
        if _multihop is not None:
            res.extend(_multihop.prsrc('{self_name}.multihop', False).splitlines())
        _afi_safi = self.afi_safi
        for _element in _afi_safi:
            res.append('')
            res.append("# List /network-instance/protocols/bgp/neighbor/afi-safi element: {_element.to_gdata().key_str(['afi-safi-name'])}")
            list_elem = 'afi_safi_element = {self_name}.afi_safi.create({repr(_element.afi_safi_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('afi_safi_element', False, list_element=True).splitlines())
        _local_as = self.local_as
        if _local_as is not None:
            res.extend(_local_as.prsrc('{self_name}.local_as', False).splitlines())
        _route_flap_damping = self.route_flap_damping
        if _route_flap_damping is not None:
            leaves.append('{self_name}.route_flap_damping = {repr(_route_flap_damping)}')
        _route_reflector = self.route_reflector
        if _route_reflector is not None:
            res.extend(_route_reflector.prsrc('{self_name}.route_reflector', False).splitlines())
        _send_community = self.send_community
        if _send_community is not None:
            res.extend(_send_community.prsrc('{self_name}.send_community', False).splitlines())
        _send_default_route = self.send_default_route
        if _send_default_route is not None:
            res.extend(_send_default_route.prsrc('{self_name}.send_default_route', False).splitlines())
        _timers = self.timers
        if _timers is not None:
            res.extend(_timers.prsrc('{self_name}.timers', False).splitlines())
        _transport = self.transport
        if _transport is not None:
            res.extend(_transport.prsrc('{self_name}.transport', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp/neighbor'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp', 'neighbor'])

class srl_nokia_network_instance__network_instance__protocols__bgp__neighbor(yang.adata.MNode):
    elements: list[srl_nokia_network_instance__network_instance__protocols__bgp__neighbor_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self._name = 'neighbor'
        self.elements = elements

    mut def create(self, peer_address, peer_group):
        for e in self:
            match = True
            if e.peer_address != peer_address:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor_entry(peer_address, peer_group)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['peer-address'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_network_instance__network_instance__protocols__bgp__neighbor_entry]:
        if n is not None:
            return [srl_nokia_network_instance__network_instance__protocols__bgp__neighbor_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_network_instance__network_instance__protocols__bgp__neighbor(elements=copied_elements)

extension srl_nokia_network_instance__network_instance__protocols__bgp__neighbor(Iterable[srl_nokia_network_instance__network_instance__protocols__bgp__neighbor_entry]):
    def __iter__(self) -> Iterator[srl_nokia_network_instance__network_instance__protocols__bgp__neighbor_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_peer_address = yang.gdata.from_xml_str(node, 'peer-address')
    yang.gdata.maybe_add(children, 'peer-address', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__peer_address, child_peer_address)
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__admin_state, child_admin_state)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__description, child_description)
    child_local_preference = yang.gdata.from_xml_opt_int(node, 'local-preference')
    yang.gdata.maybe_add(children, 'local-preference', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_preference, child_local_preference)
    child_next_hop_self = yang.gdata.from_xml_opt_bool(node, 'next-hop-self')
    yang.gdata.maybe_add(children, 'next-hop-self', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__next_hop_self, child_next_hop_self)
    child_peer_as = yang.gdata.from_xml_opt_int(node, 'peer-as')
    yang.gdata.maybe_add(children, 'peer-as', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__peer_as, child_peer_as)
    child_peer_group = yang.gdata.from_xml_opt_str(node, 'peer-group')
    yang.gdata.maybe_add(children, 'peer-group', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__peer_group, child_peer_group)
    child_as_path_options = yang.gdata.from_xml_opt_cnt(node, 'as-path-options')
    yang.gdata.maybe_add(children, 'as-path-options', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__as_path_options, child_as_path_options)
    child_authentication = yang.gdata.from_xml_opt_cnt(node, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__authentication, child_authentication)
    child_failure_detection = yang.gdata.from_xml_opt_cnt(node, 'failure-detection')
    yang.gdata.maybe_add(children, 'failure-detection', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__failure_detection, child_failure_detection)
    child_graceful_restart = yang.gdata.from_xml_opt_cnt(node, 'graceful-restart')
    yang.gdata.maybe_add(children, 'graceful-restart', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__graceful_restart, child_graceful_restart)
    child_multihop = yang.gdata.from_xml_opt_cnt(node, 'multihop')
    yang.gdata.maybe_add(children, 'multihop', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__multihop, child_multihop)
    child_afi_safi = yang.gdata.from_xml_opt_list(node, 'afi-safi')
    yang.gdata.maybe_add(children, 'afi-safi', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__afi_safi, child_afi_safi)
    child_local_as = yang.gdata.from_xml_opt_cnt(node, 'local-as')
    yang.gdata.maybe_add(children, 'local-as', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__local_as, child_local_as)
    child_route_flap_damping = yang.gdata.from_xml_opt_bool(node, 'route-flap-damping')
    yang.gdata.maybe_add(children, 'route-flap-damping', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_flap_damping, child_route_flap_damping)
    child_route_reflector = yang.gdata.from_xml_opt_cnt(node, 'route-reflector')
    yang.gdata.maybe_add(children, 'route-reflector', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__route_reflector, child_route_reflector)
    child_send_community = yang.gdata.from_xml_opt_cnt(node, 'send-community')
    yang.gdata.maybe_add(children, 'send-community', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_community, child_send_community)
    child_send_default_route = yang.gdata.from_xml_opt_cnt(node, 'send-default-route')
    yang.gdata.maybe_add(children, 'send-default-route', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__send_default_route, child_send_default_route)
    child_timers = yang.gdata.from_xml_opt_cnt(node, 'timers')
    yang.gdata.maybe_add(children, 'timers', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__timers, child_timers)
    child_transport = yang.gdata.from_xml_opt_cnt(node, 'transport')
    yang.gdata.maybe_add(children, 'transport', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor__transport, child_transport)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor_element(e) for e in nodes]
    return yang.gdata.List(keys=['peer-address'], elements=elements)

class srl_nokia_network_instance__network_instance__protocols__bgp(yang.adata.MNode):
    admin_state: ?str
    autonomous_system: ?int
    local_preference: ?int
    router_id: ?str
    as_path_options: srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options
    authentication: srl_nokia_network_instance__network_instance__protocols__bgp__authentication
    ebgp_default_policy: srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy
    afi_safi: srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi
    preference: srl_nokia_network_instance__network_instance__protocols__bgp__preference
    rib_management: srl_nokia_network_instance__network_instance__protocols__bgp__rib_management
    route_advertisement: srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement
    route_flap_damping: srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping
    route_reflector: srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector
    segment_routing_mpls: srl_nokia_network_instance__network_instance__protocols__bgp__segment_routing_mpls
    send_community: srl_nokia_network_instance__network_instance__protocols__bgp__send_community
    transport: srl_nokia_network_instance__network_instance__protocols__bgp__transport
    group: srl_nokia_network_instance__network_instance__protocols__bgp__group
    neighbor: srl_nokia_network_instance__network_instance__protocols__bgp__neighbor

    mut def __init__(self, admin_state: ?str, autonomous_system: ?int, local_preference: ?int, router_id: ?str, as_path_options: ?srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options=None, authentication: ?srl_nokia_network_instance__network_instance__protocols__bgp__authentication=None, ebgp_default_policy: ?srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy=None, afi_safi: list[srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi_entry]=[], preference: ?srl_nokia_network_instance__network_instance__protocols__bgp__preference=None, rib_management: ?srl_nokia_network_instance__network_instance__protocols__bgp__rib_management=None, route_advertisement: ?srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement=None, route_flap_damping: ?srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping=None, route_reflector: ?srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector=None, segment_routing_mpls: ?srl_nokia_network_instance__network_instance__protocols__bgp__segment_routing_mpls=None, send_community: ?srl_nokia_network_instance__network_instance__protocols__bgp__send_community=None, transport: ?srl_nokia_network_instance__network_instance__protocols__bgp__transport=None, group: list[srl_nokia_network_instance__network_instance__protocols__bgp__group_entry]=[], neighbor: list[srl_nokia_network_instance__network_instance__protocols__bgp__neighbor_entry]=[]):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp'
        self.admin_state = admin_state
        self.autonomous_system = autonomous_system
        self.local_preference = local_preference
        self.router_id = router_id
        self.as_path_options = as_path_options if as_path_options is not None else srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options()
        self.authentication = authentication if authentication is not None else srl_nokia_network_instance__network_instance__protocols__bgp__authentication()
        self.ebgp_default_policy = ebgp_default_policy if ebgp_default_policy is not None else srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy()
        self.afi_safi = srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi(elements=afi_safi)
        self.preference = preference if preference is not None else srl_nokia_network_instance__network_instance__protocols__bgp__preference()
        self.rib_management = rib_management if rib_management is not None else srl_nokia_network_instance__network_instance__protocols__bgp__rib_management()
        self.route_advertisement = route_advertisement if route_advertisement is not None else srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement()
        self.route_flap_damping = route_flap_damping if route_flap_damping is not None else srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping()
        self.route_reflector = route_reflector if route_reflector is not None else srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector()
        self.segment_routing_mpls = segment_routing_mpls if segment_routing_mpls is not None else srl_nokia_network_instance__network_instance__protocols__bgp__segment_routing_mpls()
        self.send_community = send_community if send_community is not None else srl_nokia_network_instance__network_instance__protocols__bgp__send_community()
        self.transport = transport if transport is not None else srl_nokia_network_instance__network_instance__protocols__bgp__transport()
        self.group = srl_nokia_network_instance__network_instance__protocols__bgp__group(elements=group)
        self.neighbor = srl_nokia_network_instance__network_instance__protocols__bgp__neighbor(elements=neighbor)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _autonomous_system = self.autonomous_system
        if _autonomous_system is not None:
            children['autonomous-system'] = yang.gdata.Leaf('uint32', _autonomous_system)
        _local_preference = self.local_preference
        if _local_preference is not None:
            children['local-preference'] = yang.gdata.Leaf('uint32', _local_preference)
        _router_id = self.router_id
        if _router_id is not None:
            children['router-id'] = yang.gdata.Leaf('union', _router_id)
        _as_path_options = self.as_path_options
        if _as_path_options is not None:
            children['as-path-options'] = _as_path_options.to_gdata()
        _authentication = self.authentication
        if _authentication is not None:
            children['authentication'] = _authentication.to_gdata()
        _ebgp_default_policy = self.ebgp_default_policy
        if _ebgp_default_policy is not None:
            children['ebgp-default-policy'] = _ebgp_default_policy.to_gdata()
        _afi_safi = self.afi_safi
        if _afi_safi is not None:
            children['afi-safi'] = _afi_safi.to_gdata()
        _preference = self.preference
        if _preference is not None:
            children['preference'] = _preference.to_gdata()
        _rib_management = self.rib_management
        if _rib_management is not None:
            children['rib-management'] = _rib_management.to_gdata()
        _route_advertisement = self.route_advertisement
        if _route_advertisement is not None:
            children['route-advertisement'] = _route_advertisement.to_gdata()
        _route_flap_damping = self.route_flap_damping
        if _route_flap_damping is not None:
            children['route-flap-damping'] = _route_flap_damping.to_gdata()
        _route_reflector = self.route_reflector
        if _route_reflector is not None:
            children['route-reflector'] = _route_reflector.to_gdata()
        _segment_routing_mpls = self.segment_routing_mpls
        if _segment_routing_mpls is not None:
            children['segment-routing-mpls'] = _segment_routing_mpls.to_gdata()
        _send_community = self.send_community
        if _send_community is not None:
            children['send-community'] = _send_community.to_gdata()
        _transport = self.transport
        if _transport is not None:
            children['transport'] = _transport.to_gdata()
        _group = self.group
        if _group is not None:
            children['group'] = _group.to_gdata()
        _neighbor = self.neighbor
        if _neighbor is not None:
            children['neighbor'] = _neighbor.to_gdata()
        return yang.gdata.Container(children, presence=True, ns='urn:nokia.com:srlinux:bgp:bgp', module='srl_nokia-bgp')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?srl_nokia_network_instance__network_instance__protocols__bgp:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp(admin_state=n.get_opt_str('admin-state'), autonomous_system=n.get_opt_int('autonomous-system'), local_preference=n.get_opt_int('local-preference'), router_id=n.get_opt_str('router-id'), as_path_options=srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options.from_gdata(n.get_opt_cnt('as-path-options')), authentication=srl_nokia_network_instance__network_instance__protocols__bgp__authentication.from_gdata(n.get_opt_cnt('authentication')), ebgp_default_policy=srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy.from_gdata(n.get_opt_cnt('ebgp-default-policy')), afi_safi=srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi.from_gdata(n.get_opt_list('afi-safi')), preference=srl_nokia_network_instance__network_instance__protocols__bgp__preference.from_gdata(n.get_opt_cnt('preference')), rib_management=srl_nokia_network_instance__network_instance__protocols__bgp__rib_management.from_gdata(n.get_opt_cnt('rib-management')), route_advertisement=srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement.from_gdata(n.get_opt_cnt('route-advertisement')), route_flap_damping=srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping.from_gdata(n.get_opt_cnt('route-flap-damping')), route_reflector=srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector.from_gdata(n.get_opt_cnt('route-reflector')), segment_routing_mpls=srl_nokia_network_instance__network_instance__protocols__bgp__segment_routing_mpls.from_gdata(n.get_opt_cnt('segment-routing-mpls')), send_community=srl_nokia_network_instance__network_instance__protocols__bgp__send_community.from_gdata(n.get_opt_cnt('send-community')), transport=srl_nokia_network_instance__network_instance__protocols__bgp__transport.from_gdata(n.get_opt_cnt('transport')), group=srl_nokia_network_instance__network_instance__protocols__bgp__group.from_gdata(n.get_opt_list('group')), neighbor=srl_nokia_network_instance__network_instance__protocols__bgp__neighbor.from_gdata(n.get_opt_list('neighbor')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = srl_nokia_network_instance__network_instance__protocols__bgp.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in srl_nokia_network_instance__network_instance__protocols__bgp.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp()')
        leaves = []
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _autonomous_system = self.autonomous_system
        if _autonomous_system is not None:
            leaves.append('{self_name}.autonomous_system = {repr(_autonomous_system)}')
        _local_preference = self.local_preference
        if _local_preference is not None:
            leaves.append('{self_name}.local_preference = {repr(_local_preference)}')
        _router_id = self.router_id
        if _router_id is not None:
            leaves.append('{self_name}.router_id = {repr(_router_id)}')
        _as_path_options = self.as_path_options
        if _as_path_options is not None:
            res.extend(_as_path_options.prsrc('{self_name}.as_path_options', False).splitlines())
        _authentication = self.authentication
        if _authentication is not None:
            res.extend(_authentication.prsrc('{self_name}.authentication', False).splitlines())
        _ebgp_default_policy = self.ebgp_default_policy
        if _ebgp_default_policy is not None:
            res.extend(_ebgp_default_policy.prsrc('{self_name}.ebgp_default_policy', False).splitlines())
        _afi_safi = self.afi_safi
        for _element in _afi_safi:
            res.append('')
            res.append("# List /network-instance/protocols/bgp/afi-safi element: {_element.to_gdata().key_str(['afi-safi-name'])}")
            list_elem = 'afi_safi_element = {self_name}.afi_safi.create({repr(_element.afi_safi_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('afi_safi_element', False, list_element=True).splitlines())
        _preference = self.preference
        if _preference is not None:
            res.extend(_preference.prsrc('{self_name}.preference', False).splitlines())
        _rib_management = self.rib_management
        if _rib_management is not None:
            res.extend(_rib_management.prsrc('{self_name}.rib_management', False).splitlines())
        _route_advertisement = self.route_advertisement
        if _route_advertisement is not None:
            res.extend(_route_advertisement.prsrc('{self_name}.route_advertisement', False).splitlines())
        _route_flap_damping = self.route_flap_damping
        if _route_flap_damping is not None:
            res.extend(_route_flap_damping.prsrc('{self_name}.route_flap_damping', False).splitlines())
        _route_reflector = self.route_reflector
        if _route_reflector is not None:
            res.extend(_route_reflector.prsrc('{self_name}.route_reflector', False).splitlines())
        _segment_routing_mpls = self.segment_routing_mpls
        if _segment_routing_mpls is not None:
            res.extend(_segment_routing_mpls.prsrc('{self_name}.segment_routing_mpls', False).splitlines())
        _send_community = self.send_community
        if _send_community is not None:
            res.extend(_send_community.prsrc('{self_name}.send_community', False).splitlines())
        _transport = self.transport
        if _transport is not None:
            res.extend(_transport.prsrc('{self_name}.transport', False).splitlines())
        _group = self.group
        for _element in _group:
            res.append('')
            res.append("# List /network-instance/protocols/bgp/group element: {_element.to_gdata().key_str(['group-name'])}")
            list_elem = 'group_element = {self_name}.group.create({repr(_element.group_name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('group_element', False, list_element=True).splitlines())
        _neighbor = self.neighbor
        for _element in _neighbor:
            res.append('')
            res.append("# List /network-instance/protocols/bgp/neighbor element: {_element.to_gdata().key_str(['peer-address'])}")
            list_elem = 'neighbor_element = {self_name}.neighbor.create({repr(_element.peer_address)})'
            res.append(list_elem)
            res.extend(_element.prsrc('neighbor_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp:bgp'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__admin_state, child_admin_state)
    child_autonomous_system = yang.gdata.from_xml_opt_int(node, 'autonomous-system')
    yang.gdata.maybe_add(children, 'autonomous-system', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__autonomous_system, child_autonomous_system)
    child_local_preference = yang.gdata.from_xml_opt_int(node, 'local-preference')
    yang.gdata.maybe_add(children, 'local-preference', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__local_preference, child_local_preference)
    child_router_id = yang.gdata.from_xml_opt_str(node, 'router-id')
    yang.gdata.maybe_add(children, 'router-id', from_data_srl_nokia_network_instance__network_instance__protocols__bgp__router_id, child_router_id)
    child_as_path_options = yang.gdata.from_xml_opt_cnt(node, 'as-path-options')
    yang.gdata.maybe_add(children, 'as-path-options', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__as_path_options, child_as_path_options)
    child_authentication = yang.gdata.from_xml_opt_cnt(node, 'authentication')
    yang.gdata.maybe_add(children, 'authentication', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__authentication, child_authentication)
    child_ebgp_default_policy = yang.gdata.from_xml_opt_cnt(node, 'ebgp-default-policy')
    yang.gdata.maybe_add(children, 'ebgp-default-policy', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__ebgp_default_policy, child_ebgp_default_policy)
    child_afi_safi = yang.gdata.from_xml_opt_list(node, 'afi-safi')
    yang.gdata.maybe_add(children, 'afi-safi', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__afi_safi, child_afi_safi)
    child_preference = yang.gdata.from_xml_opt_cnt(node, 'preference')
    yang.gdata.maybe_add(children, 'preference', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__preference, child_preference)
    child_rib_management = yang.gdata.from_xml_opt_cnt(node, 'rib-management')
    yang.gdata.maybe_add(children, 'rib-management', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__rib_management, child_rib_management)
    child_route_advertisement = yang.gdata.from_xml_opt_cnt(node, 'route-advertisement')
    yang.gdata.maybe_add(children, 'route-advertisement', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__route_advertisement, child_route_advertisement)
    child_route_flap_damping = yang.gdata.from_xml_opt_cnt(node, 'route-flap-damping')
    yang.gdata.maybe_add(children, 'route-flap-damping', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__route_flap_damping, child_route_flap_damping)
    child_route_reflector = yang.gdata.from_xml_opt_cnt(node, 'route-reflector')
    yang.gdata.maybe_add(children, 'route-reflector', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__route_reflector, child_route_reflector)
    child_segment_routing_mpls = yang.gdata.from_xml_opt_cnt(node, 'segment-routing-mpls')
    yang.gdata.maybe_add(children, 'segment-routing-mpls', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__segment_routing_mpls, child_segment_routing_mpls)
    child_send_community = yang.gdata.from_xml_opt_cnt(node, 'send-community')
    yang.gdata.maybe_add(children, 'send-community', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__send_community, child_send_community)
    child_transport = yang.gdata.from_xml_opt_cnt(node, 'transport')
    yang.gdata.maybe_add(children, 'transport', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__transport, child_transport)
    child_group = yang.gdata.from_xml_opt_list(node, 'group')
    yang.gdata.maybe_add(children, 'group', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__group, child_group)
    child_neighbor = yang.gdata.from_xml_opt_list(node, 'neighbor')
    yang.gdata.maybe_add(children, 'neighbor', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp__neighbor, child_neighbor)
    return yang.gdata.Container(children, presence=True, ns='urn:nokia.com:srlinux:bgp:bgp', module='srl_nokia-bgp')

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint8', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_distinguisher__rd(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_distinguisher(yang.adata.MNode):
    rd: ?str

    mut def __init__(self, rd: ?str):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp-vpn'
        self.rd = rd

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _rd = self.rd
        if _rd is not None:
            children['rd'] = yang.gdata.Leaf('union', _rd)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_distinguisher:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_distinguisher(rd=n.get_opt_str('rd'))
        return srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_distinguisher()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_distinguisher.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp-vpn/bgp-instance/route-distinguisher')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_distinguisher()')
        leaves = []
        _rd = self.rd
        if _rd is not None:
            leaves.append('{self_name}.rd = {repr(_rd)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp-vpn/bgp-instance/route-distinguisher'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp-vpn:bgp-vpn', 'bgp-instance', 'route-distinguisher'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_distinguisher(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_rd = yang.gdata.from_xml_opt_str(node, 'rd')
    yang.gdata.maybe_add(children, 'rd', from_data_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_distinguisher__rd, child_rd)
    return yang.gdata.Container(children)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target__export_rt(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

mut def from_data_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target__import_rt(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('union', val)

class srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target(yang.adata.MNode):
    export_rt: ?str
    import_rt: ?str

    mut def __init__(self, export_rt: ?str, import_rt: ?str):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp-vpn'
        self.export_rt = export_rt
        self.import_rt = import_rt

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _export_rt = self.export_rt
        if _export_rt is not None:
            children['export-rt'] = yang.gdata.Leaf('union', _export_rt)
        _import_rt = self.import_rt
        if _import_rt is not None:
            children['import-rt'] = yang.gdata.Leaf('union', _import_rt)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target(export_rt=n.get_opt_str('export-rt'), import_rt=n.get_opt_str('import-rt'))
        return srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp-vpn/bgp-instance/route-target')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target()')
        leaves = []
        _export_rt = self.export_rt
        if _export_rt is not None:
            leaves.append('{self_name}.export_rt = {repr(_export_rt)}')
        _import_rt = self.import_rt
        if _import_rt is not None:
            leaves.append('{self_name}.import_rt = {repr(_import_rt)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp-vpn/bgp-instance/route-target'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp-vpn:bgp-vpn', 'bgp-instance', 'route-target'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_export_rt = yang.gdata.from_xml_opt_str(node, 'export-rt')
    yang.gdata.maybe_add(children, 'export-rt', from_data_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target__export_rt, child_export_rt)
    child_import_rt = yang.gdata.from_xml_opt_str(node, 'import-rt')
    yang.gdata.maybe_add(children, 'import-rt', from_data_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target__import_rt, child_import_rt)
    return yang.gdata.Container(children)

class srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance_entry(yang.adata.MNode):
    id: int
    route_distinguisher: srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_distinguisher
    route_target: srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target

    mut def __init__(self, id: int, route_distinguisher: ?srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_distinguisher=None, route_target: ?srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target=None):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp-vpn'
        self.id = id
        self.route_distinguisher = route_distinguisher if route_distinguisher is not None else srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_distinguisher()
        self.route_target = route_target if route_target is not None else srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('uint8', _id)
        _route_distinguisher = self.route_distinguisher
        if _route_distinguisher is not None:
            children['route-distinguisher'] = _route_distinguisher.to_gdata()
        _route_target = self.route_target
        if _route_target is not None:
            children['route-target'] = _route_target.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance_entry:
        return srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance_entry(id=n.get_int('id'), route_distinguisher=srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_distinguisher.from_gdata(n.get_opt_cnt('route-distinguisher')), route_target=srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target.from_gdata(n.get_opt_cnt('route-target')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp-vpn/bgp-instance')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance({repr(self.id)})')
        leaves = []
        _route_distinguisher = self.route_distinguisher
        if _route_distinguisher is not None:
            res.extend(_route_distinguisher.prsrc('{self_name}.route_distinguisher', False).splitlines())
        _route_target = self.route_target
        if _route_target is not None:
            res.extend(_route_target.prsrc('{self_name}.route_target', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp-vpn/bgp-instance'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp-vpn:bgp-vpn', 'bgp-instance'])

class srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance(yang.adata.MNode):
    elements: list[srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp-vpn'
        self._name = 'bgp-instance'
        self.elements = elements

    mut def create(self, id):
        for e in self:
            match = True
            if e.id != id:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance_entry(id)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['id'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance_entry]:
        if n is not None:
            return [srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance(elements=copied_elements)

extension srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance(Iterable[srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance_entry]):
    def __iter__(self) -> Iterator[srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_id = yang.gdata.from_xml_int(node, 'id')
    yang.gdata.maybe_add(children, 'id', from_data_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__id, child_id)
    child_route_distinguisher = yang.gdata.from_xml_opt_cnt(node, 'route-distinguisher')
    yang.gdata.maybe_add(children, 'route-distinguisher', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_distinguisher, child_route_distinguisher)
    child_route_target = yang.gdata.from_xml_opt_cnt(node, 'route-target')
    yang.gdata.maybe_add(children, 'route-target', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance__route_target, child_route_target)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance_element(e) for e in nodes]
    return yang.gdata.List(keys=['id'], elements=elements)

class srl_nokia_network_instance__network_instance__protocols__bgp_vpn(yang.adata.MNode):
    bgp_instance: srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance

    mut def __init__(self, bgp_instance: list[srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance_entry]=[]):
        self._ns = 'urn:nokia.com:srlinux:bgp:bgp-vpn'
        self.bgp_instance = srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance(elements=bgp_instance)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _bgp_instance = self.bgp_instance
        if _bgp_instance is not None:
            children['bgp-instance'] = _bgp_instance.to_gdata()
        return yang.gdata.Container(children, presence=True, ns='urn:nokia.com:srlinux:bgp:bgp-vpn', module='srl_nokia-bgp-vpn')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?srl_nokia_network_instance__network_instance__protocols__bgp_vpn:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols__bgp_vpn(bgp_instance=srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance.from_gdata(n.get_opt_list('bgp-instance')))
        return None

    def copy(self):
        """Create a deep copy of this adata object"""
        ad = srl_nokia_network_instance__network_instance__protocols__bgp_vpn.from_gdata(self.to_gdata())
        if ad is not None:
            return ad
        raise Exception('Unreachable in srl_nokia_network_instance__network_instance__protocols__bgp_vpn.copy()')

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols/bgp-vpn')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols__bgp_vpn()')
        leaves = []
        _bgp_instance = self.bgp_instance
        for _element in _bgp_instance:
            res.append('')
            res.append("# List /network-instance/protocols/bgp-vpn/bgp-instance element: {_element.to_gdata().key_str(['id'])}")
            list_elem = 'bgp_instance_element = {self_name}.bgp_instance.create({repr(_element.id)})'
            res.append(list_elem)
            res.extend(_element.prsrc('bgp_instance_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols/bgp-vpn'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols', 'srl_nokia-bgp-vpn:bgp-vpn'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_vpn(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_bgp_instance = yang.gdata.from_xml_opt_list(node, 'bgp-instance')
    yang.gdata.maybe_add(children, 'bgp-instance', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_vpn__bgp_instance, child_bgp_instance)
    return yang.gdata.Container(children, presence=True, ns='urn:nokia.com:srlinux:bgp:bgp-vpn', module='srl_nokia-bgp-vpn')

class srl_nokia_network_instance__network_instance__protocols(yang.adata.MNode):
    bgp_evpn: ?srl_nokia_network_instance__network_instance__protocols__bgp_evpn
    bgp_ipvpn: ?srl_nokia_network_instance__network_instance__protocols__bgp_ipvpn
    directly_connected: srl_nokia_network_instance__network_instance__protocols__directly_connected
    isis: ?srl_nokia_network_instance__network_instance__protocols__isis
    bgp: ?srl_nokia_network_instance__network_instance__protocols__bgp
    bgp_vpn: ?srl_nokia_network_instance__network_instance__protocols__bgp_vpn

    mut def __init__(self, bgp_evpn: ?srl_nokia_network_instance__network_instance__protocols__bgp_evpn=None, bgp_ipvpn: ?srl_nokia_network_instance__network_instance__protocols__bgp_ipvpn=None, directly_connected: ?srl_nokia_network_instance__network_instance__protocols__directly_connected=None, isis: ?srl_nokia_network_instance__network_instance__protocols__isis=None, bgp: ?srl_nokia_network_instance__network_instance__protocols__bgp=None, bgp_vpn: ?srl_nokia_network_instance__network_instance__protocols__bgp_vpn=None):
        self._ns = 'urn:nokia.com:srlinux:net-inst:network-instance'
        self.bgp_evpn = bgp_evpn
        self.bgp_ipvpn = bgp_ipvpn
        self.directly_connected = directly_connected if directly_connected is not None else srl_nokia_network_instance__network_instance__protocols__directly_connected()
        self.isis = isis
        self.bgp = bgp
        self.bgp_vpn = bgp_vpn

    mut def create_bgp_evpn(self):
        existing = self.bgp_evpn
        if existing is not None:
            return existing
        res = srl_nokia_network_instance__network_instance__protocols__bgp_evpn()
        self.bgp_evpn = res
        return res

    mut def create_bgp_ipvpn(self):
        existing = self.bgp_ipvpn
        if existing is not None:
            return existing
        res = srl_nokia_network_instance__network_instance__protocols__bgp_ipvpn()
        self.bgp_ipvpn = res
        return res

    mut def create_isis(self):
        existing = self.isis
        if existing is not None:
            return existing
        res = srl_nokia_network_instance__network_instance__protocols__isis()
        self.isis = res
        return res

    mut def create_bgp(self, autonomous_system, router_id):
        existing = self.bgp
        if existing is not None:
            return existing
        res = srl_nokia_network_instance__network_instance__protocols__bgp(autonomous_system, router_id)
        self.bgp = res
        return res

    mut def create_bgp_vpn(self):
        existing = self.bgp_vpn
        if existing is not None:
            return existing
        res = srl_nokia_network_instance__network_instance__protocols__bgp_vpn()
        self.bgp_vpn = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _bgp_evpn = self.bgp_evpn
        if _bgp_evpn is not None:
            children['bgp-evpn'] = _bgp_evpn.to_gdata()
        _bgp_ipvpn = self.bgp_ipvpn
        if _bgp_ipvpn is not None:
            children['bgp-ipvpn'] = _bgp_ipvpn.to_gdata()
        _directly_connected = self.directly_connected
        if _directly_connected is not None:
            children['directly-connected'] = _directly_connected.to_gdata()
        _isis = self.isis
        if _isis is not None:
            children['isis'] = _isis.to_gdata()
        _bgp = self.bgp
        if _bgp is not None:
            children['bgp'] = _bgp.to_gdata()
        _bgp_vpn = self.bgp_vpn
        if _bgp_vpn is not None:
            children['bgp-vpn'] = _bgp_vpn.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_network_instance__network_instance__protocols:
        if n is not None:
            return srl_nokia_network_instance__network_instance__protocols(bgp_evpn=srl_nokia_network_instance__network_instance__protocols__bgp_evpn.from_gdata(n.get_opt_cnt('bgp-evpn')), bgp_ipvpn=srl_nokia_network_instance__network_instance__protocols__bgp_ipvpn.from_gdata(n.get_opt_cnt('bgp-ipvpn')), directly_connected=srl_nokia_network_instance__network_instance__protocols__directly_connected.from_gdata(n.get_opt_cnt('directly-connected')), isis=srl_nokia_network_instance__network_instance__protocols__isis.from_gdata(n.get_opt_cnt('isis')), bgp=srl_nokia_network_instance__network_instance__protocols__bgp.from_gdata(n.get_opt_cnt('bgp')), bgp_vpn=srl_nokia_network_instance__network_instance__protocols__bgp_vpn.from_gdata(n.get_opt_cnt('bgp-vpn')))
        return srl_nokia_network_instance__network_instance__protocols()

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance__protocols.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance/protocols')
            res.append('{self_name} = srl_nokia_network_instance__network_instance__protocols()')
        leaves = []
        _bgp_evpn = self.bgp_evpn
        if _bgp_evpn is not None:
            res.append('')
            res.append('# P-container: /network-instance/protocols/bgp-evpn')
            res.append('bgp_evpn = {self_name}.create_bgp_evpn()')
            res.extend(_bgp_evpn.prsrc('bgp_evpn', False).splitlines())
        _bgp_ipvpn = self.bgp_ipvpn
        if _bgp_ipvpn is not None:
            res.append('')
            res.append('# P-container: /network-instance/protocols/bgp-ipvpn')
            res.append('bgp_ipvpn = {self_name}.create_bgp_ipvpn()')
            res.extend(_bgp_ipvpn.prsrc('bgp_ipvpn', False).splitlines())
        _directly_connected = self.directly_connected
        if _directly_connected is not None:
            res.extend(_directly_connected.prsrc('{self_name}.directly_connected', False).splitlines())
        _isis = self.isis
        if _isis is not None:
            res.append('')
            res.append('# P-container: /network-instance/protocols/isis')
            res.append('isis = {self_name}.create_isis()')
            res.extend(_isis.prsrc('isis', False).splitlines())
        _bgp = self.bgp
        if _bgp is not None:
            res.append('')
            res.append('# P-container: /network-instance/protocols/bgp')
            res.append('bgp = {self_name}.create_bgp()')
            res.extend(_bgp.prsrc('bgp', False).splitlines())
        _bgp_vpn = self.bgp_vpn
        if _bgp_vpn is not None:
            res.append('')
            res.append('# P-container: /network-instance/protocols/bgp-vpn')
            res.append('bgp_vpn = {self_name}.create_bgp_vpn()')
            res.extend(_bgp_vpn.prsrc('bgp_vpn', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance/protocols'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance', 'protocols'])


mut def from_xml_srl_nokia_network_instance__network_instance__protocols(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_bgp_evpn = yang.gdata.from_xml_opt_cnt(node, 'bgp-evpn')
    yang.gdata.maybe_add(children, 'bgp-evpn', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_evpn, child_bgp_evpn)
    child_bgp_ipvpn = yang.gdata.from_xml_opt_cnt(node, 'bgp-ipvpn')
    yang.gdata.maybe_add(children, 'bgp-ipvpn', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_ipvpn, child_bgp_ipvpn)
    child_directly_connected = yang.gdata.from_xml_opt_cnt(node, 'directly-connected')
    yang.gdata.maybe_add(children, 'directly-connected', from_xml_srl_nokia_network_instance__network_instance__protocols__directly_connected, child_directly_connected)
    child_isis = yang.gdata.from_xml_opt_cnt(node, 'isis', 'urn:nokia.com:srlinux:isis:isis')
    yang.gdata.maybe_add(children, 'isis', from_xml_srl_nokia_network_instance__network_instance__protocols__isis, child_isis)
    child_bgp = yang.gdata.from_xml_opt_cnt(node, 'bgp', 'urn:nokia.com:srlinux:bgp:bgp')
    yang.gdata.maybe_add(children, 'bgp', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp, child_bgp)
    child_bgp_vpn = yang.gdata.from_xml_opt_cnt(node, 'bgp-vpn', 'urn:nokia.com:srlinux:bgp:bgp-vpn')
    yang.gdata.maybe_add(children, 'bgp-vpn', from_xml_srl_nokia_network_instance__network_instance__protocols__bgp_vpn, child_bgp_vpn)
    return yang.gdata.Container(children)

class srl_nokia_network_instance__network_instance_entry(yang.adata.MNode):
    name: str
    type: ?Identityref
    admin_state: ?str
    description: ?str
    router_id: ?str
    interface: srl_nokia_network_instance__network_instance__interface
    vxlan_interface: srl_nokia_network_instance__network_instance__vxlan_interface
    protocols: srl_nokia_network_instance__network_instance__protocols

    mut def __init__(self, name: str, type: ?Identityref, admin_state: ?str, description: ?str, router_id: ?str, interface: list[srl_nokia_network_instance__network_instance__interface_entry]=[], vxlan_interface: list[srl_nokia_network_instance__network_instance__vxlan_interface_entry]=[], protocols: ?srl_nokia_network_instance__network_instance__protocols=None):
        self._ns = 'urn:nokia.com:srlinux:net-inst:network-instance'
        self.name = name
        self.type = type
        self.admin_state = admin_state
        self.description = description
        self.router_id = router_id
        self.interface = srl_nokia_network_instance__network_instance__interface(elements=interface)
        self.vxlan_interface = srl_nokia_network_instance__network_instance__vxlan_interface(elements=vxlan_interface)
        self.protocols = protocols if protocols is not None else srl_nokia_network_instance__network_instance__protocols()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _type = self.type
        if _type is not None:
            _identityref_type, error = complete_and_validate_identityref(_type, _identities, ['srl_nokia-netinst:ni-type'], 'srl_nokia-network-instance')
            if _identityref_type is not None:
                _type = _identityref_type
            else:
                raise ValueError('Invalid value for identityref leaf type: {error}')
            children['type'] = yang.gdata.Leaf('identityref', _type)
        _admin_state = self.admin_state
        if _admin_state is not None:
            children['admin-state'] = yang.gdata.Leaf('enumeration', _admin_state)
        _description = self.description
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        _router_id = self.router_id
        if _router_id is not None:
            children['router-id'] = yang.gdata.Leaf('string', _router_id)
        _interface = self.interface
        if _interface is not None:
            children['interface'] = _interface.to_gdata()
        _vxlan_interface = self.vxlan_interface
        if _vxlan_interface is not None:
            children['vxlan-interface'] = _vxlan_interface.to_gdata()
        _protocols = self.protocols
        if _protocols is not None:
            children['protocols'] = _protocols.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_network_instance__network_instance_entry:
        return srl_nokia_network_instance__network_instance_entry(name=n.get_str('name'), type=n.get_opt_Identityref('type'), admin_state=n.get_opt_str('admin-state'), description=n.get_opt_str('description'), router_id=n.get_opt_str('router-id'), interface=srl_nokia_network_instance__network_instance__interface.from_gdata(n.get_opt_list('interface')), vxlan_interface=srl_nokia_network_instance__network_instance__vxlan_interface.from_gdata(n.get_opt_list('vxlan-interface')), protocols=srl_nokia_network_instance__network_instance__protocols.from_gdata(n.get_opt_cnt('protocols')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_network_instance__network_instance_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /network-instance')
            res.append('{self_name} = srl_nokia_network_instance__network_instance({repr(self.name)})')
        leaves = []
        _type = self.type
        if _type is not None:
            leaves.append('{self_name}.type = {repr(_type)}')
        _admin_state = self.admin_state
        if _admin_state is not None:
            leaves.append('{self_name}.admin_state = {repr(_admin_state)}')
        _description = self.description
        if _description is not None:
            leaves.append('{self_name}.description = {repr(_description)}')
        _router_id = self.router_id
        if _router_id is not None:
            leaves.append('{self_name}.router_id = {repr(_router_id)}')
        _interface = self.interface
        for _element in _interface:
            res.append('')
            res.append("# List /network-instance/interface element: {_element.to_gdata().key_str(['name'])}")
            list_elem = 'interface_element = {self_name}.interface.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('interface_element', False, list_element=True).splitlines())
        _vxlan_interface = self.vxlan_interface
        for _element in _vxlan_interface:
            res.append('')
            res.append("# List /network-instance/vxlan-interface element: {_element.to_gdata().key_str(['name'])}")
            list_elem = 'vxlan_interface_element = {self_name}.vxlan_interface.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('vxlan_interface_element', False, list_element=True).splitlines())
        _protocols = self.protocols
        if _protocols is not None:
            res.extend(_protocols.prsrc('{self_name}.protocols', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /network-instance'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-network-instance:network-instance'])

class srl_nokia_network_instance__network_instance(yang.adata.MNode):
    elements: list[srl_nokia_network_instance__network_instance_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:net-inst:network-instance'
        self._name = 'network-instance'
        self.elements = elements

    mut def create(self, name):
        for e in self:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_network_instance__network_instance_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements, ns='urn:nokia.com:srlinux:net-inst:network-instance', module='srl_nokia-network-instance')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_network_instance__network_instance_entry]:
        if n is not None:
            return [srl_nokia_network_instance__network_instance_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_network_instance__network_instance(elements=copied_elements)

extension srl_nokia_network_instance__network_instance(Iterable[srl_nokia_network_instance__network_instance_entry]):
    def __iter__(self) -> Iterator[srl_nokia_network_instance__network_instance_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_network_instance__network_instance_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_data_srl_nokia_network_instance__network_instance__name, child_name)
    child_type = yang.gdata.from_xml_opt_Identityref(node, 'type')
    yang.gdata.maybe_add(children, 'type', from_data_srl_nokia_network_instance__network_instance__type, child_type)
    child_admin_state = yang.gdata.from_xml_opt_str(node, 'admin-state')
    yang.gdata.maybe_add(children, 'admin-state', from_data_srl_nokia_network_instance__network_instance__admin_state, child_admin_state)
    child_description = yang.gdata.from_xml_opt_str(node, 'description')
    yang.gdata.maybe_add(children, 'description', from_data_srl_nokia_network_instance__network_instance__description, child_description)
    child_router_id = yang.gdata.from_xml_opt_str(node, 'router-id')
    yang.gdata.maybe_add(children, 'router-id', from_data_srl_nokia_network_instance__network_instance__router_id, child_router_id)
    child_interface = yang.gdata.from_xml_opt_list(node, 'interface')
    yang.gdata.maybe_add(children, 'interface', from_xml_srl_nokia_network_instance__network_instance__interface, child_interface)
    child_vxlan_interface = yang.gdata.from_xml_opt_list(node, 'vxlan-interface')
    yang.gdata.maybe_add(children, 'vxlan-interface', from_xml_srl_nokia_network_instance__network_instance__vxlan_interface, child_vxlan_interface)
    child_protocols = yang.gdata.from_xml_opt_cnt(node, 'protocols')
    yang.gdata.maybe_add(children, 'protocols', from_xml_srl_nokia_network_instance__network_instance__protocols, child_protocols)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_network_instance__network_instance(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_network_instance__network_instance_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements, ns='urn:nokia.com:srlinux:net-inst:network-instance', module='srl_nokia-network-instance')

mut def from_data_srl_nokia_tunnel_interfaces__tunnel_interface__name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('string', val)

mut def from_data_srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__index(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

mut def from_data_srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__type(val: value) -> yang.gdata.Leaf:
    new_val, error = complete_and_validate_identityref(val, _identities, ['srl_nokia-if:si-type'], 'srl_nokia-tunnel-interfaces')
    if new_val is not None:
        return yang.gdata.Leaf('identityref', new_val)
    else:
        raise ValueError('Invalid value for identityref leaf type: {error}')

mut def from_data_srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__ingress__vni(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf('uint32', val)

class srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__ingress(yang.adata.MNode):
    vni: ?int

    mut def __init__(self, vni: ?int):
        self._ns = 'urn:nokia.com:srlinux:vxlan:tunnel-interfaces'
        self.vni = vni

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vni = self.vni
        if _vni is not None:
            children['vni'] = yang.gdata.Leaf('uint32', _vni)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__ingress:
        if n is not None:
            return srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__ingress(vni=n.get_opt_int('vni'))
        raise ValueError('Missing required subtree srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__ingress')

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__ingress.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /tunnel-interface/vxlan-interface/ingress')
            res.append('{self_name} = srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__ingress()')
        leaves = []
        _vni = self.vni
        if _vni is not None:
            leaves.append('{self_name}.vni = {repr(_vni)}')
        if leaves:
            if not list_element:
               res = ['', '# Container: /tunnel-interface/vxlan-interface/ingress'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-tunnel-interfaces:tunnel-interface', 'vxlan-interface', 'ingress'])


mut def from_xml_srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__ingress(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_vni = yang.gdata.from_xml_opt_int(node, 'vni')
    yang.gdata.maybe_add(children, 'vni', from_data_srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__ingress__vni, child_vni)
    return yang.gdata.Container(children)

class srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface_entry(yang.adata.MNode):
    index: int
    type: ?Identityref
    ingress: srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__ingress

    mut def __init__(self, index: int, type: ?Identityref, ingress: ?srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__ingress=None):
        self._ns = 'urn:nokia.com:srlinux:vxlan:tunnel-interfaces'
        self.index = index
        self.type = type
        self.ingress = ingress if ingress is not None else srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__ingress()

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _index = self.index
        if _index is not None:
            children['index'] = yang.gdata.Leaf('uint32', _index)
        _type = self.type
        if _type is not None:
            _identityref_type, error = complete_and_validate_identityref(_type, _identities, ['srl_nokia-if:si-type'], 'srl_nokia-tunnel-interfaces')
            if _identityref_type is not None:
                _type = _identityref_type
            else:
                raise ValueError('Invalid value for identityref leaf type: {error}')
            children['type'] = yang.gdata.Leaf('identityref', _type)
        _ingress = self.ingress
        if _ingress is not None:
            children['ingress'] = _ingress.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface_entry:
        return srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface_entry(index=n.get_int('index'), type=n.get_opt_Identityref('type'), ingress=srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__ingress.from_gdata(n.get_opt_cnt('ingress')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /tunnel-interface/vxlan-interface')
            res.append('{self_name} = srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface({repr(self.index)})')
        leaves = []
        _type = self.type
        if _type is not None:
            leaves.append('{self_name}.type = {repr(_type)}')
        _ingress = self.ingress
        if _ingress is not None:
            res.extend(_ingress.prsrc('{self_name}.ingress', False).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /tunnel-interface/vxlan-interface'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-tunnel-interfaces:tunnel-interface', 'vxlan-interface'])

class srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface(yang.adata.MNode):
    elements: list[srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:vxlan:tunnel-interfaces'
        self._name = 'vxlan-interface'
        self.elements = elements

    mut def create(self, index, type):
        for e in self:
            match = True
            if e.index != index:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface_entry(index, type)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['index'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface_entry]:
        if n is not None:
            return [srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface(elements=copied_elements)

extension srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface(Iterable[srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface_entry]):
    def __iter__(self) -> Iterator[srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_index = yang.gdata.from_xml_int(node, 'index')
    yang.gdata.maybe_add(children, 'index', from_data_srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__index, child_index)
    child_type = yang.gdata.from_xml_opt_Identityref(node, 'type')
    yang.gdata.maybe_add(children, 'type', from_data_srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__type, child_type)
    child_ingress = yang.gdata.from_xml_opt_cnt(node, 'ingress')
    yang.gdata.maybe_add(children, 'ingress', from_xml_srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface__ingress, child_ingress)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface_element(e) for e in nodes]
    return yang.gdata.List(keys=['index'], elements=elements)

class srl_nokia_tunnel_interfaces__tunnel_interface_entry(yang.adata.MNode):
    name: str
    vxlan_interface: srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface

    mut def __init__(self, name: str, vxlan_interface: list[srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface_entry]=[]):
        self._ns = 'urn:nokia.com:srlinux:vxlan:tunnel-interfaces'
        self.name = name
        self.vxlan_interface = srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface(elements=vxlan_interface)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _name = self.name
        if _name is not None:
            children['name'] = yang.gdata.Leaf('string', _name)
        _vxlan_interface = self.vxlan_interface
        if _vxlan_interface is not None:
            children['vxlan-interface'] = _vxlan_interface.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> srl_nokia_tunnel_interfaces__tunnel_interface_entry:
        return srl_nokia_tunnel_interfaces__tunnel_interface_entry(name=n.get_str('name'), vxlan_interface=srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface.from_gdata(n.get_opt_list('vxlan-interface')))

    def copy(self):
        """Create a deep copy of this adata object"""
        return srl_nokia_tunnel_interfaces__tunnel_interface_entry.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /tunnel-interface')
            res.append('{self_name} = srl_nokia_tunnel_interfaces__tunnel_interface({repr(self.name)})')
        leaves = []
        _vxlan_interface = self.vxlan_interface
        for _element in _vxlan_interface:
            res.append('')
            res.append("# List /tunnel-interface/vxlan-interface element: {_element.to_gdata().key_str(['index'])}")
            list_elem = 'vxlan_interface_element = {self_name}.vxlan_interface.create({repr(_element.index)})'
            res.append(list_elem)
            res.extend(_element.prsrc('vxlan_interface_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /tunnel-interface'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True, root_path=['srl_nokia-tunnel-interfaces:tunnel-interface'])

class srl_nokia_tunnel_interfaces__tunnel_interface(yang.adata.MNode):
    elements: list[srl_nokia_tunnel_interfaces__tunnel_interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = 'urn:nokia.com:srlinux:vxlan:tunnel-interfaces'
        self._name = 'tunnel-interface'
        self.elements = elements

    mut def create(self, name):
        for e in self:
            match = True
            if e.name != name:
                match = False
                continue
            if match:
                return e

        res = srl_nokia_tunnel_interfaces__tunnel_interface_entry(name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.Container):
                elements.append(e_gdata)
        return yang.gdata.List(['name'], elements, ns='urn:nokia.com:srlinux:vxlan:tunnel-interfaces', module='srl_nokia-tunnel-interfaces')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[srl_nokia_tunnel_interfaces__tunnel_interface_entry]:
        if n is not None:
            return [srl_nokia_tunnel_interfaces__tunnel_interface_entry.from_gdata(e) for e in n.elements]
        return []

    def copy(self):
        """Create a deep copy of this list object"""
        # Copy each element in the list
        copied_elements = []
        for e in self:
            ce = e.copy()
            if ce is not None:
                copied_elements.append(ce)
        return srl_nokia_tunnel_interfaces__tunnel_interface(elements=copied_elements)

extension srl_nokia_tunnel_interfaces__tunnel_interface(Iterable[srl_nokia_tunnel_interfaces__tunnel_interface_entry]):
    def __iter__(self) -> Iterator[srl_nokia_tunnel_interfaces__tunnel_interface_entry]:
        return self.elements.__iter__()

mut def from_xml_srl_nokia_tunnel_interfaces__tunnel_interface_element(node: xml.Node) -> yang.gdata.Node:
    children = {}
    child_name = yang.gdata.from_xml_str(node, 'name')
    yang.gdata.maybe_add(children, 'name', from_data_srl_nokia_tunnel_interfaces__tunnel_interface__name, child_name)
    child_vxlan_interface = yang.gdata.from_xml_opt_list(node, 'vxlan-interface')
    yang.gdata.maybe_add(children, 'vxlan-interface', from_xml_srl_nokia_tunnel_interfaces__tunnel_interface__vxlan_interface, child_vxlan_interface)
    return yang.gdata.Container(children)

mut def from_xml_srl_nokia_tunnel_interfaces__tunnel_interface(nodes: list[xml.Node]) -> yang.gdata.List:
    elements = [from_xml_srl_nokia_tunnel_interfaces__tunnel_interface_element(e) for e in nodes]
    return yang.gdata.List(keys=['name'], elements=elements, ns='urn:nokia.com:srlinux:vxlan:tunnel-interfaces', module='srl_nokia-tunnel-interfaces')

class root(yang.adata.MNode):
    tunnel: srl_nokia_tunnel__tunnel
    system: srl_nokia_system__system
    interface: srl_nokia_interfaces__interface
    network_instance: srl_nokia_network_instance__network_instance
    tunnel_interface: srl_nokia_tunnel_interfaces__tunnel_interface

    mut def __init__(self, tunnel: ?srl_nokia_tunnel__tunnel=None, system: ?srl_nokia_system__system=None, interface: list[srl_nokia_interfaces__interface_entry]=[], network_instance: list[srl_nokia_network_instance__network_instance_entry]=[], tunnel_interface: list[srl_nokia_tunnel_interfaces__tunnel_interface_entry]=[]):
        self._ns = ''
        self.tunnel = tunnel if tunnel is not None else srl_nokia_tunnel__tunnel()
        self.system = system if system is not None else srl_nokia_system__system()
        self.interface = srl_nokia_interfaces__interface(elements=interface)
        self.network_instance = srl_nokia_network_instance__network_instance(elements=network_instance)
        self.tunnel_interface = srl_nokia_tunnel_interfaces__tunnel_interface(elements=tunnel_interface)

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _tunnel = self.tunnel
        if _tunnel is not None:
            children['tunnel'] = _tunnel.to_gdata()
        _system = self.system
        if _system is not None:
            children['system'] = _system.to_gdata()
        _interface = self.interface
        if _interface is not None:
            children['interface'] = _interface.to_gdata()
        _network_instance = self.network_instance
        if _network_instance is not None:
            children['network-instance'] = _network_instance.to_gdata()
        _tunnel_interface = self.tunnel_interface
        if _tunnel_interface is not None:
            children['tunnel-interface'] = _tunnel_interface.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> root:
        if n is not None:
            return root(tunnel=srl_nokia_tunnel__tunnel.from_gdata(n.get_opt_cnt('tunnel')), system=srl_nokia_system__system.from_gdata(n.get_opt_cnt('system')), interface=srl_nokia_interfaces__interface.from_gdata(n.get_opt_list('interface')), network_instance=srl_nokia_network_instance__network_instance.from_gdata(n.get_opt_list('network-instance')), tunnel_interface=srl_nokia_tunnel_interfaces__tunnel_interface.from_gdata(n.get_opt_list('tunnel-interface')))
        return root()

    def copy(self):
        """Create a deep copy of this adata object"""
        return root.from_gdata(self.to_gdata())

    def prsrc(self, self_name='ad', top=True, list_element=False):
        res = []
        if top:
            res.append('# Top node: /')
            res.append('{self_name} = root()')
        leaves = []
        _tunnel = self.tunnel
        if _tunnel is not None:
            res.extend(_tunnel.prsrc('{self_name}.tunnel', False).splitlines())
        _system = self.system
        if _system is not None:
            res.extend(_system.prsrc('{self_name}.system', False).splitlines())
        _interface = self.interface
        for _element in _interface:
            res.append('')
            res.append("# List /interface element: {_element.to_gdata().key_str(['name'])}")
            list_elem = 'interface_element = {self_name}.interface.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('interface_element', False, list_element=True).splitlines())
        _network_instance = self.network_instance
        for _element in _network_instance:
            res.append('')
            res.append("# List /network-instance element: {_element.to_gdata().key_str(['name'])}")
            list_elem = 'network_instance_element = {self_name}.network_instance.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('network_instance_element', False, list_element=True).splitlines())
        _tunnel_interface = self.tunnel_interface
        for _element in _tunnel_interface:
            res.append('')
            res.append("# List /tunnel-interface element: {_element.to_gdata().key_str(['name'])}")
            list_elem = 'tunnel_interface_element = {self_name}.tunnel_interface.create({repr(_element.name)})'
            res.append(list_elem)
            res.extend(_element.prsrc('tunnel_interface_element', False, list_element=True).splitlines())
        if leaves:
            if not list_element:
               res = ['', '# Container: /'] + leaves + res
            else:
                res = leaves + res
        return '\n'.join(res)

    def prsrc_gen3(self, self_name='ad'):
        # WARNING: this wrapper for the gen3.pradata schema-driven parser compiles the schema on every call!
        s = yang.compile(src_yang())
        return yang.gen3.pradata(s, self.to_gdata(), self_name, loose=True)


mut def from_xml(node: xml.Node) -> yang.gdata.Container:
    children = {}
    child_tunnel = yang.gdata.from_xml_opt_cnt(node, 'tunnel', 'urn:nokia.com:srlinux:vxlan:tunnel')
    yang.gdata.maybe_add(children, 'tunnel', from_xml_srl_nokia_tunnel__tunnel, child_tunnel)
    child_system = yang.gdata.from_xml_opt_cnt(node, 'system', 'urn:nokia.com:srlinux:general:system')
    yang.gdata.maybe_add(children, 'system', from_xml_srl_nokia_system__system, child_system)
    child_interface = yang.gdata.from_xml_opt_list(node, 'interface', 'urn:nokia.com:srlinux:chassis:interfaces')
    yang.gdata.maybe_add(children, 'interface', from_xml_srl_nokia_interfaces__interface, child_interface)
    child_network_instance = yang.gdata.from_xml_opt_list(node, 'network-instance', 'urn:nokia.com:srlinux:net-inst:network-instance')
    yang.gdata.maybe_add(children, 'network-instance', from_xml_srl_nokia_network_instance__network_instance, child_network_instance)
    child_tunnel_interface = yang.gdata.from_xml_opt_list(node, 'tunnel-interface', 'urn:nokia.com:srlinux:vxlan:tunnel-interfaces')
    yang.gdata.maybe_add(children, 'tunnel-interface', from_xml_srl_nokia_tunnel_interfaces__tunnel_interface, child_tunnel_interface)
    return yang.gdata.Container(children)

def from_xml_gen3(node: xml.Node, root_path: list[str]=[]) -> yang.gdata.Container:
    # WARNING: this wrapper for the gen3.from_xml schema-driven parser compiles the schema on every call!
    s = yang.compile(src_yang())
    return yang.gen3.from_data(s, node, loose=True, root_path=root_path)

schema_namespaces: set[str] = {
    'urn:nokia.com:srlinux:bgp:bgp',
    'urn:nokia.com:srlinux:bgp:bgp-vpn',
    'urn:nokia.com:srlinux:chassis:interfaces',
    'urn:nokia.com:srlinux:chassis:interfaces-vlans',
    'urn:nokia.com:srlinux:chassis:system-name',
    'urn:nokia.com:srlinux:general:system',
    'urn:nokia.com:srlinux:general:system-protocols',
    'urn:nokia.com:srlinux:isis:isis',
    'urn:nokia.com:srlinux:net-inst:bgp-evpn',
    'urn:nokia.com:srlinux:net-inst:network-instance',
    'urn:nokia.com:srlinux:vxlan:tunnel',
    'urn:nokia.com:srlinux:vxlan:tunnel-interfaces',
}

def prsrc_gen3(data, self_name='ad'):
    # WARNING: this wrapper for the gen3.prsrc schema-driven parser compiles the schema on every call!
    s = yang.compile(src_yang())
    return yang.gen3.pradata(s, data, self_name, loose=True)
